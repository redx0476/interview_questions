<h1>Ruby Object-Oriented Programming Interview Questions</h1>
<h2>Question 1: What is the difference between a class and a module?</h2>
<h3>Answer</h3>
<p><strong>Class:</strong></p>
<ul>
<li>A blueprint for creating objects (instances)</li>
<li>Can be instantiated using <code>.new</code></li>
<li>Supports single inheritance</li>
<li>Maintains state through instance variables</li>
<li>Used to model real-world entities</li>
</ul>
<p><strong>Module:</strong></p>
<ul>
<li>A collection of methods and constants</li>
<li>Cannot be instantiated</li>
<li>No inheritance support</li>
<li>Used for mixins and namespacing</li>
<li>Provides shared behavior across classes</li>
</ul>
<h3>Example</h3>
<pre><code class="language-ruby"># Class - can be instantiated
class Car
  def initialize(brand)
    @brand = brand
  end
  
  def drive
    &quot;Driving #{@brand}&quot;
  end
end

car = Car.new(&quot;Toyota&quot;)
car.drive # &quot;Driving Toyota&quot;

# Module - cannot be instantiated, used as mixin
module Drivable
  def start_engine
    &quot;Engine started&quot;
  end
end

class Vehicle
  include Drivable
end

vehicle = Vehicle.new
vehicle.start_engine # &quot;Engine started&quot;
</code></pre>
<p><strong>Key Differences:</strong></p>
<ul>
<li><strong>Instantiation</strong>: Class can create objects, Module cannot</li>
<li><strong>Inheritance</strong>: Class supports inheritance, Module doesn&#39;t</li>
<li><strong>Purpose</strong>: Class models objects, Module shares behavior</li>
<li><strong>Usage</strong>: Use class for &quot;is-a&quot;, module for &quot;can-do&quot;</li>
</ul>
<hr>
<h2>Question 2: What is the difference between instance methods and class methods?</h2>
<h3>Answer</h3>
<p><strong>Instance Methods:</strong></p>
<ul>
<li>Called on instances of a class</li>
<li>Access instance variables</li>
<li>Defined normally within a class</li>
<li>Represent behavior specific to an object</li>
</ul>
<p><strong>Class Methods:</strong></p>
<ul>
<li>Called on the class itself</li>
<li>Access class variables</li>
<li>Defined with <code>self.</code> or <code>class &lt;&lt;self</code></li>
<li>Represent behavior for the class as a whole</li>
</ul>
<h3>Example</h3>
<pre><code class="language-ruby">class User
  @@count = 0
  
  def initialize(name)
    @name = name
    @@count += 1
  end
  
  # Instance method
  def greet
    &quot;Hello, I&#39;m #{@name}&quot;
  end
  
  # Class method - using self
  def self.count
    @@count
  end
  
  # Class method - using class &lt;&lt; self
  class &lt;&lt; self
    def total_users
      &quot;Total users: #{@@count}&quot;
    end
  end
end

# Instance method usage
user = User.new(&quot;John&quot;)
user.greet # &quot;Hello, I&#39;m John&quot;

# Class method usage
User.count # 1
User.total_users # &quot;Total users: 1&quot;
</code></pre>
<p><strong>Rails Example:</strong></p>
<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  # Instance method
  def published?
    published_at.present? &amp;&amp; published_at &lt;= Time.current
  end
  
  # Class method
  def self.published
    where(&quot;published_at &lt;= ?&quot;, Time.current)
  end
end

# Usage
article = Article.first
article.published? # Instance method

Article.published # Class method returning scope
</code></pre>
<hr>
<h2>Question 3: Explain instance variables, class variables, and global variables</h2>
<h3>Answer</h3>
<p><strong>Instance Variables (@variable):</strong></p>
<ul>
<li>Belong to a specific instance of a class</li>
<li>Each object has its own copy</li>
<li>Accessible only within instance methods</li>
<li>Prefix: <code>@</code></li>
</ul>
<p><strong>Class Variables (@@variable):</strong></p>
<ul>
<li>Shared across all instances of a class</li>
<li>Single copy for the entire class</li>
<li>Can cause issues with inheritance</li>
<li>Prefix: <code>@@</code></li>
</ul>
<p><strong>Global Variables ($variable):</strong></p>
<ul>
<li>Accessible from anywhere in the program</li>
<li>Should be avoided (pollutes global namespace)</li>
<li>Prefix: <code>$</code></li>
</ul>
<h3>Example</h3>
<pre><code class="language-ruby">class Counter
  @@class_count = 0  # Class variable
  $global_count = 0  # Global variable
  
  def initialize(name)
    @name = name           # Instance variable
    @instance_count = 0    # Instance variable
    @@class_count += 1
    $global_count += 1
  end
  
  def increment
    @instance_count += 1
  end
  
  def show_counts
    puts &quot;Instance (#{@name}): #{@instance_count}&quot;
    puts &quot;Class: #{@@class_count}&quot;
    puts &quot;Global: #{$global_count}&quot;
  end
end

counter1 = Counter.new(&quot;Counter1&quot;)
counter2 = Counter.new(&quot;Counter2&quot;)

counter1.increment
counter1.increment
counter2.increment

counter1.show_counts
# Instance (Counter1): 2
# Class: 2
# Global: 2

counter2.show_counts
# Instance (Counter2): 1
# Class: 2
# Global: 2
</code></pre>
<p><strong>Class Variables with Inheritance Problem:</strong></p>
<pre><code class="language-ruby">class Parent
  @@count = 0
  
  def self.increment
    @@count += 1
  end
  
  def self.count
    @@count
  end
end

class Child &lt; Parent
end

Parent.increment
Child.increment

Parent.count # 2 (shared!)
Child.count  # 2 (same variable!)
</code></pre>
<p><strong>Better Alternative - Class Instance Variables:</strong></p>
<pre><code class="language-ruby">class Parent
  @count = 0
  
  class &lt;&lt; self
    attr_accessor :count
  end
  
  def self.increment
    @count += 1
  end
end

class Child &lt; Parent
  @count = 0
end

Parent.increment
Child.increment

Parent.count # 1
Child.count  # 1 (separate!)
</code></pre>
<hr>
<h2>Question 4: What is Duck Typing in Ruby?</h2>
<h3>Answer</h3>
<p>Duck typing is a programming concept where the type of an object is determined by its behavior (methods) rather than its class. If an object walks like a duck and quacks like a duck, then it&#39;s treated as a duck.</p>
<p><strong>&quot;If it walks like a duck and quacks like a duck, it must be a duck.&quot;</strong></p>
<h3>Example</h3>
<pre><code class="language-ruby">class Duck
  def quack
    &quot;Quack quack!&quot;
  end
  
  def swim
    &quot;Swimming...&quot;
  end
end

class Person
  def quack
    &quot;I&#39;m imitating a duck: Quack!&quot;
  end
  
  def swim
    &quot;I&#39;m swimming like a duck!&quot;
  end
end

class Robot
  def quack
    &quot;Robotic quack sound&quot;
  end
  
  def swim
    &quot;Activating swimming mode&quot;
  end
end

# Method that uses duck typing
def make_it_quack(duck_like_thing)
  duck_like_thing.quack
end

# All work because they respond to quack
make_it_quack(Duck.new)    # &quot;Quack quack!&quot;
make_it_quack(Person.new)  # &quot;I&#39;m imitating a duck: Quack!&quot;
make_it_quack(Robot.new)   # &quot;Robotic quack sound&quot;
</code></pre>
<p><strong>Rails Example:</strong></p>
<pre><code class="language-ruby"># Any object that responds to &#39;each&#39; can be rendered
def render_collection(collection)
  collection.each do |item|
    puts item
  end
end

render_collection([1, 2, 3])           # Array
render_collection((1..5))              # Range
render_collection({a: 1, b: 2})        # Hash
render_collection(User.all)            # ActiveRecord Relation

# All work because they respond to &#39;each&#39;
</code></pre>
<p><strong>Practical Example - Payment Processing:</strong></p>
<pre><code class="language-ruby">class CreditCardPayment
  def process(amount)
    &quot;Processing $#{amount} via Credit Card&quot;
  end
end

class PayPalPayment
  def process(amount)
    &quot;Processing $#{amount} via PayPal&quot;
  end
end

class CryptoPayment
  def process(amount)
    &quot;Processing $#{amount} via Cryptocurrency&quot;
  end
end

class PaymentProcessor
  def charge(payment_method, amount)
    # Duck typing - doesn&#39;t care about the class
    # Only cares that it responds to &#39;process&#39;
    payment_method.process(amount)
  end
end

processor = PaymentProcessor.new
processor.charge(CreditCardPayment.new, 100)
processor.charge(PayPalPayment.new, 50)
processor.charge(CryptoPayment.new, 75)
</code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>Flexible and dynamic code</li>
<li>Easy to add new types without modifying existing code</li>
<li>Promotes polymorphism</li>
<li>Reduces coupling</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Runtime errors if method doesn&#39;t exist</li>
<li>Less type safety</li>
<li>Can be harder to debug</li>
</ul>
<p><strong>Best Practice - Defensive Programming:</strong></p>
<pre><code class="language-ruby">def make_it_quack(thing)
  if thing.respond_to?(:quack)
    thing.quack
  else
    raise &quot;Object doesn&#39;t respond to quack!&quot;
  end
end
</code></pre>
<hr>
<h2>Question 5: Explain Ruby&#39;s Object Model and how it impacts performance</h2>
<h3>Answer</h3>
<p>Ruby&#39;s object model is based on the principle that <strong>everything is an object</strong>, including classes themselves. This impacts memory usage and method lookup performance.</p>
<h3>Object Model Structure</h3>
<pre><code class="language-ruby"># Every object is an instance of a class
number = 5
number.class # Integer

# Every class is an instance of Class
String.class # Class
Integer.class # Class
Class.class # Class

# Every class inherits from BasicObject
String.ancestors
# [String, Comparable, Object, Kernel, BasicObject]
</code></pre>
<p><strong>Hierarchy:</strong></p>
<pre><code>BasicObject (root)
    ↓
  Object
    ↓
  Kernel (module)
    ↓
  YourClass
    ↓
  your_instance
</code></pre>
<h3>Method Lookup Chain</h3>
<p>When you call a method on an object, Ruby searches in this order:</p>
<ol>
<li>The object&#39;s singleton class (eigenclass)</li>
<li>The object&#39;s class</li>
<li>Modules included in the class (last included first)</li>
<li>The superclass</li>
<li>Modules included in the superclass</li>
<li>And so on up to BasicObject</li>
</ol>
<pre><code class="language-ruby">module M1
  def test
    &quot;M1&quot;
  end
end

module M2
  def test
    &quot;M2&quot;
  end
end

class Parent
  def test
    &quot;Parent&quot;
  end
end

class Child &lt; Parent
  prepend M1
  include M2
  
  def test
    &quot;Child&quot;
  end
end

child = Child.new
puts Child.ancestors
# [M1, Child, M2, Parent, Object, Kernel, BasicObject]

child.test # &quot;M1&quot; (prepend comes first)
</code></pre>
<h3>Performance Impact</h3>
<p><strong>1. Method Lookup Overhead:</strong></p>
<pre><code class="language-ruby"># Longer inheritance chain = slower method lookup
class A; end
class B &lt; A; end
class C &lt; B; end
class D &lt; C; end
class E &lt; D; end

# Calling a method on E has to traverse the entire chain
</code></pre>
<p><strong>2. Memory Overhead:</strong></p>
<pre><code class="language-ruby"># Each object carries its own instance variables
users = 10_000.times.map do |i|
  User.new(&quot;User#{i}&quot;, &quot;user#{i}@example.com&quot;)
end

# 10,000 objects, each with its own @name and @email
# High memory consumption
</code></pre>
<p><strong>3. Dynamic Nature Impact:</strong></p>
<pre><code class="language-ruby"># Ruby can&#39;t optimize as much as statically typed languages
def add(a, b)
  a + b  # Could be integers, strings, arrays, etc.
end

# JIT compiler has to handle multiple types
</code></pre>
<h3>Optimization Strategies</h3>
<p><strong>1. Use Structs for Simple Objects:</strong></p>
<pre><code class="language-ruby"># Instead of:
class Point
  attr_accessor :x, :y
  def initialize(x, y)
    @x, @y = x, y
  end
end

# Use:
Point = Struct.new(:x, :y)
# Faster and less memory
</code></pre>
<p><strong>2. Avoid Deep Inheritance:</strong></p>
<pre><code class="language-ruby"># Bad - too deep
class A; end
class B &lt; A; end
class C &lt; B; end
class D &lt; C; end

# Good - flatter hierarchy
class Base; end
class Feature &lt; Base; end
</code></pre>
<p><strong>3. Use Modules Wisely:</strong></p>
<pre><code class="language-ruby"># Don&#39;t include too many modules
class MyClass
  include Module1
  include Module2
  include Module3
  # ... slows down method lookup
end
</code></pre>
<p><strong>4. Cache Method Results:</strong></p>
<pre><code class="language-ruby">class User
  def full_name
    @full_name ||= &quot;#{first_name} #{last_name}&quot;
  end
end
</code></pre>
<p><strong>5. Use Symbols Over Strings:</strong></p>
<pre><code class="language-ruby"># Strings create new objects
hash = {}
1000.times { |i| hash[&quot;key#{i}&quot;] = i }

# Symbols are reused
hash = {}
1000.times { |i| hash[:&quot;key#{i}&quot;] = i }
# Faster and less memory
</code></pre>
<h3>Rails Performance Example</h3>
<pre><code class="language-ruby"># Slow - N+1 query problem
users = User.all
users.each do |user|
  puts user.posts.count  # Separate query for each user
end

# Fast - eager loading
users = User.includes(:posts)
users.each do |user|
  puts user.posts.count  # Already loaded
end
</code></pre>
<p><strong>Benchmarking Example:</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

Benchmark.bm do |x|
  x.report(&quot;String keys:&quot;) do
    hash = {}
    100_000.times { |i| hash[&quot;key#{i}&quot;] = i }
  end
  
  x.report(&quot;Symbol keys:&quot;) do
    hash = {}
    100_000.times { |i| hash[:&quot;key#{i}&quot;] = i }
  end
end

# Symbol keys are faster!
</code></pre>
<hr>
<h2>Question 6: What are Eigenclasses and Singleton Classes in Ruby?</h2>
<h3>Answer</h3>
<p><strong>Eigenclass (Singleton Class)</strong> is a hidden class that Ruby creates for each object to hold its unique methods. It sits between the object and its class in the inheritance chain.</p>
<h3>Why Eigenclasses Exist</h3>
<p>Every object in Ruby can have methods defined specifically for it, separate from its class. These methods are stored in the object&#39;s eigenclass.</p>
<h3>Example - Basic Singleton Methods</h3>
<pre><code class="language-ruby">str1 = &quot;Hello&quot;
str2 = &quot;World&quot;

# Define method only for str1
def str1.shout
  self.upcase + &quot;!!!&quot;
end

str1.shout # &quot;HELLO!!!&quot;
str2.shout # NoMethodError - str2 doesn&#39;t have this method

# Check singleton class
str1.singleton_class # #&lt;Class:#&lt;String:0x00...&gt;&gt;
str1.singleton_methods # [:shout]
</code></pre>
<h3>Accessing Eigenclass</h3>
<p><strong>Method 1: Using <code>singleton_class</code></strong></p>
<pre><code class="language-ruby">obj = Object.new

obj.singleton_class.class_eval do
  def custom_method
    &quot;I&#39;m unique to this object&quot;
  end
end

obj.custom_method # &quot;I&#39;m unique to this object&quot;
</code></pre>
<p><strong>Method 2: Using <code>class &lt;&lt; self</code> syntax</strong></p>
<pre><code class="language-ruby">obj = Object.new

class &lt;&lt; obj
  def custom_method
    &quot;I&#39;m unique to this object&quot;
  end
end

obj.custom_method # &quot;I&#39;m unique to this object&quot;
</code></pre>
<h3>Class Methods Are Singleton Methods</h3>
<p>Class methods are actually singleton methods defined on the class object:</p>
<pre><code class="language-ruby">class User
  # These are equivalent:
  
  # Method 1
  def self.count
    &quot;Counting users...&quot;
  end
  
  # Method 2
  class &lt;&lt; self
    def total
      &quot;Total users...&quot;
    end
  end
end

User.count # &quot;Counting users...&quot;
User.total # &quot;Total users...&quot;

# Class methods are in the eigenclass
User.singleton_methods # [:count, :total]
</code></pre>
<h3>Inheritance Chain with Eigenclasses</h3>
<pre><code class="language-ruby">class Animal
end

class Dog &lt; Animal
end

dog = Dog.new

# Inheritance chain:
# dog -&gt; Dog -&gt; Animal -&gt; Object -&gt; BasicObject

# But with eigenclass:
# dog -&gt; dog&#39;s eigenclass -&gt; Dog -&gt; Dog&#39;s eigenclass -&gt; Animal -&gt; Animal&#39;s eigenclass -&gt; ...

dog.singleton_class # #&lt;Class:#&lt;Dog:0x00...&gt;&gt;
Dog.singleton_class # #&lt;Class:Dog&gt;
Animal.singleton_class # #&lt;Class:Animal&gt;
</code></pre>
<h3>Practical Example - Adding Methods to Specific Instances</h3>
<pre><code class="language-ruby">class User
  attr_accessor :name
  
  def initialize(name)
    @name = name
  end
end

admin = User.new(&quot;Admin&quot;)
regular = User.new(&quot;Regular&quot;)

# Add admin-specific methods
class &lt;&lt; admin
  def promote
    &quot;#{name} promoted to super admin&quot;
  end
  
  def delete_all
    &quot;Admin deleting all users&quot;
  end
end

admin.promote # &quot;Admin promoted to super admin&quot;
admin.delete_all # &quot;Admin deleting all users&quot;

regular.promote # NoMethodError
</code></pre>
<h3>Rails Example - Dynamic Model Methods</h3>
<pre><code class="language-ruby">class Product &lt; ApplicationRecord
end

# Add method to specific product instance
product = Product.find(1)

product.singleton_class.class_eval do
  def special_discount
    price * 0.5
  end
end

product.special_discount # Works only for this product
Product.find(2).special_discount # NoMethodError
</code></pre>
<h3>Eigenclass with Modules</h3>
<pre><code class="language-ruby">module AdminFeatures
  def admin_panel
    &quot;Access granted&quot;
  end
end

user = User.new(&quot;John&quot;)

# Extend adds module methods to eigenclass
user.extend(AdminFeatures)
user.admin_panel # &quot;Access granted&quot;

# Other users don&#39;t have this
another_user = User.new(&quot;Jane&quot;)
another_user.admin_panel # NoMethodError
</code></pre>
<h3>Method Lookup with Eigenclasses</h3>
<pre><code class="language-ruby">class Animal
  def speak
    &quot;Some sound&quot;
  end
end

class Dog &lt; Animal
  def speak
    &quot;Woof&quot;
  end
end

dog = Dog.new

# Add singleton method
def dog.speak
  &quot;Bark bark!&quot;
end

dog.speak # &quot;Bark bark!&quot; - singleton method wins

# Lookup order:
# 1. dog&#39;s eigenclass (singleton methods)
# 2. Dog class
# 3. Animal class
# 4. Object, Kernel, BasicObject
</code></pre>
<h3>Performance Consideration</h3>
<pre><code class="language-ruby"># Creating many singleton methods can impact memory
1000.times do
  obj = Object.new
  def obj.custom
    &quot;Custom method&quot;
  end
  # Each obj has its own eigenclass
end

# Better approach - use a class if behavior is shared
class CustomObject
  def custom
    &quot;Custom method&quot;
  end
end

1000.times do
  obj = CustomObject.new
  # All share the same class
end
</code></pre>
<h3>Real-World Use Case - Decorators</h3>
<pre><code class="language-ruby">class User
  attr_accessor :name, :email
  
  def initialize(name, email)
    @name = name
    @email = email
  end
end

# Decorate specific user with admin features
def make_admin(user)
  class &lt;&lt; user
    def admin?
      true
    end
    
    def permissions
      [:read, :write, :delete]
    end
  end
  user
end

user = User.new(&quot;John&quot;, &quot;john@example.com&quot;)
user.respond_to?(:admin?) # false

admin_user = make_admin(user)
admin_user.admin? # true
admin_user.permissions # [:read, :write, :delete]
</code></pre>
<h3>Key Takeaways</h3>
<ul>
<li>Eigenclass is a hidden class for each object</li>
<li>Stores singleton methods (object-specific methods)</li>
<li>Class methods are singleton methods on the class object</li>
<li>Sits between object and its class in lookup chain</li>
<li>Useful for decorators and dynamic method addition</li>
<li>Can impact memory if overused</li>
</ul>
<hr>
<h2>Question 7: How does Ruby handle method resolution (Method Lookup Path)?</h2>
<h3>Answer</h3>
<p>Ruby uses a specific order to find methods when they&#39;re called on an object. This is called the <strong>Method Lookup Path</strong> or <strong>Method Resolution Order (MRO)</strong>.</p>
<h3>Basic Method Lookup Order</h3>
<pre><code class="language-ruby">class Animal
  def speak
    &quot;Some sound&quot;
  end
end

class Dog &lt; Animal
  def speak
    &quot;Woof!&quot;
  end
end

dog = Dog.new
dog.speak # Ruby searches: Dog -&gt; Animal -&gt; Object -&gt; Kernel -&gt; BasicObject
</code></pre>
<p><strong>Search Order:</strong></p>
<ol>
<li>Object&#39;s singleton class (eigenclass)</li>
<li>Object&#39;s class</li>
<li>Modules included/prepended in the class</li>
<li>Superclass</li>
<li>Modules in superclass</li>
<li>Continue up to BasicObject</li>
</ol>
<h3>Viewing the Lookup Path</h3>
<pre><code class="language-ruby">class Animal
end

class Dog &lt; Animal
end

Dog.ancestors
# [Dog, Animal, Object, Kernel, BasicObject]

# This is the method lookup path
</code></pre>
<h3>With Modules - <code>include</code></h3>
<p>When you <code>include</code> a module, it&#39;s inserted into the lookup path <strong>after</strong> the class:</p>
<pre><code class="language-ruby">module Walkable
  def move
    &quot;Walking...&quot;
  end
end

module Swimmable
  def move
    &quot;Swimming...&quot;
  end
end

class Animal
  include Walkable
  include Swimmable  # Last included wins
  
  def move
    &quot;Moving...&quot;
  end
end

Animal.ancestors
# [Animal, Swimmable, Walkable, Object, Kernel, BasicObject]

animal = Animal.new
animal.move # &quot;Moving...&quot; - class method wins over modules
</code></pre>
<p><strong>If class doesn&#39;t define the method:</strong></p>
<pre><code class="language-ruby">class Animal
  include Walkable
  include Swimmable
end

animal = Animal.new
animal.move # &quot;Swimming...&quot; - last included module wins
</code></pre>
<h3>With Modules - <code>prepend</code></h3>
<p>When you <code>prepend</code> a module, it&#39;s inserted <strong>before</strong> the class in lookup path:</p>
<pre><code class="language-ruby">module Loggable
  def move
    puts &quot;Logging movement...&quot;
    super  # Calls next method in chain
  end
end

class Animal
  prepend Loggable
  
  def move
    &quot;Moving...&quot;
  end
end

Animal.ancestors
# [Loggable, Animal, Object, Kernel, BasicObject]

animal = Animal.new
animal.move
# Output:
# Logging movement...
# &quot;Moving...&quot;
</code></pre>
<h3>With Modules - <code>extend</code></h3>
<p><code>extend</code> adds module methods as <strong>class methods</strong> (singleton methods):</p>
<pre><code class="language-ruby">module Countable
  def count
    &quot;Counting...&quot;
  end
end

class Animal
  extend Countable
end

Animal.count # &quot;Counting...&quot; - class method
animal = Animal.new
animal.count # NoMethodError - not an instance method
</code></pre>
<h3>Complete Example with All Components</h3>
<pre><code class="language-ruby">module M1
  def test
    &quot;M1&quot;
  end
end

module M2
  def test
    &quot;M2&quot;
  end
end

module M3
  def test
    &quot;M3&quot;
  end
end

class Grandparent
  def test
    &quot;Grandparent&quot;
  end
end

class Parent &lt; Grandparent
  include M1
end

class Child &lt; Parent
  prepend M2
  include M3
end

child = Child.new

# Add singleton method
def child.test
  &quot;Singleton&quot;
end

puts Child.ancestors
# [M2, Child, M3, Parent, M1, Grandparent, Object, Kernel, BasicObject]

child.test # &quot;Singleton&quot; - eigenclass first
</code></pre>
<p><strong>Lookup order for child.test:</strong></p>
<ol>
<li>child&#39;s singleton class → &quot;Singleton&quot; ✓ (Found!)</li>
<li>M2 (prepended)</li>
<li>Child</li>
<li>M3 (included)</li>
<li>Parent</li>
<li>M1 (included in Parent)</li>
<li>Grandparent</li>
<li>Object</li>
<li>Kernel</li>
<li>BasicObject</li>
</ol>
<h3>Using <code>super</code></h3>
<p><code>super</code> calls the next method in the lookup chain:</p>
<pre><code class="language-ruby">module Loggable
  def save
    puts &quot;Logging...&quot;
    super
  end
end

class Parent
  def save
    puts &quot;Parent save&quot;
  end
end

class Child &lt; Parent
  prepend Loggable
  
  def save
    puts &quot;Child save&quot;
    super
  end
end

child = Child.new
child.save
# Output:
# Logging...
# Child save
# Parent save
</code></pre>
<h3>Method Lookup with Multiple Inheritance (Modules)</h3>
<pre><code class="language-ruby">module A
  def greet
    &quot;Hello from A&quot;
  end
end

module B
  def greet
    &quot;Hello from B&quot;
  end
end

module C
  def greet
    &quot;Hello from C&quot;
  end
end

class MyClass
  include A
  include B
  include C
end

MyClass.ancestors
# [MyClass, C, B, A, Object, Kernel, BasicObject]

obj = MyClass.new
obj.greet # &quot;Hello from C&quot; - last included wins
</code></pre>
<h3>Performance Implications</h3>
<pre><code class="language-ruby"># Longer lookup chain = slower method calls
class A; end
class B &lt; A; end
class C &lt; B; end
class D &lt; C; end
class E &lt; D; end

# Method call on E traverses: E -&gt; D -&gt; C -&gt; B -&gt; A -&gt; Object -&gt; Kernel -&gt; BasicObject

# Better: Flatter hierarchy
class Base; end
class Feature &lt; Base; end
</code></pre>
<h3>Rails Example - Controller Inheritance</h3>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  before_action :authenticate_user!
  
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
end

class PostsController &lt; ApplicationController
  def index
    # Can use current_user (inherited from ApplicationController)
    @posts = current_user.posts
  end
end

PostsController.ancestors
# [PostsController, ApplicationController, ActionController::Base, ...]
</code></pre>
<h3>Checking Method Lookup</h3>
<pre><code class="language-ruby">class User
  def greet
    &quot;Hello&quot;
  end
end

user = User.new

# Check if method exists
user.respond_to?(:greet) # true

# Find where method is defined
user.method(:greet).owner # User

# Get method object
method_obj = user.method(:greet)
method_obj.call # &quot;Hello&quot;
</code></pre>
<h3>Method Lookup with <code>method_missing</code></h3>
<p>If Ruby doesn&#39;t find a method, it calls <code>method_missing</code>:</p>
<pre><code class="language-ruby">class DynamicClass
  def method_missing(method_name, *args)
    if method_name.to_s.start_with?(&#39;find_by_&#39;)
      attribute = method_name.to_s.sub(&#39;find_by_&#39;, &#39;&#39;)
      &quot;Finding by #{attribute} with args: #{args}&quot;
    else
      super
    end
  end
  
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.start_with?(&#39;find_by_&#39;) || super
  end
end

obj = DynamicClass.new
obj.find_by_name(&quot;John&quot;) # &quot;Finding by name with args: [\&quot;John\&quot;]&quot;
obj.find_by_email(&quot;john@example.com&quot;) # &quot;Finding by email...&quot;
</code></pre>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Lookup order</strong>: Singleton → Class → Modules (last in first out) → Superclass → repeat</li>
<li><strong><code>prepend</code></strong>: Inserts module before class</li>
<li><strong><code>include</code></strong>: Inserts module after class</li>
<li><strong><code>extend</code></strong>: Adds as class methods</li>
<li><strong><code>super</code></strong>: Calls next method in chain</li>
<li>Use <code>.ancestors</code> to see lookup path</li>
<li>Shorter chains = better performance</li>
</ol>
<hr>
<h2>Question 8: What is method overloading and method overriding in Ruby?</h2>
<h3>Answer</h3>
<p>Ruby doesn&#39;t support <strong>method overloading</strong> (same method name with different parameters) like Java or C++, but it supports <strong>method overriding</strong> (redefining methods in subclasses).</p>
<h3>Method Overloading (Not Supported Directly)</h3>
<p><strong>In other languages (Java):</strong></p>
<pre><code class="language-java">// Java example
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
    int add(int a, int b, int c) { return a + b + c; }
}
</code></pre>
<p><strong>Ruby alternative using default parameters:</strong></p>
<pre><code class="language-ruby">class Calculator
  def add(a, b, c = 0)
    a + b + c
  end
end

calc = Calculator.new
calc.add(5, 3)      # 8
calc.add(5, 3, 2)   # 10
</code></pre>
<p><strong>Ruby alternative using variable arguments:</strong></p>
<pre><code class="language-ruby">class Calculator
  def add(*numbers)
    numbers.sum
  end
end

calc = Calculator.new
calc.add(5, 3)           # 8
calc.add(5, 3, 2)        # 10
calc.add(5, 3, 2, 1)     # 11
</code></pre>
<p><strong>Ruby alternative using keyword arguments:</strong></p>
<pre><code class="language-ruby">class User
  def initialize(name:, email: nil, age: nil)
    @name = name
    @email = email
    @age = age
  end
end

User.new(name: &quot;John&quot;)
User.new(name: &quot;John&quot;, email: &quot;john@example.com&quot;)
User.new(name: &quot;John&quot;, email: &quot;john@example.com&quot;, age: 30)
</code></pre>
<p><strong>Ruby alternative using method_missing:</strong></p>
<pre><code class="language-ruby">class FlexibleClass
  def method_missing(method_name, *args)
    if method_name.to_s.start_with?(&#39;add_&#39;)
      args.sum
    else
      super
    end
  end
end

obj = FlexibleClass.new
obj.add_two(5, 3)        # 8
obj.add_three(5, 3, 2)   # 10
</code></pre>
<h3>Method Overriding (Fully Supported)</h3>
<p><strong>Method overriding</strong> is when a subclass provides its own implementation of a method defined in the parent class.</p>
<pre><code class="language-ruby">class Animal
  def speak
    &quot;Some generic sound&quot;
  end
  
  def move
    &quot;Moving...&quot;
  end
end

class Dog &lt; Animal
  def speak
    &quot;Woof!&quot;  # Overriding parent method
  end
  
  # move is inherited, not overridden
end

class Cat &lt; Animal
  def speak
    &quot;Meow!&quot;  # Overriding parent method
  end
end

dog = Dog.new
dog.speak  # &quot;Woof!&quot; - overridden method
dog.move   # &quot;Moving...&quot; - inherited method

cat = Cat.new
cat.speak  # &quot;Meow!&quot; - overridden method
</code></pre>
<h3>Using <code>super</code> in Overridden Methods</h3>
<p><code>super</code> calls the parent class&#39;s version of the method:</p>
<pre><code class="language-ruby">class Animal
  def speak
    &quot;Animal sound&quot;
  end
end

class Dog &lt; Animal
  def speak
    &quot;#{super} + Woof!&quot;  # Calls parent&#39;s speak
  end
end

dog = Dog.new
dog.speak  # &quot;Animal sound + Woof!&quot;
</code></pre>
<p><strong><code>super</code> with arguments:</strong></p>
<pre><code class="language-ruby">class Parent
  def greet(name)
    &quot;Hello, #{name}&quot;
  end
end

class Child &lt; Parent
  def greet(name)
    super(name.upcase)  # Pass modified argument to parent
  end
end

child = Child.new
child.greet(&quot;john&quot;)  # &quot;Hello, JOHN&quot;
</code></pre>
<p><strong><code>super</code> without parentheses (passes all arguments):</strong></p>
<pre><code class="language-ruby">class Parent
  def greet(first_name, last_name)
    &quot;Hello, #{first_name} #{last_name}&quot;
  end
end

class Child &lt; Parent
  def greet(first_name, last_name)
    super  # Automatically passes both arguments
  end
end

child = Child.new
child.greet(&quot;John&quot;, &quot;Doe&quot;)  # &quot;Hello, John Doe&quot;
</code></pre>
<h3>Rails Example - ActiveRecord Callbacks</h3>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Overriding ActiveRecord&#39;s save method
  def save
    normalize_email
    super  # Call parent&#39;s save
  end
  
  private
  
  def normalize_email
    self.email = email.downcase.strip if email.present?
  end
end
</code></pre>
<h3>Module Overriding</h3>
<p>Modules can override class methods:</p>
<pre><code class="language-ruby">module Auditable
  def save
    puts &quot;Auditing...&quot;
    super  # Calls next method in chain
  end
end

class User &lt; ApplicationRecord
  prepend Auditable  # Module method called first
  
  def save
    puts &quot;Saving user...&quot;
    super
  end
end

user = User.new
user.save
# Output:
# Auditing...
# Saving user...
# (ActiveRecord&#39;s save)
</code></pre>
<h3>Simulating Method Overloading with Pattern Matching (Ruby 3+)</h3>
<pre><code class="language-ruby">class Calculator
  def add(numbers)
    case numbers
    in [a, b]
      a + b
    in [a, b, c]
      a + b + c
    in [*rest]
      rest.sum
    end
  end
end

calc = Calculator.new
calc.add([5, 3])        # 8
calc.add([5, 3, 2])     # 10
calc.add([1, 2, 3, 4])  # 10
</code></pre>
<h3>Simulating Method Overloading with Options Hash</h3>
<pre><code class="language-ruby">class Payment
  def process(amount, options = {})
    method = options[:method] || &#39;credit_card&#39;
    currency = options[:currency] || &#39;USD&#39;
    
    case method
    when &#39;credit_card&#39;
      process_credit_card(amount, currency)
    when &#39;paypal&#39;
      process_paypal(amount, currency)
    when &#39;crypto&#39;
      process_crypto(amount, currency)
    end
  end
  
  private
  
  def process_credit_card(amount, currency)
    &quot;Processing #{amount} #{currency} via Credit Card&quot;
  end
  
  def process_paypal(amount, currency)
    &quot;Processing #{amount} #{currency} via PayPal&quot;
  end
  
  def process_crypto(amount, currency)
    &quot;Processing #{amount} #{currency} via Crypto&quot;
  end
end

payment = Payment.new
payment.process(100)
payment.process(100, method: &#39;paypal&#39;)
payment.process(100, method: &#39;crypto&#39;, currency: &#39;BTC&#39;)
</code></pre>
<h3>Complete Example - Polymorphism with Overriding</h3>
<pre><code class="language-ruby">class Shape
  def area
    raise NotImplementedError, &quot;Subclass must implement area&quot;
  end
  
  def perimeter
    raise NotImplementedError, &quot;Subclass must implement perimeter&quot;
  end
end

class Rectangle &lt; Shape
  attr_reader :width, :height
  
  def initialize(width, height)
    @width = width
    @height = height
  end
  
  def area
    width * height
  end
  
  def perimeter
    2 * (width + height)
  end
end

class Circle &lt; Shape
  attr_reader :radius
  
  def initialize(radius)
    @radius = radius
  end
  
  def area
    Math::PI * radius ** 2
  end
  
  def perimeter
    2 * Math::PI * radius
  end
end

shapes = [Rectangle.new(10, 20), Circle.new(5)]

shapes.each do |shape|
  puts &quot;Area: #{shape.area}&quot;
  puts &quot;Perimeter: #{shape.perimeter}&quot;
end
</code></pre>
<h3>Key Differences Summary</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Method Overloading</th>
<th>Method Overriding</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Support</strong></td>
<td>Not directly supported</td>
<td>Fully supported</td>
</tr>
<tr>
<td><strong>Definition</strong></td>
<td>Same method, different parameters</td>
<td>Subclass redefines parent method</td>
</tr>
<tr>
<td><strong>Ruby Alternative</strong></td>
<td>Default params, *args, **kwargs</td>
<td>Standard inheritance</td>
</tr>
<tr>
<td><strong>Use Case</strong></td>
<td>Multiple ways to call same method</td>
<td>Customize inherited behavior</td>
</tr>
<tr>
<td><strong>Example</strong></td>
<td><code>def add(a, b = 0)</code></td>
<td><code>class Dog &lt; Animal; def speak; end</code></td>
</tr>
</tbody></table>
<h3>Key Takeaways</h3>
<ul>
<li><strong>Ruby doesn&#39;t support method overloading</strong> by parameter count/type</li>
<li>Use <strong>default parameters, variable arguments, or keyword arguments</strong> instead</li>
<li><strong>Method overriding is standard</strong> through inheritance</li>
<li>Use <code>super</code> to call parent method</li>
<li>Modules can override methods with <code>prepend</code></li>
<li>Consider options hash for flexible method signatures</li>
</ul>
<h1>Ruby Blocks, Procs, and Lambdas Interview Questions</h1>
<h2>Question 9: Explain blocks, procs, and lambdas with examples</h2>
<h3>Answer</h3>
<p><strong>Blocks</strong>, <strong>Procs</strong>, and <strong>Lambdas</strong> are all ways to encapsulate code in Ruby, but they have different behaviors and use cases.</p>
<hr>
<h3>Blocks</h3>
<p><strong>Definition:</strong> A block is a chunk of code enclosed between <code>{ }</code> or <code>do...end</code> that can be passed to methods.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Not objects (cannot be saved to variables)</li>
<li>Passed implicitly to methods</li>
<li>Can be executed with <code>yield</code></li>
<li>One block per method call</li>
</ul>
<p><strong>Syntax:</strong></p>
<pre><code class="language-ruby"># Single line with curly braces
[1, 2, 3].each { |num| puts num }

# Multi-line with do...end
[1, 2, 3].each do |num|
  puts num * 2
end
</code></pre>
<p><strong>Example - Method accepting a block:</strong></p>
<pre><code class="language-ruby">def greet
  puts &quot;Before block&quot;
  yield if block_given?  # Execute the block
  puts &quot;After block&quot;
end

greet { puts &quot;Hello from block!&quot; }

# Output:
# Before block
# Hello from block!
# After block
</code></pre>
<p><strong>Example - Block with parameters:</strong></p>
<pre><code class="language-ruby">def calculate
  result = yield(5, 3)
  puts &quot;Result: #{result}&quot;
end

calculate { |a, b| a + b }  # Result: 8
calculate { |a, b| a * b }  # Result: 15
</code></pre>
<p><strong>Example - Checking for block:</strong></p>
<pre><code class="language-ruby">def process_data(data)
  if block_given?
    yield(data)
  else
    puts &quot;No block provided&quot;
  end
end

process_data(&quot;test&quot;) { |d| puts d.upcase }  # TEST
process_data(&quot;test&quot;)  # No block provided
</code></pre>
<hr>
<h3>Procs</h3>
<p><strong>Definition:</strong> A Proc is an object that encapsulates a block of code, which can be stored in a variable and executed later.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Are objects (can be saved to variables)</li>
<li>Can be passed around like any object</li>
<li>Created with <code>Proc.new</code> or <code>proc</code> keyword</li>
<li>Don&#39;t check argument count strictly</li>
<li><code>return</code> exits the enclosing method</li>
</ul>
<p><strong>Creating Procs:</strong></p>
<pre><code class="language-ruby"># Method 1: Proc.new
my_proc = Proc.new { |name| puts &quot;Hello, #{name}!&quot; }

# Method 2: proc keyword
my_proc = proc { |name| puts &quot;Hello, #{name}!&quot; }

# Method 3: &amp; syntax
def create_proc(&amp;block)
  block  # Returns the block as a Proc
end

my_proc = create_proc { |name| puts &quot;Hello, #{name}!&quot; }
</code></pre>
<p><strong>Calling Procs:</strong></p>
<pre><code class="language-ruby">my_proc = Proc.new { |name| puts &quot;Hello, #{name}!&quot; }

my_proc.call(&quot;John&quot;)    # Hello, John!
my_proc.(&quot;Jane&quot;)        # Hello, Jane!
my_proc[&quot;Bob&quot;]          # Hello, Bob!
my_proc === &quot;Alice&quot;     # Hello, Alice!
</code></pre>
<p><strong>Example - Storing Procs:</strong></p>
<pre><code class="language-ruby">add = Proc.new { |a, b| a + b }
multiply = Proc.new { |a, b| a * b }

operations = [add, multiply]

operations.each do |op|
  puts op.call(5, 3)
end

# Output:
# 8
# 15
</code></pre>
<p><strong>Example - Proc with loose argument checking:</strong></p>
<pre><code class="language-ruby">my_proc = Proc.new { |a, b| puts &quot;a: #{a}, b: #{b}&quot; }

my_proc.call(1)          # a: 1, b:  (no error)
my_proc.call(1, 2, 3)    # a: 1, b: 2 (extra argument ignored)
</code></pre>
<p><strong>Example - Proc return behavior:</strong></p>
<pre><code class="language-ruby">def test_proc
  my_proc = Proc.new { return &quot;Returning from proc&quot; }
  my_proc.call
  &quot;This won&#39;t be reached&quot;
end

puts test_proc  # &quot;Returning from proc&quot; (returns from method)
</code></pre>
<hr>
<h3>Lambdas</h3>
<p><strong>Definition:</strong> A Lambda is a special type of Proc with stricter behavior around arguments and returns.</p>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Are Proc objects with lambda behavior</li>
<li>Created with <code>lambda</code> keyword or <code>-&gt;</code> syntax</li>
<li>Strictly check argument count</li>
<li><code>return</code> returns from lambda, not enclosing method</li>
<li>More method-like behavior</li>
</ul>
<p><strong>Creating Lambdas:</strong></p>
<pre><code class="language-ruby"># Method 1: lambda keyword
my_lambda = lambda { |name| puts &quot;Hello, #{name}!&quot; }

# Method 2: -&gt; syntax (stabby lambda)
my_lambda = -&gt;(name) { puts &quot;Hello, #{name}!&quot; }

# With parameters
add = -&gt;(a, b) { a + b }
</code></pre>
<p><strong>Calling Lambdas:</strong></p>
<pre><code class="language-ruby">my_lambda = -&gt;(name) { puts &quot;Hello, #{name}!&quot; }

my_lambda.call(&quot;John&quot;)   # Hello, John!
my_lambda.(&quot;Jane&quot;)       # Hello, Jane!
my_lambda[&quot;Bob&quot;]         # Hello, Bob!
</code></pre>
<p><strong>Example - Strict argument checking:</strong></p>
<pre><code class="language-ruby">my_lambda = -&gt;(a, b) { puts &quot;a: #{a}, b: #{b}&quot; }

my_lambda.call(1, 2)     # a: 1, b: 2
my_lambda.call(1)        # ArgumentError: wrong number of arguments
my_lambda.call(1, 2, 3)  # ArgumentError: wrong number of arguments
</code></pre>
<p><strong>Example - Lambda return behavior:</strong></p>
<pre><code class="language-ruby">def test_lambda
  my_lambda = lambda { return &quot;Returning from lambda&quot; }
  result = my_lambda.call
  &quot;Method continues: #{result}&quot;
end

puts test_lambda  # &quot;Method continues: Returning from lambda&quot;
</code></pre>
<p><strong>Example - Default parameters in lambdas:</strong></p>
<pre><code class="language-ruby">greet = -&gt;(name = &quot;Guest&quot;) { &quot;Hello, #{name}!&quot; }

greet.call           # &quot;Hello, Guest!&quot;
greet.call(&quot;John&quot;)   # &quot;Hello, John!&quot;
</code></pre>
<p><strong>Example - Multiple parameters:</strong></p>
<pre><code class="language-ruby">calculate = -&gt;(operation, a, b) do
  case operation
  when :add
    a + b
  when :multiply
    a * b
  when :divide
    a / b
  end
end

puts calculate.call(:add, 10, 5)       # 15
puts calculate.call(:multiply, 10, 5)  # 50
puts calculate.call(:divide, 10, 5)    # 2
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Block</th>
<th>Proc</th>
<th>Lambda</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Object?</strong></td>
<td>No</td>
<td>Yes</td>
<td>Yes (special Proc)</td>
</tr>
<tr>
<td><strong>Can be saved</strong></td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Argument checking</strong></td>
<td>Flexible</td>
<td>Flexible</td>
<td>Strict</td>
</tr>
<tr>
<td><strong>Return behavior</strong></td>
<td>Returns from block</td>
<td>Returns from method</td>
<td>Returns from lambda</td>
</tr>
<tr>
<td><strong>Creation</strong></td>
<td><code>{ }</code> or <code>do...end</code></td>
<td><code>Proc.new</code> or <code>proc</code></td>
<td><code>lambda</code> or <code>-&gt;</code></td>
</tr>
<tr>
<td><strong>Call syntax</strong></td>
<td><code>yield</code></td>
<td><code>.call</code>, <code>.()</code>, <code>[]</code></td>
<td><code>.call</code>, <code>.()</code>, <code>[]</code></td>
</tr>
</tbody></table>
<hr>
<h3>Detailed Return Behavior Comparison</h3>
<pre><code class="language-ruby"># Block return - not applicable (blocks don&#39;t return)

# Proc return - returns from enclosing method
def proc_return_test
  my_proc = Proc.new { return &quot;Proc return&quot; }
  my_proc.call
  &quot;This won&#39;t be printed&quot;
end

puts proc_return_test  # &quot;Proc return&quot;

# Lambda return - returns from lambda only
def lambda_return_test
  my_lambda = lambda { return &quot;Lambda return&quot; }
  result = my_lambda.call
  &quot;Method continues: #{result}&quot;
end

puts lambda_return_test  # &quot;Method continues: Lambda return&quot;
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Custom Iterator with Block</strong></p>
<pre><code class="language-ruby">class CustomArray
  def initialize(array)
    @array = array
  end
  
  def custom_each
    index = 0
    while index &lt; @array.length
      yield(@array[index]) if block_given?
      index += 1
    end
  end
end

arr = CustomArray.new([1, 2, 3, 4, 5])
arr.custom_each { |num| puts num * 2 }

# Output:
# 2
# 4
# 6
# 8
# 10
</code></pre>
<p><strong>Example 2: Callback Pattern with Procs</strong></p>
<pre><code class="language-ruby">class EventManager
  def initialize
    @callbacks = []
  end
  
  def on_event(&amp;callback)
    @callbacks &lt;&lt; callback
  end
  
  def trigger_event(data)
    @callbacks.each { |callback| callback.call(data) }
  end
end

manager = EventManager.new

manager.on_event { |data| puts &quot;Handler 1: #{data}&quot; }
manager.on_event { |data| puts &quot;Handler 2: #{data.upcase}&quot; }

manager.trigger_event(&quot;hello&quot;)

# Output:
# Handler 1: hello
# Handler 2: HELLO
</code></pre>
<p><strong>Example 3: Strategy Pattern with Lambdas</strong></p>
<pre><code class="language-ruby">class Calculator
  def initialize
    @operations = {
      add: -&gt;(a, b) { a + b },
      subtract: -&gt;(a, b) { a - b },
      multiply: -&gt;(a, b) { a * b },
      divide: -&gt;(a, b) { a.to_f / b }
    }
  end
  
  def calculate(operation, a, b)
    @operations[operation].call(a, b)
  end
end

calc = Calculator.new
puts calc.calculate(:add, 10, 5)       # 15
puts calc.calculate(:multiply, 10, 5)  # 50
puts calc.calculate(:divide, 10, 5)    # 2.0
</code></pre>
<p><strong>Example 4: Rails - Scopes with Lambdas</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Lambda ensures the current time is evaluated when called
  scope :active, -&gt; { where(&quot;last_login_at &gt; ?&quot;, 30.days.ago) }
  
  # Without lambda, time would be evaluated at class load
  # BAD: scope :active, where(&quot;last_login_at &gt; ?&quot;, 30.days.ago)
  
  scope :by_role, -&gt;(role) { where(role: role) }
  scope :recent, -&gt;(limit = 10) { order(created_at: :desc).limit(limit) }
end

# Usage
User.active
User.by_role(&#39;admin&#39;)
User.recent(5)
</code></pre>
<p><strong>Example 5: Method as Block with &amp;</strong></p>
<pre><code class="language-ruby">numbers = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]

# Without &amp;
numbers.map { |n| n.to_i }  # [1, 2, 3, 4, 5]

# With &amp; - converts symbol to proc
numbers.map(&amp;:to_i)  # [1, 2, 3, 4, 5]

# How it works
# &amp;:to_i is equivalent to { |n| n.to_i }

# More examples
[&quot;hello&quot;, &quot;world&quot;].map(&amp;:upcase)  # [&quot;HELLO&quot;, &quot;WORLD&quot;]
[1, 2, 3, 4, 5].select(&amp;:even?)   # [2, 4]
</code></pre>
<hr>
<h3>Advanced: Converting Between Types</h3>
<pre><code class="language-ruby"># Block to Proc with &amp;
def method_with_proc(&amp;block)
  # block is now a Proc object
  block.call(&quot;test&quot;)
end

method_with_proc { |x| puts x }  # test

# Proc to Block with &amp;
my_proc = Proc.new { |x| puts x * 2 }
[1, 2, 3].each(&amp;my_proc)  # 2, 4, 6

# Lambda to Block with &amp;
my_lambda = -&gt;(x) { puts x * 3 }
[1, 2, 3].each(&amp;my_lambda)  # 3, 6, 9

# Check if Proc is a Lambda
regular_proc = Proc.new { }
lambda_proc = lambda { }

regular_proc.lambda?  # false
lambda_proc.lambda?   # true
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

n = 1_000_000

Benchmark.bm do |x|
  x.report(&quot;Block:&quot;) do
    n.times { |i| i + 1 }
  end
  
  x.report(&quot;Proc:&quot;) do
    my_proc = Proc.new { |i| i + 1 }
    n.times { |i| my_proc.call(i) }
  end
  
  x.report(&quot;Lambda:&quot;) do
    my_lambda = -&gt;(i) { i + 1 }
    n.times { |i| my_lambda.call(i) }
  end
end

# Blocks are generally fastest (no object creation overhead)
# Procs and Lambdas are slightly slower but more flexible
</code></pre>
<hr>
<h3>When to Use What?</h3>
<p><strong>Use Blocks when:</strong></p>
<ul>
<li>Passing code to a method for immediate execution</li>
<li>Implementing iterators</li>
<li>Simple, one-time operations</li>
<li>Method expects only one piece of executable code</li>
</ul>
<p><strong>Use Procs when:</strong></p>
<ul>
<li>Need to store code for later use</li>
<li>Want to pass multiple pieces of code</li>
<li>Don&#39;t need strict argument checking</li>
<li>Building callback systems</li>
</ul>
<p><strong>Use Lambdas when:</strong></p>
<ul>
<li>Need strict argument checking</li>
<li>Want method-like behavior</li>
<li>Building reusable functions</li>
<li>Need predictable return behavior</li>
<li>Defining scopes in Rails</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Blocks</strong> are syntactic sugar, not objects</li>
<li><strong>Procs</strong> are objects with flexible argument handling</li>
<li><strong>Lambdas</strong> are Procs with strict, method-like behavior</li>
<li>Use <code>yield</code> for blocks, <code>.call</code> for Procs/Lambdas</li>
<li><code>&amp;</code> converts between blocks and Procs</li>
<li>Lambdas are generally preferred for predictable behavior</li>
</ol>
<hr>
<h2>Question 10: What is the difference between Proc and Lambda in Ruby?</h2>
<h3>Answer</h3>
<p>While both Procs and Lambdas are Proc objects, they have important behavioral differences in <strong>argument handling</strong> and <strong>return behavior</strong>.</p>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Proc</th>
<th>Lambda</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Argument checking</strong></td>
<td>Flexible (ignores extra, nil for missing)</td>
<td>Strict (ArgumentError if mismatch)</td>
</tr>
<tr>
<td><strong>Return behavior</strong></td>
<td>Returns from enclosing method</td>
<td>Returns from lambda itself</td>
</tr>
<tr>
<td><strong>Creation</strong></td>
<td><code>Proc.new</code>, <code>proc</code></td>
<td><code>lambda</code>, <code>-&gt;</code></td>
</tr>
<tr>
<td><strong>Lambda check</strong></td>
<td><code>.lambda?</code> returns <code>false</code></td>
<td><code>.lambda?</code> returns <code>true</code></td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Callbacks, flexible APIs</td>
<td>Reusable functions, strict contracts</td>
</tr>
</tbody></table>
<hr>
<h3>Difference 1: Argument Handling</h3>
<p><strong>Proc - Flexible Arguments:</strong></p>
<pre><code class="language-ruby">my_proc = Proc.new { |a, b| puts &quot;a: #{a}, b: #{b}&quot; }

my_proc.call(1)          # a: 1, b:  (no error, b is nil)
my_proc.call(1, 2)       # a: 1, b: 2
my_proc.call(1, 2, 3)    # a: 1, b: 2 (ignores extra argument)
</code></pre>
<p><strong>Lambda - Strict Arguments:</strong></p>
<pre><code class="language-ruby">my_lambda = lambda { |a, b| puts &quot;a: #{a}, b: #{b}&quot; }

my_lambda.call(1, 2)     # a: 1, b: 2 ✓
my_lambda.call(1)        # ArgumentError: wrong number of arguments (given 1, expected 2)
my_lambda.call(1, 2, 3)  # ArgumentError: wrong number of arguments (given 3, expected 2)
</code></pre>
<p><strong>With Default Parameters:</strong></p>
<pre><code class="language-ruby"># Proc with defaults
my_proc = Proc.new { |a, b = 10| puts &quot;a: #{a}, b: #{b}&quot; }
my_proc.call(5)      # a: 5, b: 10
my_proc.call(5, 20)  # a: 5, b: 20

# Lambda with defaults
my_lambda = -&gt;(a, b = 10) { puts &quot;a: #{a}, b: #{b}&quot; }
my_lambda.call(5)      # a: 5, b: 10
my_lambda.call(5, 20)  # a: 5, b: 20
</code></pre>
<hr>
<h3>Difference 2: Return Behavior</h3>
<p><strong>Proc - Returns from Enclosing Method:</strong></p>
<pre><code class="language-ruby">def test_proc
  puts &quot;Before proc&quot;
  
  my_proc = Proc.new do
    puts &quot;Inside proc&quot;
    return &quot;Returning from proc&quot;
  end
  
  my_proc.call
  
  puts &quot;After proc&quot;  # This won&#39;t execute
  &quot;This won&#39;t be returned&quot;
end

puts test_proc

# Output:
# Before proc
# Inside proc
# Returning from proc
</code></pre>
<p><strong>Lambda - Returns from Lambda Only:</strong></p>
<pre><code class="language-ruby">def test_lambda
  puts &quot;Before lambda&quot;
  
  my_lambda = lambda do
    puts &quot;Inside lambda&quot;
    return &quot;Returning from lambda&quot;
  end
  
  result = my_lambda.call
  
  puts &quot;After lambda&quot;  # This WILL execute
  &quot;Method return: #{result}&quot;
end

puts test_lambda

# Output:
# Before lambda
# Inside lambda
# After lambda
# Method return: Returning from lambda
</code></pre>
<p><strong>Proc Return in Different Context:</strong></p>
<pre><code class="language-ruby"># Proc outside method context raises LocalJumpError
my_proc = Proc.new { return &quot;test&quot; }
my_proc.call  # LocalJumpError: unexpected return

# Lambda works fine
my_lambda = lambda { return &quot;test&quot; }
my_lambda.call  # &quot;test&quot; - no error
</code></pre>
<hr>
<h3>Difference 3: Creation Syntax</h3>
<pre><code class="language-ruby"># Proc creation
proc1 = Proc.new { puts &quot;I&#39;m a Proc&quot; }
proc2 = proc { puts &quot;I&#39;m also a Proc&quot; }

# Lambda creation
lambda1 = lambda { puts &quot;I&#39;m a Lambda&quot; }
lambda2 = -&gt; { puts &quot;I&#39;m also a Lambda&quot; }
lambda3 = -&gt;(x) { puts &quot;Lambda with param: #{x}&quot; }

# Check type
proc1.lambda?    # false
lambda1.lambda?  # true
</code></pre>
<hr>
<h3>Difference 4: Checking Lambda Status</h3>
<pre><code class="language-ruby">def check_type(callable)
  if callable.lambda?
    puts &quot;This is a Lambda&quot;
    puts &quot;- Strict argument checking&quot;
    puts &quot;- Returns from lambda&quot;
  else
    puts &quot;This is a Proc&quot;
    puts &quot;- Flexible argument checking&quot;
    puts &quot;- Returns from enclosing method&quot;
  end
end

check_type(Proc.new { })     # This is a Proc
check_type(lambda { })       # This is a Lambda
check_type(-&gt;{})            # This is a Lambda
</code></pre>
<hr>
<h3>Practical Examples</h3>
<p><strong>Example 1: Callbacks with Proc (Flexible)</strong></p>
<pre><code class="language-ruby">class EventManager
  def initialize
    @callbacks = []
  end
  
  def on_event(&amp;callback)
    @callbacks &lt;&lt; callback
  end
  
  def trigger(data)
    @callbacks.each { |cb| cb.call(data) }
  end
end

manager = EventManager.new

# Different callbacks with different signatures
manager.on_event { |data| puts &quot;Handler 1: #{data}&quot; }
manager.on_event { puts &quot;Handler 2: no params&quot; }  # Works fine with Proc
manager.on_event { |d, extra| puts &quot;Handler 3: #{d}&quot; }  # Extra param ignored

manager.trigger(&quot;Event occurred&quot;)

# Output:
# Handler 1: Event occurred
# Handler 2: no params
# Handler 3: Event occurred
</code></pre>
<p><strong>Example 2: Function Composition with Lambda (Strict)</strong></p>
<pre><code class="language-ruby">class FunctionComposer
  def initialize
    @functions = []
  end
  
  def add(func)
    raise &quot;Must be a lambda&quot; unless func.lambda?
    @functions &lt;&lt; func
  end
  
  def execute(input)
    @functions.reduce(input) { |result, func| func.call(result) }
  end
end

composer = FunctionComposer.new
composer.add(-&gt;(x) { x * 2 })
composer.add(-&gt;(x) { x + 10 })
composer.add(-&gt;(x) { x ** 2 })

puts composer.execute(5)  # ((5 * 2) + 10) ** 2 = 400
</code></pre>
<p><strong>Example 3: Rails Scopes</strong></p>
<pre><code class="language-ruby"># Procs in scopes would break
class User &lt; ApplicationRecord
  # DON&#39;T DO THIS - Proc evaluates immediately
  # scope :active, Proc.new { where(&quot;created_at &gt; ?&quot;, 30.days.ago) }
  
  # DO THIS - Lambda evaluates when called
  scope :active, -&gt; { where(&quot;created_at &gt; ?&quot;, 30.days.ago) }
  scope :by_role, -&gt;(role) { where(role: role) }
  
  # Lambda ensures fresh evaluation
  scope :recent_orders, -&gt;(days = 7) do
    where(&quot;created_at &gt; ?&quot;, days.days.ago)
  end
end

# Each call uses current time
User.active  # Evaluates 30.days.ago from NOW
</code></pre>
<p><strong>Example 4: Return Behavior in Controllers</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  def authenticate_user!
    # With Proc - would exit the method immediately
    check = Proc.new do
      return redirect_to login_path unless current_user
    end
    check.call  # Exits authenticate_user! method
  end
  
  def authorize_admin!
    # With Lambda - returns from lambda only
    check = lambda do
      return false unless current_user&amp;.admin?
      true
    end
    
    redirect_to root_path unless check.call
    # Code continues here if authorized
  end
end
</code></pre>
<hr>
<h3>When to Use Proc vs Lambda</h3>
<p><strong>Use Proc when:</strong></p>
<ul>
<li>Building callback systems with flexible signatures</li>
<li>Don&#39;t need strict argument validation</li>
<li>Want early return from enclosing method</li>
<li>Converting blocks to objects</li>
</ul>
<pre><code class="language-ruby"># Proc for flexible callbacks
class Observer
  def notify(&amp;callback)
    # Callback can have any signature
    callback.call(&quot;event&quot;, &quot;data&quot;)  # Works even if callback expects fewer args
  end
end
</code></pre>
<p><strong>Use Lambda when:</strong></p>
<ul>
<li>Need strict argument checking</li>
<li>Want predictable return behavior</li>
<li>Building reusable, function-like objects</li>
<li>Defining Rails scopes</li>
<li>Method-like behavior is needed</li>
</ul>
<pre><code class="language-ruby"># Lambda for strict function-like behavior
class Calculator
  OPERATIONS = {
    add: -&gt;(a, b) { a + b },
    sub: -&gt;(a, b) { a - b },
    mul: -&gt;(a, b) { a * b }
  }
  
  def calculate(op, a, b)
    OPERATIONS[op].call(a, b)  # Strict args required
  end
end
</code></pre>
<hr>
<h3>Advanced: Arity Differences</h3>
<p><strong>Arity</strong> is the number of arguments a Proc/Lambda expects:</p>
<pre><code class="language-ruby"># Proc arity
proc_no_args = Proc.new { }
proc_no_args.arity  # 0

proc_one_arg = Proc.new { |a| }
proc_one_arg.arity  # 1

proc_optional = Proc.new { |a, b=nil| }
proc_optional.arity  # 1 (required args only)

proc_splat = Proc.new { |*args| }
proc_splat.arity  # -1 (variable args)

# Lambda arity
lambda_two_args = -&gt;(a, b) { }
lambda_two_args.arity  # 2

lambda_optional = -&gt;(a, b=10) { }
lambda_optional.arity  # -2 (negative = optional args)

lambda_splat = -&gt;(*args) { }
lambda_splat.arity  # -1
</code></pre>
<hr>
<h3>Memory and Performance</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

n = 1_000_000

# Procs and Lambdas have similar performance
Benchmark.bm do |x|
  my_proc = Proc.new { |i| i + 1 }
  my_lambda = -&gt;(i) { i + 1 }
  
  x.report(&quot;Proc:&quot;) do
    n.times { |i| my_proc.call(i) }
  end
  
  x.report(&quot;Lambda:&quot;) do
    n.times { |i| my_lambda.call(i) }
  end
end

# Performance is nearly identical
# Choose based on behavior, not performance
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Lambdas are more strict</strong> - check arguments and return locally</li>
<li><strong>Procs are more flexible</strong> - ignore arg mismatches and return from method</li>
<li><strong>Use lambda for function-like behavior</strong> (Rails scopes, math operations)</li>
<li><strong>Use proc for callbacks</strong> where flexibility is needed</li>
<li><strong>Both are Proc objects</strong>, differentiated by <code>lambda?</code> method</li>
<li><strong>Default to lambda</strong> unless you specifically need Proc behavior</li>
</ol>
<hr>
<h2>Question 11: What is Yield in Ruby?</h2>
<h3>Answer</h3>
<p><strong><code>yield</code></strong> is a Ruby keyword that executes a block passed to a method. It transfers control from the method to the block, executes the block, and returns control back to the method.</p>
<hr>
<h3>Basic Yield</h3>
<pre><code class="language-ruby">def greet
  puts &quot;Hello&quot;
  yield
  puts &quot;Goodbye&quot;
end

greet { puts &quot;from the block!&quot; }

# Output:
# Hello
# from the block!
# Goodbye
</code></pre>
<hr>
<h3>Yield with Parameters</h3>
<pre><code class="language-ruby">def calculate
  result = yield(5, 3)
  puts &quot;Result: #{result}&quot;
end

calculate { |a, b| a + b }  # Result: 8
calculate { |a, b| a * b }  # Result: 15
</code></pre>
<hr>
<h3>Checking for Block with <code>block_given?</code></h3>
<pre><code class="language-ruby">def flexible_method
  if block_given?
    yield
  else
    puts &quot;No block provided&quot;
  end
end

flexible_method { puts &quot;Block executed!&quot; }  # Block executed!
flexible_method                              # No block provided
</code></pre>
<hr>
<h3>Multiple Yields</h3>
<pre><code class="language-ruby">def repeat(times)
  times.times do |i|
    yield(i)
  end
end

repeat(3) { |i| puts &quot;Iteration #{i}&quot; }

# Output:
# Iteration 0
# Iteration 1
# Iteration 2
</code></pre>
<hr>
<h3>Yield with Return Value</h3>
<pre><code class="language-ruby">def transform
  value = yield(10)
  &quot;Transformed: #{value}&quot;
end

result = transform { |x| x * 2 }
puts result  # Transformed: 20

result = transform { |x| x ** 2 }
puts result  # Transformed: 100
</code></pre>
<hr>
<h3>Real-World Example - Custom Iterator</h3>
<pre><code class="language-ruby">class CustomArray
  def initialize(array)
    @array = array
  end
  
  def custom_map
    result = []
    @array.each do |element|
      result &lt;&lt; yield(element)
    end
    result
  end
  
  def custom_select
    result = []
    @array.each do |element|
      result &lt;&lt; element if yield(element)
    end
    result
  end
end

arr = CustomArray.new([1, 2, 3, 4, 5])

# Using custom_map
doubled = arr.custom_map { |x| x * 2 }
puts doubled.inspect  # [2, 4, 6, 8, 10]

# Using custom_select
evens = arr.custom_select { |x| x.even? }
puts evens.inspect  # [2, 4]
</code></pre>
<hr>
<h3>Rails Example - Transaction with Block</h3>
<pre><code class="language-ruby">def with_transaction
  ActiveRecord::Base.transaction do
    begin
      yield
      puts &quot;Transaction successful&quot;
    rescue =&gt; e
      puts &quot;Transaction failed: #{e.message}&quot;
      raise ActiveRecord::Rollback
    end
  end
end

# Usage
with_transaction do
  User.create!(name: &quot;John&quot;, email: &quot;john@example.com&quot;)
  Post.create!(title: &quot;First post&quot;, user_id: 1)
end
</code></pre>
<hr>
<h3>Benchmarking Example</h3>
<pre><code class="language-ruby">def benchmark
  start_time = Time.now
  yield
  end_time = Time.now
  puts &quot;Execution time: #{end_time - start_time} seconds&quot;
end

benchmark do
  1000000.times { |i| i * 2 }
end

# Output: Execution time: 0.123 seconds
</code></pre>
<hr>
<h3>Yield vs Block Parameter</h3>
<pre><code class="language-ruby"># Using yield (implicit)
def method1
  yield
end

method1 { puts &quot;Using yield&quot; }

# Using block parameter (explicit)
def method2(&amp;block)
  block.call
end

method2 { puts &quot;Using block parameter&quot; }
</code></pre>
<p><strong>When to use which:</strong></p>
<ul>
<li><strong>Use yield</strong>: When you just need to execute the block</li>
<li><strong>Use &amp;block</strong>: When you need to store, pass, or manipulate the block</li>
</ul>
<hr>
<h3>Advanced: Yield Performance</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

n = 1_000_000

Benchmark.bm do |x|
  x.report(&quot;yield:&quot;) do
    def with_yield
      yield
    end
    
    n.times { with_yield { 1 + 1 } }
  end
  
  x.report(&quot;block:&quot;) do
    def with_block(&amp;block)
      block.call
    end
    
    n.times { with_block { 1 + 1 } }
  end
end

# yield is faster (no Proc object creation)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>yield</code> executes blocks</strong> passed to methods</li>
<li><strong>Use <code>block_given?</code></strong> to check for block presence</li>
<li><strong>Pass parameters</strong> to blocks via yield</li>
<li><strong>More performant than &amp;block</strong> (no object creation)</li>
<li><strong>Common in iterators, callbacks, and custom DSLs</strong></li>
</ol>
<h1>Ruby Metaprogramming Interview Questions</h1>
<h2>Question 12: What is metaprogramming in Ruby? Provide examples</h2>
<h3>Answer</h3>
<p><strong>Metaprogramming</strong> is writing code that writes code. Ruby allows you to define methods, classes, and modify behavior dynamically at runtime.</p>
<hr>
<h3>Why Metaprogramming?</h3>
<ul>
<li><strong>DRY (Don&#39;t Repeat Yourself)</strong>: Generate repetitive code automatically</li>
<li><strong>Flexibility</strong>: Create dynamic APIs and DSLs</li>
<li><strong>Rails Magic</strong>: ActiveRecord, validations, associations all use metaprogramming</li>
</ul>
<hr>
<h3>Common Metaprogramming Techniques</h3>
<h4>1. <code>define_method</code> - Define Methods Dynamically</h4>
<pre><code class="language-ruby">class User
  [:name, :email, :age].each do |attribute|
    define_method(attribute) do
      instance_variable_get(&quot;@#{attribute}&quot;)
    end
    
    define_method(&quot;#{attribute}=&quot;) do |value|
      instance_variable_set(&quot;@#{attribute}&quot;, value)
    end
  end
end

user = User.new
user.name = &quot;John&quot;
user.email = &quot;john@example.com&quot;

puts user.name   # John
puts user.email  # john@example.com
</code></pre>
<h4>2. <code>method_missing</code> - Handle Missing Methods</h4>
<pre><code class="language-ruby">class DynamicFinder
  def initialize(data)
    @data = data
  end
  
  def method_missing(method_name, *args)
    if method_name.to_s.start_with?(&#39;find_by_&#39;)
      attribute = method_name.to_s.sub(&#39;find_by_&#39;, &#39;&#39;)
      @data.find { |item| item[attribute.to_sym] == args.first }
    else
      super
    end
  end
  
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.start_with?(&#39;find_by_&#39;) || super
  end
end

users = [
  { name: &quot;John&quot;, age: 30 },
  { name: &quot;Jane&quot;, age: 25 }
]

finder = DynamicFinder.new(users)
puts finder.find_by_name(&quot;John&quot;).inspect  # {:name=&gt;&quot;John&quot;, :age=&gt;30}
puts finder.find_by_age(25).inspect       # {:name=&gt;&quot;Jane&quot;, :age=&gt;25}
</code></pre>
<h4>3. <code>send</code> - Call Methods Dynamically</h4>
<pre><code class="language-ruby">class Calculator
  def add(a, b)
    a + b
  end
  
  def multiply(a, b)
    a * b
  end
end

calc = Calculator.new
method_name = :add

result = calc.send(method_name, 5, 3)  # 8

# Useful for dynamic method calls
operations = [:add, :multiply]
operations.each do |op|
  puts calc.send(op, 10, 5)
end
# Output: 15, 50
</code></pre>
<h4>4. <code>class_eval</code> and <code>instance_eval</code></h4>
<pre><code class="language-ruby"># class_eval - Evaluates code in the context of a class
class User
end

User.class_eval do
  def greet
    &quot;Hello!&quot;
  end
end

User.new.greet  # &quot;Hello!&quot;

# instance_eval - Evaluates code in the context of an instance
user = User.new
user.instance_eval do
  @name = &quot;John&quot;
end

user.instance_variable_get(:@name)  # &quot;John&quot;
</code></pre>
<h4>5. <code>attr_accessor</code>, <code>attr_reader</code>, <code>attr_writer</code> - Built-in Metaprogramming</h4>
<pre><code class="language-ruby"># What attr_accessor does behind the scenes:
class User
  def name
    @name
  end
  
  def name=(value)
    @name = value
  end
end

# Using metaprogramming:
class User
  attr_accessor :name
end

# Both are equivalent!
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: ActiveRecord-Style Associations</strong></p>
<pre><code class="language-ruby">class Model
  def self.has_many(association)
    define_method(association) do
      # Simulate fetching associated records
      instance_variable_get(&quot;@#{association}&quot;) || []
    end
    
    define_method(&quot;#{association}=&quot;) do |value|
      instance_variable_set(&quot;@#{association}&quot;, value)
    end
  end
  
  def self.belongs_to(association)
    define_method(association) do
      instance_variable_get(&quot;@#{association}&quot;)
    end
    
    define_method(&quot;#{association}=&quot;) do |value|
      instance_variable_set(&quot;@#{association}&quot;, value)
    end
  end
end

class User &lt; Model
  has_many :posts
end

class Post &lt; Model
  belongs_to :user
end

user = User.new
user.posts = [&quot;Post 1&quot;, &quot;Post 2&quot;]
puts user.posts.inspect  # [&quot;Post 1&quot;, &quot;Post 2&quot;]
</code></pre>
<p><strong>Example 2: Validation DSL</strong></p>
<pre><code class="language-ruby">class Validator
  def self.validates(attribute, options = {})
    define_method(&quot;validate_#{attribute}&quot;) do
      value = instance_variable_get(&quot;@#{attribute}&quot;)
      
      if options[:presence] &amp;&amp; value.nil?
        &quot;#{attribute} can&#39;t be blank&quot;
      elsif options[:length] &amp;&amp; value.length &gt; options[:length]
        &quot;#{attribute} is too long&quot;
      end
    end
  end
  
  def valid?
    self.class.instance_methods(false).grep(/^validate_/).all? do |method|
      send(method).nil?
    end
  end
end

class User &lt; Validator
  attr_accessor :name, :email
  
  validates :name, presence: true
  validates :email, presence: true, length: 50
  
  def initialize(name, email)
    @name = name
    @email = email
  end
end

user = User.new(nil, &quot;test@example.com&quot;)
puts user.valid?  # false
puts user.validate_name  # &quot;name can&#39;t be blank&quot;
</code></pre>
<p><strong>Example 3: Logging Decorator</strong></p>
<pre><code class="language-ruby">module Loggable
  def self.included(base)
    base.extend(ClassMethods)
  end
  
  module ClassMethods
    def log_method(method_name)
      original_method = instance_method(method_name)
      
      define_method(method_name) do |*args, &amp;block|
        puts &quot;Calling #{method_name} with #{args.inspect}&quot;
        result = original_method.bind(self).call(*args, &amp;block)
        puts &quot;#{method_name} returned #{result.inspect}&quot;
        result
      end
    end
  end
end

class Calculator
  include Loggable
  
  def add(a, b)
    a + b
  end
  
  log_method :add
end

calc = Calculator.new
calc.add(5, 3)

# Output:
# Calling add with [5, 3]
# add returned 8
</code></pre>
<p><strong>Example 4: Configuration DSL</strong></p>
<pre><code class="language-ruby">class Config
  def self.setting(name, default: nil)
    define_method(name) do
      instance_variable_get(&quot;@#{name}&quot;) || default
    end
    
    define_method(&quot;#{name}=&quot;) do |value|
      instance_variable_set(&quot;@#{name}&quot;, value)
    end
  end
end

class AppConfig &lt; Config
  setting :api_key
  setting :timeout, default: 30
  setting :retries, default: 3
end

config = AppConfig.new
config.api_key = &quot;secret123&quot;
puts config.api_key  # secret123
puts config.timeout  # 30
puts config.retries  # 3
</code></pre>
<hr>
<h3>Rails Examples</h3>
<p><strong>ActiveRecord Associations:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :posts
  has_one :profile
  belongs_to :organization
end

# Behind the scenes:
# - define_method :posts (getter)
# - define_method :posts= (setter)
# - method_missing for dynamic finders
</code></pre>
<p><strong>ActiveRecord Validations:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email, presence: true, uniqueness: true
  validates :age, numericality: { greater_than: 0 }
end

# Uses metaprogramming to create validation methods
</code></pre>
<p><strong>ActiveRecord Scopes:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  scope :active, -&gt; { where(active: true) }
  scope :admin, -&gt; { where(role: &#39;admin&#39;) }
end

# Defines class methods dynamically
</code></pre>
<hr>
<h3>Advanced Metaprogramming</h3>
<p><strong>Creating a Simple ORM:</strong></p>
<pre><code class="language-ruby">class SimpleORM
  def self.table(name)
    @table_name = name
  end
  
  def self.table_name
    @table_name
  end
  
  def self.column(name, type)
    @columns ||= []
    @columns &lt;&lt; { name: name, type: type }
    
    attr_accessor name
  end
  
  def self.columns
    @columns || []
  end
  
  def self.all
    # Simulate SELECT * FROM table
    puts &quot;SELECT * FROM #{table_name}&quot;
    []
  end
  
  def save
    attrs = self.class.columns.map { |col| col[:name] }
    values = attrs.map { |attr| send(attr) }
    puts &quot;INSERT INTO #{self.class.table_name} (#{attrs.join(&#39;, &#39;)}) VALUES (#{values.join(&#39;, &#39;)})&quot;
  end
end

class User &lt; SimpleORM
  table :users
  column :name, :string
  column :email, :string
  column :age, :integer
end

user = User.new
user.name = &quot;John&quot;
user.email = &quot;john@example.com&quot;
user.age = 30
user.save

# Output: INSERT INTO users (name, email, age) VALUES (John, john@example.com, 30)
</code></pre>
<hr>
<h3>Dangers of Metaprogramming</h3>
<p><strong>1. Performance Overhead:</strong></p>
<pre><code class="language-ruby"># Slower than regular methods
def method_missing(name, *args)
  # Dynamic lookup
end
</code></pre>
<p><strong>2. Debugging Difficulty:</strong></p>
<pre><code class="language-ruby"># Hard to trace where methods are defined
user.some_dynamic_method  # Where is this defined?
</code></pre>
<p><strong>3. Unexpected Behavior:</strong></p>
<pre><code class="language-ruby">class User
  def method_missing(name, *args)
    &quot;Method #{name} called&quot;
  end
end

user = User.new
user.typo_method  # Returns string instead of error
</code></pre>
<hr>
<h3>Best Practices</h3>
<ol>
<li><strong>Use <code>respond_to_missing?</code> with <code>method_missing</code>:</strong></li>
</ol>
<pre><code class="language-ruby">def method_missing(name, *args)
  # handle method
end

def respond_to_missing?(name, include_private = false)
  # return true if method should exist
end
</code></pre>
<ol start="2">
<li><strong>Document Dynamic Methods:</strong></li>
</ol>
<pre><code class="language-ruby"># @!method name
#   Returns the user&#39;s name
#   @return [String]
define_method(:name) { @name }
</code></pre>
<ol start="3">
<li><strong>Prefer Explicit Over Magical:</strong></li>
</ol>
<pre><code class="language-ruby"># Bad: Too much magic
user.find_by_name_and_email(&quot;John&quot;, &quot;john@example.com&quot;)

# Good: Explicit
user.find_by(name: &quot;John&quot;, email: &quot;john@example.com&quot;)
</code></pre>
<ol start="4">
<li><strong>Cache Dynamic Methods:</strong></li>
</ol>
<pre><code class="language-ruby"># Don&#39;t create methods on every call
def method_missing(name, *args)
  if name.to_s.start_with?(&#39;get_&#39;)
    # Define the method for future calls
    self.class.define_method(name) do
      # Method body
    end
    send(name, *args)
  else
    super
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ul>
<li>Metaprogramming allows writing code that generates code</li>
<li>Common techniques: <code>define_method</code>, <code>method_missing</code>, <code>send</code>, <code>eval</code></li>
<li>Powers Rails&#39; magic (associations, validations, scopes)</li>
<li>Use wisely - can make code hard to understand and debug</li>
<li>Always implement <code>respond_to_missing?</code> with <code>method_missing</code></li>
</ul>
<hr>
<h2>Question 13: Explain <code>class_eval</code> and <code>instance_eval</code></h2>
<h3>Answer</h3>
<p>Both <code>class_eval</code> and <code>instance_eval</code> allow you to execute code in a different context, but they operate at different levels.</p>
<hr>
<h3><code>class_eval</code> (also <code>module_eval</code>)</h3>
<p><strong>Definition:</strong> Evaluates code in the context of a <strong>class or module</strong>.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Add instance methods to a class</li>
<li>Add class variables</li>
<li>Reopen classes dynamically</li>
</ul>
<pre><code class="language-ruby">class User
end

# Adding instance method with class_eval
User.class_eval do
  def greet
    &quot;Hello!&quot;
  end
end

user = User.new
user.greet  # &quot;Hello!&quot;
</code></pre>
<p><strong>With String:</strong></p>
<pre><code class="language-ruby">User.class_eval(&quot;def goodbye; &#39;Goodbye!&#39;; end&quot;)
user.goodbye  # &quot;Goodbye!&quot;
</code></pre>
<p><strong>Access to Class Variables:</strong></p>
<pre><code class="language-ruby">class User
  @@count = 0
end

User.class_eval do
  def self.increment_count
    @@count += 1
  end
  
  def self.count
    @@count
  end
end

User.increment_count
puts User.count  # 1
</code></pre>
<hr>
<h3><code>instance_eval</code></h3>
<p><strong>Definition:</strong> Evaluates code in the context of a <strong>specific instance</strong>.</p>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Add singleton methods (methods specific to one instance)</li>
<li>Access/modify instance variables of a specific object</li>
<li>Create DSLs</li>
</ul>
<pre><code class="language-ruby">user = User.new

# Adding singleton method
user.instance_eval do
  def special_method
    &quot;I&#39;m special!&quot;
  end
end

user.special_method  # &quot;I&#39;m special!&quot;
User.new.special_method  # NoMethodError - only this instance has it
</code></pre>
<p><strong>Access Instance Variables:</strong></p>
<pre><code class="language-ruby">class User
  def initialize(name)
    @name = name
  end
end

user = User.new(&quot;John&quot;)

user.instance_eval do
  @name  # &quot;John&quot;
  @age = 30  # Can set new instance variables
end

user.instance_eval { @age }  # 30
</code></pre>
<p><strong>Creating Class Methods:</strong></p>
<pre><code class="language-ruby">class User
end

User.instance_eval do
  def all
    &quot;Getting all users&quot;
  end
end

User.all  # &quot;Getting all users&quot; - class method!
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>class_eval</code></th>
<th><code>instance_eval</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Context</strong></td>
<td>Class/Module</td>
<td>Instance</td>
</tr>
<tr>
<td><strong>Defines</strong></td>
<td>Instance methods</td>
<td>Singleton methods</td>
</tr>
<tr>
<td><strong>Called on</strong></td>
<td>Class or Module</td>
<td>Any object</td>
</tr>
<tr>
<td><strong>Access</strong></td>
<td>Class variables, constants</td>
<td>Instance variables</td>
</tr>
<tr>
<td><strong>Use for</strong></td>
<td>Reopening classes</td>
<td>Modifying specific objects</td>
</tr>
</tbody></table>
<hr>
<h3>Comparison Example</h3>
<pre><code class="language-ruby">class User
end

# class_eval - adds instance method
User.class_eval do
  def instance_method
    &quot;Available to all instances&quot;
  end
end

# instance_eval - adds class method
User.instance_eval do
  def class_method
    &quot;Called on the class itself&quot;
  end
end

user = User.new
user.instance_method  # Works
User.class_method     # Works

# user.class_method   # NoMethodError
# User.instance_method # NoMethodError
</code></pre>
<hr>
<h3>Self in Different Contexts</h3>
<pre><code class="language-ruby">class User
end

User.class_eval do
  puts self  # User (the class)
  
  def who_am_i
    self  # Will be the instance when called
  end
end

User.instance_eval do
  puts self  # User (but as an object, not class)
  
  def who_am_i_class
    self  # Will be User class
  end
end

user = User.new
puts user.who_am_i  # #&lt;User:0x...&gt; (the instance)
puts User.who_am_i_class  # User (the class)
</code></pre>
<hr>
<h3>Practical Example - Reopening Classes</h3>
<pre><code class="language-ruby"># Add methods to existing classes
String.class_eval do
  def shout
    self.upcase + &quot;!!!&quot;
  end
end

&quot;hello&quot;.shout  # &quot;HELLO!!!&quot;
</code></pre>
<hr>
<h3>DSL Example</h3>
<pre><code class="language-ruby">class Config
  def self.configure(&amp;block)
    instance_eval(&amp;block)
  end
  
  def self.setting(name, value)
    instance_variable_set(&quot;@#{name}&quot;, value)
    
    define_singleton_method(name) do
      instance_variable_get(&quot;@#{name}&quot;)
    end
  end
end

Config.configure do
  setting :api_key, &quot;secret123&quot;
  setting :timeout, 30
end

puts Config.api_key  # secret123
puts Config.timeout  # 30
</code></pre>
<hr>
<h3>Rails Example - Association Extension</h3>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :posts do
    # This block is evaluated with instance_eval
    def published
      where(published: true)
    end
    
    def recent(limit = 5)
      order(created_at: :desc).limit(limit)
    end
  end
end

user = User.first
user.posts.published  # Custom association method
user.posts.recent(10)  # Custom association method
</code></pre>
<hr>
<h3>When to Use Which?</h3>
<p><strong>Use <code>class_eval</code> when:</strong></p>
<ul>
<li>Adding instance methods to a class</li>
<li>Reopening classes to modify behavior</li>
<li>Need to access class-level scope</li>
<li>Working with class variables</li>
</ul>
<p><strong>Use <code>instance_eval</code> when:</strong></p>
<ul>
<li>Adding methods to a specific object (singleton methods)</li>
<li>Creating DSLs</li>
<li>Need to access instance-level scope</li>
<li>Adding class methods (since classes are objects)</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>class_eval</code></strong> modifies classes, adds instance methods</li>
<li><strong><code>instance_eval</code></strong> modifies instances, adds singleton methods</li>
<li>Both change the context of <code>self</code></li>
<li>Useful for metaprogramming and DSLs</li>
<li>Can accept blocks or strings (blocks preferred for safety)</li>
</ol>
<hr>
<h2>Question 14: Explain the use of <code>method_missing</code> in Ruby</h2>
<h3>Answer</h3>
<p><strong><code>method_missing</code></strong> is a Ruby method that gets called when you try to call a method that doesn&#39;t exist on an object. It&#39;s the last stop in method lookup before raising a <code>NoMethodError</code>.</p>
<hr>
<h3>Basic Usage</h3>
<pre><code class="language-ruby">class DynamicClass
  def method_missing(method_name, *args, &amp;block)
    puts &quot;You tried to call: #{method_name}&quot;
    puts &quot;With arguments: #{args.inspect}&quot;
    &quot;Method doesn&#39;t exist&quot;
  end
end

obj = DynamicClass.new
obj.undefined_method(1, 2, 3)

# Output:
# You tried to call: undefined_method
# With arguments: [1, 2, 3]
# =&gt; &quot;Method doesn&#39;t exist&quot;
</code></pre>
<hr>
<h3>Method Parameters</h3>
<pre><code class="language-ruby">def method_missing(method_name, *arguments, &amp;block)
  # method_name: Symbol of the called method
  # arguments: Array of arguments passed
  # block: Block passed (if any)
end
</code></pre>
<hr>
<h3>Always Implement <code>respond_to_missing?</code></h3>
<p>When using <code>method_missing</code>, you MUST implement <code>respond_to_missing?</code> to make your object behave correctly:</p>
<pre><code class="language-ruby">class DynamicFinder
  def method_missing(method_name, *args)
    if method_name.to_s.start_with?(&#39;find_by_&#39;)
      &quot;Finding...&quot;
    else
      super
    end
  end
  
  # IMPORTANT: Implement this!
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.start_with?(&#39;find_by_&#39;) || super
  end
end

finder = DynamicFinder.new
finder.respond_to?(:find_by_name)  # true
finder.respond_to?(:random_method)  # false
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: ActiveRecord-Style Dynamic Finders</strong></p>
<pre><code class="language-ruby">class User
  attr_accessor :name, :email, :age
  
  def initialize(name, email, age)
    @name = name
    @email = email
    @age = age
  end
  
  @@users = []
  
  def self.create(name, email, age)
    user = new(name, email, age)
    @@users &lt;&lt; user
    user
  end
  
  def self.method_missing(method_name, *args)
    if method_name.to_s =~ /^find_by_(.+)$/
      attribute = $1.to_sym
      @@users.find { |user| user.send(attribute) == args.first }
    else
      super
    end
  end
  
  def self.respond_to_missing?(method_name, include_private = false)
    method_name.to_s.start_with?(&#39;find_by_&#39;) || super
  end
end

User.create(&quot;John&quot;, &quot;john@example.com&quot;, 30)
User.create(&quot;Jane&quot;, &quot;jane@example.com&quot;, 25)

user = User.find_by_name(&quot;John&quot;)
puts user.email  # john@example.com

user = User.find_by_age(25)
puts user.name  # Jane
</code></pre>
<p><strong>Example 2: OpenStruct-like Behavior</strong></p>
<pre><code class="language-ruby">class FlexibleObject
  def initialize(data = {})
    @data = data
  end
  
  def method_missing(method_name, *args)
    method_string = method_name.to_s
    
    if method_string.end_with?(&#39;=&#39;)
      # Setter
      attribute = method_string.chop.to_sym
      @data[attribute] = args.first
    elsif @data.key?(method_name)
      # Getter
      @data[method_name]
    else
      super
    end
  end
  
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.end_with?(&#39;=&#39;) || @data.key?(method_name) || super
  end
end

obj = FlexibleObject.new
obj.name = &quot;John&quot;
obj.age = 30

puts obj.name  # John
puts obj.age   # 30
</code></pre>
<p><strong>Example 3: API Client with Dynamic Methods</strong></p>
<pre><code class="language-ruby">class APIClient
  ENDPOINTS = {
    users: &#39;/api/users&#39;,
    posts: &#39;/api/posts&#39;,
    comments: &#39;/api/comments&#39;
  }
  
  def method_missing(method_name, *args)
    if method_name.to_s =~ /^get_(.+)$/
      endpoint = $1.to_sym
      if ENDPOINTS.key?(endpoint)
        fetch(ENDPOINTS[endpoint])
      else
        super
      end
    else
      super
    end
  end
  
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s =~ /^get_(.+)$/ &amp;&amp; ENDPOINTS.key?($1.to_sym) || super
  end
  
  private
  
  def fetch(url)
    &quot;Fetching data from #{url}&quot;
  end
end

api = APIClient.new
puts api.get_users     # Fetching data from /api/users
puts api.get_posts     # Fetching data from /api/posts
# api.get_invalid      # NoMethodError (correctly raised)
</code></pre>
<p><strong>Example 4: Method Delegation</strong></p>
<pre><code class="language-ruby">class Delegator
  def initialize(target)
    @target = target
  end
  
  def method_missing(method_name, *args, &amp;block)
    if @target.respond_to?(method_name)
      @target.send(method_name, *args, &amp;block)
    else
      super
    end
  end
  
  def respond_to_missing?(method_name, include_private = false)
    @target.respond_to?(method_name) || super
  end
end

array = [1, 2, 3, 4, 5]
delegator = Delegator.new(array)

puts delegator.length  # 5
puts delegator.first   # 1
puts delegator.map { |x| x * 2 }.inspect  # [2, 4, 6, 8, 10]
</code></pre>
<hr>
<h3>Rails Example - ActiveRecord</h3>
<pre><code class="language-ruby"># ActiveRecord uses method_missing for dynamic finders
User.find_by_email(&quot;john@example.com&quot;)
User.find_by_name_and_age(&quot;John&quot;, 30)

# Behind the scenes (simplified):
class ActiveRecord::Base
  def self.method_missing(method_name, *args)
    if method_name.to_s =~ /^find_by_(.+)$/
      attributes = $1.split(&#39;_and_&#39;)
      # Build query dynamically
      where(attributes.zip(args).to_h).first
    else
      super
    end
  end
end
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<p><strong>Problem:</strong> <code>method_missing</code> is slow because Ruby has to search the entire method lookup chain first.</p>
<p><strong>Solution:</strong> Define methods dynamically after first call:</p>
<pre><code class="language-ruby">class SmartDynamic
  def method_missing(method_name, *args)
    if method_name.to_s.start_with?(&#39;get_&#39;)
      attribute = method_name.to_s.sub(&#39;get_&#39;, &#39;&#39;)
      
      # Define the method for future calls
      self.class.define_method(method_name) do
        instance_variable_get(&quot;@#{attribute}&quot;)
      end
      
      # Call the newly defined method
      send(method_name)
    else
      super
    end
  end
  
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.start_with?(&#39;get_&#39;) || super
  end
end
</code></pre>
<hr>
<h3>Common Pitfalls</h3>
<p><strong>1. Not implementing <code>respond_to_missing?</code></strong></p>
<pre><code class="language-ruby"># Bad
class Bad
  def method_missing(name, *args)
    &quot;handled&quot;
  end
end

obj = Bad.new
obj.respond_to?(:anything)  # false (wrong!)

# Good
class Good
  def method_missing(name, *args)
    &quot;handled&quot;
  end
  
  def respond_to_missing?(name, include_private = false)
    true
  end
end

obj = Good.new
obj.respond_to?(:anything)  # true (correct!)
</code></pre>
<p><strong>2. Catching too many methods</strong></p>
<pre><code class="language-ruby"># Bad - catches everything
def method_missing(name, *args)
  &quot;handled&quot;
end

# Good - specific pattern matching
def method_missing(name, *args)
  if name.to_s.start_with?(&#39;find_by_&#39;)
    # handle
  else
    super  # Let the error be raised
  end
end
</code></pre>
<p><strong>3. Not calling <code>super</code></strong></p>
<pre><code class="language-ruby"># Bad - no super
def method_missing(name, *args)
  # handle or do nothing
end

# Good - call super for unhandled cases
def method_missing(name, *args)
  if condition
    # handle
  else
    super
  end
end
</code></pre>
<hr>
<h3>Debugging Tips</h3>
<pre><code class="language-ruby">class Debuggable
  def method_missing(method_name, *args, &amp;block)
    puts &quot;Method: #{method_name}&quot;
    puts &quot;Args: #{args.inspect}&quot;
    puts &quot;Caller: #{caller.first}&quot;
    super
  end
end
</code></pre>
<hr>
<h3>Alternatives to <code>method_missing</code></h3>
<p>Sometimes <code>method_missing</code> is overkill. Consider these alternatives:</p>
<p><strong>1. <code>define_method</code></strong></p>
<pre><code class="language-ruby">[:name, :email, :age].each do |attr|
  define_method(attr) do
    instance_variable_get(&quot;@#{attr}&quot;)
  end
end
</code></pre>
<p><strong>2. <code>send</code></strong></p>
<pre><code class="language-ruby">object.send(:method_name, args)
</code></pre>
<p><strong>3. <code>method</code></strong></p>
<pre><code class="language-ruby">method_object = object.method(:method_name)
method_object.call(args)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><code>method_missing</code> intercepts calls to undefined methods</li>
<li><strong>ALWAYS implement <code>respond_to_missing?</code></strong></li>
<li>Call <code>super</code> for unhandled cases</li>
<li>Use for dynamic APIs and DSLs</li>
<li>Has performance overhead - consider caching</li>
<li>Rails uses it extensively (dynamic finders, associations)</li>
</ol>
<hr>
<h2>Question 15: What is dynamic method dispatching in Ruby?</h2>
<h3>Answer</h3>
<p><strong>Dynamic method dispatching</strong> is the ability to determine which method to call at runtime based on the object type or other conditions, rather than at compile time.</p>
<hr>
<h3>Basic Dynamic Dispatching with <code>send</code></h3>
<pre><code class="language-ruby">class Calculator
  def add(a, b)
    a + b
  end
  
  def subtract(a, b)
    a - b
  end
  
  def multiply(a, b)
    a * b
  end
end

calc = Calculator.new

# Instead of: calc.add(5, 3)
method_name = :add
result = calc.send(method_name, 5, 3)  # 8

# Dynamic based on user input
operation = gets.chomp.to_sym
result = calc.send(operation, 10, 5)
</code></pre>
<hr>
<h3><code>send</code> vs <code>public_send</code></h3>
<pre><code class="language-ruby">class User
  def public_method
    &quot;I&#39;m public&quot;
  end
  
  private
  
  def private_method
    &quot;I&#39;m private&quot;
  end
end

user = User.new

# send - can call private methods
user.send(:private_method)  # &quot;I&#39;m private&quot; (works!)

# public_send - only public methods
user.public_send(:public_method)  # &quot;I&#39;m public&quot;
user.public_send(:private_method)  # NoMethodError (respects privacy)
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Command Pattern</strong></p>
<pre><code class="language-ruby">class RemoteControl
  def initialize(device)
    @device = device
  end
  
  def execute(command, *args)
    if @device.respond_to?(command)
      @device.send(command, *args)
    else
      &quot;Command not supported&quot;
    end
  end
end

class TV
  def on
    &quot;TV is now ON&quot;
  end
  
  def off
    &quot;TV is now OFF&quot;
  end
  
  def channel(number)
    &quot;Changed to channel #{number}&quot;
  end
end

remote = RemoteControl.new(TV.new)
puts remote.execute(:on)              # TV is now ON
puts remote.execute(:channel, 5)      # Changed to channel 5
puts remote.execute(:off)             # TV is now OFF
</code></pre>
<p><strong>Example 2: Dynamic Attribute Access</strong></p>
<pre><code class="language-ruby">class User
  attr_accessor :name, :email, :age
  
  def initialize(name, email, age)
    @name = name
    @email = email
    @age = age
  end
  
  def get_attribute(attribute)
    send(attribute)
  end
  
  def set_attribute(attribute, value)
    send(&quot;#{attribute}=&quot;, value)
  end
end

user = User.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)

# Dynamic getter
puts user.get_attribute(:name)  # John
puts user.get_attribute(:age)   # 30

# Dynamic setter
user.set_attribute(:email, &quot;newemail@example.com&quot;)
puts user.email  # newemail@example.com
</code></pre>
<p><strong>Example 3: API Request Handler</strong></p>
<pre><code class="language-ruby">class APIController
  def get_users
    { users: [&quot;John&quot;, &quot;Jane&quot;] }
  end
  
  def get_posts
    { posts: [&quot;Post 1&quot;, &quot;Post 2&quot;] }
  end
  
  def get_comments
    { comments: [&quot;Comment 1&quot;] }
  end
  
  def handle_request(endpoint, method)
    action = &quot;#{method}_#{endpoint}&quot;.to_sym
    
    if respond_to?(action, true)  # true includes private methods
      send(action)
    else
      { error: &quot;Endpoint not found&quot; }
    end
  end
end

api = APIController.new
puts api.handle_request(&#39;users&#39;, &#39;get&#39;).inspect
# {:users=&gt;[&quot;John&quot;, &quot;Jane&quot;]}

puts api.handle_request(&#39;posts&#39;, &#39;get&#39;).inspect
# {:posts=&gt;[&quot;Post 1&quot;, &quot;Post 2&quot;]}
</code></pre>
<p><strong>Example 4: State Machine</strong></p>
<pre><code class="language-ruby">class Order
  attr_reader :state
  
  def initialize
    @state = :pending
  end
  
  def transition(event)
    method_name = &quot;#{@state}_#{event}&quot;.to_sym
    
    if respond_to?(method_name, true)
      send(method_name)
    else
      raise &quot;Invalid transition: #{@state} -&gt; #{event}&quot;
    end
  end
  
  private
  
  def pending_pay
    @state = :paid
    &quot;Order paid&quot;
  end
  
  def paid_ship
    @state = :shipped
    &quot;Order shipped&quot;
  end
  
  def shipped_deliver
    @state = :delivered
    &quot;Order delivered&quot;
  end
end

order = Order.new
puts order.state  # pending

puts order.transition(:pay)      # Order paid
puts order.state                 # paid

puts order.transition(:ship)     # Order shipped
puts order.state                 # shipped

puts order.transition(:deliver)  # Order delivered
puts order.state                 # delivered
</code></pre>
<hr>
<h3>Rails Example - Controller Actions</h3>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def index
    @posts = Post.all
  end
  
  def show
    @post = Post.find(params[:id])
  end
  
  def create
    @post = Post.create(post_params)
  end
  
  # Rails dispatches to the correct action dynamically
  def process_action(action_name)
    send(action_name)  # Calls the method matching action_name
  end
end

# When user visits /posts -&gt; calls index
# When user visits /posts/1 -&gt; calls show
</code></pre>
<hr>
<h3><code>method</code> and <code>call</code></h3>
<p>Get a method object and call it:</p>
<pre><code class="language-ruby">class Calculator
  def add(a, b)
    a + b
  end
end

calc = Calculator.new

# Get method object
add_method = calc.method(:add)

# Call it
add_method.call(5, 3)  # 8
add_method.(5, 3)      # 8
add_method[5, 3]       # 8

# Check arity
add_method.arity  # 2

# Get method owner
add_method.owner  # Calculator
</code></pre>
<hr>
<h3><code>try</code> Method (Rails)</h3>
<p>Rails provides <code>try</code> for safe dynamic dispatch:</p>
<pre><code class="language-ruby">user = User.first
user.try(:admin?)  # Calls admin? if method exists, nil otherwise

# Equivalent to:
user.respond_to?(:admin?) ? user.admin? : nil

# With arguments
user.try(:create_post, title: &quot;New Post&quot;)
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

class Test
  def fast_method
    &quot;fast&quot;
  end
end

obj = Test.new
n = 1_000_000

Benchmark.bm do |x|
  x.report(&quot;Direct call:&quot;) do
    n.times { obj.fast_method }
  end
  
  x.report(&quot;send:&quot;) do
    n.times { obj.send(:fast_method) }
  end
  
  x.report(&quot;method.call:&quot;) do
    method_obj = obj.method(:fast_method)
    n.times { method_obj.call }
  end
end

# Direct call is fastest
# send is slightly slower
# method.call is comparable to send
</code></pre>
<hr>
<h3>Security Considerations</h3>
<pre><code class="language-ruby"># DANGEROUS - User input directly to send
user_input = params[:method]
obj.send(user_input)  # Could call private methods!

# BETTER - Whitelist allowed methods
ALLOWED_METHODS = [:safe_method1, :safe_method2]

if ALLOWED_METHODS.include?(user_input.to_sym)
  obj.send(user_input)
else
  raise &quot;Method not allowed&quot;
end

# BEST - Use public_send
obj.public_send(user_input)  # Only public methods
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li>Dynamic dispatch determines methods at runtime</li>
<li><code>send</code> calls methods by name (symbol or string)</li>
<li><code>public_send</code> only calls public methods (safer)</li>
<li><code>method</code> returns a Method object that can be called later</li>
<li>Useful for polymorphism, APIs, and flexible code</li>
<li>Be careful with user input - use whitelists</li>
<li>Has slight performance overhead compared to direct calls</li>
</ol>
<hr>
<h2>Question 16: How do you use <code>alias_method</code> and <code>define_method</code> in Ruby?</h2>
<h3>Answer</h3>
<p>Both <code>alias_method</code> and <code>define_method</code> are metaprogramming tools for working with methods dynamically.</p>
<hr>
<h3><code>alias_method</code> - Creating Method Aliases</h3>
<p><strong>Definition:</strong> Creates an alias (alternative name) for an existing method.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-ruby">alias_method :new_name, :original_name
</code></pre>
<p><strong>Basic Example:</strong></p>
<pre><code class="language-ruby">class User
  def full_name
    &quot;#{@first_name} #{@last_name}&quot;
  end
  
  alias_method :name, :full_name
end

user = User.new
user.full_name  # Works
user.name       # Also works (alias)
</code></pre>
<p><strong>Common Use Case - Method Wrapping:</strong></p>
<pre><code class="language-ruby">class User
  def save
    puts &quot;Saving user...&quot;
    # save logic
  end
  
  # Save original method
  alias_method :save_without_logging, :save
  
  # Redefine with logging
  def save
    puts &quot;LOG: About to save&quot;
    save_without_logging  # Call original
    puts &quot;LOG: Save complete&quot;
  end
end

user = User.new
user.save

# Output:
# LOG: About to save
# Saving user...
# LOG: Save complete
</code></pre>
<p><strong>Rails Example - Aliasing for Hooks:</strong></p>
<pre><code class="language-ruby">class Product &lt; ApplicationRecord
  def price
    @price
  end
  
  alias_method :price_without_tax, :price
  
  def price
    price_without_tax * 1.2  # Add 20% tax
  end
end

product = Product.new
product.price_without_tax  # 100
product.price              # 120
</code></pre>
<hr>
<h3><code>define_method</code> - Defining Methods Dynamically</h3>
<p><strong>Definition:</strong> Creates methods dynamically at runtime.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-ruby">define_method :method_name do |args|
  # method body
end
</code></pre>
<p><strong>Basic Example:</strong></p>
<pre><code class="language-ruby">class User
  define_method :greet do
    &quot;Hello!&quot;
  end
end

user = User.new
user.greet  # &quot;Hello!&quot;
</code></pre>
<p><strong>With Parameters:</strong></p>
<pre><code class="language-ruby">class Calculator
  define_method :add do |a, b|
    a + b
  end
end

calc = Calculator.new
calc.add(5, 3)  # 8
</code></pre>
<p><strong>Common Use Case - Creating Multiple Similar Methods:</strong></p>
<pre><code class="language-ruby">class User
  [:name, :email, :age].each do |attribute|
    define_method(attribute) do
      instance_variable_get(&quot;@#{attribute}&quot;)
    end
    
    define_method(&quot;#{attribute}=&quot;) do |value|
      instance_variable_set(&quot;@#{attribute}&quot;, value)
    end
  end
end

user = User.new
user.name = &quot;John&quot;
user.email = &quot;john@example.com&quot;

puts user.name   # John
puts user.email  # john@example.com
</code></pre>
<p><strong>Dynamic Method Creation:</strong></p>
<pre><code class="language-ruby">class APIClient
  ENDPOINTS = {
    users: &#39;/api/users&#39;,
    posts: &#39;/api/posts&#39;,
    comments: &#39;/api/comments&#39;
  }
  
  ENDPOINTS.each do |name, url|
    define_method(&quot;get_#{name}&quot;) do
      fetch(url)
    end
  end
  
  private
  
  def fetch(url)
    &quot;Fetching from #{url}&quot;
  end
end

api = APIClient.new
puts api.get_users     # Fetching from /api/users
puts api.get_posts     # Fetching from /api/posts
puts api.get_comments  # Fetching from /api/comments
</code></pre>
<hr>
<h3>Combining <code>alias_method</code> and <code>define_method</code></h3>
<p><strong>Decorating Methods:</strong></p>
<pre><code class="language-ruby">class User
  def save
    &quot;Saving user&quot;
  end
  
  # Save original
  alias_method :save_original, :save
  
  # Create new version with logging
  define_method :save do
    puts &quot;Before save&quot;
    result = save_original
    puts &quot;After save&quot;
    result
  end
end

user = User.new
user.save

# Output:
# Before save
# Saving user
# After save
</code></pre>
<hr>
<h3>Rails Example - ActiveSupport::Concern</h3>
<pre><code class="language-ruby">module Timestampable
  extend ActiveSupport::Concern
  
  included do
    alias_method :save_without_timestamps, :save
    
    define_method :save do
      self.updated_at = Time.now
      save_without_timestamps
    end
  end
end

class Post &lt; ApplicationRecord
  include Timestampable
end
</code></pre>
<hr>
<h3>Practical Example - Method Chaining</h3>
<pre><code class="language-ruby">class QueryBuilder
  def initialize
    @conditions = []
  end
  
  [:where, :order, :limit].each do |method_name|
    define_method(method_name) do |*args|
      @conditions &lt;&lt; &quot;#{method_name.upcase}: #{args.join(&#39;, &#39;)}&quot;
      self  # Return self for chaining
    end
  end
  
  def to_sql
    @conditions.join(&#39; &#39;)
  end
end

query = QueryBuilder.new
          .where(&#39;age &gt; 18&#39;)
          .order(&#39;name ASC&#39;)
          .limit(10)
          
puts query.to_sql
# WHERE: age &gt; 18 ORDER: name ASC LIMIT: 10
</code></pre>
<hr>
<h3>Advanced Example - Method Missing to Define Method</h3>
<pre><code class="language-ruby">class SmartClass
  def method_missing(method_name, *args)
    if method_name.to_s.start_with?(&#39;calculate_&#39;)
      # Define the method for future calls
      self.class.define_method(method_name) do |*method_args|
        method_args.sum
      end
      
      # Call the newly defined method
      send(method_name, *args)
    else
      super
    end
  end
  
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.start_with?(&#39;calculate_&#39;) || super
  end
end

obj = SmartClass.new
puts obj.calculate_total(1, 2, 3)  # 6 - defined on first call
puts obj.calculate_sum(10, 20)     # 30 - defined on first call
</code></pre>
<hr>
<h3><code>alias</code> vs <code>alias_method</code></h3>
<pre><code class="language-ruby">class User
  def greet
    &quot;Hello&quot;
  end
  
  # alias (keyword) - doesn&#39;t work with variables
  alias greeting greet
  
  # alias_method (method) - works with variables
  alias_method :salutation, :greet
  
  # alias_method can be used dynamically
  method_name = :welcome
  alias_method method_name, :greet
end
</code></pre>
<p><strong>Key differences:</strong></p>
<ul>
<li><code>alias</code> is a keyword (can&#39;t use with variables)</li>
<li><code>alias_method</code> is a method (more flexible, works with variables)</li>
<li><code>alias_method</code> is preferred in Rails/modern Ruby</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<p><strong><code>alias_method</code>:</strong></p>
<ul>
<li>Creates alternative names for methods</li>
<li>Useful for wrapping/decorating methods</li>
<li>Preserves original method</li>
<li>Commonly used for hooks and callbacks</li>
</ul>
<p><strong><code>define_method</code>:</strong></p>
<ul>
<li>Creates methods dynamically</li>
<li>Useful for DRY code (generating similar methods)</li>
<li>Can access closure variables</li>
<li>Powers DSLs and metaprogramming</li>
</ul>
<hr>
<h2>Question 17: How do you implement custom DSLs in Ruby?</h2>
<h3>Answer</h3>
<p>A <strong>DSL (Domain-Specific Language)</strong> is a mini-language designed for a specific problem domain. Ruby&#39;s flexible syntax makes it excellent for creating DSLs.</p>
<hr>
<h3>Key Techniques for Building DSLs</h3>
<ol>
<li><strong>Blocks and <code>instance_eval</code></strong></li>
<li><strong>Method chaining</strong></li>
<li><strong><code>method_missing</code> for dynamic methods</strong></li>
<li><strong><code>define_method</code> for generated methods</strong></li>
<li><strong>Metaprogramming</strong></li>
</ol>
<hr>
<h3>Example 1: Configuration DSL</h3>
<pre><code class="language-ruby">class Config
  attr_reader :settings
  
  def initialize(&amp;block)
    @settings = {}
    instance_eval(&amp;block) if block_given?
  end
  
  def set(key, value)
    @settings[key] = value
  end
  
  def database(&amp;block)
    @settings[:database] = DatabaseConfig.new(&amp;block).settings
  end
end

class DatabaseConfig
  attr_reader :settings
  
  def initialize(&amp;block)
    @settings = {}
    instance_eval(&amp;block) if block_given?
  end
  
  def host(value)
    @settings[:host] = value
  end
  
  def port(value)
    @settings[:port] = value
  end
  
  def username(value)
    @settings[:username] = value
  end
end

# Usage
config = Config.new do
  set :app_name, &quot;MyApp&quot;
  set :version, &quot;1.0.0&quot;
  
  database do
    host &quot;localhost&quot;
    port 5432
    username &quot;admin&quot;
  end
end

puts config.settings.inspect
# {:app_name=&gt;&quot;MyApp&quot;, :version=&gt;&quot;1.0.0&quot;, :database=&gt;{:host=&gt;&quot;localhost&quot;, :port=&gt;5432, :username=&gt;&quot;admin&quot;}}
</code></pre>
<hr>
<h3>Example 2: Route DSL (Rails-like)</h3>
<pre><code class="language-ruby">class Router
  attr_reader :routes
  
  def initialize(&amp;block)
    @routes = {}
    instance_eval(&amp;block) if block_given?
  end
  
  def get(path, to:)
    @routes[path] = { method: :get, controller: to }
  end
  
  def post(path, to:)
    @routes[path] = { method: :post, controller: to }
  end
  
  def resources(name)
    get &quot;/#{name}&quot;, to: &quot;#{name}#index&quot;
    get &quot;/#{name}/:id&quot;, to: &quot;#{name}#show&quot;
    post &quot;/#{name}&quot;, to: &quot;#{name}#create&quot;
  end
end

# Usage
router = Router.new do
  get &#39;/&#39;, to: &#39;home#index&#39;
  get &#39;/about&#39;, to: &#39;pages#about&#39;
  post &#39;/login&#39;, to: &#39;auth#login&#39;
  
  resources :posts
end

puts router.routes.inspect
</code></pre>
<hr>
<h3>Example 3: HTML Builder DSL</h3>
<pre><code class="language-ruby">class HTMLBuilder
  def initialize(&amp;block)
    @html = &quot;&quot;
    instance_eval(&amp;block) if block_given?
  end
  
  def method_missing(tag, *args, &amp;block)
    attributes = args.first.is_a?(Hash) ? args.first : {}
    content = args.last.is_a?(String) ? args.last : nil
    
    @html &lt;&lt; &quot;&lt;#{tag}&quot;
    attributes.each { |key, value| @html &lt;&lt; &quot; #{key}=&#39;#{value}&#39;&quot; }
    @html &lt;&lt; &quot;&gt;&quot;
    
    if block_given?
      previous_html = @html
      @html = &quot;&quot;
      instance_eval(&amp;block)
      nested_content = @html
      @html = previous_html + nested_content
    elsif content
      @html &lt;&lt; content
    end
    
    @html &lt;&lt; &quot;&lt;/#{tag}&gt;&quot;
  end
  
  def to_html
    @html
  end
end

# Usage
html = HTMLBuilder.new do
  div class: &#39;container&#39; do
    h1 &quot;Welcome&quot;
    p &quot;This is a paragraph&quot;
    
    ul id: &#39;list&#39; do
      li &quot;Item 1&quot;
      li &quot;Item 2&quot;
      li &quot;Item 3&quot;
    end
  end
end

puts html.to_html
</code></pre>
<hr>
<h3>Example 4: SQL Query Builder DSL</h3>
<pre><code class="language-ruby">class QueryBuilder
  def initialize(table)
    @table = table
    @conditions = []
    @columns = &#39;*&#39;
    @order = nil
    @limit_value = nil
  end
  
  def select(*columns)
    @columns = columns.join(&#39;, &#39;)
    self
  end
  
  def where(condition)
    @conditions &lt;&lt; condition
    self
  end
  
  def order(column)
    @order = column
    self
  end
  
  def limit(value)
    @limit_value = value
    self
  end
  
  def to_sql
    sql = &quot;SELECT #{@columns} FROM #{@table}&quot;
    sql += &quot; WHERE #{@conditions.join(&#39; AND &#39;)}&quot; if @conditions.any?
    sql += &quot; ORDER BY #{@order}&quot; if @order
    sql += &quot; LIMIT #{@limit_value}&quot; if @limit_value
    sql
  end
end

# Usage
query = QueryBuilder.new(:users)
          .select(:name, :email, :age)
          .where(&#39;age &gt; 18&#39;)
          .where(&quot;status = &#39;active&#39;&quot;)
          .order(&#39;name ASC&#39;)
          .limit(10)

puts query.to_sql
# SELECT name, email, age FROM users WHERE age &gt; 18 AND status = &#39;active&#39; ORDER BY name ASC LIMIT 10
</code></pre>
<hr>
<h3>Example 5: Test DSL (RSpec-like)</h3>
<pre><code class="language-ruby">class TestSuite
  def initialize(description, &amp;block)
    @description = description
    @tests = []
    instance_eval(&amp;block)
  end
  
  def it(test_description, &amp;block)
    @tests &lt;&lt; { description: test_description, block: block }
  end
  
  def run
    puts &quot;Testing: #{@description}&quot;
    @tests.each do |test|
      begin
        test[:block].call
        puts &quot;  ✓ #{test[:description]}&quot;
      rescue =&gt; e
        puts &quot;  ✗ #{test[:description]}: #{e.message}&quot;
      end
    end
  end
end

def describe(description, &amp;block)
  TestSuite.new(description, &amp;block).run
end

def expect(actual)
  Expectation.new(actual)
end

class Expectation
  def initialize(actual)
    @actual = actual
  end
  
  def to_eq(expected)
    raise &quot;Expected #{expected}, got #{@actual}&quot; unless @actual == expected
  end
  
  def to_be_truthy
    raise &quot;Expected truthy, got #{@actual}&quot; unless @actual
  end
end

# Usage
describe &quot;Calculator&quot; do
  it &quot;adds two numbers&quot; do
    result = 2 + 2
    expect(result).to_eq(4)
  end
  
  it &quot;multiplies two numbers&quot; do
    result = 3 * 4
    expect(result).to_eq(12)
  end
  
  it &quot;checks truthiness&quot; do
    expect(true).to_be_truthy
  end
end
</code></pre>
<hr>
<h3>Example 6: Validation DSL (ActiveRecord-like)</h3>
<pre><code class="language-ruby">class Validator
  def self.validations
    @validations ||= []
  end
  
  def self.validates(attribute, rules = {})
    validations &lt;&lt; { attribute: attribute, rules: rules }
    
    define_method(&quot;validate_#{attribute}&quot;) do
      value = instance_variable_get(&quot;@#{attribute}&quot;)
      errors = []
      
      if rules[:presence] &amp;&amp; value.nil?
        errors &lt;&lt; &quot;#{attribute} cannot be blank&quot;
      end
      
      if rules[:length] &amp;&amp; value &amp;&amp; value.length &gt; rules[:length]
        errors &lt;&lt; &quot;#{attribute} is too long (max: #{rules[:length]})&quot;
      end
      
      if rules[:format] &amp;&amp; value &amp;&amp; !value.match?(rules[:format])
        errors &lt;&lt; &quot;#{attribute} format is invalid&quot;
      end
      
      errors
    end
  end
  
  def valid?
    errors.empty?
  end
  
  def errors
    self.class.validations.flat_map do |validation|
      send(&quot;validate_#{validation[:attribute]}&quot;)
    end
  end
end

class User &lt; Validator
  attr_accessor :name, :email, :age
  
  validates :name, presence: true, length: 50
  validates :email, presence: true, format: /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
  validates :age, presence: true
  
  def initialize(name, email, age)
    @name = name
    @email = email
    @age = age
  end
end

user = User.new(nil, &quot;invalid-email&quot;, nil)
puts user.valid?  # false
puts user.errors.inspect
# [&quot;name cannot be blank&quot;, &quot;email format is invalid&quot;, &quot;age cannot be blank&quot;]
</code></pre>
<hr>
<h3>Real Rails DSL Examples</h3>
<p><strong>ActiveRecord Associations:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :posts
  has_one :profile
  belongs_to :organization
end
</code></pre>
<p><strong>Routes:</strong></p>
<pre><code class="language-ruby">Rails.application.routes.draw do
  resources :posts do
    member do
      post :publish
    end
    
    collection do
      get :search
    end
  end
  
  namespace :admin do
    resources :users
  end
end
</code></pre>
<p><strong>Validations:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email, presence: true, uniqueness: true
  validates :age, numericality: { greater_than: 0 }
  validate :custom_validation
end
</code></pre>
<hr>
<h3>Key Principles for DSLs</h3>
<ol>
<li><strong>Keep it readable</strong> - Should read like natural language</li>
<li><strong>Use blocks</strong> - For nested structures</li>
<li><strong>Method chaining</strong> - For fluent interfaces</li>
<li><strong><code>instance_eval</code></strong> - For clean block syntax</li>
<li><strong>Sensible defaults</strong> - Make common cases easy</li>
<li><strong>Good error messages</strong> - Help users debug</li>
</ol>
<hr>
<h3>Key Takeaways</h3>
<ul>
<li>DSLs make Ruby code more expressive and readable</li>
<li>Use <code>instance_eval</code> for block evaluation</li>
<li>Method chaining creates fluent interfaces</li>
<li><code>method_missing</code> enables dynamic methods</li>
<li>Rails is full of DSL examples</li>
<li>Balance readability with flexibility</li>
</ul>
<hr>
<h2>Question 18: What is monkey patching, and what are its implications?</h2>
<h3>Answer</h3>
<p><strong>Monkey patching</strong> is reopening and modifying existing classes (including Ruby core classes and third-party gems) to add, modify, or remove methods at runtime.</p>
<hr>
<h3>Basic Monkey Patching</h3>
<pre><code class="language-ruby"># Reopening String class
class String
  def shout
    self.upcase + &quot;!!!&quot;
  end
end

&quot;hello&quot;.shout  # &quot;HELLO!!!&quot;
</code></pre>
<hr>
<h3>Examples</h3>
<p><strong>Adding Methods to Core Classes:</strong></p>
<pre><code class="language-ruby">class Integer
  def seconds
    self
  end
  
  def minutes
    self * 60
  end
  
  def hours
    self * 60 * 60
  end
end

puts 5.minutes  # 300 (seconds)
puts 2.hours    # 7200 (seconds)
</code></pre>
<p><strong>Modifying Existing Methods:</strong></p>
<pre><code class="language-ruby">class String
  alias_method :original_upcase, :upcase
  
  def upcase
    original_upcase + &quot;!!!&quot;
  end
end

&quot;hello&quot;.upcase  # &quot;HELLO!!!&quot;
</code></pre>
<hr>
<h3>Dangers of Monkey Patching</h3>
<p><strong>1. Name Collisions:</strong></p>
<pre><code class="language-ruby"># Your code
class Array
  def sum
    reduce(:+)
  end
end

# Ruby 2.4+ already has Array#sum
# Your implementation might conflict with Ruby&#39;s
</code></pre>
<p><strong>2. Breaking Existing Code:</strong></p>
<pre><code class="language-ruby"># Gem A
class String
  def reverse
    &quot;Reversed: #{self}&quot;
  end
end

# Gem B expects normal reverse
&quot;hello&quot;.reverse  # Should be &quot;olleh&quot; but gets &quot;Reversed: hello&quot;
</code></pre>
<p><strong>3. Debugging Nightmares:</strong></p>
<pre><code class="language-ruby"># Hard to trace where method came from
user.weird_method  # Where is this defined?
</code></pre>
<p><strong>4. Maintenance Issues:</strong></p>
<pre><code class="language-ruby"># When Ruby updates, your patches might break
class Array
  def sum  # Ruby adds sum in 2.4
    # Your implementation
  end
end
</code></pre>
<hr>
<h3>Safe Alternatives</h3>
<p><strong>1. Refinements (Ruby 2.0+)</strong></p>
<p>Refinements provide lexically scoped monkey patching:</p>
<pre><code class="language-ruby">module StringExtensions
  refine String do
    def shout
      self.upcase + &quot;!!!&quot;
    end
  end
end

# Without using refinement
&quot;hello&quot;.shout  # NoMethodError

# With refinement
using StringExtensions
&quot;hello&quot;.shout  # &quot;HELLO!!!&quot;

# Refinement scope ends here
</code></pre>
<p><strong>2. Decorator Pattern:</strong></p>
<pre><code class="language-ruby">class ShoutingString
  def initialize(string)
    @string = string
  end
  
  def shout
    @string.upcase + &quot;!!!&quot;
  end
  
  def method_missing(method, *args, &amp;block)
    @string.send(method, *args, &amp;block)
  end
end

str = ShoutingString.new(&quot;hello&quot;)
str.shout  # &quot;HELLO!!!&quot;
str.upcase # &quot;HELLO&quot; (delegates to String)
</code></pre>
<p><strong>3. Helper Modules:</strong></p>
<pre><code class="language-ruby">module StringHelpers
  def self.shout(string)
    string.upcase + &quot;!!!&quot;
  end
end

StringHelpers.shout(&quot;hello&quot;)  # &quot;HELLO!!!&quot;
</code></pre>
<p><strong>4. Namespaced Extensions:</strong></p>
<pre><code class="language-ruby">module MyApp
  module StringExtensions
    def shout
      upcase + &quot;!!!&quot;
    end
  end
end

str = &quot;hello&quot;
str.extend(MyApp::StringExtensions)
str.shout  # &quot;HELLO!!!&quot;
</code></pre>
<hr>
<h3>When Monkey Patching is Acceptable</h3>
<p><strong>1. In your own application (with caution):</strong></p>
<pre><code class="language-ruby"># config/initializers/string_extensions.rb
class String
  def to_bool
    return true if self == &quot;true&quot;
    return false if self == &quot;false&quot;
    nil
  end
end
</code></pre>
<p><strong>2. For compatibility shims:</strong></p>
<pre><code class="language-ruby"># Ruby 2.3 doesn&#39;t have Array#sum
unless Array.method_defined?(:sum)
  class Array
    def sum(initial = 0)
      reduce(initial, :+)
    end
  end
end
</code></pre>
<p><strong>3. Bug fixes in gems (temporary):</strong></p>
<pre><code class="language-ruby"># Until gem is updated
module BuggyGem
  class SomeClass
    def broken_method
      # Fixed implementation
    end
  end
end
</code></pre>
<hr>
<h3>Rails Example - ActiveSupport</h3>
<p>Rails itself uses monkey patching extensively:</p>
<pre><code class="language-ruby"># Active Support patches

# Time calculations
2.days.ago
5.minutes.from_now

# String methods
&quot;hello&quot;.titleize   # &quot;Hello&quot;
&quot;hello_world&quot;.camelize  # &quot;HelloWorld&quot;

# Hash methods
{ a: 1, b: 2 }.symbolize_keys
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Check before patching:</strong></p>
<pre><code class="language-ruby">class String
  def my_method
    # implementation
  end unless method_defined?(:my_method)
end
</code></pre>
<p><strong>2. Use a module:</strong></p>
<pre><code class="language-ruby">module MyStringExtensions
  def shout
    upcase + &quot;!!!&quot;
  end
end

String.include(MyStringExtensions)
</code></pre>
<p><strong>3. Document patches:</strong></p>
<pre><code class="language-ruby"># config/initializers/core_ext.rb
# Adds #shout method to String for internal DSL
class String
  def shout
    upcase + &quot;!!!&quot;
  end
end
</code></pre>
<p><strong>4. Keep patches isolated:</strong></p>
<pre><code class="language-ruby"># lib/core_ext/string.rb
class String
  # All String patches here
end

# lib/core_ext/array.rb
class Array
  # All Array patches here
end
</code></pre>
<p><strong>5. Test thoroughly:</strong></p>
<pre><code class="language-ruby">RSpec.describe String do
  describe &quot;#shout&quot; do
    it &quot;uppercases and adds exclamation&quot; do
      expect(&quot;hello&quot;.shout).to eq(&quot;HELLO!!!&quot;)
    end
  end
end
</code></pre>
<hr>
<h3>Refinements vs Monkey Patching</h3>
<pre><code class="language-ruby"># Monkey patch - global
class String
  def shout
    upcase + &quot;!!!&quot;
  end
end

&quot;hello&quot;.shout  # Works everywhere

# Refinement - scoped
module StringRefinements
  refine String do
    def shout
      upcase + &quot;!!!&quot;
    end
  end
end

&quot;hello&quot;.shout  # NoMethodError

class MyClass
  using StringRefinements
  
  def test
    &quot;hello&quot;.shout  # Works only here
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<p><strong>Monkey Patching:</strong></p>
<ul>
<li>Modifies existing classes at runtime</li>
<li>Can cause naming conflicts and bugs</li>
<li>Makes code hard to debug and maintain</li>
<li>Use sparingly and with caution</li>
</ul>
<p><strong>Alternatives:</strong></p>
<ul>
<li>Refinements (scoped patching)</li>
<li>Decorator pattern</li>
<li>Helper modules</li>
<li>Namespaced extensions</li>
</ul>
<p><strong>When to use:</strong></p>
<ul>
<li>Your own application (with care)</li>
<li>Compatibility shims</li>
<li>Temporary bug fixes</li>
<li>Always document and isolate patches</li>
</ul>
<h1>Ruby Data Types and Structures Interview Questions</h1>
<h2>Question 19: What are symbols in Ruby, and how do they differ from strings?</h2>
<h3>Answer</h3>
<p><strong>Symbols</strong> are immutable, reusable identifiers represented by a colon (<code>:</code>) followed by a name. They&#39;re stored in memory once and reused, unlike strings which create new objects.</p>
<hr>
<h3>Basic Comparison</h3>
<pre><code class="language-ruby"># Strings
str1 = &quot;hello&quot;
str2 = &quot;hello&quot;
str1.object_id  # 70123456789000
str2.object_id  # 70123456789020 (different!)

# Symbols
sym1 = :hello
sym2 = :hello
sym1.object_id  # 1234567
sym2.object_id  # 1234567 (same!)
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>String</th>
<th>Symbol</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mutability</strong></td>
<td>Mutable</td>
<td>Immutable</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>New object each time</td>
<td>Single object reused</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Slower comparison</td>
<td>Faster comparison</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Text data, user input</td>
<td>Identifiers, hash keys, constants</td>
</tr>
<tr>
<td><strong>Object ID</strong></td>
<td>Different each time</td>
<td>Same for same symbol</td>
</tr>
<tr>
<td><strong>Garbage Collection</strong></td>
<td>Yes</td>
<td>No (persists until program ends)</td>
</tr>
</tbody></table>
<hr>
<h3>Memory Comparison</h3>
<pre><code class="language-ruby">require &#39;objspace&#39;

# String memory
1000.times { &quot;hello&quot; }  # Creates 1000 string objects

# Symbol memory
1000.times { :hello }   # Uses same symbol object

# Check memory size
ObjectSpace.memsize_of(&quot;hello&quot;)  # ~40 bytes
ObjectSpace.memsize_of(:hello)   # ~40 bytes (but only one instance)
</code></pre>
<hr>
<h3>When to Use Symbols vs Strings</h3>
<p><strong>Use Symbols for:</strong></p>
<ul>
<li>Hash keys</li>
<li>Method names</li>
<li>Constants and identifiers</li>
<li>Internal state/status values</li>
<li>Anything that won&#39;t change</li>
</ul>
<pre><code class="language-ruby"># Good - symbols for hash keys
user = { name: &quot;John&quot;, email: &quot;john@example.com&quot;, role: :admin }

# Good - symbols for status
order = { status: :pending, payment: :completed }

# Good - symbols for method names
object.send(:method_name, args)
</code></pre>
<p><strong>Use Strings for:</strong></p>
<ul>
<li>User input</li>
<li>Text that will be modified</li>
<li>Display text</li>
<li>Data from external sources</li>
</ul>
<pre><code class="language-ruby"># Good - strings for user input
name = params[:name]  # String from user
message = &quot;Hello, #{name}!&quot;

# Good - strings for modifiable text
text = &quot;hello&quot;
text.upcase!  # Modifies the string
</code></pre>
<hr>
<h3>Symbol to String and Vice Versa</h3>
<pre><code class="language-ruby"># Symbol to String
:hello.to_s   # &quot;hello&quot;
:hello.id2name  # &quot;hello&quot;

# String to Symbol
&quot;hello&quot;.to_sym  # :hello
&quot;hello&quot;.intern  # :hello

# With spaces or special characters
:&quot;hello world&quot;  # Symbol with spaces
&quot;hello-world&quot;.to_sym  # :hello-world
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

n = 1_000_000

Benchmark.bm do |x|
  x.report(&quot;String keys:&quot;) do
    n.times do
      hash = { &quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30 }
      hash[&quot;name&quot;]
    end
  end
  
  x.report(&quot;Symbol keys:&quot;) do
    n.times do
      hash = { name: &quot;John&quot;, age: 30 }
      hash[:name]
    end
  end
end

# Symbol keys are significantly faster!
</code></pre>
<hr>
<h3>Hash Keys: Symbols vs Strings</h3>
<pre><code class="language-ruby"># String keys
user = { &quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30 }
user[&quot;name&quot;]  # &quot;John&quot;

# Symbol keys (modern syntax)
user = { name: &quot;John&quot;, age: 30 }
user[:name]  # &quot;John&quot;

# Symbol keys (traditional syntax)
user = { :name =&gt; &quot;John&quot;, :age =&gt; 30 }
user[:name]  # &quot;John&quot;
</code></pre>
<p><strong>Note:</strong> String keys and Symbol keys are different!</p>
<pre><code class="language-ruby">hash = { &quot;name&quot; =&gt; &quot;John&quot;, :name =&gt; &quot;Jane&quot; }
hash[&quot;name&quot;]  # &quot;John&quot;
hash[:name]   # &quot;Jane&quot;
</code></pre>
<hr>
<h3>Rails Examples</h3>
<p><strong>ActiveRecord:</strong></p>
<pre><code class="language-ruby"># Symbols for attribute names
User.where(role: :admin)
User.find_by(email: &quot;john@example.com&quot;)

# Symbols for associations
user.posts.where(status: :published)
</code></pre>
<p><strong>Routes:</strong></p>
<pre><code class="language-ruby"># Symbols for actions
get &#39;/posts&#39;, to: &#39;posts#index&#39;
resources :posts, only: [:index, :show, :create]
</code></pre>
<p><strong>Strong Parameters:</strong></p>
<pre><code class="language-ruby">def user_params
  params.require(:user).permit(:name, :email, :age)
end
</code></pre>
<hr>
<h3>Symbol Methods</h3>
<pre><code class="language-ruby">sym = :hello

# Check if symbol
sym.is_a?(Symbol)  # true

# Symbol methods
sym.to_s      # &quot;hello&quot;
sym.upcase    # :HELLO
sym.downcase  # :hello
sym.capitalize  # :Hello
sym.length    # 5
sym.empty?    # false

# Comparison
:hello == :hello  # true (fast!)
:hello == :world  # false

# String comparison (slower)
&quot;hello&quot; == &quot;hello&quot;  # true (creates objects)
</code></pre>
<hr>
<h3>Symbols in Method Parameters</h3>
<pre><code class="language-ruby">class User
  attr_accessor :name, :email  # Symbols as parameters
  
  def update(attributes)
    attributes.each do |key, value|
      # key is a symbol
      send(&quot;#{key}=&quot;, value) if respond_to?(&quot;#{key}=&quot;)
    end
  end
end

user = User.new
user.update(name: &quot;John&quot;, email: &quot;john@example.com&quot;)
</code></pre>
<hr>
<h3>Symbols in Case Statements</h3>
<pre><code class="language-ruby">def process_status(status)
  case status
  when :pending
    &quot;Order is pending&quot;
  when :processing
    &quot;Order is being processed&quot;
  when :completed
    &quot;Order completed&quot;
  when :cancelled
    &quot;Order cancelled&quot;
  else
    &quot;Unknown status&quot;
  end
end

process_status(:pending)  # &quot;Order is pending&quot;
</code></pre>
<hr>
<h3>Gotchas with Symbols</h3>
<p><strong>1. Symbols are not garbage collected (until Ruby 2.2):</strong></p>
<pre><code class="language-ruby"># Dangerous in user input
user_input = params[:action]
user_input.to_sym  # Creates symbol permanently!

# Better: Use string or whitelist
ALLOWED_ACTIONS = [:index, :show, :create]
action = user_input.to_sym if ALLOWED_ACTIONS.include?(user_input.to_sym)
</code></pre>
<p><strong>2. Symbols can&#39;t be modified:</strong></p>
<pre><code class="language-ruby">sym = :hello
sym.upcase!  # NoMethodError (symbols are immutable)

# Must create new symbol
new_sym = sym.upcase  # :HELLO
</code></pre>
<p><strong>3. Memory leak potential (pre Ruby 2.2):</strong></p>
<pre><code class="language-ruby"># BAD: Don&#39;t do this with user input
1_000_000.times do |i|
  &quot;dynamic_symbol_#{i}&quot;.to_sym  # Creates 1 million permanent symbols!
end
</code></pre>
<hr>
<h3>Modern Ruby (2.2+) - Symbols are GC&#39;d</h3>
<pre><code class="language-ruby"># Ruby 2.2+ garbage collects symbols created dynamically
1000.times { |i| &quot;symbol_#{i}&quot;.to_sym }

# Check symbol count
Symbol.all_symbols.size
</code></pre>
<hr>
<h3>Converting Hash Keys</h3>
<pre><code class="language-ruby">hash = { &quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30 }

# String keys to symbol keys
hash.transform_keys(&amp;:to_sym)
# or
hash.symbolize_keys  # Rails only
# { name: &quot;John&quot;, age: 30 }

# Symbol keys to string keys
hash = { name: &quot;John&quot;, age: 30 }
hash.transform_keys(&amp;:to_s)
# or
hash.stringify_keys  # Rails only
# { &quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30 }
</code></pre>
<hr>
<h3>Rails JSON API Example</h3>
<pre><code class="language-ruby"># API returns strings
json_data = { &quot;name&quot; =&gt; &quot;John&quot;, &quot;email&quot; =&gt; &quot;john@example.com&quot; }

# Convert to symbols for internal use
user_attributes = json_data.symbolize_keys
# { name: &quot;John&quot;, email: &quot;john@example.com&quot; }

# Use with ActiveRecord
User.create(user_attributes)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Symbols are immutable identifiers</strong>, strings are mutable text</li>
<li><strong>Same symbol = same object_id</strong> (memory efficient)</li>
<li><strong>Use symbols for</strong> hash keys, identifiers, constants</li>
<li><strong>Use strings for</strong> user input, modifiable text</li>
<li><strong>Symbols are faster</strong> for comparisons and hash keys</li>
<li><strong>Be careful</strong> with dynamic symbol creation (memory leak)</li>
<li>In modern Ruby (2.2+), symbols can be garbage collected</li>
</ol>
<hr>
<h2>Question 20: What is the difference between single quotes and double quotes?</h2>
<h3>Answer</h3>
<p>In Ruby, strings can be defined with single quotes (<code>&#39;</code>) or double quotes (<code>&quot;</code>), and they have different behaviors.</p>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Single Quotes <code>&#39; &#39;</code></th>
<th>Double Quotes <code>&quot; &quot;</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Interpolation</strong></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Escape sequences</strong></td>
<td>Limited (only <code>\&#39;</code> and <code>\\</code>)</td>
<td>Full support</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Slightly faster</td>
<td>Slightly slower</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Static strings, no interpolation</td>
<td>Dynamic strings, interpolation</td>
</tr>
</tbody></table>
<hr>
<h3>String Interpolation</h3>
<p><strong>Double quotes support interpolation:</strong></p>
<pre><code class="language-ruby">name = &quot;John&quot;
age = 30

# Double quotes - interpolation works
greeting = &quot;Hello, #{name}! You are #{age} years old.&quot;
# &quot;Hello, John! You are 30 years old.&quot;

# Single quotes - no interpolation
greeting = &#39;Hello, #{name}! You are #{age} years old.&#39;
# &quot;Hello, #{name}! You are #{age} years old.&quot; (literal)
</code></pre>
<p><strong>Complex interpolation:</strong></p>
<pre><code class="language-ruby">users = [&quot;John&quot;, &quot;Jane&quot;, &quot;Bob&quot;]

# Works with double quotes
&quot;Users: #{users.join(&#39;, &#39;)}&quot;
# &quot;Users: John, Jane, Bob&quot;

# Doesn&#39;t work with single quotes
&#39;Users: #{users.join(&quot;, &quot;)}&#39;
# &quot;Users: #{users.join(&#39;, &#39;)}&quot; (literal)
</code></pre>
<hr>
<h3>Escape Sequences</h3>
<p><strong>Double quotes support many escape sequences:</strong></p>
<pre><code class="language-ruby"># Double quotes
&quot;Hello\nWorld&quot;    # &quot;Hello
                  # World&quot; (newline)
&quot;Hello\tWorld&quot;    # &quot;Hello    World&quot; (tab)
&quot;Say \&quot;Hi\&quot;&quot;      # &quot;Say &quot;Hi&quot;&quot; (escaped quote)
&quot;Line 1\nLine 2&quot;  # Multi-line with \n

# Single quotes (only \&#39; and \\)
&#39;Hello\nWorld&#39;    # &quot;Hello\\nWorld&quot; (literal \n)
&#39;It\&#39;s sunny&#39;     # &quot;It&#39;s sunny&quot; (escaped quote)
&#39;Path\\File&#39;      # &quot;Path\File&quot; (escaped backslash)
</code></pre>
<p><strong>Common escape sequences (double quotes only):</strong></p>
<pre><code class="language-ruby">&quot;\n&quot;   # Newline
&quot;\t&quot;   # Tab
&quot;\r&quot;   # Carriage return
&quot;\\&quot;   # Backslash
&quot;\&quot;&quot;   # Double quote
&quot;\0&quot;   # Null character
&quot;\a&quot;   # Bell
&quot;\b&quot;   # Backspace
&quot;\f&quot;   # Form feed
&quot;\v&quot;   # Vertical tab
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

n = 1_000_000

Benchmark.bm do |x|
  x.report(&quot;Single quotes:&quot;) do
    n.times { &#39;Hello World&#39; }
  end
  
  x.report(&quot;Double quotes:&quot;) do
    n.times { &quot;Hello World&quot; }
  end
  
  x.report(&quot;Double with interpolation:&quot;) do
    name = &quot;John&quot;
    n.times { &quot;Hello #{name}&quot; }
  end
end

# Single quotes: slightly faster (no interpolation check)
# Double quotes: slightly slower (checks for interpolation)
# With interpolation: slowest (actually does interpolation)
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use Single Quotes (<code>&#39; &#39;</code>) for:</strong></p>
<ul>
<li>Static strings with no interpolation</li>
<li>Regex patterns</li>
<li>Keys and identifiers</li>
<li>Strings with many backslashes</li>
</ul>
<pre><code class="language-ruby"># Good uses of single quotes
message = &#39;Hello World&#39;
regex = /\d{3}-\d{2}-\d{4}/
path = &#39;C:\Users\Documents&#39;
key = &#39;user_id&#39;
</code></pre>
<p><strong>Use Double Quotes (<code>&quot; &quot;</code>) for:</strong></p>
<ul>
<li>Strings with interpolation</li>
<li>Strings with escape sequences</li>
<li>Dynamic content</li>
<li>Multi-line formatted strings</li>
</ul>
<pre><code class="language-ruby"># Good uses of double quotes
name = &quot;John&quot;
greeting = &quot;Hello, #{name}!&quot;
multi_line = &quot;Line 1\nLine 2\nLine 3&quot;
formatted = &quot;Total: $#{amount}&quot;
</code></pre>
<hr>
<h3>Rails String Interpolation</h3>
<pre><code class="language-ruby"># View templates (ERB)
&lt;p&gt;Welcome, &lt;%= @user.name %&gt;!&lt;/p&gt;

# Controller
flash[:notice] = &quot;User #{@user.name} was successfully created.&quot;

# Model
def full_name
  &quot;#{first_name} #{last_name}&quot;
end

# Mailer
mail(to: @user.email, subject: &quot;Welcome #{@user.name}!&quot;)
</code></pre>
<hr>
<h3>Heredoc (Multi-line Strings)</h3>
<pre><code class="language-ruby"># With double quotes (default)
message = &lt;&lt;-TEXT
  Hello #{name},
  
  Welcome to our service!
  
  Best regards,
  The Team
TEXT

# With single quotes (no interpolation)
message = &lt;&lt;-&#39;TEXT&#39;
  Hello #{name},
  
  This will be literal: #{name}
TEXT

# Squiggly heredoc (removes indentation)
message = &lt;&lt;~TEXT
  Hello #{name},
  
  Indentation removed automatically.
TEXT
</code></pre>
<hr>
<h3>String Concatenation vs Interpolation</h3>
<pre><code class="language-ruby">name = &quot;John&quot;
age = 30

# Concatenation (works with both)
message = &#39;Hello, &#39; + name + &#39;! You are &#39; + age.to_s + &#39; years old.&#39;

# Interpolation (double quotes only, preferred)
message = &quot;Hello, #{name}! You are #{age} years old.&quot;

# Performance
Benchmark.bm do |x|
  x.report(&quot;Concatenation:&quot;) do
    10000.times { &#39;Hello, &#39; + name + &#39;!&#39; }
  end
  
  x.report(&quot;Interpolation:&quot;) do
    10000.times { &quot;Hello, #{name}!&quot; }
  end
end

# Interpolation is generally faster and more readable
</code></pre>
<hr>
<h3>Quotes in Quotes</h3>
<pre><code class="language-ruby"># Single quotes inside double quotes
message = &quot;He said, &#39;Hello!&#39;&quot;

# Double quotes inside single quotes
message = &#39;He said, &quot;Hello!&quot;&#39;

# Escaping quotes
message = &quot;He said, \&quot;Hello!\&quot;&quot;
message = &#39;It\&#39;s sunny today&#39;

# Alternative: Use %q and %Q
message = %q(He said, &quot;Hello!&quot;)  # Single quote behavior
message = %Q(He said, &quot;Hello!&quot;)  # Double quote behavior
message = %(He said, &quot;Hello!&quot;)   # Double quote behavior (default)
</code></pre>
<hr>
<h3>Advanced String Literals</h3>
<pre><code class="language-ruby"># %q - single quote behavior
%q(no interpolation #{name})
# &quot;no interpolation #{name}&quot;

# %Q - double quote behavior
%Q(with interpolation #{name})
# &quot;with interpolation John&quot;

# % - double quote behavior (default)
%(also interpolation #{name})
# &quot;also interpolation John&quot;

# Useful for strings with many quotes
html = %(&lt;div class=&quot;container&quot; id=&quot;main&quot;&gt;&lt;/div&gt;)
</code></pre>
<hr>
<h3>Freezing Strings</h3>
<pre><code class="language-ruby"># Single quoted (still mutable)
str = &#39;hello&#39;
str.upcase!  # Works, modifies string

# Frozen string literal (Ruby 2.3+)
# frozen_string_literal: true

str = &#39;hello&#39;
str.frozen?  # true
str.upcase!  # FrozenError

# Manually freeze
str = &quot;hello&quot;.freeze
str.frozen?  # true
str.upcase!  # FrozenError
</code></pre>
<hr>
<h3>Rails Best Practices</h3>
<p><strong>Prefer double quotes for:</strong></p>
<pre><code class="language-ruby"># Interpolation
flash[:notice] = &quot;User #{user.name} created&quot;

# I18n
t(&quot;users.created&quot;, name: user.name)

# SQL queries (with interpolation)
User.where(&quot;age &gt; ?&quot;, 18)
</code></pre>
<p><strong>Prefer single quotes for:</strong></p>
<pre><code class="language-ruby"># Static strings
redirect_to root_path, notice: &#39;Successfully logged in&#39;

# Hash keys (or use symbols)
user = { &#39;name&#39; =&gt; &#39;John&#39; }

# Regex
if email.match?(/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Double quotes</strong> support interpolation and escape sequences</li>
<li><strong>Single quotes</strong> are literal (except <code>\&#39;</code> and <code>\\</code>)</li>
<li><strong>Single quotes</strong> are marginally faster (no interpolation check)</li>
<li><strong>Use double quotes</strong> when you need interpolation</li>
<li><strong>Use single quotes</strong> for static strings</li>
<li><strong>Interpolation is preferred</strong> over concatenation (faster, cleaner)</li>
<li><strong>Heredocs</strong> for multi-line strings with proper indentation</li>
</ol>
<hr>
<h2>Question 21: What is the difference between Hash and OpenStruct?</h2>
<h3>Answer</h3>
<p><strong>Hash</strong> is a built-in Ruby data structure for key-value pairs. <strong>OpenStruct</strong> is a class that creates objects with arbitrary attributes dynamically.</p>
<hr>
<h3>Hash</h3>
<p><strong>Definition:</strong> A collection of key-value pairs.</p>
<pre><code class="language-ruby"># Creating a hash
user = {
  name: &quot;John&quot;,
  email: &quot;john@example.com&quot;,
  age: 30
}

# Accessing values
user[:name]   # &quot;John&quot;
user[:age]    # 30

# Setting values
user[:role] = &quot;admin&quot;

# Methods
user.keys     # [:name, :email, :age, :role]
user.values   # [&quot;John&quot;, &quot;john@example.com&quot;, 30, &quot;admin&quot;]
user.empty?   # false
user.size     # 4
</code></pre>
<hr>
<h3>OpenStruct</h3>
<p><strong>Definition:</strong> An object that allows you to define attributes dynamically.</p>
<pre><code class="language-ruby">require &#39;ostruct&#39;

# Creating an OpenStruct
user = OpenStruct.new(
  name: &quot;John&quot;,
  email: &quot;john@example.com&quot;,
  age: 30
)

# Accessing values (method-like)
user.name   # &quot;John&quot;
user.age    # 30

# Setting values
user.role = &quot;admin&quot;

# Methods
user.to_h   # {:name=&gt;&quot;John&quot;, :email=&gt;&quot;john@example.com&quot;, :age=&gt;30, :role=&gt;&quot;admin&quot;}
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Hash</th>
<th>OpenStruct</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Type</strong></td>
<td>Data structure</td>
<td>Object</td>
</tr>
<tr>
<td><strong>Access</strong></td>
<td><code>hash[:key]</code></td>
<td><code>obj.attribute</code></td>
</tr>
<tr>
<td><strong>Built-in</strong></td>
<td>Yes</td>
<td>No (requires <code>require &#39;ostruct&#39;</code>)</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Faster</td>
<td>Slower</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>Less</td>
<td>More (method creation overhead)</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Simple data storage</td>
<td>Object-like access to data</td>
</tr>
<tr>
<td><strong>Syntax</strong></td>
<td>Bracket notation</td>
<td>Dot notation</td>
</tr>
<tr>
<td><strong>Methods</strong></td>
<td>Many built-in methods</td>
<td>Fewer methods</td>
</tr>
</tbody></table>
<hr>
<h3>Access Syntax Comparison</h3>
<pre><code class="language-ruby"># Hash
user = { name: &quot;John&quot;, age: 30 }
user[:name]        # &quot;John&quot;
user[:email]       # nil
user[:role] = &quot;admin&quot;

# OpenStruct
require &#39;ostruct&#39;
user = OpenStruct.new(name: &quot;John&quot;, age: 30)
user.name          # &quot;John&quot;
user.email         # nil
user.role = &quot;admin&quot;
</code></pre>
<hr>
<h3>Adding Attributes Dynamically</h3>
<pre><code class="language-ruby"># Hash
user = {}
user[:name] = &quot;John&quot;
user[:age] = 30

# OpenStruct
user = OpenStruct.new
user.name = &quot;John&quot;
user.age = 30
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;
require &#39;ostruct&#39;

n = 100_000

Benchmark.bm do |x|
  x.report(&quot;Hash:&quot;) do
    n.times do
      h = { name: &quot;John&quot;, age: 30 }
      h[:name]
      h[:age] = 31
    end
  end
  
  x.report(&quot;OpenStruct:&quot;) do
    n.times do
      os = OpenStruct.new(name: &quot;John&quot;, age: 30)
      os.name
      os.age = 31
    end
  end
end

# Hash is significantly faster!
</code></pre>
<hr>
<h3>Converting Between Hash and OpenStruct</h3>
<pre><code class="language-ruby"># Hash to OpenStruct
hash = { name: &quot;John&quot;, email: &quot;john@example.com&quot; }
ostruct = OpenStruct.new(hash)

ostruct.name  # &quot;John&quot;

# OpenStruct to Hash
ostruct.to_h  # { name: &quot;John&quot;, email: &quot;john@example.com&quot; }
</code></pre>
<hr>
<h3>Nested Structures</h3>
<p><strong>Hash:</strong></p>
<pre><code class="language-ruby">user = {
  name: &quot;John&quot;,
  address: {
    street: &quot;123 Main St&quot;,
    city: &quot;New York&quot;
  }
}

user[:address][:city]  # &quot;New York&quot;
</code></pre>
<p><strong>OpenStruct:</strong></p>
<pre><code class="language-ruby">require &#39;ostruct&#39;

user = OpenStruct.new(
  name: &quot;John&quot;,
  address: OpenStruct.new(
    street: &quot;123 Main St&quot;,
    city: &quot;New York&quot;
  )
)

user.address.city  # &quot;New York&quot;
</code></pre>
<p><strong>Recursive OpenStruct:</strong></p>
<pre><code class="language-ruby">def to_recursive_ostruct(hash)
  OpenStruct.new(hash.transform_values { |v|
    v.is_a?(Hash) ? to_recursive_ostruct(v) : v
  })
end

user = to_recursive_ostruct({
  name: &quot;John&quot;,
  address: {
    street: &quot;123 Main St&quot;,
    city: &quot;New York&quot;
  }
})

user.address.city  # &quot;New York&quot;
</code></pre>
<hr>
<h3>Real-World Use Cases</h3>
<p><strong>Hash - Best for:</strong></p>
<ul>
<li>Simple data storage</li>
<li>API responses</li>
<li>Database query results</li>
<li>Performance-critical code</li>
<li>Large datasets</li>
</ul>
<pre><code class="language-ruby"># API response
response = {
  status: 200,
  data: { users: [...] },
  meta: { total: 100, page: 1 }
}

# Database results
users = User.where(active: true).pluck(:id, :name, :email)
</code></pre>
<p><strong>OpenStruct - Best for:</strong></p>
<ul>
<li>Configuration objects</li>
<li>Test data/mocking</li>
<li>Small, object-like data structures</li>
<li>Readability over performance</li>
</ul>
<pre><code class="language-ruby"># Configuration
config = OpenStruct.new(
  api_key: &quot;secret123&quot;,
  timeout: 30,
  retries: 3
)

puts config.api_key
puts config.timeout

# Test doubles/mocks
user_double = OpenStruct.new(
  name: &quot;John&quot;,
  admin?: true,
  posts: []
)

expect(user_double.admin?).to be true
</code></pre>
<hr>
<h3>Rails Examples</h3>
<p><strong>Hash in Rails:</strong></p>
<pre><code class="language-ruby"># Strong parameters
def user_params
  params.require(:user).permit(:name, :email, :age)
end
# Returns Hash

# Session
session[:user_id] = current_user.id
session[:user_id]  # Access with brackets

# Flash messages
flash[:notice] = &quot;User created&quot;
</code></pre>
<p><strong>OpenStruct in Rails:</strong></p>
<pre><code class="language-ruby"># View object pattern
class UserPresenter &lt; OpenStruct
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
  
  def avatar_url
    gravatar_url(email)
  end
end

presenter = UserPresenter.new(
  first_name: &quot;John&quot;,
  last_name: &quot;Doe&quot;,
  email: &quot;john@example.com&quot;
)

presenter.full_name  # &quot;John Doe&quot;
</code></pre>
<hr>
<h3>Method Missing Behavior</h3>
<p><strong>OpenStruct uses <code>method_missing</code>:</strong></p>
<pre><code class="language-ruby">require &#39;ostruct&#39;

user = OpenStruct.new(name: &quot;John&quot;)

# This creates a method dynamically
user.age = 30

# Check if method exists
user.respond_to?(:age)  # true
user.respond_to?(:email)  # false

# Methods are created on-the-fly
user.methods.grep(/age/)  # [:age, :age=]
</code></pre>
<hr>
<h3>Hash with Indifferent Access (Rails)</h3>
<pre><code class="language-ruby"># Regular Hash
hash = { name: &quot;John&quot; }
hash[:name]   # &quot;John&quot;
hash[&quot;name&quot;]  # nil

# HashWithIndifferentAccess (Rails)
hash = { name: &quot;John&quot; }.with_indifferent_access
hash[:name]   # &quot;John&quot;
hash[&quot;name&quot;]  # &quot;John&quot; (works with both!)

# Or
hash = ActiveSupport::HashWithIndifferentAccess.new(name: &quot;John&quot;)
hash[:name]   # &quot;John&quot;
hash[&quot;name&quot;]  # &quot;John&quot;
</code></pre>
<hr>
<h3>Alternative: Struct</h3>
<p><strong>Struct</strong> is a middle ground between Hash and OpenStruct:</p>
<pre><code class="language-ruby"># Define structure upfront
User = Struct.new(:name, :email, :age)

user = User.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)

# Access like OpenStruct
user.name   # &quot;John&quot;
user.age    # 30

# Set values
user.age = 31

# Convert to array/hash
user.to_a  # [&quot;John&quot;, &quot;john@example.com&quot;, 31]
user.to_h  # {:name=&gt;&quot;John&quot;, :email=&gt;&quot;john@example.com&quot;, :age=&gt;31}

# Faster than OpenStruct!
</code></pre>
<hr>
<h3>Memory Usage</h3>
<pre><code class="language-ruby">require &#39;ostruct&#39;
require &#39;objspace&#39;

# Hash
hash = { name: &quot;John&quot;, age: 30 }
ObjectSpace.memsize_of(hash)  # ~200 bytes

# OpenStruct
ostruct = OpenStruct.new(name: &quot;John&quot;, age: 30)
ObjectSpace.memsize_of(ostruct)  # ~400+ bytes

# Struct
User = Struct.new(:name, :age)
struct = User.new(&quot;John&quot;, 30)
ObjectSpace.memsize_of(struct)  # ~240 bytes

# Hash uses least memory!
</code></pre>
<hr>
<h3>When NOT to Use OpenStruct</h3>
<pre><code class="language-ruby"># DON&#39;T use for large datasets
users = []
10_000.times do |i|
  users &lt;&lt; OpenStruct.new(name: &quot;User#{i}&quot;, email: &quot;user#{i}@example.com&quot;)
end
# Too slow and memory-intensive!

# DO use Hash or Struct instead
users = []
10_000.times do |i|
  users &lt;&lt; { name: &quot;User#{i}&quot;, email: &quot;user#{i}@example.com&quot; }
end
# Much better!
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Hash</strong> is faster, more memory-efficient, built-in</li>
<li><strong>OpenStruct</strong> provides object-like syntax, but slower</li>
<li><strong>Use Hash</strong> for most data storage needs</li>
<li><strong>Use OpenStruct</strong> for configuration, tests, small objects</li>
<li><strong>Struct</strong> is a good middle ground (faster than OpenStruct)</li>
<li><strong>Performance matters</strong> - Hash &gt; Struct &gt; OpenStruct</li>
<li><strong>Rails</strong> provides <code>HashWithIndifferentAccess</code> for flexible access</li>
</ol>
<hr>
<h2>Question 22: How does the Struct class work in Ruby?</h2>
<h3>Answer</h3>
<p><strong>Struct</strong> is a convenient way to create simple classes that hold data with named attributes. It&#39;s a hybrid between Hash and OpenStruct - faster than OpenStruct, more structured than Hash.</p>
<hr>
<h3>Creating a Struct</h3>
<p><strong>Basic Syntax:</strong></p>
<pre><code class="language-ruby"># Create a Struct class
User = Struct.new(:name, :email, :age)

# Create instances
user1 = User.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)
user2 = User.new(&quot;Jane&quot;, &quot;jane@example.com&quot;, 25)

# Access attributes
user1.name   # &quot;John&quot;
user1.email  # &quot;john@example.com&quot;
user1.age    # 30
</code></pre>
<hr>
<h3>Different Ways to Create Structs</h3>
<p><strong>1. Constant Assignment:</strong></p>
<pre><code class="language-ruby">User = Struct.new(:name, :email, :age)
user = User.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)
</code></pre>
<p><strong>2. Anonymous Struct:</strong></p>
<pre><code class="language-ruby">user_struct = Struct.new(:name, :email, :age)
user = user_struct.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)
</code></pre>
<p><strong>3. With Block (adding methods):</strong></p>
<pre><code class="language-ruby">User = Struct.new(:first_name, :last_name, :email) do
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
  
  def initials
    &quot;#{first_name[0]}#{last_name[0]}&quot;
  end
end

user = User.new(&quot;John&quot;, &quot;Doe&quot;, &quot;john@example.com&quot;)
user.full_name  # &quot;John Doe&quot;
user.initials   # &quot;JD&quot;
</code></pre>
<p><strong>4. Keyword Arguments (Ruby 2.5+):</strong></p>
<pre><code class="language-ruby">User = Struct.new(:name, :email, :age, keyword_init: true)

user = User.new(name: &quot;John&quot;, email: &quot;john@example.com&quot;, age: 30)
user.name  # &quot;John&quot;
</code></pre>
<hr>
<h3>Accessing and Modifying Attributes</h3>
<pre><code class="language-ruby">User = Struct.new(:name, :email, :age)
user = User.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)

# Getter
user.name  # &quot;John&quot;
user[:name]  # &quot;John&quot; (also works)

# Setter
user.name = &quot;Jane&quot;
user[:name] = &quot;Bob&quot;  # Also works

# Get all values
user.values  # [&quot;Bob&quot;, &quot;john@example.com&quot;, 30]
user.to_a    # [&quot;Bob&quot;, &quot;john@example.com&quot;, 30]

# Get as hash
user.to_h  # {:name=&gt;&quot;Bob&quot;, :email=&gt;&quot;john@example.com&quot;, :age=&gt;30}

# Get members (attribute names)
user.members  # [:name, :email, :age]
</code></pre>
<hr>
<h3>Comparison with Hash and OpenStruct</h3>
<pre><code class="language-ruby"># Hash
user_hash = { name: &quot;John&quot;, email: &quot;john@example.com&quot;, age: 30 }
user_hash[:name]  # &quot;John&quot;

# OpenStruct
require &#39;ostruct&#39;
user_os = OpenStruct.new(name: &quot;John&quot;, email: &quot;john@example.com&quot;, age: 30)
user_os.name  # &quot;John&quot;

# Struct
User = Struct.new(:name, :email, :age)
user_struct = User.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)
user_struct.name  # &quot;John&quot;
</code></pre>
<p><strong>Performance:</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

n = 100_000

Benchmark.bm do |x|
  x.report(&quot;Hash:&quot;) do
    n.times { { name: &quot;John&quot;, age: 30 } }
  end
  
  x.report(&quot;Struct:&quot;) do
    User = Struct.new(:name, :age)
    n.times { User.new(&quot;John&quot;, 30) }
  end
  
  x.report(&quot;OpenStruct:&quot;) do
    n.times { OpenStruct.new(name: &quot;John&quot;, age: 30) }
  end
end

# Hash: fastest
# Struct: middle (close to Hash)
# OpenStruct: slowest
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong>1. Simple Data Containers:</strong></p>
<pre><code class="language-ruby">Point = Struct.new(:x, :y) do
  def distance_from_origin
    Math.sqrt(x**2 + y**2)
  end
end

p1 = Point.new(3, 4)
p1.distance_from_origin  # 5.0
</code></pre>
<p><strong>2. Configuration Objects:</strong></p>
<pre><code class="language-ruby">Config = Struct.new(:api_key, :timeout, :retries, :debug)

config = Config.new(&quot;secret123&quot;, 30, 3, true)
puts config.api_key  # &quot;secret123&quot;
puts config.timeout  # 30
</code></pre>
<p><strong>3. Return Values from Methods:</strong></p>
<pre><code class="language-ruby">Result = Struct.new(:success, :data, :error)

def fetch_data
  # ... fetch logic
  if success
    Result.new(true, data, nil)
  else
    Result.new(false, nil, &quot;Error message&quot;)
  end
end

result = fetch_data
if result.success
  process(result.data)
else
  handle_error(result.error)
end
</code></pre>
<p><strong>4. Light Value Objects:</strong></p>
<pre><code class="language-ruby">Money = Struct.new(:amount, :currency) do
  def to_s
    &quot;#{amount} #{currency}&quot;
  end
  
  def ==(other)
    amount == other.amount &amp;&amp; currency == other.currency
  end
end

price = Money.new(100, &quot;USD&quot;)
puts price  # &quot;100 USD&quot;
</code></pre>
<hr>
<h3>Rails Examples</h3>
<p><strong>1. View Objects/Presenters:</strong></p>
<pre><code class="language-ruby">class UserPresenter &lt; Struct.new(:user)
  def full_name
    &quot;#{user.first_name} #{user.last_name}&quot;
  end
  
  def avatar_url
    user.avatar.url || &#39;/default-avatar.png&#39;
  end
  
  def formatted_joined_date
    user.created_at.strftime(&quot;%B %d, %Y&quot;)
  end
end

# In controller
@presenter = UserPresenter.new(@user)

# In view
&lt;%= @presenter.full_name %&gt;
&lt;%= image_tag @presenter.avatar_url %&gt;
</code></pre>
<p><strong>2. Form Objects:</strong></p>
<pre><code class="language-ruby">class RegistrationForm &lt; Struct.new(:name, :email, :password, :password_confirmation)
  def valid?
    name.present? &amp;&amp; 
    email.match?(/\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i) &amp;&amp;
    password == password_confirmation
  end
  
  def save
    return false unless valid?
    User.create(name: name, email: email, password: password)
  end
end

form = RegistrationForm.new(
  params[:name],
  params[:email],
  params[:password],
  params[:password_confirmation]
)

if form.save
  redirect_to root_path
else
  render :new
end
</code></pre>
<p><strong>3. Query Objects:</strong></p>
<pre><code class="language-ruby">class UserSearch &lt; Struct.new(:query, :role, :active_only)
  def results
    scope = User.all
    scope = scope.where(&quot;name LIKE ?&quot;, &quot;%#{query}%&quot;) if query.present?
    scope = scope.where(role: role) if role.present?
    scope = scope.where(active: true) if active_only
    scope
  end
end

search = UserSearch.new(params[:query], params[:role], true)
@users = search.results
</code></pre>
<hr>
<h3>Advanced Features</h3>
<p><strong>1. Equality Comparison:</strong></p>
<pre><code class="language-ruby">User = Struct.new(:name, :age)

user1 = User.new(&quot;John&quot;, 30)
user2 = User.new(&quot;John&quot;, 30)
user3 = User.new(&quot;Jane&quot;, 25)

user1 == user2  # true (same values)
user1 == user3  # false (different values)
user1.eql?(user2)  # true
</code></pre>
<p><strong>2. Iteration:</strong></p>
<pre><code class="language-ruby">User = Struct.new(:name, :email, :age)
user = User.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)

# Iterate over values
user.each { |value| puts value }
# John
# john@example.com
# 30

# Iterate with index
user.each_pair { |key, value| puts &quot;#{key}: #{value}&quot; }
# name: John
# email: john@example.com
# age: 30
</code></pre>
<p><strong>3. Pattern Matching (Ruby 2.7+):</strong></p>
<pre><code class="language-ruby">User = Struct.new(:name, :email, :age)
user = User.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)

case user
in User(name: &quot;John&quot;, age: age) if age &gt; 18
  puts &quot;Adult John&quot;
in User(name:, age:)
  puts &quot;#{name} is #{age} years old&quot;
end
</code></pre>
<hr>
<h3>Inheritance</h3>
<pre><code class="language-ruby"># Base Struct
Person = Struct.new(:name, :age)

# Inherit and add methods
class Employee &lt; Person
  def initialize(name, age, employee_id)
    super(name, age)
    @employee_id = employee_id
  end
  
  attr_reader :employee_id
  
  def display
    &quot;#{name} (ID: #{employee_id}), Age: #{age}&quot;
  end
end

emp = Employee.new(&quot;John&quot;, 30, &quot;E123&quot;)
puts emp.display  # &quot;John (ID: E123), Age: 30&quot;
</code></pre>
<hr>
<h3>Struct vs Class</h3>
<p><strong>When to use Struct:</strong></p>
<ul>
<li>Simple data containers</li>
<li>Immutable-like value objects</li>
<li>Quick prototyping</li>
<li>When you need both Hash-like and Object-like behavior</li>
</ul>
<p><strong>When to use Class:</strong></p>
<ul>
<li>Complex behavior</li>
<li>Need inheritance</li>
<li>Multiple methods</li>
<li>Business logic</li>
</ul>
<pre><code class="language-ruby"># Struct - simple
Point = Struct.new(:x, :y)

# Class - complex
class Point
  attr_accessor :x, :y
  
  def initialize(x, y)
    @x = x
    @y = y
    validate!
  end
  
  def distance_to(other)
    # complex logic
  end
  
  private
  
  def validate!
    raise &quot;Invalid coordinates&quot; if x.nil? || y.nil?
  end
end
</code></pre>
<hr>
<h3>Immutability with Struct</h3>
<pre><code class="language-ruby"># Struct is mutable by default
User = Struct.new(:name, :age)
user = User.new(&quot;John&quot;, 30)
user.age = 31  # Can be modified

# Make immutable by freezing
user.freeze
user.age = 32  # FrozenError

# Or create immutable Struct
class ImmutableUser &lt; Struct.new(:name, :age)
  def initialize(*args)
    super
    freeze
  end
end

user = ImmutableUser.new(&quot;John&quot;, 30)
user.age = 31  # FrozenError
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Struct creates lightweight classes</strong> with named attributes</li>
<li><strong>Faster than OpenStruct</strong>, slightly slower than Hash</li>
<li><strong>Use for simple data containers</strong> and value objects</li>
<li><strong>Can add methods</strong> via block or inheritance</li>
<li><strong>keyword_init: true</strong> for named parameters (Ruby 2.5+)</li>
<li><strong>Good for</strong>: presenters, form objects, configuration</li>
<li><strong>Not good for</strong>: complex business logic, heavy validation</li>
</ol>
<hr>
<h2>Question 23: Explain Hash and its use cases</h2>
<h3>Answer</h3>
<p><strong>Hash</strong> (also called dictionary or associative array) is a collection of key-value pairs where keys are unique and map to values.</p>
<hr>
<h3>Creating Hashes</h3>
<pre><code class="language-ruby"># Using hash rocket =&gt;
user = { &quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30 }

# Using symbol keys (colon syntax - Ruby 1.9+)
user = { name: &quot;John&quot;, age: 30 }

# Using Hash.new
user = Hash.new
user[:name] = &quot;John&quot;

# With default value
counts = Hash.new(0)
counts[:a]  # 0 (default value)

# With default block
hash = Hash.new { |h, k| h[k] = [] }
hash[:key] &lt;&lt; &quot;value&quot;  # Automatically creates array
</code></pre>
<hr>
<h3>Accessing Values</h3>
<pre><code class="language-ruby">user = { name: &quot;John&quot;, email: &quot;john@example.com&quot;, age: 30 }

# Using []
user[:name]   # &quot;John&quot;
user[:phone]  # nil

# Using fetch (with default)
user.fetch(:name)          # &quot;John&quot;
user.fetch(:phone, &quot;N/A&quot;)  # &quot;N/A&quot;
user.fetch(:phone) { &quot;No phone&quot; }  # &quot;No phone&quot;

# Using dig (nested access)
data = { user: { profile: { name: &quot;John&quot; } } }
data.dig(:user, :profile, :name)  # &quot;John&quot;
data.dig(:user, :settings, :theme)  # nil (safe)
</code></pre>
<hr>
<h3>Adding/Updating Values</h3>
<pre><code class="language-ruby">user = { name: &quot;John&quot; }

# Add new key-value
user[:email] = &quot;john@example.com&quot;

# Update existing
user[:name] = &quot;Jane&quot;

# Merge hashes
defaults = { role: &quot;user&quot;, active: true }
user.merge!(defaults)  # Modifies user
# or
combined = user.merge(defaults)  # New hash

# Multiple updates
user.update(age: 30, city: &quot;New York&quot;)
</code></pre>
<hr>
<h3>Deleting Values</h3>
<pre><code class="language-ruby">user = { name: &quot;John&quot;, email: &quot;john@example.com&quot;, age: 30 }

# Delete specific key
user.delete(:age)  # Returns 30
user  # { name: &quot;John&quot;, email: &quot;john@example.com&quot; }

# Delete if condition
user.delete_if { |k, v| v.nil? }

# Keep only certain keys
user.keep_if { |k, v| k == :name }

# Select (non-destructive)
active_users = users.select { |k, v| v[:active] }
</code></pre>
<hr>
<h3>Common Hash Methods</h3>
<pre><code class="language-ruby">user = { name: &quot;John&quot;, email: &quot;john@example.com&quot;, age: 30 }

# Keys and values
user.keys    # [:name, :email, :age]
user.values  # [&quot;John&quot;, &quot;john@example.com&quot;, 30]

# Size/length
user.size    # 3
user.length  # 3
user.empty?  # false

# Check for key/value
user.key?(:name)      # true
user.has_key?(:phone) # false
user.value?(&quot;John&quot;)   # true

# Clear all
user.clear  # {}

# Invert (swap keys and values)
hash = { a: 1, b: 2 }
hash.invert  # { 1 =&gt; :a, 2 =&gt; :b }
</code></pre>
<hr>
<h3>Iterating Over Hashes</h3>
<pre><code class="language-ruby">user = { name: &quot;John&quot;, email: &quot;john@example.com&quot;, age: 30 }

# Each (key and value)
user.each do |key, value|
  puts &quot;#{key}: #{value}&quot;
end

# Each key
user.each_key do |key|
  puts key
end

# Each value
user.each_value do |value|
  puts value
end

# Map/collect
uppercased = user.map { |k, v| [k, v.to_s.upcase] }.to_h
# or
uppercased = user.transform_values(&amp;:upcase)

# Select
adults = users.select { |k, v| v[:age] &gt;= 18 }

# Reject
inactive = users.reject { |k, v| v[:active] }
</code></pre>
<hr>
<h3>Transforming Hashes</h3>
<pre><code class="language-ruby">user = { name: &quot;john&quot;, email: &quot;JOHN@EXAMPLE.COM&quot; }

# Transform values
user.transform_values(&amp;:upcase)
# { name: &quot;JOHN&quot;, email: &quot;JOHN@EXAMPLE.COM&quot; }

# Transform keys
user.transform_keys(&amp;:to_s)
# { &quot;name&quot; =&gt; &quot;john&quot;, &quot;email&quot; =&gt; &quot;JOHN@EXAMPLE.COM&quot; }

# Symbolize keys (Rails)
hash = { &quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30 }
hash.symbolize_keys  # { name: &quot;John&quot;, age: 30 }

# Stringify keys (Rails)
hash = { name: &quot;John&quot;, age: 30 }
hash.stringify_keys  # { &quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30 }
</code></pre>
<hr>
<h3>Nested Hashes</h3>
<pre><code class="language-ruby">user = {
  name: &quot;John&quot;,
  address: {
    street: &quot;123 Main St&quot;,
    city: &quot;New York&quot;,
    coordinates: {
      lat: 40.7128,
      lng: -74.0060
    }
  }
}

# Access nested values
user[:address][:city]  # &quot;New York&quot;
user.dig(:address, :coordinates, :lat)  # 40.7128

# Modify nested values
user[:address][:street] = &quot;456 Oak Ave&quot;
</code></pre>
<hr>
<h3>Default Values</h3>
<pre><code class="language-ruby"># Default value (same for all missing keys)
counts = Hash.new(0)
counts[:a] += 1  # 1
counts[:b] += 2  # 2

# Default block (different for each key)
hash = Hash.new { |h, k| h[k] = [] }
hash[:a] &lt;&lt; 1  # Creates array, adds 1
hash[:a] &lt;&lt; 2  # Adds to existing array
hash[:a]  # [1, 2]

# Default with block for complex initialization
cache = Hash.new { |h, k| h[k] = { count: 0, items: [] } }
cache[:users][:count] += 1
cache[:users][:items] &lt;&lt; &quot;John&quot;
</code></pre>
<hr>
<h3>Use Cases</h3>
<p><strong>1. Configuration:</strong></p>
<pre><code class="language-ruby">config = {
  database: {
    host: &quot;localhost&quot;,
    port: 5432,
    username: &quot;admin&quot;
  },
  cache: {
    enabled: true,
    ttl: 3600
  }
}

puts config[:database][:host]
</code></pre>
<p><strong>2. Counting/Frequency:</strong></p>
<pre><code class="language-ruby">words = [&quot;apple&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;cherry&quot;, &quot;banana&quot;, &quot;apple&quot;]

frequency = Hash.new(0)
words.each { |word| frequency[word] += 1 }
frequency  # { &quot;apple&quot; =&gt; 3, &quot;banana&quot; =&gt; 2, &quot;cherry&quot; =&gt; 1 }
</code></pre>
<p><strong>3. Grouping:</strong></p>
<pre><code class="language-ruby">users = [
  { name: &quot;John&quot;, role: &quot;admin&quot; },
  { name: &quot;Jane&quot;, role: &quot;user&quot; },
  { name: &quot;Bob&quot;, role: &quot;admin&quot; }
]

grouped = users.group_by { |user| user[:role] }
# {
#   &quot;admin&quot; =&gt; [{ name: &quot;John&quot;, role: &quot;admin&quot; }, { name: &quot;Bob&quot;, role: &quot;admin&quot; }],
#   &quot;user&quot; =&gt; [{ name: &quot;Jane&quot;, role: &quot;user&quot; }]
# }
</code></pre>
<p><strong>4. Caching:</strong></p>
<pre><code class="language-ruby">cache = {}

def fetch_user(id, cache)
  cache[id] ||= expensive_database_query(id)
end

user = fetch_user(123, cache)  # Database query
user = fetch_user(123, cache)  # From cache
</code></pre>
<p><strong>5. Options/Parameters:</strong></p>
<pre><code class="language-ruby">def create_user(name, options = {})
  defaults = { role: &quot;user&quot;, active: true, notifications: true }
  settings = defaults.merge(options)
  
  User.create(
    name: name,
    role: settings[:role],
    active: settings[:active],
    notifications: settings[:notifications]
  )
end

create_user(&quot;John&quot;, role: &quot;admin&quot;, notifications: false)
</code></pre>
<hr>
<h3>Rails Examples</h3>
<p><strong>1. Params:</strong></p>
<pre><code class="language-ruby"># params is a Hash
params = {
  user: {
    name: &quot;John&quot;,
    email: &quot;john@example.com&quot;,
    profile: {
      bio: &quot;Developer&quot;
    }
  }
}

params[:user][:name]  # &quot;John&quot;
params.dig(:user, :profile, :bio)  # &quot;Developer&quot;
</code></pre>
<p><strong>2. Session:</strong></p>
<pre><code class="language-ruby">session[:user_id] = current_user.id
session[:cart] = { items: [], total: 0 }

user_id = session[:user_id]
</code></pre>
<p><strong>3. Flash Messages:</strong></p>
<pre><code class="language-ruby">flash[:notice] = &quot;User created successfully&quot;
flash[:alert] = &quot;Error occurred&quot;

# In view
&lt;%= flash[:notice] %&gt;
</code></pre>
<p><strong>4. Strong Parameters:</strong></p>
<pre><code class="language-ruby">def user_params
  params.require(:user).permit(:name, :email, profile: [:bio, :avatar])
end

# Returns hash with only permitted keys
</code></pre>
<p><strong>5. Where Conditions:</strong></p>
<pre><code class="language-ruby">User.where(role: &quot;admin&quot;, active: true)
User.where(&quot;age &gt; ? AND city = ?&quot;, 18, &quot;New York&quot;)

# Hash conditions
Post.where(status: :published, featured: true)
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-ruby"># Hash lookup is O(1) - constant time
hash = { a: 1, b: 2, c: 3 }
hash[:b]  # Very fast, regardless of hash size

# Better than Array search O(n)
array = [[:a, 1], [:b, 2], [:c, 3]]
array.find { |k, v| k == :b }[1]  # Slower for large arrays
</code></pre>
<hr>
<h3>Hash vs HashWithIndifferentAccess (Rails)</h3>
<pre><code class="language-ruby"># Regular Hash
hash = { name: &quot;John&quot;, :email =&gt; &quot;john@example.com&quot; }
hash[:name]   # &quot;John&quot;
hash[&quot;name&quot;]  # nil (different key!)

# HashWithIndifferentAccess
hash = { name: &quot;John&quot; }.with_indifferent_access
hash[:name]   # &quot;John&quot;
hash[&quot;name&quot;]  # &quot;John&quot; (same result!)

# Useful for params in Rails
params = { &quot;user&quot; =&gt; { &quot;name&quot; =&gt; &quot;John&quot; } }.with_indifferent_access
params[:user][:name]  # Works!
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Hash stores key-value pairs</strong> with unique keys</li>
<li><strong>O(1) lookup time</strong> makes it very fast</li>
<li><strong>Symbol keys preferred</strong> for performance and consistency</li>
<li><strong>Use <code>.dig</code> for safe nested access</strong></li>
<li><strong>Default values/blocks</strong> prevent nil errors</li>
<li><strong>Common uses</strong>: config, counting, grouping, caching</li>
<li><strong>Rails heavily uses hashes</strong> for params, session, options</li>
</ol>
<hr>
<h2>Question 24: What is String Interpolation?</h2>
<h3>Answer</h3>
<p><strong>String interpolation</strong> is embedding Ruby expressions directly into strings using <code>#{}</code> syntax. It only works with double quotes.</p>
<hr>
<h3>Basic Interpolation</h3>
<pre><code class="language-ruby">name = &quot;John&quot;
age = 30

# With interpolation
message = &quot;Hello, #{name}! You are #{age} years old.&quot;
# &quot;Hello, John! You are 30 years old.&quot;

# Without interpolation (concatenation)
message = &quot;Hello, &quot; + name + &quot;! You are &quot; + age.to_s + &quot; years old.&quot;
</code></pre>
<hr>
<h3>Interpolating Expressions</h3>
<pre><code class="language-ruby"># Variables
city = &quot;New York&quot;
&quot;I live in #{city}&quot;

# Method calls
&quot;Uppercase: #{name.upcase}&quot;
&quot;Length: #{name.length}&quot;

# Arithmetic
price = 100
&quot;Total: $#{price * 1.2}&quot;

# Conditionals
status = true
&quot;Status: #{status ? &#39;Active&#39; : &#39;Inactive&#39;}&quot;

# Array/Hash access
users = [&quot;John&quot;, &quot;Jane&quot;]
&quot;First user: #{users.first}&quot;

hash = { name: &quot;John&quot; }
&quot;Name: #{hash[:name]}&quot;
</code></pre>
<hr>
<h3>Complex Expressions</h3>
<pre><code class="language-ruby"># Multiple operations
numbers = [1, 2, 3, 4, 5]
&quot;Sum: #{numbers.sum}, Average: #{numbers.sum / numbers.size.to_f}&quot;

# Block iteration
items = [&quot;apple&quot;, &quot;banana&quot;]
&quot;Items: #{items.map(&amp;:capitalize).join(&#39;, &#39;)}&quot;

# Method chaining
text = &quot;hello world&quot;
&quot;Processed: #{text.split.map(&amp;:capitalize).join(&#39; &#39;)}&quot;
</code></pre>
<hr>
<h3>Rails Examples</h3>
<pre><code class="language-ruby"># Views (ERB)
&lt;h1&gt;Welcome, &lt;%= @user.name %&gt;!&lt;/h1&gt;
&lt;p&gt;You have &lt;%= @user.posts.count %&gt; posts&lt;/p&gt;

# Controllers
flash[:notice] = &quot;User #{@user.name} was successfully created&quot;
redirect_to root_path, alert: &quot;Invalid credentials for #{params[:email]}&quot;

# Models
def full_name
  &quot;#{first_name} #{last_name}&quot;
end

# Mailers
mail(
  to: user.email,
  subject: &quot;Welcome #{user.name} to our platform!&quot;
)

# ActiveRecord queries
User.where(&quot;age &gt; ? AND city = &#39;#{city}&#39;&quot;, 18)  # Careful with SQL injection!
# Better:
User.where(&quot;age &gt; ? AND city = ?&quot;, 18, city)
</code></pre>
<hr>
<h3>Nested Interpolation</h3>
<pre><code class="language-ruby">name = &quot;John&quot;
greeting = &quot;Hello&quot;

# Nested interpolation
&quot;#{greeting}, #{name}!&quot;  # &quot;Hello, John!&quot;

# Can nest expressions
users = [{ name: &quot;John&quot; }, { name: &quot;Jane&quot; }]
&quot;Users: #{users.map { |u| u[:name] }.join(&#39;, &#39;)}&quot;
# &quot;Users: John, Jane&quot;
</code></pre>
<hr>
<h3>Interpolation vs Concatenation</h3>
<pre><code class="language-ruby">name = &quot;John&quot;
age = 30

# Concatenation - multiple objects
message = &quot;Hello, &quot; + name + &quot;! Age: &quot; + age.to_s
# Need to call to_s on non-strings

# Interpolation - automatic conversion
message = &quot;Hello, #{name}! Age: #{age}&quot;
# Automatically converts to string

# Performance
require &#39;benchmark&#39;

n = 100_000

Benchmark.bm do |x|
  x.report(&quot;Concatenation:&quot;) do
    n.times { &quot;Hello &quot; + name + &quot;!&quot; }
  end
  
  x.report(&quot;Interpolation:&quot;) do
    n.times { &quot;Hello #{name}!&quot; }
  end
end

# Interpolation is generally faster
</code></pre>
<hr>
<h3>Escaping Interpolation</h3>
<pre><code class="language-ruby"># To show literal #{}
&quot;The syntax is: \#{variable}&quot;
# &quot;The syntax is: #{variable}&quot;

# In heredoc
message = &lt;&lt;-TEXT
  Use \#{variable} for interpolation
TEXT
</code></pre>
<hr>
<h3>Multiline Interpolation (Heredoc)</h3>
<pre><code class="language-ruby">name = &quot;John&quot;
items = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]

email = &lt;&lt;~EMAIL
  Hello #{name},
  
  Your order contains:
  #{items.map { |item| &quot;- #{item}&quot; }.join(&quot;\n  &quot;)}
  
  Total: #{items.count} items
  
  Thanks!
EMAIL

puts email
# Hello John,
#
# Your order contains:
# - apple
# - banana
# - cherry
#
# Total: 3 items
#
# Thanks!
</code></pre>
<hr>
<h3>Common Mistakes</h3>
<p><strong>1. Using single quotes:</strong></p>
<pre><code class="language-ruby">name = &quot;John&quot;

&#39;Hello, #{name}!&#39;  # &quot;Hello, #{name}!&quot; (literal, no interpolation)
&quot;Hello, #{name}!&quot;  # &quot;Hello, John!&quot; (interpolation works)
</code></pre>
<p><strong>2. Forgetting to convert to string:</strong></p>
<pre><code class="language-ruby"># Not needed with interpolation
&quot;Age: #{age}&quot;  # Automatic conversion

# Needed with concatenation
&quot;Age: &quot; + age.to_s  # Manual conversion
</code></pre>
<p><strong>3. SQL injection vulnerability:</strong></p>
<pre><code class="language-ruby"># DANGEROUS
city = params[:city]
User.where(&quot;city = &#39;#{city}&#39;&quot;)  # SQL injection risk!

# SAFE
User.where(&quot;city = ?&quot;, city)
# or
User.where(city: city)
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Use interpolation over concatenation:</strong></p>
<pre><code class="language-ruby"># Bad
&quot;Hello, &quot; + name + &quot;! You are &quot; + age.to_s + &quot; years old.&quot;

# Good
&quot;Hello, #{name}! You are #{age} years old.&quot;
</code></pre>
<p><strong>2. Keep interpolation simple:</strong></p>
<pre><code class="language-ruby"># Bad (too complex)
&quot;Result: #{array.select { |x| x &gt; 10 }.map(&amp;:to_s).join(&#39;, &#39;)}&quot;

# Good (extract to variable)
filtered = array.select { |x| x &gt; 10 }.map(&amp;:to_s).join(&#39;, &#39;)
&quot;Result: #{filtered}&quot;
</code></pre>
<p><strong>3. Use parentheses for clarity with instance variables:</strong></p>
<pre><code class="language-ruby"># Can be confusing
&quot;Name: #{@user.name}&quot;

# Clearer
&quot;Name: #{(@user.name)}&quot;
</code></pre>
<hr>
<h3>Alternative String Formatting</h3>
<p><strong>1. Format/sprintf:</strong></p>
<pre><code class="language-ruby"># Using %
name = &quot;John&quot;
age = 30
&quot;%s is %d years old&quot; % [name, age]

# Using sprintf
sprintf(&quot;%-10s | %03d&quot;, name, age)
</code></pre>
<p><strong>2. String#% operator:</strong></p>
<pre><code class="language-ruby">&quot;Hello, %s! Age: %d&quot; % [&quot;John&quot;, 30]
&quot;Hello, %{name}! Age: %{age}&quot; % { name: &quot;John&quot;, age: 30 }
</code></pre>
<hr>
<h3>Rails I18n with Interpolation</h3>
<pre><code class="language-ruby"># en.yml
en:
  greetings:
    welcome: &quot;Welcome, %{name}!&quot;
    message: &quot;You have %{count} new messages&quot;

# In code
t(&#39;greetings.welcome&#39;, name: current_user.name)
# &quot;Welcome, John!&quot;

t(&#39;greetings.message&#39;, count: @messages.count)
# &quot;You have 5 new messages&quot;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Use <code>#{expression}</code> syntax</strong> with double quotes</li>
<li><strong>Automatic type conversion</strong> to string</li>
<li><strong>Faster and cleaner</strong> than concatenation</li>
<li><strong>Works with any Ruby expression</strong></li>
<li><strong>Only in double quotes</strong>, not single quotes</li>
<li><strong>Be careful with SQL</strong> - use parameterized queries</li>
<li><strong>Keep expressions simple</strong> for readability</li>
</ol>
<h1>Ruby Memory Management Interview Questions</h1>
<h2>Question 25: How does garbage collection work in Ruby?</h2>
<h3>Answer</h3>
<p>Ruby uses <strong>automatic garbage collection (GC)</strong> to manage memory. The garbage collector automatically reclaims memory from objects that are no longer reachable or needed by the program.</p>
<hr>
<h3>How Ruby GC Works</h3>
<p><strong>Current GC Algorithm: Generational GC (Ruby 2.1+)</strong></p>
<p>Ruby uses a <strong>mark-and-sweep</strong> garbage collector with <strong>generational</strong> optimization.</p>
<hr>
<h3>Mark and Sweep Algorithm</h3>
<p><strong>Two Phases:</strong></p>
<ol>
<li><strong>Mark Phase</strong>: Identifies which objects are still in use</li>
<li><strong>Sweep Phase</strong>: Reclaims memory from unmarked (unreachable) objects</li>
</ol>
<pre><code class="language-ruby"># Example
def create_objects
  user = User.new  # Object created in memory
  post = Post.new  # Another object created
  
  user.posts &lt;&lt; post  # Reference maintained
end  # user and post go out of scope

# After method ends:
# - If no external references exist, objects become eligible for GC
# - GC marks unreachable objects
# - GC sweeps (deallocates) their memory
</code></pre>
<hr>
<h3>Generational GC</h3>
<p>Ruby divides objects into generations based on age:</p>
<p><strong>1. Young Generation (Generation 0):</strong></p>
<ul>
<li>Newly created objects</li>
<li>Collected frequently</li>
<li>Most objects die young (short-lived)</li>
</ul>
<p><strong>2. Old Generation (Generation 1+):</strong></p>
<ul>
<li>Objects that survive multiple GC cycles</li>
<li>Collected less frequently</li>
<li>Long-lived objects</li>
</ul>
<pre><code class="language-ruby"># Young objects (die quickly)
def process_request
  temp_data = fetch_data  # Dies after method ends
  process(temp_data)
end

# Old objects (survive long)
class Application
  @@cache = {}  # Lives for entire application lifetime
end
</code></pre>
<hr>
<h3>GC Triggers</h3>
<p>Garbage collection runs when:</p>
<ol>
<li><strong>Memory threshold reached</strong>: Heap is full</li>
<li><strong>Manual trigger</strong>: <code>GC.start</code> called</li>
<li><strong>Object allocation</strong>: Too many objects created</li>
<li><strong>Heap growth</strong>: Memory usage increases</li>
</ol>
<pre><code class="language-ruby"># Manual GC trigger
GC.start  # Forces garbage collection

# Check GC stats
GC.stat
# {
#   :count =&gt; 45,
#   :heap_allocated_pages =&gt; 153,
#   :heap_live_slots =&gt; 62458,
#   :heap_free_slots =&gt; 62,
#   :total_allocated_objects =&gt; 1234567,
#   ...
# }

# Disable/enable GC
GC.disable  # Disable automatic GC
# ... do work ...
GC.enable   # Re-enable automatic GC
</code></pre>
<hr>
<h3>Object Lifecycle</h3>
<pre><code class="language-ruby"># 1. Object created (allocated in heap)
user = User.new

# 2. Object in use (reachable)
puts user.name

# 3. Object becomes unreachable
user = nil  # No references left

# 4. GC marks as garbage

# 5. GC sweeps (memory reclaimed)
</code></pre>
<hr>
<h3>Reachability</h3>
<p>An object is <strong>reachable</strong> if:</p>
<ul>
<li>Referenced by a variable in scope</li>
<li>Referenced by a constant</li>
<li>Referenced by another reachable object</li>
<li>In the call stack</li>
</ul>
<pre><code class="language-ruby">class User
  attr_accessor :name
end

# Reachable objects
$global_user = User.new  # Global variable - always reachable
CONSTANT_USER = User.new  # Constant - always reachable

class App
  @@class_var = User.new  # Class variable - reachable while class exists
  
  def initialize
    @instance_var = User.new  # Reachable while instance exists
  end
end

# Unreachable object
def create_temp
  temp = User.new  # Becomes unreachable after method ends
end
</code></pre>
<hr>
<h3>GC Tuning Environment Variables</h3>
<pre><code class="language-ruby"># Set via environment variables or GC.tune

# RUBY_GC_HEAP_INIT_SLOTS
# Initial number of heap slots
ENV[&#39;RUBY_GC_HEAP_INIT_SLOTS&#39;] = &#39;100000&#39;

# RUBY_GC_HEAP_GROWTH_FACTOR
# How much to grow heap when full
ENV[&#39;RUBY_GC_HEAP_GROWTH_FACTOR&#39;] = &#39;1.1&#39;

# RUBY_GC_HEAP_GROWTH_MAX_SLOTS
# Maximum slots to add at once
ENV[&#39;RUBY_GC_HEAP_GROWTH_MAX_SLOTS&#39;] = &#39;100000&#39;

# RUBY_GC_MALLOC_LIMIT
# Trigger GC after this much malloc
ENV[&#39;RUBY_GC_MALLOC_LIMIT&#39;] = &#39;16000000&#39;
</code></pre>
<hr>
<h3>Monitoring GC</h3>
<pre><code class="language-ruby"># Enable GC profiling
GC::Profiler.enable

# Do work
10000.times { &quot;string&quot; * 100 }

# Get report
puts GC::Profiler.report

# Sample output:
# GC 10 invokes.
# Index    Invoke Time(sec)       Use Size(byte)     Total Size(byte)
#     1               0.003              1560000              2097152
#     2               0.006              1560000              2097152
</code></pre>
<hr>
<h3>ObjectSpace</h3>
<p>Inspect all objects in memory:</p>
<pre><code class="language-ruby">require &#39;objspace&#39;

# Count objects by class
ObjectSpace.count_objects
# {:TOTAL=&gt;52341, :FREE=&gt;124, :T_OBJECT=&gt;1234, :T_CLASS=&gt;567, ...}

# Find all instances of a class
users = []
ObjectSpace.each_object(User) do |user|
  users &lt;&lt; user
end

puts &quot;Total User objects in memory: #{users.size}&quot;

# Memory size of an object
user = User.new
ObjectSpace.memsize_of(user)  # bytes
</code></pre>
<hr>
<h3>Memory Leaks in Ruby</h3>
<p>Common causes:</p>
<p><strong>1. Unbounded caches:</strong></p>
<pre><code class="language-ruby"># BAD - cache grows forever
class Cache
  @@data = {}
  
  def self.store(key, value)
    @@data[key] = value  # Never removed!
  end
end

# GOOD - use TTL or size limit
class Cache
  def initialize(max_size: 1000)
    @data = {}
    @max_size = max_size
  end
  
  def store(key, value)
    @data[key] = value
    cleanup if @data.size &gt; @max_size
  end
  
  def cleanup
    @data.shift  # Remove oldest
  end
end
</code></pre>
<p><strong>2. Global references:</strong></p>
<pre><code class="language-ruby"># BAD - objects never garbage collected
$global_array = []

def process
  $global_array &lt;&lt; User.new  # Accumulates forever
end

# GOOD - use local scope
def process
  local_array = []
  local_array &lt;&lt; User.new  # Can be GC&#39;d after method ends
end
</code></pre>
<p><strong>3. Event listeners not removed:</strong></p>
<pre><code class="language-ruby"># BAD
class Publisher
  @@listeners = []
  
  def self.subscribe(listener)
    @@listeners &lt;&lt; listener  # Listener never removed
  end
end

# GOOD
class Publisher
  def initialize
    @listeners = []
  end
  
  def subscribe(listener)
    @listeners &lt;&lt; listener
  end
  
  def unsubscribe(listener)
    @listeners.delete(listener)
  end
end
</code></pre>
<hr>
<h3>WeakRef - Weak References</h3>
<p>Weak references don&#39;t prevent garbage collection:</p>
<pre><code class="language-ruby">require &#39;weakref&#39;

user = User.new
weak_ref = WeakRef.new(user)

weak_ref.name  # Works

user = nil  # Original reference removed
GC.start

weak_ref.name  # WeakRef::RefError - object was GC&#39;d
</code></pre>
<hr>
<h3>Rails GC Optimization</h3>
<pre><code class="language-ruby"># config/puma.rb
before_fork do
  # Reduce memory before forking
  3.times { GC.start }
  GC.compact if GC.respond_to?(:compact)
end

# Unicorn configuration
before_fork do |server, worker|
  GC.respond_to?(:copy_on_write_friendly=) &amp;&amp;
    GC.copy_on_write_friendly = true
end
</code></pre>
<hr>
<h3>GC.compact (Ruby 2.7+)</h3>
<p>Compacts the heap to reduce fragmentation:</p>
<pre><code class="language-ruby"># Before compaction
GC.stat(:heap_available_slots)  # 10000

# Compact heap
GC.compact

# After compaction
GC.stat(:heap_available_slots)  # 8000 (reclaimed fragmented space)
</code></pre>
<hr>
<h3>Benchmark Memory Usage</h3>
<pre><code class="language-ruby">require &#39;benchmark/memory&#39;

Benchmark.memory do |x|
  x.report(&quot;Creating arrays&quot;) do
    1000.times { Array.new(1000) }
  end
  
  x.report(&quot;Creating hashes&quot;) do
    1000.times { Hash.new }
  end
  
  x.compare!
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li>Ruby uses <strong>automatic mark-and-sweep GC</strong></li>
<li><strong>Generational GC</strong> optimizes for young/old objects</li>
<li>Objects become <strong>unreachable</strong> when no references exist</li>
<li><strong>Manual GC control</strong>: <code>GC.start</code>, <code>GC.disable</code>, <code>GC.enable</code></li>
<li><strong>Memory leaks</strong> happen with unbounded caches and global refs</li>
<li><strong>Monitor GC</strong> with <code>GC.stat</code> and <code>GC::Profiler</code></li>
<li><strong>WeakRef</strong> for cache-like references</li>
<li><strong>GC tuning</strong> via environment variables for production</li>
</ol>
<hr>
<h2>Question 26: How does memory management work in Ruby?</h2>
<h3>Answer</h3>
<p>Ruby&#39;s memory management involves <strong>automatic allocation</strong> of memory for objects and <strong>garbage collection</strong> to reclaim unused memory. It uses a heap-based memory system with object pools.</p>
<hr>
<h3>Memory Layout</h3>
<p>Ruby divides memory into several areas:</p>
<p><strong>1. Heap:</strong></p>
<ul>
<li>Stores all Ruby objects</li>
<li>Divided into pages</li>
<li>Each page contains slots for objects</li>
</ul>
<p><strong>2. Stack:</strong></p>
<ul>
<li>Stores local variables and method calls</li>
<li>Fixed size per thread</li>
<li>Automatically cleaned up</li>
</ul>
<p><strong>3. Global Area:</strong></p>
<ul>
<li>Constants</li>
<li>Global variables</li>
<li>Class definitions</li>
</ul>
<hr>
<h3>Object Allocation</h3>
<pre><code class="language-ruby"># Object created on heap
user = User.new

# Memory allocated:
# 1. Object header (flags, class pointer)
# 2. Instance variables storage
# 3. Reference counting information

# Check object size
require &#39;objspace&#39;
ObjectSpace.memsize_of(user)  # bytes
</code></pre>
<hr>
<h3>Heap Structure</h3>
<pre><code class="language-ruby"># Heap organized as:
# Heap -&gt; Pages -&gt; Slots -&gt; Objects

# View heap stats
GC.stat
# {
#   :heap_allocated_pages =&gt; 150,     # Total pages
#   :heap_eden_pages =&gt; 147,          # Pages with objects
#   :heap_tomb_pages =&gt; 3,            # Empty pages
#   :heap_available_slots =&gt; 61440,   # Available slots
#   :heap_live_slots =&gt; 58234,        # Occupied slots
#   :heap_free_slots =&gt; 3206,         # Free slots
# }
</code></pre>
<hr>
<h3>Memory Allocation Process</h3>
<p><strong>When creating an object:</strong></p>
<ol>
<li>Ruby checks free slot list</li>
<li>If slot available → allocate there</li>
<li>If no slots → trigger minor GC</li>
<li>If still no space → allocate new page</li>
<li>If heap full → trigger major GC</li>
</ol>
<pre><code class="language-ruby"># Example allocation
class User
  attr_accessor :name, :email
  
  def initialize(name, email)
    @name = name    # Allocates string
    @email = email  # Allocates string
  end
end

# Memory allocated:
# - User object (40 bytes)
# - @name string (40 + string data)
# - @email string (40 + string data)
# Total: ~120+ bytes

user = User.new(&quot;John&quot;, &quot;john@example.com&quot;)
</code></pre>
<hr>
<h3>Copy-on-Write (CoW)</h3>
<p>Ruby uses CoW for forked processes:</p>
<pre><code class="language-ruby"># Parent process
data = &quot;x&quot; * 1_000_000  # 1MB string

# Fork creates child process
pid = fork do
  # Child shares memory with parent (CoW)
  puts data.length  # Doesn&#39;t copy memory
  
  # Modifying triggers copy
  data.upcase!  # Now child gets own copy
end

Process.wait(pid)
</code></pre>
<p><strong>Rails/Puma Example:</strong></p>
<pre><code class="language-ruby"># config/puma.rb
workers 4  # 4 worker processes

# All workers share memory via CoW
# Only modified memory is copied
preload_app!  # Load app before fork (saves memory)
</code></pre>
<hr>
<h3>Memory Pools</h3>
<p>Ruby uses object pools for small objects:</p>
<pre><code class="language-ruby"># Ruby maintains pools for:
# - Small strings
# - Small arrays
# - Small hashes
# - Integers (FIXNUM - no heap allocation!)

# FIXNUM (no heap allocation)
a = 5  # Immediate value (tagged pointer)

# BIGNUM (heap allocation)
b = 10 ** 100  # Too large for immediate value

# Check if immediate
5.object_id    # Odd number (immediate)
&quot;test&quot;.object_id  # Even number (heap allocated)
</code></pre>
<hr>
<h3>String Memory Optimization</h3>
<pre><code class="language-ruby"># Frozen strings (Ruby 2.3+)
# frozen_string_literal: true

str1 = &quot;hello&quot;
str2 = &quot;hello&quot;

# With frozen string literal
str1.object_id == str2.object_id  # true (same object)

# Without frozen string literal
str1.object_id == str2.object_id  # false (different objects)

# Manual freeze
CONSTANT = &quot;frozen&quot;.freeze
</code></pre>
<hr>
<h3>Shared Strings (Ruby 2.1+)</h3>
<pre><code class="language-ruby"># Strings can share memory
str = &quot;hello world&quot;
substr = str[0..4]  # Shares memory with str (initially)

# Modifying breaks sharing
substr.upcase!  # Now gets own copy
</code></pre>
<hr>
<h3>Memory Profiling Tools</h3>
<p><strong>1. memory_profiler gem:</strong></p>
<pre><code class="language-ruby">require &#39;memory_profiler&#39;

report = MemoryProfiler.report do
  10000.times { User.new(&quot;John&quot;, &quot;john@example.com&quot;) }
end

report.pretty_print
# Total allocated: 1.5 MB
# Total retained: 50 KB
# Allocated objects by class:
#   String: 20000
#   User: 10000
</code></pre>
<p><strong>2. derailed_benchmarks (Rails):</strong></p>
<pre><code class="language-bash"># Add to Gemfile
gem &#39;derailed_benchmarks&#39;, group: :development

# Run memory tests
bundle exec derailed bundle:mem
bundle exec derailed bundle:objects
</code></pre>
<p><strong>3. ObjectSpace:</strong></p>
<pre><code class="language-ruby">require &#39;objspace&#39;

# Count objects
ObjectSpace.count_objects[:T_STRING]  # Number of strings

# Memory dump
require &#39;objspace&#39;
GC.start
File.open(&#39;heap.json&#39;, &#39;w&#39;) do |f|
  ObjectSpace.dump_all(output: f)
end
</code></pre>
<hr>
<h3>Memory Bloat in Rails</h3>
<p><strong>Common causes:</strong></p>
<p><strong>1. N+1 Queries:</strong></p>
<pre><code class="language-ruby"># BAD - loads each user&#39;s posts separately
users.each do |user|
  user.posts.count  # Separate query per user
end

# GOOD - eager loading
users.includes(:posts).each do |user|
  user.posts.count  # Already loaded
end
</code></pre>
<p><strong>2. Large arrays in memory:</strong></p>
<pre><code class="language-ruby"># BAD - loads all users at once
User.all.each { |user| process(user) }

# GOOD - batch processing
User.find_each(batch_size: 1000) do |user|
  process(user)
end
</code></pre>
<p><strong>3. Memoization leaks:</strong></p>
<pre><code class="language-ruby"># BAD - caches forever
class User
  def expensive_calculation
    @result ||= complex_calculation
  end
end

# GOOD - time-limited cache
class User
  def expensive_calculation(ttl: 1.hour)
    @result = nil if @cached_at &amp;&amp; @cached_at &lt; ttl.ago
    @result ||= begin
      @cached_at = Time.current
      complex_calculation
    end
  end
end
</code></pre>
<hr>
<h3>Reducing Memory Usage</h3>
<p><strong>1. Use symbols instead of strings:</strong></p>
<pre><code class="language-ruby"># BAD
1000.times { hash[&quot;key&quot;] = &quot;value&quot; }

# GOOD
1000.times { hash[:key] = &quot;value&quot; }
</code></pre>
<p><strong>2. Avoid string concatenation:</strong></p>
<pre><code class="language-ruby"># BAD
result = &quot;&quot;
1000.times { result += &quot;x&quot; }  # Creates 1000 strings

# GOOD
result = []
1000.times { result &lt;&lt; &quot;x&quot; }
result.join  # Creates 1 string
</code></pre>
<p><strong>3. Use streaming for large files:</strong></p>
<pre><code class="language-ruby"># BAD - loads entire file in memory
content = File.read(&#39;large_file.csv&#39;)
content.each_line { |line| process(line) }

# GOOD - streams line by line
File.foreach(&#39;large_file.csv&#39;) do |line|
  process(line)
end
</code></pre>
<p><strong>4. Clear large data structures:</strong></p>
<pre><code class="language-ruby">large_array = (1..1_000_000).to_a
# Process array
large_array = nil  # Help GC
</code></pre>
<hr>
<h3>Memory Monitoring in Production</h3>
<pre><code class="language-ruby"># config/initializers/memory_monitor.rb
if Rails.env.production?
  Thread.new do
    loop do
      sleep 60  # Check every minute
      
      memory_mb = `ps -o rss= -p #{Process.pid}`.to_i / 1024
      
      if memory_mb &gt; 1000  # Alert if &gt; 1GB
        Rails.logger.warn &quot;High memory usage: #{memory_mb} MB&quot;
      end
    end
  end
end
</code></pre>
<hr>
<h3>jemalloc (Alternative Memory Allocator)</h3>
<pre><code class="language-bash"># Install jemalloc
apt-get install libjemalloc-dev

# Use with Ruby
LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so ruby app.rb

# Or in Dockerfile
ENV LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.2
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Heap-based</strong> memory system with pages and slots</li>
<li><strong>Automatic allocation</strong> and garbage collection</li>
<li><strong>Copy-on-Write</strong> for forked processes</li>
<li><strong>String optimization</strong> with frozen literals</li>
<li><strong>Memory pools</strong> for small objects</li>
<li><strong>Profile memory</strong> with memory_profiler</li>
<li><strong>Reduce memory</strong> with eager loading, streaming, batching</li>
<li><strong>Monitor production</strong> memory usage</li>
</ol>
<hr>
<h2>Question 27: What is the difference between frozen and unfrozen objects?</h2>
<h3>Answer</h3>
<p><strong>Frozen objects</strong> are immutable - their state cannot be changed. <strong>Unfrozen objects</strong> are mutable and can be modified.</p>
<hr>
<h3>Freezing Objects</h3>
<pre><code class="language-ruby"># Unfrozen (mutable)
str = &quot;hello&quot;
str.upcase!  # Works
str  # &quot;HELLO&quot;

# Frozen (immutable)
str = &quot;hello&quot;.freeze
str.upcase!  # FrozenError: can&#39;t modify frozen String

# Check if frozen
str.frozen?  # true
</code></pre>
<hr>
<h3>What Gets Frozen</h3>
<pre><code class="language-ruby">user = { name: &quot;John&quot;, age: 30 }
user.freeze

# Cannot modify
user[:name] = &quot;Jane&quot;  # FrozenError
user[:email] = &quot;test&quot;  # FrozenError
user.delete(:age)     # FrozenError

# Check frozen state
user.frozen?  # true
</code></pre>
<hr>
<h3>Shallow vs Deep Freeze</h3>
<p><strong>Shallow freeze</strong> (default):</p>
<pre><code class="language-ruby">user = { name: &quot;John&quot;, address: { city: &quot;NYC&quot; } }
user.freeze

user[:name] = &quot;Jane&quot;  # FrozenError
user[:address][:city] = &quot;LA&quot;  # Works! Nested object not frozen
</code></pre>
<p><strong>Deep freeze</strong> (manual):</p>
<pre><code class="language-ruby">def deep_freeze(obj)
  obj.freeze
  obj.each_value { |v| deep_freeze(v) if v.is_a?(Hash) }
  obj
end

user = { name: &quot;John&quot;, address: { city: &quot;NYC&quot; } }
deep_freeze(user)

user[:name] = &quot;Jane&quot;  # FrozenError
user[:address][:city] = &quot;LA&quot;  # FrozenError
</code></pre>
<hr>
<h3>Frozen String Literals</h3>
<p><strong>Ruby 2.3+ magic comment:</strong></p>
<pre><code class="language-ruby"># frozen_string_literal: true

str1 = &quot;hello&quot;
str2 = &quot;hello&quot;

str1.object_id == str2.object_id  # true (same object)
str1.frozen?  # true

str1.upcase!  # FrozenError
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>Memory savings (strings are reused)</li>
<li>Better performance</li>
<li>Thread-safe strings</li>
<li>Prevents accidental mutations</li>
</ul>
<hr>
<h3>Unfreezing Objects</h3>
<p><strong>You cannot unfreeze an object!</strong></p>
<pre><code class="language-ruby">str = &quot;hello&quot;.freeze
str.frozen?  # true

# No unfreeze method exists
# Must create new object
new_str = str.dup
new_str.frozen?  # false
</code></pre>
<hr>
<h3>Use Cases for Frozen Objects</h3>
<p><strong>1. Constants:</strong></p>
<pre><code class="language-ruby">API_KEY = &quot;secret123&quot;.freeze
ALLOWED_ROLES = [:admin, :user, :guest].freeze

# Prevents accidental modification
API_KEY.upcase!  # FrozenError
ALLOWED_ROLES &lt;&lt; :moderator  # FrozenError
</code></pre>
<p><strong>2. Hash keys:</strong></p>
<pre><code class="language-ruby"># Frozen strings as keys (memory efficient)
cache = {}
cache[&quot;user:1&quot;.freeze] = user_data
</code></pre>
<p><strong>3. Configuration:</strong></p>
<pre><code class="language-ruby">class Config
  SETTINGS = {
    timeout: 30,
    retries: 3,
    enabled: true
  }.freeze
  
  def self.get(key)
    SETTINGS[key]
  end
end

Config::SETTINGS[:timeout] = 60  # FrozenError
</code></pre>
<p><strong>4. Thread safety:</strong></p>
<pre><code class="language-ruby"># Frozen objects are thread-safe
CACHE = {}.freeze

threads = 10.times.map do
  Thread.new do
    # Safe to read from frozen object
    CACHE[:key]
  end
end
</code></pre>
<hr>
<h3>Rails Examples</h3>
<p><strong>1. ActiveModel::FrozenError:</strong></p>
<pre><code class="language-ruby">user = User.first
user.readonly!  # Mark as readonly
user.save  # ActiveRecord::ReadOnlyRecord

# Similar to freezing
</code></pre>
<p><strong>2. Frozen constants:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  ROLES = [:admin, :user, :guest].freeze
  
  validates :role, inclusion: { in: ROLES }
end
</code></pre>
<p><strong>3. I18n:</strong></p>
<pre><code class="language-ruby"># Translations are frozen
I18n.t(&#39;welcome.message&#39;)  # Frozen string
</code></pre>
<hr>
<h3>Performance Impact</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

n = 1_000_000

Benchmark.bm do |x|
  x.report(&quot;Unfrozen:&quot;) do
    n.times { &quot;hello&quot; }
  end
  
  x.report(&quot;Frozen:&quot;) do
    n.times { &quot;hello&quot;.freeze }
  end
  
  x.report(&quot;Frozen literal:&quot;) do
    # frozen_string_literal: true
    n.times { &quot;hello&quot; }
  end
end

# Frozen strings are faster (reused)
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Frozen</th>
<th>Unfrozen</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mutability</strong></td>
<td>Immutable</td>
<td>Mutable</td>
</tr>
<tr>
<td><strong>Modification</strong></td>
<td>Raises FrozenError</td>
<td>Allowed</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>Can be reused</td>
<td>New object each time</td>
</tr>
<tr>
<td><strong>Thread-safe</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Faster (for literals)</td>
<td>Slower</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Constants, keys</td>
<td>Normal variables</td>
</tr>
</tbody></table>
<hr>
<h3>Checking Frozen State</h3>
<pre><code class="language-ruby">obj = &quot;hello&quot;

# Check if frozen
obj.frozen?  # false

# Freeze it
obj.freeze

# Check again
obj.frozen?  # true

# Try to modify
obj.upcase!  # FrozenError: can&#39;t modify frozen String
</code></pre>
<hr>
<h3>Frozen Arrays and Hashes</h3>
<pre><code class="language-ruby"># Frozen array
arr = [1, 2, 3].freeze
arr &lt;&lt; 4  # FrozenError
arr[0] = 10  # FrozenError

# Frozen hash
hash = { a: 1, b: 2 }.freeze
hash[:c] = 3  # FrozenError
hash.delete(:a)  # FrozenError

# But internal objects can be modified (shallow freeze)
arr = [[1, 2], [3, 4]].freeze
arr[0] &lt;&lt; 5  # Works! [1, 2, 5]
arr &lt;&lt; [6, 7]  # FrozenError
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Frozen objects are immutable</strong> - cannot be modified</li>
<li><strong>Use <code>.freeze</code> to freeze</strong> objects</li>
<li><strong>Shallow freeze by default</strong> - nested objects not frozen</li>
<li><strong>Cannot unfreeze</strong> - must duplicate</li>
<li><strong>Frozen string literals</strong> save memory and improve performance</li>
<li><strong>Thread-safe</strong> - frozen objects safe in concurrent code</li>
<li><strong>Use for constants, keys, config</strong> where immutability is desired</li>
<li><strong>FrozenError raised</strong> when trying to modify frozen objects</li>
</ol>
<hr>
<h2>Question 28: What is the difference between <code>dup</code> and <code>clone</code>?</h2>
<h3>Answer</h3>
<p>Both <code>dup</code> and <code>clone</code> create shallow copies of objects, but they differ in how they handle <strong>frozen state</strong> and <strong>singleton methods</strong>.</p>
<hr>
<h3>Basic Difference</h3>
<pre><code class="language-ruby">str = &quot;hello&quot;

# dup - creates unfrozen copy
dup_str = str.dup
dup_str.frozen?  # false

# clone - preserves frozen state
clone_str = str.clone
clone_str.frozen?  # false (original not frozen)

# With frozen object
frozen_str = &quot;hello&quot;.freeze

dup_frozen = frozen_str.dup
dup_frozen.frozen?  # false (unfrozen!)

clone_frozen = frozen_str.clone
clone_frozen.frozen?  # true (preserves frozen state)
</code></pre>
<hr>
<h3>Key Differences Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>dup</code></th>
<th><code>clone</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Frozen state</strong></td>
<td>Not preserved</td>
<td>Preserved</td>
</tr>
<tr>
<td><strong>Singleton methods</strong></td>
<td>Not copied</td>
<td>Copied</td>
</tr>
<tr>
<td><strong>Tainted state</strong></td>
<td>Preserved</td>
<td>Preserved</td>
</tr>
<tr>
<td><strong>Instance variables</strong></td>
<td>Copied</td>
<td>Copied</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Fresh mutable copy</td>
<td>Exact replica</td>
</tr>
</tbody></table>
<hr>
<h3>Frozen State Handling</h3>
<pre><code class="language-ruby">original = &quot;hello&quot;.freeze
original.frozen?  # true

# dup - returns unfrozen copy
copy1 = original.dup
copy1.frozen?  # false
copy1.upcase!  # Works

# clone - returns frozen copy
copy2 = original.clone
copy2.frozen?  # true
copy2.upcase!  # FrozenError
</code></pre>
<hr>
<h3>Singleton Methods</h3>
<pre><code class="language-ruby">str = &quot;hello&quot;

# Add singleton method to original
def str.shout
  self.upcase + &quot;!!!&quot;
end

str.shout  # &quot;HELLO!!!&quot;

# dup - doesn&#39;t copy singleton methods
dup_str = str.dup
dup_str.shout  # NoMethodError

# clone - copies singleton methods
clone_str = str.clone
clone_str.shout  # &quot;HELLO!!!&quot;
</code></pre>
<hr>
<h3>Shallow Copy Behavior</h3>
<p>Both <code>dup</code> and <code>clone</code> create shallow copies:</p>
<pre><code class="language-ruby">original = { name: &quot;John&quot;, tags: [&quot;ruby&quot;, &quot;rails&quot;] }

# dup
copy1 = original.dup
copy1[:tags] &lt;&lt; &quot;javascript&quot;
original[:tags]  # [&quot;ruby&quot;, &quot;rails&quot;, &quot;javascript&quot;] - shared!

# clone
copy2 = original.clone
copy2[:tags] &lt;&lt; &quot;python&quot;
original[:tags]  # [&quot;ruby&quot;, &quot;rails&quot;, &quot;javascript&quot;, &quot;python&quot;] - shared!

# Both share nested objects
copy1[:tags].object_id == original[:tags].object_id  # true
copy2[:tags].object_id == original[:tags].object_id  # true
</code></pre>
<hr>
<h3>Deep Copy Alternative</h3>
<p>Neither <code>dup</code> nor <code>clone</code> creates deep copies. For deep copies:</p>
<pre><code class="language-ruby"># Using Marshal (most common)
original = { name: &quot;John&quot;, tags: [&quot;ruby&quot;, &quot;rails&quot;] }
deep_copy = Marshal.load(Marshal.dump(original))

deep_copy[:tags] &lt;&lt; &quot;javascript&quot;
original[:tags]  # [&quot;ruby&quot;, &quot;rails&quot;] - not affected!

# Custom deep copy
def deep_copy(obj)
  case obj
  when Hash
    obj.transform_values { |v| deep_copy(v) }
  when Array
    obj.map { |v| deep_copy(v) }
  else
    obj.dup rescue obj
  end
end

original = { name: &quot;John&quot;, tags: [&quot;ruby&quot;, &quot;rails&quot;] }
copy = deep_copy(original)
copy[:tags] &lt;&lt; &quot;javascript&quot;
original[:tags]  # [&quot;ruby&quot;, &quot;rails&quot;]
</code></pre>
<hr>
<h3>Instance Variables</h3>
<p>Both copy instance variables:</p>
<pre><code class="language-ruby">class User
  attr_accessor :name, :email
  
  def initialize(name, email)
    @name = name
    @email = email
  end
end

original = User.new(&quot;John&quot;, &quot;john@example.com&quot;)

# dup - copies instance variables
dup_user = original.dup
dup_user.name  # &quot;John&quot;
dup_user.email  # &quot;john@example.com&quot;

# clone - also copies instance variables
clone_user = original.clone
clone_user.name  # &quot;John&quot;
clone_user.email  # &quot;john@example.com&quot;

# But they&#39;re separate objects
dup_user.name = &quot;Jane&quot;
original.name  # &quot;John&quot; (not affected)
</code></pre>
<hr>
<h3>Practical Examples</h3>
<p><strong>Example 1: Modifying copies</strong></p>
<pre><code class="language-ruby">original = [1, 2, 3].freeze

# Need mutable copy
copy = original.dup  # Use dup to get unfrozen copy
copy &lt;&lt; 4  # Works
copy  # [1, 2, 3, 4]

original  # [1, 2, 3] (unchanged)
</code></pre>
<p><strong>Example 2: Preserving special properties</strong></p>
<pre><code class="language-ruby">original = &quot;secret&quot;
def original.encrypted?
  true
end

# Need exact replica with methods
replica = original.clone  # Use clone
replica.encrypted?  # true (method copied)

# Regular copy without methods
regular_copy = original.dup
regular_copy.encrypted?  # NoMethodError
</code></pre>
<p><strong>Example 3: Rails model duplication</strong></p>
<pre><code class="language-ruby"># ActiveRecord #dup
user = User.find(1)
new_user = user.dup

# Creates new record with same attributes
new_user.id  # nil (new record)
new_user.name  # Same as original
new_user.save  # Creates new database record
</code></pre>
<hr>
<h3>Rails-specific Behavior</h3>
<p><strong>ActiveRecord models:</strong></p>
<pre><code class="language-ruby">user = User.create(name: &quot;John&quot;, email: &quot;john@example.com&quot;)

# dup - creates new record
new_user = user.dup
new_user.id  # nil
new_user.new_record?  # true
new_user.save  # Creates new database record

# clone - deprecated in Rails, use dup
</code></pre>
<hr>
<h3>Initialize_copy Hook</h3>
<p>Customize duplication behavior:</p>
<pre><code class="language-ruby">class User
  attr_accessor :name, :copied_at
  
  def initialize(name)
    @name = name
  end
  
  def initialize_copy(original)
    super
    @copied_at = Time.now
    @name = &quot;Copy of #{original.name}&quot;
  end
end

original = User.new(&quot;John&quot;)
copy = original.dup

copy.name  # &quot;Copy of John&quot;
copy.copied_at  # Current time
</code></pre>
<hr>
<h3>When to Use Which</h3>
<p><strong>Use <code>dup</code> when:</strong></p>
<ul>
<li>You need a mutable copy</li>
<li>You want to modify the copy</li>
<li>You don&#39;t care about singleton methods</li>
<li>Working with ActiveRecord models</li>
</ul>
<p><strong>Use <code>clone</code> when:</strong></p>
<ul>
<li>You need an exact replica</li>
<li>You want to preserve frozen state</li>
<li>You need singleton methods copied</li>
<li>You want an identical object</li>
</ul>
<pre><code class="language-ruby"># dup - for working copies
frozen_config = { timeout: 30 }.freeze
working_config = frozen_config.dup
working_config[:timeout] = 60  # Works

# clone - for exact replicas
template = &quot;Hello {{name}}&quot;
def template.variables
  scan(/{{(\w+)}}/).flatten
end

replica = template.clone
replica.variables  # Works (method preserved)
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

str = &quot;hello&quot; * 1000
n = 100_000

Benchmark.bm do |x|
  x.report(&quot;dup:&quot;) do
    n.times { str.dup }
  end
  
  x.report(&quot;clone:&quot;) do
    n.times { str.clone }
  end
end

# Performance is nearly identical
# Use based on behavior needed, not performance
</code></pre>
<hr>
<h3>Common Mistakes</h3>
<p><strong>1. Expecting deep copy:</strong></p>
<pre><code class="language-ruby">original = { data: [1, 2, 3] }
copy = original.dup

copy[:data] &lt;&lt; 4
original[:data]  # [1, 2, 3, 4] - oops! Shared reference
</code></pre>
<p><strong>2. Not considering frozen state:</strong></p>
<pre><code class="language-ruby">frozen = &quot;immutable&quot;.freeze
copy = frozen.clone  # Still frozen!

copy.upcase!  # FrozenError - unexpected
</code></pre>
<p><strong>3. Losing singleton methods:</strong></p>
<pre><code class="language-ruby">obj = Object.new
def obj.special_method
  &quot;special&quot;
end

copy = obj.dup
copy.special_method  # NoMethodError - method lost
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Both create shallow copies</strong> of objects</li>
<li><strong><code>dup</code></strong>: Creates unfrozen copy, doesn&#39;t copy singleton methods</li>
<li><strong><code>clone</code></strong>: Preserves frozen state and singleton methods</li>
<li><strong>Neither creates deep copies</strong> - nested objects are shared</li>
<li><strong>Use <code>dup</code> for mutable copies</strong>, <code>clone</code> for exact replicas</li>
<li><strong>Marshal for deep copies</strong> when needed</li>
<li><strong>Rails #dup</strong> creates new ActiveRecord instances</li>
<li><strong>Override <code>initialize_copy</code></strong> to customize duplication</li>
</ol>
<h1>Ruby Modules and Mixins Interview Questions</h1>
<h2>Question 29: What is the difference between a concern and a module?</h2>
<h3>Answer</h3>
<p><strong>Concerns</strong> are a Rails-specific pattern built on top of Ruby modules using <code>ActiveSupport::Concern</code>. They provide a cleaner way to organize shared code, especially for class methods and dependencies.</p>
<hr>
<h3>Regular Module</h3>
<pre><code class="language-ruby">module Loggable
  def self.included(base)
    base.extend(ClassMethods)
    base.class_eval do
      after_save :log_save
    end
  end
  
  module ClassMethods
    def log_prefix
      &quot;[#{name}]&quot;
    end
  end
  
  def log_save
    puts &quot;#{self.class.log_prefix} Saved!&quot;
  end
end

class User
  include Loggable
end

User.log_prefix  # &quot;[User]&quot;
</code></pre>
<hr>
<h3>Concern (Rails)</h3>
<pre><code class="language-ruby">module Loggable
  extend ActiveSupport::Concern
  
  included do
    after_save :log_save
  end
  
  class_methods do
    def log_prefix
      &quot;[#{name}]&quot;
    end
  end
  
  def log_save
    puts &quot;#{self.class.log_prefix} Saved!&quot;
  end
end

class User &lt; ApplicationRecord
  include Loggable
end

User.log_prefix  # &quot;[User]&quot;
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Module</th>
<th>Concern</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Framework</strong></td>
<td>Ruby standard</td>
<td>Rails (ActiveSupport)</td>
</tr>
<tr>
<td><strong>Syntax</strong></td>
<td>More verbose</td>
<td>Cleaner, more readable</td>
</tr>
<tr>
<td><strong>Class methods</strong></td>
<td><code>self.included</code> + <code>extend</code></td>
<td><code>class_methods</code> block</td>
</tr>
<tr>
<td><strong>Dependencies</strong></td>
<td>Manual handling</td>
<td>Automatic dependency resolution</td>
</tr>
<tr>
<td><strong>Callbacks</strong></td>
<td><code>base.class_eval</code></td>
<td><code>included</code> block</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Any Ruby code</td>
<td>Rails applications</td>
</tr>
</tbody></table>
<hr>
<h3>Concern Advantages</h3>
<p><strong>1. Cleaner syntax:</strong></p>
<pre><code class="language-ruby"># Module - verbose
module Searchable
  def self.included(base)
    base.extend(ClassMethods)
  end
  
  module ClassMethods
    def search(query)
      where(&quot;name LIKE ?&quot;, &quot;%#{query}%&quot;)
    end
  end
end

# Concern - clean
module Searchable
  extend ActiveSupport::Concern
  
  class_methods do
    def search(query)
      where(&quot;name LIKE ?&quot;, &quot;%#{query}%&quot;)
    end
  end
end
</code></pre>
<p><strong>2. Dependency resolution:</strong></p>
<pre><code class="language-ruby"># With Module - must include in correct order
module A
  def method_a
    &quot;A&quot;
  end
end

module B
  def method_b
    method_a + &quot;B&quot;  # Depends on A
  end
end

class MyClass
  include A  # Must be first!
  include B
end

# With Concern - automatic dependency resolution
module A
  extend ActiveSupport::Concern
  
  def method_a
    &quot;A&quot;
  end
end

module B
  extend ActiveSupport::Concern
  include A  # Dependency declared
  
  def method_b
    method_a + &quot;B&quot;
  end
end

class MyClass
  include B  # Automatically includes A
end
</code></pre>
<p><strong>3. Included block:</strong></p>
<pre><code class="language-ruby"># Concern&#39;s included block
module Timestampable
  extend ActiveSupport::Concern
  
  included do
    # Runs in class context
    before_save :set_timestamps
    validates :created_at, presence: true
  end
  
  private
  
  def set_timestamps
    self.updated_at = Time.current
  end
end
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Soft Delete Concern</strong></p>
<pre><code class="language-ruby"># app/models/concerns/soft_deletable.rb
module SoftDeletable
  extend ActiveSupport::Concern
  
  included do
    scope :active, -&gt; { where(deleted_at: nil) }
    scope :deleted, -&gt; { where.not(deleted_at: nil) }
    
    default_scope -&gt; { active }
  end
  
  class_methods do
    def with_deleted
      unscope(where: :deleted_at)
    end
  end
  
  def soft_delete
    update(deleted_at: Time.current)
  end
  
  def restore
    update(deleted_at: nil)
  end
  
  def deleted?
    deleted_at.present?
  end
end

class User &lt; ApplicationRecord
  include SoftDeletable
end

# Usage
user = User.first
user.soft_delete
User.deleted  # Returns soft-deleted users
User.with_deleted  # Returns all users including deleted
</code></pre>
<p><strong>Example 2: Sluggable Concern</strong></p>
<pre><code class="language-ruby">module Sluggable
  extend ActiveSupport::Concern
  
  included do
    before_validation :generate_slug
    validates :slug, presence: true, uniqueness: true
  end
  
  class_methods do
    def find_by_slug(slug)
      find_by(slug: slug)
    end
  end
  
  def to_param
    slug
  end
  
  private
  
  def generate_slug
    self.slug ||= title.to_s.parameterize
  end
end

class Post &lt; ApplicationRecord
  include Sluggable
end

# Usage
post = Post.create(title: &quot;Hello World&quot;)
post.slug  # &quot;hello-world&quot;
Post.find_by_slug(&quot;hello-world&quot;)
</code></pre>
<p><strong>Example 3: Taggable Concern</strong></p>
<pre><code class="language-ruby">module Taggable
  extend ActiveSupport::Concern
  
  included do
    has_many :taggings, as: :taggable
    has_many :tags, through: :taggings
  end
  
  class_methods do
    def tagged_with(tag_name)
      joins(:tags).where(tags: { name: tag_name })
    end
  end
  
  def tag_list
    tags.pluck(:name).join(&quot;, &quot;)
  end
  
  def tag_list=(names)
    self.tags = names.split(&quot;,&quot;).map do |name|
      Tag.find_or_create_by(name: name.strip)
    end
  end
end

class Post &lt; ApplicationRecord
  include Taggable
end

class Video &lt; ApplicationRecord
  include Taggable
end

# Usage
post = Post.create(title: &quot;Ruby Tips&quot;, tag_list: &quot;ruby, rails&quot;)
Post.tagged_with(&quot;ruby&quot;)
</code></pre>
<hr>
<h3>Module vs Concern in Practice</h3>
<p><strong>Use Module when:</strong></p>
<ul>
<li>Pure Ruby code (not Rails)</li>
<li>No need for class methods or callbacks</li>
<li>Simple functionality</li>
<li>Want to keep it framework-agnostic</li>
</ul>
<pre><code class="language-ruby">module Greetable
  def greet
    &quot;Hello, #{name}!&quot;
  end
end

class User
  include Greetable
  attr_accessor :name
end
</code></pre>
<p><strong>Use Concern when:</strong></p>
<ul>
<li>Rails application</li>
<li>Need class methods and instance methods</li>
<li>Need callbacks or validations</li>
<li>Have dependencies on other concerns</li>
<li>Want cleaner, more organized code</li>
</ul>
<pre><code class="language-ruby">module Authenticatable
  extend ActiveSupport::Concern
  
  included do
    has_secure_password
    validates :email, presence: true, uniqueness: true
  end
  
  class_methods do
    def find_by_credentials(email, password)
      user = find_by(email: email)
      user&amp;.authenticate(password) ? user : nil
    end
  end
  
  def generate_reset_token
    self.reset_token = SecureRandom.urlsafe_base64
    save
  end
end
</code></pre>
<hr>
<h3>Testing Concerns</h3>
<pre><code class="language-ruby"># spec/models/concerns/soft_deletable_spec.rb
require &#39;rails_helper&#39;

RSpec.describe SoftDeletable do
  let(:test_class) do
    Class.new(ApplicationRecord) do
      self.table_name = &#39;users&#39;
      include SoftDeletable
    end
  end
  
  let(:instance) { test_class.create(name: &quot;Test&quot;) }
  
  describe &#39;#soft_delete&#39; do
    it &#39;sets deleted_at timestamp&#39; do
      expect {
        instance.soft_delete
      }.to change { instance.deleted_at }.from(nil)
    end
  end
  
  describe &#39;.active&#39; do
    it &#39;returns only non-deleted records&#39; do
      deleted = test_class.create(name: &quot;Deleted&quot;, deleted_at: Time.current)
      expect(test_class.active).not_to include(deleted)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Concerns are Rails-specific</strong>, modules are Ruby standard</li>
<li><strong>Concerns provide cleaner syntax</strong> for class methods and callbacks</li>
<li><strong>Automatic dependency resolution</strong> with concerns</li>
<li><strong>Use concerns in Rails apps</strong>, modules in pure Ruby</li>
<li><strong>Concerns organize code better</strong> for ActiveRecord models</li>
<li><strong><code>included</code> block</strong> runs in class context</li>
<li><strong><code>class_methods</code> block</strong> defines class methods</li>
<li>Both promote <strong>code reusability</strong></li>
</ol>
<hr>
<h2>Question 30: What is the difference between a mixin and a module?</h2>
<h3>Answer</h3>
<p><strong>A module is a Ruby construct</strong>, while <strong>a mixin is a pattern</strong> of using modules to add functionality to classes. All mixins are modules, but not all modules are mixins.</p>
<hr>
<h3>Module</h3>
<p>A module is a container for methods, constants, and classes:</p>
<pre><code class="language-ruby"># Module as namespace
module MyApp
  class User
  end
  
  def self.version
    &quot;1.0.0&quot;
  end
end

MyApp::User.new
MyApp.version

# Module as mixin
module Greetable
  def greet
    &quot;Hello!&quot;
  end
end
</code></pre>
<hr>
<h3>Mixin</h3>
<p>A mixin is when you use <code>include</code>, <code>extend</code>, or <code>prepend</code> to add module functionality to a class:</p>
<pre><code class="language-ruby">module Swimmable
  def swim
    &quot;Swimming...&quot;
  end
end

module Flyable
  def fly
    &quot;Flying...&quot;
  end
end

# Mixins - adding module functionality
class Duck
  include Swimmable  # Mixin
  include Flyable    # Mixin
end

duck = Duck.new
duck.swim  # From Swimmable mixin
duck.fly   # From Flyable mixin
</code></pre>
<hr>
<h3>Key Concepts</h3>
<table>
<thead>
<tr>
<th>Term</th>
<th>Definition</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Module</strong></td>
<td>Container for code</td>
<td><code>module Greetable</code></td>
</tr>
<tr>
<td><strong>Mixin</strong></td>
<td>Pattern of using modules</td>
<td><code>include Greetable</code></td>
</tr>
<tr>
<td><strong>Include</strong></td>
<td>Add module as mixin (instance methods)</td>
<td><code>include Swimmable</code></td>
</tr>
<tr>
<td><strong>Extend</strong></td>
<td>Add module as mixin (class methods)</td>
<td><code>extend Searchable</code></td>
</tr>
<tr>
<td><strong>Prepend</strong></td>
<td>Add module before class in lookup</td>
<td><code>prepend Loggable</code></td>
</tr>
</tbody></table>
<hr>
<h3>Module Uses Beyond Mixins</h3>
<p><strong>1. Namespace:</strong></p>
<pre><code class="language-ruby">module Payment
  class CreditCard
    def process
      &quot;Processing credit card&quot;
    end
  end
  
  class PayPal
    def process
      &quot;Processing PayPal&quot;
    end
  end
end

Payment::CreditCard.new.process
Payment::PayPal.new.process
</code></pre>
<p><strong>2. Module methods (not mixin):</strong></p>
<pre><code class="language-ruby">module Math
  def self.add(a, b)
    a + b
  end
  
  def self.multiply(a, b)
    a * b
  end
end

Math.add(5, 3)      # Called on module
Math.multiply(5, 3)
</code></pre>
<p><strong>3. Constants:</strong></p>
<pre><code class="language-ruby">module Config
  API_KEY = &quot;secret123&quot;
  TIMEOUT = 30
  BASE_URL = &quot;https://api.example.com&quot;
end

Config::API_KEY
Config::TIMEOUT
</code></pre>
<hr>
<h3>Mixin Pattern Examples</h3>
<p><strong>Example 1: Multiple Mixins</strong></p>
<pre><code class="language-ruby">module Loggable
  def log(message)
    puts &quot;[#{Time.now}] #{message}&quot;
  end
end

module Timestampable
  def created_at
    @created_at ||= Time.now
  end
end

module Validatable
  def valid?
    errors.empty?
  end
  
  def errors
    @errors ||= []
  end
end

class User
  include Loggable      # Mixin
  include Timestampable # Mixin
  include Validatable   # Mixin
  
  def save
    return false unless valid?
    log(&quot;Saving user...&quot;)
    true
  end
end

user = User.new
user.log(&quot;Test&quot;)  # From Loggable
user.created_at   # From Timestampable
user.valid?       # From Validatable
</code></pre>
<p><strong>Example 2: Composition Over Inheritance</strong></p>
<pre><code class="language-ruby"># Without mixins - inheritance
class Animal
  def eat
    &quot;Eating...&quot;
  end
end

class Bird &lt; Animal
  def fly
    &quot;Flying...&quot;
  end
end

# Problem: Penguin is a bird but can&#39;t fly!
class Penguin &lt; Bird
end

penguin = Penguin.new
penguin.fly  # &quot;Flying...&quot; - but penguins can&#39;t fly!

# With mixins - composition
module Eatable
  def eat
    &quot;Eating...&quot;
  end
end

module Flyable
  def fly
    &quot;Flying...&quot;
  end
end

module Swimmable
  def swim
    &quot;Swimming...&quot;
  end
end

class Eagle
  include Eatable
  include Flyable
end

class Penguin
  include Eatable
  include Swimmable  # No Flyable!
end

eagle = Eagle.new
eagle.fly  # Works

penguin = Penguin.new
penguin.swim  # Works
# penguin.fly  # NoMethodError - as expected
</code></pre>
<hr>
<h3>Include, Extend, Prepend</h3>
<p><strong>Include (instance methods):</strong></p>
<pre><code class="language-ruby">module Greetable
  def greet
    &quot;Hello!&quot;
  end
end

class User
  include Greetable
end

User.new.greet  # Instance method
</code></pre>
<p><strong>Extend (class methods):</strong></p>
<pre><code class="language-ruby">module Searchable
  def search(query)
    &quot;Searching for #{query}&quot;
  end
end

class User
  extend Searchable
end

User.search(&quot;John&quot;)  # Class method
</code></pre>
<p><strong>Prepend (before class):</strong></p>
<pre><code class="language-ruby">module Loggable
  def save
    puts &quot;Before save&quot;
    super
    puts &quot;After save&quot;
  end
end

class User
  prepend Loggable
  
  def save
    puts &quot;Saving...&quot;
  end
end

User.new.save
# Output:
# Before save
# Saving...
# After save
</code></pre>
<hr>
<h3>Rails Mixin Examples</h3>
<p><strong>ActiveRecord Mixins:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Built-in Rails mixins
  include ActiveModel::Validations
  include ActiveModel::Callbacks
  
  # Custom mixins
  include SoftDeletable
  include Sluggable
  include Taggable
end
</code></pre>
<p><strong>Controller Mixins:</strong></p>
<pre><code class="language-ruby">module AuthenticationConcern
  extend ActiveSupport::Concern
  
  included do
    before_action :authenticate_user!
  end
  
  private
  
  def authenticate_user!
    redirect_to login_path unless current_user
  end
  
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
end

class PostsController &lt; ApplicationController
  include AuthenticationConcern  # Mixin
end
</code></pre>
<hr>
<h3>Module vs Mixin Best Practices</h3>
<p><strong>Module should be a mixin when:</strong></p>
<ul>
<li>Provides reusable functionality</li>
<li>Can be applied to multiple classes</li>
<li>Represents a &quot;capability&quot; (Swimmable, Flyable)</li>
<li>Used with include/extend/prepend</li>
</ul>
<p><strong>Module should NOT be a mixin when:</strong></p>
<ul>
<li>Used only for namespacing</li>
<li>Contains only module methods</li>
<li>Used for configuration</li>
<li>Never included in classes</li>
</ul>
<pre><code class="language-ruby"># Good mixin - reusable functionality
module Exportable
  def to_csv
    # export logic
  end
  
  def to_json
    # json logic
  end
end

# Not a mixin - namespace
module Reports
  class SalesReport
  end
  
  class UserReport
  end
end

# Not a mixin - module methods
module Calculator
  def self.add(a, b)
    a + b
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Module</strong> is a Ruby construct, <strong>mixin</strong> is a pattern</li>
<li><strong>Mixin</strong> = including a module in a class</li>
<li><strong>Modules</strong> can be used for namespace, constants, module methods</li>
<li><strong>Not all modules are mixins</strong>, but all mixins are modules</li>
<li><strong>Include/extend/prepend</strong> create mixins</li>
<li><strong>Mixins enable composition</strong> over inheritance</li>
<li><strong>Multiple mixins</strong> allowed, single inheritance only</li>
<li><strong>Rails heavily uses mixins</strong> for shared functionality</li>
</ol>
<hr>
<h2>Question 31: Explain Mixins in detail</h2>
<h3>Answer</h3>
<p><strong>Mixins</strong> are a way to add functionality to classes by including modules. They enable multiple inheritance-like behavior in Ruby while avoiding the complexity of true multiple inheritance.</p>
<hr>
<h3>What are Mixins?</h3>
<p>Mixins allow you to:</p>
<ul>
<li>Share functionality across multiple classes</li>
<li>Compose behavior instead of inheriting it</li>
<li>Follow the DRY (Don&#39;t Repeat Yourself) principle</li>
<li>Avoid the &quot;diamond problem&quot; of multiple inheritance</li>
</ul>
<pre><code class="language-ruby">module Loggable
  def log(message)
    puts &quot;[#{self.class.name}] #{message}&quot;
  end
end

class User
  include Loggable
end

class Post
  include Loggable
end

User.new.log(&quot;User created&quot;)  # [User] User created
Post.new.log(&quot;Post published&quot;)  # [Post] Post published
</code></pre>
<hr>
<h3>How Mixins Work</h3>
<p>When you include a module:</p>
<ol>
<li>Module methods become instance methods</li>
<li>Module is added to the class&#39;s ancestor chain</li>
<li>Methods can be overridden in the class</li>
<li><code>super</code> calls the next method in the chain</li>
</ol>
<pre><code class="language-ruby">module A
  def greet
    &quot;Hello from A&quot;
  end
end

class MyClass
  include A
end

obj = MyClass.new
obj.greet  # &quot;Hello from A&quot;

# Check ancestor chain
MyClass.ancestors  # [MyClass, A, Object, Kernel, BasicObject]
</code></pre>
<hr>
<h3>Three Ways to Mix In Modules</h3>
<p><strong>1. Include - Instance Methods</strong></p>
<pre><code class="language-ruby">module Greetable
  def greet
    &quot;Hello!&quot;
  end
end

class User
  include Greetable
end

user = User.new
user.greet  # Instance method
</code></pre>
<p><strong>2. Extend - Class Methods</strong></p>
<pre><code class="language-ruby">module Searchable
  def search(query)
    &quot;Searching for #{query}&quot;
  end
end

class User
  extend Searchable
end

User.search(&quot;John&quot;)  # Class method
</code></pre>
<p><strong>3. Prepend - Before Class Methods</strong></p>
<pre><code class="language-ruby">module Wrapper
  def process
    puts &quot;Before&quot;
    super
    puts &quot;After&quot;
  end
end

class Processor
  prepend Wrapper
  
  def process
    puts &quot;Processing&quot;
  end
end

Processor.new.process
# Before
# Processing
# After
</code></pre>
<hr>
<h3>Method Lookup Chain</h3>
<pre><code class="language-ruby">module M1
  def test
    &quot;M1&quot;
  end
end

module M2
  def test
    &quot;M2&quot;
  end
end

class Parent
  def test
    &quot;Parent&quot;
  end
end

class Child &lt; Parent
  prepend M1
  include M2
  
  def test
    &quot;Child&quot;
  end
end

Child.ancestors
# [M1, Child, M2, Parent, Object, Kernel, BasicObject]

Child.new.test  # &quot;M1&quot; (prepend comes first)
</code></pre>
<hr>
<h3>Multiple Mixins</h3>
<pre><code class="language-ruby">module Loggable
  def log(msg)
    puts &quot;[LOG] #{msg}&quot;
  end
end

module Timestampable
  def timestamp
    Time.now
  end
end

module Validatable
  def valid?
    true
  end
end

class User
  include Loggable
  include Timestampable
  include Validatable
  
  def save
    return unless valid?
    log(&quot;Saving at #{timestamp}&quot;)
  end
end

user = User.new
user.save  # [LOG] Saving at 2024-01-15 10:30:00
</code></pre>
<hr>
<h3>Mixin Design Patterns</h3>
<p><strong>1. Capability Pattern</strong></p>
<p>Name mixins after capabilities:</p>
<pre><code class="language-ruby">module Swimmable
  def swim
    &quot;#{name} is swimming&quot;
  end
end

module Flyable
  def fly
    &quot;#{name} is flying&quot;
  end
end

module Walkable
  def walk
    &quot;#{name} is walking&quot;
  end
end

class Duck
  include Swimmable
  include Flyable
  include Walkable
  
  attr_reader :name
  
  def initialize(name)
    @name = name
  end
end

duck = Duck.new(&quot;Donald&quot;)
duck.swim  # Donald is swimming
duck.fly   # Donald is flying
duck.walk  # Donald is walking
</code></pre>
<p><strong>2. Decorator Pattern</strong></p>
<p>Wrap functionality around methods:</p>
<pre><code class="language-ruby">module Benchmarkable
  def self.included(base)
    base.extend(ClassMethods)
  end
  
  module ClassMethods
    def benchmark(method_name)
      original_method = instance_method(method_name)
      
      define_method(method_name) do |*args, &amp;block|
        start_time = Time.now
        result = original_method.bind(self).call(*args, &amp;block)
        end_time = Time.now
        
        puts &quot;#{method_name} took #{end_time - start_time} seconds&quot;
        result
      end
    end
  end
end

class DataProcessor
  include Benchmarkable
  
  def process_data
    sleep 1
    &quot;Data processed&quot;
  end
  
  benchmark :process_data
end

processor = DataProcessor.new
processor.process_data
# process_data took 1.001 seconds
# =&gt; &quot;Data processed&quot;
</code></pre>
<p><strong>3. Strategy Pattern</strong></p>
<p>Different implementations via mixins:</p>
<pre><code class="language-ruby">module PaymentProcessor
  def process_payment(amount)
    raise NotImplementedError
  end
end

module CreditCardPayment
  include PaymentProcessor
  
  def process_payment(amount)
    &quot;Processing $#{amount} via Credit Card&quot;
  end
end

module PayPalPayment
  include PaymentProcessor
  
  def process_payment(amount)
    &quot;Processing $#{amount} via PayPal&quot;
  end
end

class Order
  def initialize(payment_method)
    extend payment_method
  end
  
  def checkout(amount)
    process_payment(amount)
  end
end

order1 = Order.new(CreditCardPayment)
order1.checkout(100)  # Credit Card

order2 = Order.new(PayPalPayment)
order2.checkout(50)   # PayPal
</code></pre>
<hr>
<h3>Rails Mixin Examples</h3>
<p><strong>Model Concerns:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/taggable.rb
module Taggable
  extend ActiveSupport::Concern
  
  included do
    has_many :taggings, as: :taggable
    has_many :tags, through: :taggings
    
    scope :tagged_with, -&gt;(name) {
      joins(:tags).where(tags: { name: name })
    }
  end
  
  def tag_list
    tags.map(&amp;:name).join(&#39;, &#39;)
  end
  
  def tag_list=(names)
    self.tags = names.split(&#39;,&#39;).map do |name|
      Tag.where(name: name.strip).first_or_create!
    end
  end
end

class Post &lt; ApplicationRecord
  include Taggable
end

class Video &lt; ApplicationRecord
  include Taggable
end

# Usage
post = Post.create(title: &quot;Ruby Tips&quot;, tag_list: &quot;ruby, rails, tips&quot;)
Post.tagged_with(&quot;ruby&quot;)
</code></pre>
<p><strong>Controller Concerns:</strong></p>
<pre><code class="language-ruby"># app/controllers/concerns/authentication.rb
module Authentication
  extend ActiveSupport::Concern
  
  included do
    before_action :authenticate_user!
    helper_method :current_user, :logged_in?
  end
  
  private
  
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
  
  def logged_in?
    current_user.present?
  end
  
  def authenticate_user!
    redirect_to login_path unless logged_in?
  end
end

class PostsController &lt; ApplicationController
  include Authentication
  
  skip_before_action :authenticate_user!, only: [:index, :show]
  
  def index
    @posts = Post.all
  end
end
</code></pre>
<hr>
<h3>Advanced Mixin Techniques</h3>
<p><strong>1. Self-referential Mixins:</strong></p>
<pre><code class="language-ruby">module Comparable
  def &lt;(other)
    (self &lt;=&gt; other) &lt; 0
  end
  
  def &lt;=(other)
    (self &lt;=&gt; other) &lt;= 0
  end
  
  def &gt;(other)
    (self &lt;=&gt; other) &gt; 0
  end
  
  def &gt;=(other)
    (self &lt;=&gt; other) &gt;= 0
  end
  
  def between?(min, max)
    self &gt;= min &amp;&amp; self &lt;= max
  end
end

class Version
  include Comparable
  
  attr_reader :major, :minor, :patch
  
  def initialize(version_string)
    @major, @minor, @patch = version_string.split(&#39;.&#39;).map(&amp;:to_i)
  end
  
  def &lt;=&gt;(other)
    return nil unless other.is_a?(Version)
    
    [major, minor, patch] &lt;=&gt; [other.major, other.minor, other.patch]
  end
  
  def to_s
    &quot;#{major}.#{minor}.#{patch}&quot;
  end
end

v1 = Version.new(&quot;1.2.3&quot;)
v2 = Version.new(&quot;2.0.0&quot;)

v1 &lt; v2   # true
v1 &gt;= v2  # false
v1.between?(Version.new(&quot;1.0.0&quot;), Version.new(&quot;1.5.0&quot;))  # true
</code></pre>
<p><strong>2. Parameterized Mixins:</strong></p>
<pre><code class="language-ruby">module Cacheable
  def self.included(base)
    base.extend(ClassMethods)
  end
  
  module ClassMethods
    def cache_method(method_name, ttl: 3600)
      original_method = instance_method(method_name)
      
      define_method(method_name) do |*args|
        cache_key = &quot;#{self.class.name}##{method_name}:#{args.join(&#39;:&#39;)}&quot;
        cached = Rails.cache.read(cache_key)
        
        if cached
          cached
        else
          result = original_method.bind(self).call(*args)
          Rails.cache.write(cache_key, result, expires_in: ttl)
          result
        end
      end
    end
  end
end

class User &lt; ApplicationRecord
  include Cacheable
  
  def expensive_calculation
    sleep 2
    &quot;Result&quot;
  end
  
  cache_method :expensive_calculation, ttl: 1.hour
end
</code></pre>
<p><strong>3. Conditional Mixins:</strong></p>
<pre><code class="language-ruby">module AdminFeatures
  def delete_all_users
    &quot;Deleting all users&quot;
  end
end

module ModeratorFeatures
  def ban_user(user)
    &quot;Banning #{user}&quot;
  end
end

class User
  attr_reader :role
  
  def initialize(role)
    @role = role
    apply_role_features
  end
  
  private
  
  def apply_role_features
    case role
    when :admin
      extend AdminFeatures
      extend ModeratorFeatures
    when :moderator
      extend ModeratorFeatures
    end
  end
end

admin = User.new(:admin)
admin.delete_all_users  # Works

moderator = User.new(:moderator)
moderator.ban_user(&quot;spammer&quot;)  # Works
# moderator.delete_all_users  # NoMethodError
</code></pre>
<hr>
<h3>Mixin Best Practices</h3>
<p><strong>1. Single Responsibility:</strong></p>
<pre><code class="language-ruby"># BAD - too many responsibilities
module Everything
  def save
  end
  
  def validate
  end
  
  def send_email
  end
  
  def calculate_tax
  end
end

# GOOD - focused mixins
module Persistable
  def save
  end
end

module Validatable
  def validate
  end
end

module Notifiable
  def send_email
  end
end
</code></pre>
<p><strong>2. Meaningful Names:</strong></p>
<pre><code class="language-ruby"># BAD
module Helpers
  def do_stuff
  end
end

# GOOD
module Exportable
  def to_csv
  end
  
  def to_json
  end
end
</code></pre>
<p><strong>3. Avoid State in Mixins:</strong></p>
<pre><code class="language-ruby"># BAD - mixin with state
module Counter
  def increment
    @count ||= 0
    @count += 1
  end
end

# GOOD - stateless or explicit state
module Counter
  def increment_count
    self.count ||= 0
    self.count += 1
  end
end
</code></pre>
<hr>
<h3>Testing Mixins</h3>
<pre><code class="language-ruby"># spec/support/shared_examples/taggable.rb
RSpec.shared_examples &#39;taggable&#39; do
  let(:model) { described_class }
  
  it &#39;has tags association&#39; do
    expect(model.reflect_on_association(:tags)).to be_present
  end
  
  it &#39;can add tags&#39; do
    instance = model.create(tag_list: &#39;ruby, rails&#39;)
    expect(instance.tags.count).to eq(2)
  end
  
  it &#39;can search by tag&#39; do
    instance = model.create(tag_list: &#39;ruby&#39;)
    results = model.tagged_with(&#39;ruby&#39;)
    expect(results).to include(instance)
  end
end

# spec/models/post_spec.rb
RSpec.describe Post do
  it_behaves_like &#39;taggable&#39;
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Mixins add functionality</strong> to classes via modules</li>
<li><strong>Include</strong> for instance methods, <strong>extend</strong> for class methods</li>
<li><strong>Prepend</strong> adds module before class in lookup chain</li>
<li><strong>Multiple mixins</strong> solve multiple inheritance problems</li>
<li><strong>Name after capabilities</strong> (Swimmable, Flyable)</li>
<li><strong>Keep mixins focused</strong> and single-responsibility</li>
<li><strong>Rails uses concerns</strong> as enhanced mixins</li>
<li><strong>Test mixins</strong> with shared examples</li>
</ol>
<hr>
<h2>Question 32: What is <code>include</code> vs <code>extend</code> vs <code>prepend</code>?</h2>
<h3>Answer</h3>
<p>These three keywords add modules to classes but differ in <strong>where methods are added</strong> in the method lookup chain and <strong>how they&#39;re accessed</strong>.</p>
<hr>
<h3>Include - Instance Methods</h3>
<p><code>include</code> adds module methods as <strong>instance methods</strong> and inserts the module <strong>after</strong> the class in the lookup chain.</p>
<pre><code class="language-ruby">module Greetable
  def greet
    &quot;Hello from instance method!&quot;
  end
end

class User
  include Greetable
end

# Methods become instance methods
user = User.new
user.greet  # &quot;Hello from instance method!&quot;

# User.greet  # NoMethodError - not a class method

# Lookup chain
User.ancestors  # [User, Greetable, Object, Kernel, BasicObject]
</code></pre>
<hr>
<h3>Extend - Class Methods</h3>
<p><code>extend</code> adds module methods as <strong>class methods</strong> (singleton methods on the class).</p>
<pre><code class="language-ruby">module Searchable
  def search(query)
    &quot;Searching for: #{query}&quot;
  end
end

class User
  extend Searchable
end

# Methods become class methods
User.search(&quot;John&quot;)  # &quot;Searching for: John&quot;

# User.new.search(&quot;John&quot;)  # NoMethodError - not an instance method

# Singleton class gets the module
User.singleton_class.ancestors.include?(Searchable)  # true
</code></pre>
<hr>
<h3>Prepend - Before Class Methods</h3>
<p><code>prepend</code> adds module methods as instance methods but inserts the module <strong>before</strong> the class in the lookup chain.</p>
<pre><code class="language-ruby">module Loggable
  def save
    puts &quot;Before save&quot;
    super  # Calls the class&#39;s save method
    puts &quot;After save&quot;
  end
end

class User
  prepend Loggable
  
  def save
    puts &quot;Saving user...&quot;
  end
end

user = User.new
user.save

# Output:
# Before save
# Saving user...
# After save

# Lookup chain
User.ancestors  # [Loggable, User, Object, Kernel, BasicObject]
# Loggable comes BEFORE User!
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>include</th>
<th>extend</th>
<th>prepend</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Method type</strong></td>
<td>Instance methods</td>
<td>Class methods</td>
<td>Instance methods</td>
</tr>
<tr>
<td><strong>Lookup position</strong></td>
<td>After class</td>
<td>Singleton class</td>
<td>Before class</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Add instance behavior</td>
<td>Add class behavior</td>
<td>Wrap/decorate methods</td>
</tr>
<tr>
<td><strong>super works</strong></td>
<td>Yes</td>
<td>N/A</td>
<td>Yes (calls class method)</td>
</tr>
<tr>
<td><strong>Common for</strong></td>
<td>Mixins</td>
<td>Class methods</td>
<td>Method decoration</td>
</tr>
</tbody></table>
<hr>
<h3>Detailed Examples</h3>
<p><strong>Example 1: Include</strong></p>
<pre><code class="language-ruby">module Walkable
  def walk
    &quot;Walking...&quot;
  end
end

module Swimmable
  def swim
    &quot;Swimming...&quot;
  end
end

class Animal
  include Walkable
  include Swimmable
  
  def move
    &quot;Moving...&quot;
  end
end

animal = Animal.new
animal.walk  # From Walkable
animal.swim  # From Swimmable
animal.move  # From Animal

Animal.ancestors
# [Animal, Swimmable, Walkable, Object, Kernel, BasicObject]
# Last included comes first in chain
</code></pre>
<p><strong>Example 2: Extend</strong></p>
<pre><code class="language-ruby">module ClassUtilities
  def count
    &quot;Counting records...&quot;
  end
  
  def find_by_name(name)
    &quot;Finding #{name}...&quot;
  end
end

class User
  extend ClassUtilities
  
  def self.custom_method
    &quot;Custom class method&quot;
  end
end

# All class methods
User.count  # From module
User.find_by_name(&quot;John&quot;)  # From module
User.custom_method  # From class

# Not instance methods
# User.new.count  # NoMethodError
</code></pre>
<p><strong>Example 3: Prepend</strong></p>
<pre><code class="language-ruby">module Timestampable
  def save
    self.updated_at = Time.now
    super  # Calls User#save
  end
end

class User
  prepend Timestampable
  
  attr_accessor :name, :updated_at
  
  def save
    puts &quot;Saving #{name}...&quot;
    true
  end
end

user = User.new
user.name = &quot;John&quot;
user.save

# Module method runs first, then class method
</code></pre>
<hr>
<h3>Using All Three Together</h3>
<pre><code class="language-ruby">module InstanceFeatures
  def instance_method
    &quot;Instance method from module&quot;
  end
end

module ClassFeatures
  def class_method
    &quot;Class method from module&quot;
  end
end

module Wrapper
  def wrapped_method
    puts &quot;Before&quot;
    super
    puts &quot;After&quot;
  end
end

class MyClass
  include InstanceFeatures  # Instance methods (after class)
  extend ClassFeatures      # Class methods
  prepend Wrapper           # Instance methods (before class)
  
  def wrapped_method
    puts &quot;Original method&quot;
  end
end

MyClass.ancestors
# [Wrapper, MyClass, InstanceFeatures, Object, Kernel, BasicObject]

obj = MyClass.new
obj.instance_method  # Works
MyClass.class_method  # Works

obj.wrapped_method
# Before
# Original method
# After
</code></pre>
<hr>
<h3>Super with Include/Prepend</h3>
<pre><code class="language-ruby">module A
  def test
    &quot;A: &quot; + super
  end
end

module B
  def test
    &quot;B: &quot; + super
  end
end

class C
  prepend A
  include B
  
  def test
    &quot;C&quot;
  end
end

C.ancestors  # [A, C, B, Object, Kernel, BasicObject]

C.new.test  # &quot;A: C&quot;
# A is prepended (before C), so it runs first
# A calls super -&gt; goes to C
# C doesn&#39;t call super, so stops at C
</code></pre>
<hr>
<h3>Dynamic Include/Extend</h3>
<pre><code class="language-ruby">module Features
  def feature_one
    &quot;Feature 1&quot;
  end
end

class User
  # Conditional include
  if Rails.env.production?
    include Features
  end
  
  # Dynamic extend
  def self.add_features(mod)
    extend mod
  end
end

# Add features at runtime
User.add_features(SomeModule)
</code></pre>
<hr>
<h3>Rails Examples</h3>
<p><strong>Include in Models:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  include Devise::Models::Authenticatable
  include SoftDeletable
  include Taggable
end
</code></pre>
<p><strong>Extend for Class Methods:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  extend FriendlyId
  
  friendly_id :name, use: :slugged
end
</code></pre>
<p><strong>Prepend for Decoration:</strong></p>
<pre><code class="language-ruby">module AuditLog
  def save
    log_action(&quot;Attempting save&quot;)
    result = super
    log_action(&quot;Save #{result ? &#39;successful&#39; : &#39;failed&#39;}&quot;)
    result
  end
  
  private
  
  def log_action(message)
    AuditLogger.log(self.class.name, message)
  end
end

class User &lt; ApplicationRecord
  prepend AuditLog
end
</code></pre>
<hr>
<h3>ActiveSupport::Concern Pattern</h3>
<p>Combines include and extend:</p>
<pre><code class="language-ruby">module Taggable
  extend ActiveSupport::Concern
  
  # These become instance methods (like include)
  def tag_list
    tags.pluck(:name).join(&#39;, &#39;)
  end
  
  # These become class methods (like extend)
  class_methods do
    def tagged_with(name)
      joins(:tags).where(tags: { name: name })
    end
  end
  
  # Runs when included
  included do
    has_many :tags
    scope :with_tags, -&gt; { includes(:tags) }
  end
end

class Post &lt; ApplicationRecord
  include Taggable  # Gets everything above
end

# Instance methods
post.tag_list

# Class methods
Post.tagged_with(&quot;ruby&quot;)
</code></pre>
<hr>
<h3>Method Lookup Visualization</h3>
<pre><code class="language-ruby">module M1
  def test
    &quot;M1&quot;
  end
end

module M2
  def test
    &quot;M2&quot;
  end
end

class Parent
  def test
    &quot;Parent&quot;
  end
end

class Child &lt; Parent
  prepend M1
  include M2
  
  def test
    &quot;Child&quot;
  end
end

Child.ancestors
# [M1, Child, M2, Parent, Object, Kernel, BasicObject]
#  ^prepend  ^class  ^include  ^superclass

Child.new.test  # &quot;M1&quot; (found first in chain)
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>Use include when:</strong></p>
<ul>
<li>Adding instance methods</li>
<li>Creating mixins</li>
<li>Sharing behavior across classes</li>
<li>Default choice for modules</li>
</ul>
<p><strong>Use extend when:</strong></p>
<ul>
<li>Adding class methods</li>
<li>Creating utility modules</li>
<li>Factory pattern</li>
<li>Adding methods to specific instances</li>
</ul>
<p><strong>Use prepend when:</strong></p>
<ul>
<li>Wrapping/decorating methods</li>
<li>Adding before/after behavior</li>
<li>Need to call original method with super</li>
<li>Implementing AOP (Aspect-Oriented Programming)</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>include</strong>: Instance methods, after class in lookup</li>
<li><strong>extend</strong>: Class methods (singleton methods)</li>
<li><strong>prepend</strong>: Instance methods, before class in lookup</li>
<li><strong>Use super</strong> with prepend to call original method</li>
<li><strong>include</strong> is most common for mixins</li>
<li><strong>prepend</strong> for method decoration/wrapping</li>
<li><strong>extend</strong> for class-level utilities</li>
<li><strong>ActiveSupport::Concern</strong> combines include and extend patterns</li>
</ol>
<h1>Ruby Advanced Concepts Interview Questions - Part 1</h1>
<h2>Question 33: What are keyword arguments, and how do they work?</h2>
<h3>Answer</h3>
<p><strong>Keyword arguments</strong> (kwargs) allow you to pass arguments to methods by name rather than by position. They make code more readable and flexible.</p>
<hr>
<h3>Basic Syntax</h3>
<pre><code class="language-ruby"># Traditional positional arguments
def create_user(name, email, age)
  &quot;#{name}, #{email}, #{age}&quot;
end

create_user(&quot;John&quot;, &quot;john@example.com&quot;, 30)
# Must remember order!

# Keyword arguments
def create_user(name:, email:, age:)
  &quot;#{name}, #{email}, #{age}&quot;
end

create_user(name: &quot;John&quot;, email: &quot;john@example.com&quot;, age: 30)
create_user(age: 30, name: &quot;John&quot;, email: &quot;john@example.com&quot;)
# Order doesn&#39;t matter!
</code></pre>
<hr>
<h3>Required vs Optional Keyword Arguments</h3>
<pre><code class="language-ruby"># Required keyword arguments (Ruby 2.1+)
def register(name:, email:)
  &quot;Registered: #{name}, #{email}&quot;
end

register(name: &quot;John&quot;, email: &quot;john@example.com&quot;)  # Works
register(name: &quot;John&quot;)  # ArgumentError: missing keyword: email

# Optional keyword arguments (with defaults)
def register(name:, email:, role: &#39;user&#39;, active: true)
  &quot;#{name}, #{email}, #{role}, #{active}&quot;
end

register(name: &quot;John&quot;, email: &quot;john@example.com&quot;)
# Uses defaults: role=&#39;user&#39;, active=true

register(name: &quot;John&quot;, email: &quot;john@example.com&quot;, role: &quot;admin&quot;)
# Overrides role
</code></pre>
<hr>
<h3>Mixing Positional and Keyword Arguments</h3>
<pre><code class="language-ruby"># Ruby 3.0+ requires explicit separation
def process(id, name:, email: nil)
  &quot;ID: #{id}, Name: #{name}, Email: #{email}&quot;
end

process(123, name: &quot;John&quot;)
process(123, name: &quot;John&quot;, email: &quot;john@example.com&quot;)
</code></pre>
<hr>
<h3>Double Splat (**) - Collecting Keyword Arguments</h3>
<pre><code class="language-ruby"># Collect remaining keyword arguments
def create_user(name:, email:, **options)
  puts &quot;Name: #{name}&quot;
  puts &quot;Email: #{email}&quot;
  puts &quot;Options: #{options.inspect}&quot;
end

create_user(
  name: &quot;John&quot;,
  email: &quot;john@example.com&quot;,
  age: 30,
  role: &quot;admin&quot;,
  active: true
)

# Output:
# Name: John
# Email: john@example.com
# Options: {:age=&gt;30, :role=&gt;&quot;admin&quot;, :active=&gt;true}
</code></pre>
<hr>
<h3>Passing Hash as Keyword Arguments</h3>
<pre><code class="language-ruby">def greet(name:, message:)
  &quot;#{message}, #{name}!&quot;
end

# Using hash with **
options = { name: &quot;John&quot;, message: &quot;Hello&quot; }
greet(**options)  # &quot;Hello, John!&quot;

# Without **, it&#39;s a single positional argument
# greet(options)  # ArgumentError
</code></pre>
<hr>
<h3>Evolution Across Ruby Versions</h3>
<p><strong>Ruby 2.0:</strong></p>
<pre><code class="language-ruby"># Hashes automatically converted to kwargs
def method(name:, age:)
end

hash = { name: &quot;John&quot;, age: 30 }
method(hash)  # Works (automatic conversion)
</code></pre>
<p><strong>Ruby 2.7:</strong></p>
<pre><code class="language-ruby"># Warning about automatic conversion
method(hash)  # Warning: deprecated
</code></pre>
<p><strong>Ruby 3.0+:</strong></p>
<pre><code class="language-ruby"># Must explicitly use **
method(**hash)  # Correct way
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Configuration Object</strong></p>
<pre><code class="language-ruby">class Database
  def connect(host:, port: 5432, username:, password:, ssl: true, timeout: 30)
    @connection = {
      host: host,
      port: port,
      username: username,
      password: password,
      ssl: ssl,
      timeout: timeout
    }
  end
end

db = Database.new
db.connect(
  host: &#39;localhost&#39;,
  username: &#39;admin&#39;,
  password: &#39;secret&#39;,
  port: 3306,
  ssl: false
)
</code></pre>
<p><strong>Example 2: Flexible API Methods</strong></p>
<pre><code class="language-ruby">class UserService
  def search(
    query: nil,
    role: nil,
    active: true,
    order: :created_at,
    limit: 100,
    offset: 0
  )
    users = User.all
    users = users.where(&quot;name LIKE ?&quot;, &quot;%#{query}%&quot;) if query
    users = users.where(role: role) if role
    users = users.where(active: active)
    users.order(order).limit(limit).offset(offset)
  end
end

# Clean, self-documenting calls
service = UserService.new
service.search(query: &quot;John&quot;, role: &quot;admin&quot;, limit: 50)
service.search(active: false, order: :email)
</code></pre>
<p><strong>Example 3: Rails Controller</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    @post = Post.create(post_params)
    
    respond_with_post(
      post: @post,
      status: :created,
      location: post_path(@post),
      notice: &quot;Post created successfully&quot;
    )
  end
  
  private
  
  def respond_with_post(post:, status:, location:, notice: nil)
    if post.persisted?
      redirect_to location, notice: notice, status: status
    else
      render :new, status: :unprocessable_entity
    end
  end
end
</code></pre>
<hr>
<h3>Advantages of Keyword Arguments</h3>
<p><strong>1. Self-documenting code:</strong></p>
<pre><code class="language-ruby"># Hard to understand
user.update(&quot;John&quot;, &quot;john@example.com&quot;, 30, true, &quot;admin&quot;)

# Clear and readable
user.update(
  name: &quot;John&quot;,
  email: &quot;john@example.com&quot;,
  age: 30,
  active: true,
  role: &quot;admin&quot;
)
</code></pre>
<p><strong>2. Order independence:</strong></p>
<pre><code class="language-ruby"># Can pass in any order
create_order(
  total: 100,
  user_id: 123,
  status: &quot;pending&quot;,
  items: [1, 2, 3]
)

create_order(
  items: [1, 2, 3],
  user_id: 123,
  total: 100,
  status: &quot;pending&quot;
)
</code></pre>
<p><strong>3. Optional parameters clear:</strong></p>
<pre><code class="language-ruby">def send_email(to:, subject:, body:, cc: nil, bcc: nil, attachments: [])
  # Clear which params are optional
end

send_email(
  to: &quot;user@example.com&quot;,
  subject: &quot;Hello&quot;,
  body: &quot;World&quot;
)
# No need to pass nil for cc, bcc, attachments
</code></pre>
<p><strong>4. Easier to refactor:</strong></p>
<pre><code class="language-ruby"># Adding new parameter - easy!
def process(name:, email:, age: nil)
end

# Later, add another optional param
def process(name:, email:, age: nil, role: &#39;user&#39;)
end
# Existing calls still work!
</code></pre>
<hr>
<h3>Common Patterns</h3>
<p><strong>Builder Pattern:</strong></p>
<pre><code class="language-ruby">class QueryBuilder
  def initialize(table:)
    @table = table
    @conditions = []
    @order = nil
    @limit = nil
  end
  
  def where(field:, value:, operator: &#39;=&#39;)
    @conditions &lt;&lt; &quot;#{field} #{operator} &#39;#{value}&#39;&quot;
    self
  end
  
  def order(field:, direction: :asc)
    @order = &quot;#{field} #{direction.to_s.upcase}&quot;
    self
  end
  
  def limit(count:)
    @limit = count
    self
  end
  
  def to_sql
    sql = &quot;SELECT * FROM #{@table}&quot;
    sql += &quot; WHERE #{@conditions.join(&#39; AND &#39;)}&quot; if @conditions.any?
    sql += &quot; ORDER BY #{@order}&quot; if @order
    sql += &quot; LIMIT #{@limit}&quot; if @limit
    sql
  end
end

query = QueryBuilder.new(table: &#39;users&#39;)
  .where(field: &#39;age&#39;, value: 18, operator: &#39;&gt;&#39;)
  .where(field: &#39;active&#39;, value: true)
  .order(field: &#39;created_at&#39;, direction: :desc)
  .limit(count: 10)
  
puts query.to_sql
</code></pre>
<p><strong>Options Hash Pattern:</strong></p>
<pre><code class="language-ruby">def render_widget(type:, **options)
  defaults = {
    width: 300,
    height: 200,
    color: &#39;blue&#39;,
    border: true
  }
  
  settings = defaults.merge(options)
  
  &quot;Rendering #{type} widget: #{settings.inspect}&quot;
end

render_widget(type: &#39;chart&#39;, width: 500, color: &#39;red&#39;)
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Use keyword arguments for:</strong></p>
<ul>
<li>Methods with 3+ parameters</li>
<li>Methods with optional parameters</li>
<li>Configuration methods</li>
<li>Builder/factory methods</li>
</ul>
<p><strong>2. Use positional arguments for:</strong></p>
<ul>
<li>Methods with 1-2 obvious parameters</li>
<li>Very commonly called methods</li>
<li>Mathematical operations</li>
</ul>
<p><strong>3. Combine both when appropriate:</strong></p>
<pre><code class="language-ruby"># Good combination
def calculate_tax(amount, state:, county: nil, city: nil)
  # amount is obvious/required
  # location params benefit from being named
end

calculate_tax(1000, state: &#39;CA&#39;, city: &#39;SF&#39;)
</code></pre>
<p><strong>4. Required vs optional:</strong></p>
<pre><code class="language-ruby"># Make intent clear
def create_post(title:, body:, published: false, tags: [])
  # title and body required
  # published and tags optional with sensible defaults
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Keyword arguments</strong> pass by name, not position</li>
<li><strong>Required keywords</strong> have no default value (<code>:</code>)</li>
<li><strong>Optional keywords</strong> have default values (<code>key: value</code>)</li>
<li><strong><code>**kwargs</code></strong> collects extra keyword arguments</li>
<li><strong>Ruby 3.0+</strong> requires explicit <code>**</code> for hash-to-kwargs</li>
<li><strong>Self-documenting</strong> and <strong>order-independent</strong></li>
<li><strong>Ideal for</strong> configuration and multi-parameter methods</li>
</ol>
<hr>
<h2>Question 34: Explain Lazy Enumerators in Ruby</h2>
<h3>Answer</h3>
<p><strong>Lazy enumerators</strong> delay computation until values are actually needed. They enable working with infinite sequences and improve performance by avoiding unnecessary calculations.</p>
<hr>
<h3>Regular vs Lazy Enumerators</h3>
<p><strong>Regular (Eager):</strong></p>
<pre><code class="language-ruby"># Processes entire array immediately
result = (1..10).map { |n| n * 2 }
  .select { |n| n &gt; 10 }
  .first(3)

# Steps:
# 1. map creates [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
# 2. select creates [12, 14, 16, 18, 20]
# 3. first(3) returns [12, 14, 16]
# All values computed even though we only need 3
</code></pre>
<p><strong>Lazy:</strong></p>
<pre><code class="language-ruby"># Processes only what&#39;s needed
result = (1..10).lazy
  .map { |n| n * 2 }
  .select { |n| n &gt; 10 }
  .first(3)

# Only processes until 3 values found:
# 6 * 2 = 12 (keep)
# 7 * 2 = 14 (keep)
# 8 * 2 = 16 (keep)
# Stops! Returns [12, 14, 16]
</code></pre>
<hr>
<h3>Creating Lazy Enumerators</h3>
<pre><code class="language-ruby"># From range
lazy_range = (1..Float::INFINITY).lazy

# From array
lazy_array = [1, 2, 3, 4, 5].lazy

# From enumerator
lazy_enum = [1, 2, 3].each.lazy
</code></pre>
<hr>
<h3>Common Operations</h3>
<p><strong>Map:</strong></p>
<pre><code class="language-ruby"># Lazy map - no computation yet
lazy_mapped = (1..1000).lazy.map { |n| n * 2 }

# Force computation with first
lazy_mapped.first(5)  # [2, 4, 6, 8, 10]

# Or to_a (careful with infinite sequences!)
lazy_mapped.first(10).to_a
</code></pre>
<p><strong>Select:</strong></p>
<pre><code class="language-ruby">evens = (1..Float::INFINITY).lazy
  .select { |n| n.even? }
  .first(5)
# [2, 4, 6, 8, 10]
</code></pre>
<p><strong>Map + Select:</strong></p>
<pre><code class="language-ruby">result = (1..Float::INFINITY).lazy
  .map { |n| n ** 2 }
  .select { |n| n % 3 == 0 }
  .first(5)
# [9, 36, 81, 144, 225]
</code></pre>
<hr>
<h3>Infinite Sequences</h3>
<pre><code class="language-ruby"># Fibonacci sequence
fibonacci = Enumerator.new do |yielder|
  a, b = 0, 1
  loop do
    yielder &lt;&lt; a
    a, b = b, a + b
  end
end.lazy

# Get first 10 Fibonacci numbers
fibonacci.first(10)
# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

# All even Fibonacci numbers under 100
fibonacci.select { |n| n.even? }
  .take_while { |n| n &lt; 100 }
  .to_a
# [0, 2, 8, 34]
</code></pre>
<hr>
<h3>Performance Benefits</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

n = 1_000_000

Benchmark.bm do |x|
  x.report(&quot;Eager:&quot;) do
    (1..n).map { |i| i * 2 }
      .select { |i| i % 3 == 0 }
      .first(10)
  end
  
  x.report(&quot;Lazy:&quot;) do
    (1..n).lazy
      .map { |i| i * 2 }
      .select { |i| i % 3 == 0 }
      .first(10)
  end
end

# Lazy is much faster - only processes what&#39;s needed!
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: File Processing</strong></p>
<pre><code class="language-ruby"># BAD - loads entire file into memory
lines = File.readlines(&#39;large_file.log&#39;)
lines.select { |line| line.include?(&#39;ERROR&#39;) }
  .map { |line| parse_error(line) }
  .first(100)

# GOOD - lazy processing
File.open(&#39;large_file.log&#39;).lazy
  .select { |line| line.include?(&#39;ERROR&#39;) }
  .map { |line| parse_error(line) }
  .first(100)
# Stops after finding 100 errors
</code></pre>
<p><strong>Example 2: API Pagination</strong></p>
<pre><code class="language-ruby">class LazyAPI
  def self.all_users
    Enumerator.new do |yielder|
      page = 1
      loop do
        response = fetch_page(page)
        break if response.empty?
        
        response.each { |user| yielder &lt;&lt; user }
        page += 1
      end
    end.lazy
  end
  
  def self.fetch_page(page)
    # API call to fetch page
    HTTParty.get(&quot;https://api.example.com/users?page=#{page}&quot;)
  end
end

# Get first 50 users (only fetches necessary pages)
users = LazyAPI.all_users.first(50)

# Find first admin (stops when found)
admin = LazyAPI.all_users.find { |u| u[&#39;role&#39;] == &#39;admin&#39; }
</code></pre>
<p><strong>Example 3: Data Pipeline</strong></p>
<pre><code class="language-ruby"># Process stream of data
def process_events(event_stream)
  event_stream.lazy
    .select { |event| event[:type] == &#39;purchase&#39; }
    .map { |event| normalize(event) }
    .reject { |event| event[:amount] &lt; 10 }
    .map { |event| calculate_commission(event) }
    .each { |event| save_to_database(event) }
end

# Events processed one at a time as they arrive
process_events(EventStream.new)
</code></pre>
<hr>
<h3>Lazy Methods</h3>
<pre><code class="language-ruby">lazy_enum = (1..Float::INFINITY).lazy

# Transformations (lazy)
lazy_enum.map { |n| n * 2 }
lazy_enum.select { |n| n.even? }
lazy_enum.reject { |n| n.odd? }
lazy_enum.drop(5)
lazy_enum.drop_while { |n| n &lt; 10 }
lazy_enum.take(10)
lazy_enum.take_while { |n| n &lt; 100 }
lazy_enum.flat_map { |n| [n, n * 2] }
lazy_enum.zip([1, 2, 3])

# Terminal operations (eager)
lazy_enum.first(10)    # Returns array
lazy_enum.to_a         # Converts to array (careful!)
lazy_enum.force        # Same as to_a
lazy_enum.each { }     # Iterates
</code></pre>
<hr>
<h3>Custom Lazy Enumerators</h3>
<pre><code class="language-ruby"># Prime number generator
def primes
  Enumerator.new do |yielder|
    num = 2
    loop do
      yielder &lt;&lt; num if prime?(num)
      num += 1
    end
  end.lazy
end

def prime?(n)
  return false if n &lt; 2
  (2..Math.sqrt(n)).none? { |i| n % i == 0 }
end

# Get first 10 primes
primes.first(10)
# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

# Primes between 100 and 200
primes.drop_while { |n| n &lt; 100 }
  .take_while { |n| n &lt; 200 }
  .to_a
</code></pre>
<hr>
<h3>Lazy Evaluation in Rails</h3>
<pre><code class="language-ruby"># Lazy loading records
class User &lt; ApplicationRecord
  def self.active_users_lazy
    where(active: true).lazy
  end
end

# Process users one at a time
User.active_users_lazy
  .map { |user| send_email(user) }
  .first(100)
# Only loads 100 users from database
</code></pre>
<hr>
<h3>Common Pitfalls</h3>
<p><strong>1. Forgetting to terminate:</strong></p>
<pre><code class="language-ruby"># This never returns!
# (1..Float::INFINITY).lazy.map { |n| n * 2 }.to_a

# Always use a terminal operation with limits
(1..Float::INFINITY).lazy.map { |n| n * 2 }.first(10)
</code></pre>
<p><strong>2. Side effects in lazy chains:</strong></p>
<pre><code class="language-ruby"># Side effects happen only when values are consumed
counter = 0
lazy = (1..10).lazy.map do |n|
  counter += 1  # Not executed until values needed
  n * 2
end

counter  # Still 0

lazy.first(3)  # Now counter = 3
</code></pre>
<p><strong>3. Reusing lazy enumerators:</strong></p>
<pre><code class="language-ruby">lazy = (1..10).lazy.map { |n| n * 2 }

lazy.first(5)  # [2, 4, 6, 8, 10]
lazy.first(5)  # [2, 4, 6, 8, 10] - recalculates!

# Cache if needed
result = lazy.first(5)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Lazy enumerators</strong> delay computation until needed</li>
<li><strong>Enable infinite sequences</strong> without memory issues</li>
<li><strong>Improve performance</strong> by avoiding unnecessary work</li>
<li><strong>Created with</strong> <code>.lazy</code> method</li>
<li><strong>Terminated with</strong> <code>.first</code>, <code>.to_a</code>, <code>.force</code>, <code>.each</code></li>
<li><strong>Great for</strong> file processing, streaming, pagination</li>
<li><strong>Be careful</strong> with infinite sequences and <code>.to_a</code></li>
</ol>
<hr>
<h2>Question 35: What are Ruby Refinements, and how do they work?</h2>
<h3>Answer</h3>
<p><strong>Refinements</strong> provide lexically scoped monkey patching - you can modify classes within a specific scope without affecting the global behavior. They were introduced in Ruby 2.0 to address the dangers of traditional monkey patching.</p>
<hr>
<h3>Basic Refinement</h3>
<pre><code class="language-ruby"># Define refinement
module StringExtensions
  refine String do
    def shout
      self.upcase + &quot;!!!&quot;
    end
  end
end

# Without using refinement
&quot;hello&quot;.shout  # NoMethodError

# With refinement (scoped)
class MyClass
  using StringExtensions
  
  def test
    &quot;hello&quot;.shout  # &quot;HELLO!!!&quot;
  end
end

MyClass.new.test  # &quot;HELLO!!!&quot;

# Outside the class - refinement not active
&quot;hello&quot;.shout  # NoMethodError
</code></pre>
<hr>
<h3>Refinement vs Monkey Patching</h3>
<p><strong>Monkey Patching (Global):</strong></p>
<pre><code class="language-ruby">class String
  def shout
    self.upcase + &quot;!!!&quot;
  end
end

# Affects ALL code everywhere
&quot;hello&quot;.shout  # &quot;HELLO!!!&quot;

# In any file, any class
class OtherClass
  def test
    &quot;world&quot;.shout  # &quot;WORLD!!!&quot; - global change
  end
end
</code></pre>
<p><strong>Refinement (Scoped):</strong></p>
<pre><code class="language-ruby">module StringRefinements
  refine String do
    def shout
      self.upcase + &quot;!!!&quot;
    end
  end
end

class MyClass
  using StringRefinements
  
  def test
    &quot;hello&quot;.shout  # Works here
  end
end

class OtherClass
  def test
    &quot;hello&quot;.shout  # NoMethodError - not using refinement
  end
end
</code></pre>
<hr>
<h3>Using Refinements</h3>
<p><strong>In a class:</strong></p>
<pre><code class="language-ruby">module IntegerRefinements
  refine Integer do
    def even_or_odd
      even? ? &quot;even&quot; : &quot;odd&quot;
    end
  end
end

class Calculator
  using IntegerRefinements
  
  def classify(number)
    number.even_or_odd
  end
end

calc = Calculator.new
calc.classify(5)  # &quot;odd&quot;

# Outside class
5.even_or_odd  # NoMethodError
</code></pre>
<p><strong>In a module:</strong></p>
<pre><code class="language-ruby">module MathHelpers
  using IntegerRefinements
  
  def self.classify(number)
    number.even_or_odd
  end
end

MathHelpers.classify(4)  # &quot;even&quot;
</code></pre>
<p><strong>At top level (file scope):</strong></p>
<pre><code class="language-ruby"># my_script.rb
using StringRefinements

&quot;hello&quot;.shout  # Works in this file only
</code></pre>
<hr>
<h3>Multiple Refinements</h3>
<pre><code class="language-ruby">module StringRefinements
  refine String do
    def shout
      self.upcase + &quot;!!!&quot;
    end
  end
end

module IntegerRefinements
  refine Integer do
    def double
      self * 2
    end
  end
end

class MyClass
  using StringRefinements
  using IntegerRefinements
  
  def test
    puts &quot;hello&quot;.shout   # &quot;HELLO!!!&quot;
    puts 5.double        # 10
  end
end
</code></pre>
<hr>
<h3>Refining Core Classes</h3>
<pre><code class="language-ruby">module ArrayRefinements
  refine Array do
    def sum
      inject(0) { |total, n| total + n }
    end
    
    def average
      sum.to_f / size
    end
  end
end

class Statistics
  using ArrayRefinements
  
  def calculate(numbers)
    {
      sum: numbers.sum,
      average: numbers.average
    }
  end
end

stats = Statistics.new
stats.calculate([1, 2, 3, 4, 5])
# {:sum=&gt;15, :average=&gt;3.0}

# Outside class
[1, 2, 3].average  # NoMethodError
</code></pre>
<hr>
<h3>Practical Examples</h3>
<p><strong>Example 1: DSL with Refinements</strong></p>
<pre><code class="language-ruby">module DSLRefinements
  refine String do
    def to_route
      &quot;/#{self.downcase.gsub(&#39; &#39;, &#39;-&#39;)}&quot;
    end
  end
end

class Routes
  using DSLRefinements
  
  def self.define(&amp;block)
    @routes = []
    instance_eval(&amp;block)
    @routes
  end
  
  def self.get(path)
    @routes &lt;&lt; { method: :get, path: path.to_route }
  end
end

routes = Routes.define do
  get &quot;User Profile&quot;
  get &quot;Admin Dashboard&quot;
end

routes
# [
#   { method: :get, path: &quot;/user-profile&quot; },
#   { method: :get, path: &quot;/admin-dashboard&quot; }
# ]
</code></pre>
<p><strong>Example 2: Testing Helpers</strong></p>
<pre><code class="language-ruby">module TestRefinements
  refine Object do
    def should_equal(expected)
      raise &quot;Expected #{expected}, got #{self}&quot; unless self == expected
      true
    end
  end
end

class MyTest
  using TestRefinements
  
  def test_addition
    result = 2 + 2
    result.should_equal(4)  # Pass
  end
  
  def test_subtraction
    result = 5 - 2
    result.should_equal(3)  # Pass
  end
end
</code></pre>
<p><strong>Example 3: JSON Serialization</strong></p>
<pre><code class="language-ruby">module JSONRefinements
  refine Hash do
    def to_json_string
      &quot;{#{map { |k, v| &quot;\&quot;#{k}\&quot;:\&quot;#{v}\&quot;&quot; }.join(&#39;,&#39;)}}&quot;
    end
  end
end

class APIResponse
  using JSONRefinements
  
  def self.format(data)
    data.to_json_string
  end
end

data = { name: &quot;John&quot;, age: 30 }
APIResponse.format(data)
# &quot;{\&quot;name\&quot;:\&quot;John\&quot;,\&quot;age\&quot;:\&quot;30\&quot;}&quot;
</code></pre>
<hr>
<h3>Refinement Scope Rules</h3>
<p><strong>Where refinements work:</strong></p>
<ul>
<li>Inside the class/module using them</li>
<li>In methods defined in that class/module</li>
<li>In blocks passed to methods in that class/module</li>
</ul>
<p><strong>Where refinements DON&#39;T work:</strong></p>
<ul>
<li>Outside the using scope</li>
<li>In other files/classes</li>
<li>In eval/instance_eval/class_eval</li>
</ul>
<pre><code class="language-ruby">module Refinements
  refine String do
    def reversed
      reverse
    end
  end
end

class Test
  using Refinements
  
  def method1
    &quot;hello&quot;.reversed  # Works
  end
  
  def method2
    instance_eval do
      &quot;hello&quot;.reversed  # NoMethodError - doesn&#39;t work in eval
    end
  end
end
</code></pre>
<hr>
<h3>Inheritance and Refinements</h3>
<pre><code class="language-ruby">module Refinements
  refine String do
    def shout
      self.upcase + &quot;!!!&quot;
    end
  end
end

class Parent
  using Refinements
  
  def test
    &quot;parent&quot;.shout
  end
end

class Child &lt; Parent
  # Refinement NOT inherited!
  def test_child
    &quot;child&quot;.shout  # NoMethodError
  end
end

# Must use again in child
class Child &lt; Parent
  using Refinements
  
  def test_child
    &quot;child&quot;.shout  # &quot;CHILD!!!&quot;
  end
end
</code></pre>
<hr>
<h3>Limitations of Refinements</h3>
<p><strong>1. Not inherited:</strong></p>
<pre><code class="language-ruby">class Parent
  using SomeRefinement
end

class Child &lt; Parent
  # Refinement not available here
end
</code></pre>
<p><strong>2. Don&#39;t work with <code>send</code>:</strong></p>
<pre><code class="language-ruby">module Ref
  refine String do
    def custom
      &quot;custom&quot;
    end
  end
end

class Test
  using Ref
  
  def test1
    &quot;hello&quot;.custom  # Works
  end
  
  def test2
    &quot;hello&quot;.send(:custom)  # NoMethodError
  end
end
</code></pre>
<p><strong>3. Method visibility:</strong></p>
<pre><code class="language-ruby">module Ref
  refine String do
    private
    
    def secret
      &quot;secret&quot;
    end
  end
end

# private doesn&#39;t work in refinements
</code></pre>
<hr>
<h3>When to Use Refinements</h3>
<p><strong>Good use cases:</strong></p>
<ul>
<li>Internal DSLs</li>
<li>Testing frameworks</li>
<li>Temporary modifications in specific contexts</li>
<li>Safe extensions to core classes</li>
</ul>
<p><strong>Bad use cases:</strong></p>
<ul>
<li>Libraries (users can&#39;t benefit from refinements)</li>
<li>Public APIs</li>
<li>When you need global behavior</li>
<li>Cross-file modifications</li>
</ul>
<hr>
<h3>Refinements vs Alternatives</h3>
<p><strong>Use Refinement when:</strong></p>
<ul>
<li>Need temporary, scoped modification</li>
<li>Don&#39;t want to affect global state</li>
<li>Building internal tools/DSLs</li>
</ul>
<p><strong>Use Monkey Patch when:</strong></p>
<ul>
<li>Need global modification</li>
<li>Creating gem/library utilities</li>
<li>Backporting Ruby features</li>
</ul>
<p><strong>Use Decorator when:</strong></p>
<ul>
<li>Need instance-specific behavior</li>
<li>Want explicit wrapping</li>
<li>Prefer composition over modification</li>
</ul>
<pre><code class="language-ruby"># Decorator alternative
class ShoutString
  def initialize(string)
    @string = string
  end
  
  def shout
    @string.upcase + &quot;!!!&quot;
  end
  
  def method_missing(method, *args, &amp;block)
    @string.send(method, *args, &amp;block)
  end
end

ShoutString.new(&quot;hello&quot;).shout  # &quot;HELLO!!!&quot;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Refinements provide scoped modifications</strong> to classes</li>
<li><strong>Use <code>refine</code> to define</strong>, <code>using</code> to activate</li>
<li><strong>Lexically scoped</strong> - only work where <code>using</code> is called</li>
<li><strong>Not inherited</strong> by subclasses</li>
<li><strong>Don&#39;t work with <code>send</code></strong> or <code>eval</code></li>
<li><strong>Safer than monkey patching</strong> for core class modifications</li>
<li><strong>Limited adoption</strong> in community due to complexity</li>
<li><strong>Best for internal tools</strong>, not public libraries</li>
</ol>
<hr>
<h2>Question 36: What is the difference between <code>||=</code> and <code>=</code> in Ruby?</h2>
<h3>Answer</h3>
<p><strong><code>=</code></strong> is standard assignment. <strong><code>||=</code></strong> is conditional assignment - it only assigns if the variable is <code>nil</code> or <code>false</code>.</p>
<hr>
<h3>Basic Difference</h3>
<pre><code class="language-ruby"># Standard assignment (=)
x = 5
x = 10  # Overwrites, x is now 10

# Conditional assignment (||=)
x = 5
x ||= 10  # x stays 5 (not nil/false)

x = nil
x ||= 10  # x becomes 10 (was nil)
</code></pre>
<hr>
<h3>How ||= Works</h3>
<p><code>||=</code> is syntactic sugar for:</p>
<pre><code class="language-ruby">x ||= y
# Equivalent to:
x || (x = y)
# Or more verbosely:
x = x || y
</code></pre>
<p><strong>Important:</strong> It checks the current value, not the variable existence!</p>
<pre><code class="language-ruby">value ||= expensive_calculation

# Is the same as:
value = value || expensive_calculation

# NOT the same as:
if value.nil?
  value = expensive_calculation
end
</code></pre>
<hr>
<h3>Common Use Case: Memoization</h3>
<pre><code class="language-ruby">class User
  def full_name
    @full_name ||= &quot;#{first_name} #{last_name}&quot;
  end
  
  # Without ||=
  def full_name_verbose
    if @full_name.nil?
      @full_name = &quot;#{first_name} #{last_name}&quot;
    end
    @full_name
  end
end

# First call - calculates and caches
user.full_name  # Calculates: &quot;John Doe&quot;

# Subsequent calls - returns cached value
user.full_name  # Returns cached: &quot;John Doe&quot;
</code></pre>
<hr>
<h3>Gotcha: False Values</h3>
<pre><code class="language-ruby"># Problem with ||=
def admin?
  @admin ||= check_admin_status
end

# If check_admin_status returns false:
check_admin_status  # =&gt; false
@admin ||= check_admin_status  # Always calls check_admin_status!

# Because false is falsy, ||= keeps reassigning
</code></pre>
<p><strong>Solution: Check for <code>nil</code> explicitly</strong></p>
<pre><code class="language-ruby">def admin?
  return @admin unless @admin.nil?
  @admin = check_admin_status
end

# Or using defined?
def admin?
  @admin = check_admin_status unless defined?(@admin)
  @admin
end
</code></pre>
<hr>
<h3>Hash Default Values</h3>
<pre><code class="language-ruby">hash = {}

# Using ||=
hash[:key] ||= []
hash[:key] &lt;&lt; 1
hash[:key] &lt;&lt; 2
hash  # {:key=&gt;[1, 2]}

# First access creates empty array
hash[:another] ||= []

# Without ||=
hash[:key] = [] if hash[:key].nil?
hash[:key] &lt;&lt; 1
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Lazy Loading</strong></p>
<pre><code class="language-ruby">class Repository
  def users
    @users ||= User.all.to_a
  end
  
  def posts
    @posts ||= Post.all.to_a
  end
end

# First call hits database
repo.users  # SELECT * FROM users

# Subsequent calls use cache
repo.users  # No database query
</code></pre>
<p><strong>Example 2: Configuration</strong></p>
<pre><code class="language-ruby">class Config
  def self.timeout
    @timeout ||= ENV[&#39;TIMEOUT&#39;]&amp;.to_i || 30
  end
  
  def self.api_key
    @api_key ||= ENV[&#39;API_KEY&#39;] || raise(&quot;API_KEY not set&quot;)
  end
end

Config.timeout  # 30 (default)
Config.api_key  # Raises if not set
</code></pre>
<p><strong>Example 3: Counter with Default</strong></p>
<pre><code class="language-ruby">def increment_counter(name)
  @counters ||= {}
  @counters[name] ||= 0
  @counters[name] += 1
end

increment_counter(:views)  # 1
increment_counter(:views)  # 2
increment_counter(:clicks) # 1
</code></pre>
<p><strong>Example 4: Building Collections</strong></p>
<pre><code class="language-ruby">def group_by_category
  @groups ||= Hash.new { |h, k| h[k] = [] }
end

def add_item(category, item)
  group_by_category[category] &lt;&lt; item
end

add_item(:books, &quot;Ruby Book&quot;)
add_item(:books, &quot;Rails Book&quot;)
add_item(:videos, &quot;Ruby Video&quot;)
</code></pre>
<hr>
<h3>Rails Examples</h3>
<p><strong>ActiveRecord:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  def avatar_url
    @avatar_url ||= avatar.attached? ? avatar.url : default_avatar_url
  end
  
  def cached_posts
    @cached_posts ||= posts.published.order(created_at: :desc)
  end
end
</code></pre>
<p><strong>Controller:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
  
  def mobile_device?
    @mobile_device ||= request.user_agent.match?(/Mobile/)
  end
end
</code></pre>
<p><strong>Helper:</strong></p>
<pre><code class="language-ruby">module ApplicationHelper
  def page_title
    @page_title ||= &quot;Default Title&quot;
  end
  
  def meta_description
    @meta_description ||= &quot;Default description&quot;
  end
end
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

class Test
  def expensive_operation
    sleep 0.1
    &quot;result&quot;
  end
  
  # Without memoization
  def method1
    expensive_operation
  end
  
  # With ||= memoization
  def method2
    @cached ||= expensive_operation
  end
end

test = Test.new

Benchmark.bm do |x|
  x.report(&quot;No cache:&quot;) do
    10.times { test.method1 }  # 1 second (10 * 0.1)
  end
  
  x.report(&quot;With ||=:&quot;) do
    10.times { test.method2 }  # 0.1 second (cached)
  end
end
</code></pre>
<hr>
<h3>When NOT to Use ||=</h3>
<p><strong>1. Boolean values:</strong></p>
<pre><code class="language-ruby"># BAD
def enabled?
  @enabled ||= check_enabled  # Broken if false!
end

# GOOD
def enabled?
  return @enabled unless @enabled.nil?
  @enabled = check_enabled
end
</code></pre>
<p><strong>2. Values that can be false or nil:</strong></p>
<pre><code class="language-ruby"># BAD
def find_user
  @user ||= User.find_by(id: params[:id])  # Re-queries if user nil
end

# GOOD
def find_user
  return @user if defined?(@user)
  @user = User.find_by(id: params[:id])
end
</code></pre>
<p><strong>3. Arrays/Hashes that should be empty:</strong></p>
<pre><code class="language-ruby"># BAD
def items
  @items ||= []  # Always creates new array if empty
end

items &lt;&lt; 1
items.clear
items  # [] (new array, not the cleared one)

# GOOD
def items
  @items ||= []
end

def reset_items
  @items = []
end
</code></pre>
<hr>
<h3>Alternative Patterns</h3>
<p><strong>Using <code>defined?</code>:</strong></p>
<pre><code class="language-ruby">def value
  return @value if defined?(@value)
  @value = expensive_calculation
end
</code></pre>
<p><strong>Using <code>fetch</code>:</strong></p>
<pre><code class="language-ruby">hash.fetch(:key) { expensive_default }
# Only calculates default if key doesn&#39;t exist
</code></pre>
<p><strong>Explicit nil check:</strong></p>
<pre><code class="language-ruby">def value
  @value.nil? ? @value = calculate : @value
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>=</code></strong> always assigns, <strong><code>||=</code></strong> only assigns if nil/false</li>
<li><strong><code>||=</code></strong> is syntactic sugar for <code>x = x || y</code></li>
<li><strong>Great for memoization</strong> and lazy loading</li>
<li><strong>Careful with false values</strong> - use <code>defined?</code> instead</li>
<li><strong>Common in Rails</strong> for caching expensive operations</li>
<li><strong>Not thread-safe</strong> - use mutex for concurrent access</li>
<li><strong>Don&#39;t use for boolean values</strong> that can be false</li>
</ol>
<hr>
<h2>Question 37: How do you define and use singleton methods?</h2>
<h3>Answer</h3>
<p><strong>Singleton methods</strong> are methods defined for a specific object (instance) rather than for all instances of a class. They exist only on that one object.</p>
<hr>
<h3>Basic Singleton Method</h3>
<pre><code class="language-ruby">str = &quot;hello&quot;

# Define singleton method
def str.shout
  self.upcase + &quot;!!!&quot;
end

str.shout  # &quot;HELLO!!!&quot;

# Other strings don&#39;t have this method
&quot;world&quot;.shout  # NoMethodError
</code></pre>
<hr>
<h3>Different Ways to Define Singleton Methods</h3>
<p><strong>1. Using <code>def object.method</code>:</strong></p>
<pre><code class="language-ruby">user = User.new

def user.admin_access
  &quot;Admin access granted&quot;
end

user.admin_access  # &quot;Admin access granted&quot;
</code></pre>
<p><strong>2. Using <code>class &lt;&lt; object</code> (singleton class):</strong></p>
<pre><code class="language-ruby">user = User.new

class &lt;&lt; user
  def admin_access
    &quot;Admin access granted&quot;
  end
  
  def special_method
    &quot;Special method&quot;
  end
end

user.admin_access  # Works
user.special_method  # Works
</code></pre>
<p><strong>3. Using <code>define_singleton_method</code>:</strong></p>
<pre><code class="language-ruby">user = User.new

user.define_singleton_method(:admin_access) do
  &quot;Admin access granted&quot;
end

user.admin_access  # Works
</code></pre>
<p><strong>4. Using <code>instance_eval</code>:</strong></p>
<pre><code class="language-ruby">user = User.new

user.instance_eval do
  def admin_access
    &quot;Admin access granted&quot;
  end
end

user.admin_access  # Works
</code></pre>
<hr>
<h3>Class Methods Are Singleton Methods</h3>
<p>Class methods are actually singleton methods defined on the class object:</p>
<pre><code class="language-ruby">class User
  # These are all equivalent:
  
  # Method 1: self.method_name
  def self.count
    &quot;Counting...&quot;
  end
  
  # Method 2: class &lt;&lt; self
  class &lt;&lt; self
    def total
      &quot;Total...&quot;
    end
  end
  
  # Method 3: User.method_name (outside class)
end

def User.custom
  &quot;Custom...&quot;
end

# All are singleton methods on User class object
User.count
User.total
User.custom
</code></pre>
<hr>
<h3>Practical Examples</h3>
<p><strong>Example 1: Dynamic Permissions</strong></p>
<pre><code class="language-ruby">class User
  attr_accessor :name, :role
  
  def initialize(name, role)
    @name = name
    @role = role
    grant_role_abilities
  end
  
  private
  
  def grant_role_abilities
    case role
    when :admin
      grant_admin_abilities
    when :moderator
      grant_moderator_abilities
    end
  end
  
  def grant_admin_abilities
    class &lt;&lt; self
      def delete_user(user_id)
        &quot;Deleting user #{user_id}&quot;
      end
      
      def access_logs
        &quot;Accessing logs&quot;
      end
    end
  end
  
  def grant_moderator_abilities
    class &lt;&lt; self
      def ban_user(user_id)
        &quot;Banning user #{user_id}&quot;
      end
    end
  end
end

admin = User.new(&quot;Alice&quot;, :admin)
admin.delete_user(123)  # Works
admin.access_logs       # Works

moderator = User.new(&quot;Bob&quot;, :moderator)
moderator.ban_user(456)  # Works
# moderator.delete_user(123)  # NoMethodError

regular = User.new(&quot;Charlie&quot;, :user)
# regular.ban_user(123)  # NoMethodError
</code></pre>
<p><strong>Example 2: Decorator Pattern</strong></p>
<pre><code class="language-ruby">def add_logging(obj)
  obj.instance_eval do
    def save
      puts &quot;Saving #{self.class.name}...&quot;
      super
    end
  end if obj.respond_to?(:save)
end

user = User.new
add_logging(user)
user.save  # Logs before saving
</code></pre>
<p><strong>Example 3: Feature Flags</strong></p>
<pre><code class="language-ruby">class Feature
  attr_reader :name
  
  def initialize(name)
    @name = name
  end
  
  def enable!
    define_singleton_method(:enabled?) { true }
    define_singleton_method(:disabled?) { false }
  end
  
  def disable!
    define_singleton_method(:enabled?) { false }
    define_singleton_method(:disabled?) { true }
  end
end

feature = Feature.new(:new_ui)
feature.enable!
feature.enabled?  # true

feature.disable!
feature.enabled?  # false
</code></pre>
<p><strong>Example 4: Mock Objects in Testing</strong></p>
<pre><code class="language-ruby"># Test double with singleton methods
def create_mock_user
  mock = Object.new
  
  mock.define_singleton_method(:name) { &quot;Mock User&quot; }
  mock.define_singleton_method(:email) { &quot;mock@example.com&quot; }
  mock.define_singleton_method(:admin?) { true }
  
  mock
end

user = create_mock_user
user.name   # &quot;Mock User&quot;
user.admin? # true
</code></pre>
<hr>
<h3>Checking for Singleton Methods</h3>
<pre><code class="language-ruby">user = User.new

def user.special
  &quot;special&quot;
end

# List singleton methods
user.singleton_methods  # [:special]

# Check if object has singleton class
user.singleton_class  # #&lt;Class:#&lt;User:0x...&gt;&gt;

# Get singleton method
method = user.method(:special)
method.call  # &quot;special&quot;
</code></pre>
<hr>
<h3>Removing Singleton Methods</h3>
<pre><code class="language-ruby">user = User.new

def user.custom_method
  &quot;custom&quot;
end

user.custom_method  # &quot;custom&quot;

# Remove singleton method
user.singleton_class.send(:remove_method, :custom_method)

user.custom_method  # NoMethodError
</code></pre>
<hr>
<h3>Singleton Methods and Inheritance</h3>
<pre><code class="language-ruby">class Animal
  def speak
    &quot;Some sound&quot;
  end
end

class Dog &lt; Animal
end

dog = Dog.new

# Add singleton method
def dog.speak
  &quot;Woof!&quot;
end

dog.speak  # &quot;Woof!&quot; (singleton method)

# Other dogs use class method
Dog.new.speak  # &quot;Some sound&quot;

# Method lookup:
# 1. Object&#39;s singleton class
# 2. Object&#39;s class
# 3. Parent classes
</code></pre>
<hr>
<h3>Rails Examples</h3>
<p><strong>ActiveRecord:</strong></p>
<pre><code class="language-ruby"># Add method to specific record
user = User.first

def user.display_name
  &quot;#{name} (#{email})&quot;
end

user.display_name  # &quot;John (john@example.com)&quot;

# Doesn&#39;t affect other users
User.last.display_name  # NoMethodError
</code></pre>
<p><strong>Controller:</strong></p>
<pre><code class="language-ruby">class ApplicationController
  # Class methods are singleton methods
  def self.skip_auth(*actions)
    skip_before_action :authenticate_user!, only: actions
  end
end

class PostsController &lt; ApplicationController
  skip_auth :index, :show
end
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-ruby"># Creating many objects with singleton methods
# Can be expensive

# BAD
1000.times do
  obj = Object.new
  def obj.custom; &quot;custom&quot;; end
end

# BETTER - use a class
class CustomObject
  def custom
    &quot;custom&quot;
  end
end

1000.times { CustomObject.new }
</code></pre>
<hr>
<h3>Use Cases</h3>
<p><strong>When to use singleton methods:</strong></p>
<ul>
<li>Unique behavior for one object</li>
<li>Mocking/stubbing in tests</li>
<li>Dynamic permission systems</li>
<li>Decorating specific instances</li>
<li>Prototype pattern</li>
</ul>
<p><strong>When NOT to use:</strong></p>
<ul>
<li>Behavior needed by all instances (use class methods)</li>
<li>Performance-critical code (overhead of singleton class)</li>
<li>Shared behavior (use mixins)</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Singleton methods</strong> exist on specific objects only</li>
<li><strong>Class methods</strong> are singleton methods on class objects</li>
<li><strong>Define with</strong> <code>def obj.method</code>, <code>class &lt;&lt; obj</code>, <code>define_singleton_method</code></li>
<li><strong>Useful for</strong> per-instance behavior and testing</li>
<li><strong>Check with</strong> <code>singleton_methods</code></li>
<li><strong>Stored in</strong> object&#39;s singleton class (eigenclass)</li>
<li><strong>Can be removed</strong> with <code>remove_method</code></li>
<li><strong>Performance cost</strong> - use judiciously</li>
</ol>
<h1>Ruby Advanced Concepts - Part 2</h1>
<h2>Question 38: What are Ruby Gems, and how do you create one?</h2>
<h3>Answer</h3>
<p><strong>Ruby Gems</strong> are packaged Ruby libraries/applications that can be easily distributed and installed. They&#39;re Ruby&#39;s package management system.</p>
<hr>
<h3>What is a Gem?</h3>
<p>A gem contains:</p>
<ul>
<li><strong>Ruby code</strong> (lib/)</li>
<li><strong>Documentation</strong> (README, CHANGELOG)</li>
<li><strong>Gemspec</strong> (metadata file)</li>
<li><strong>Tests</strong> (spec/ or test/)</li>
<li><strong>Executables</strong> (bin/)</li>
</ul>
<hr>
<h3>Using Gems</h3>
<p><strong>Install a gem:</strong></p>
<pre><code class="language-bash">gem install rails
gem install rspec
gem install pry
</code></pre>
<p><strong>In a Gemfile (Bundler):</strong></p>
<pre><code class="language-ruby"># Gemfile
source &#39;https://rubygems.org&#39;

gem &#39;rails&#39;, &#39;~&gt; 7.0&#39;
gem &#39;pg&#39;, &#39;&gt;= 1.0&#39;
gem &#39;puma&#39;
gem &#39;redis&#39;
</code></pre>
<pre><code class="language-bash">bundle install
</code></pre>
<hr>
<h3>Creating a Gem</h3>
<p><strong>Step 1: Generate gem skeleton</strong></p>
<pre><code class="language-bash">bundle gem my_awesome_gem

# Creates:
# my_awesome_gem/
#   ├── Gemfile
#   ├── Rakefile
#   ├── README.md
#   ├── my_awesome_gem.gemspec
#   ├── lib/
#   │   ├── my_awesome_gem.rb
#   │   ├── my_awesome_gem/
#   │   │   └── version.rb
#   ├── spec/
#   │   └── spec_helper.rb
#   └── bin/
#       ├── console
#       └── setup
</code></pre>
<p><strong>Step 2: Edit the gemspec</strong></p>
<pre><code class="language-ruby"># my_awesome_gem.gemspec
Gem::Specification.new do |spec|
  spec.name          = &quot;my_awesome_gem&quot;
  spec.version       = MyAwesomeGem::VERSION
  spec.authors       = [&quot;Your Name&quot;]
  spec.email         = [&quot;your.email@example.com&quot;]
  
  spec.summary       = &quot;A brief summary&quot;
  spec.description   = &quot;A longer description&quot;
  spec.homepage      = &quot;https://github.com/username/my_awesome_gem&quot;
  spec.license       = &quot;MIT&quot;
  
  # Files
  spec.files         = Dir[&quot;lib/**/*&quot;, &quot;README.md&quot;, &quot;LICENSE.txt&quot;]
  spec.require_paths = [&quot;lib&quot;]
  
  # Dependencies
  spec.add_dependency &quot;activesupport&quot;, &quot;~&gt; 7.0&quot;
  
  # Development dependencies
  spec.add_development_dependency &quot;rspec&quot;, &quot;~&gt; 3.0&quot;
  spec.add_development_dependency &quot;bundler&quot;
  spec.add_development_dependency &quot;rake&quot;
end
</code></pre>
<p><strong>Step 3: Write your code</strong></p>
<pre><code class="language-ruby"># lib/my_awesome_gem.rb
require_relative &quot;my_awesome_gem/version&quot;
require_relative &quot;my_awesome_gem/calculator&quot;
require_relative &quot;my_awesome_gem/formatter&quot;

module MyAwesomeGem
  class Error &lt; StandardError; end
  
  def self.root
    File.dirname __dir__
  end
end
</code></pre>
<pre><code class="language-ruby"># lib/my_awesome_gem/version.rb
module MyAwesomeGem
  VERSION = &quot;0.1.0&quot;
end
</code></pre>
<pre><code class="language-ruby"># lib/my_awesome_gem/calculator.rb
module MyAwesomeGem
  class Calculator
    def self.add(a, b)
      a + b
    end
    
    def self.multiply(a, b)
      a * b
    end
  end
end
</code></pre>
<p><strong>Step 4: Write tests</strong></p>
<pre><code class="language-ruby"># spec/my_awesome_gem/calculator_spec.rb
require &#39;spec_helper&#39;

RSpec.describe MyAwesomeGem::Calculator do
  describe &#39;.add&#39; do
    it &#39;adds two numbers&#39; do
      expect(described_class.add(2, 3)).to eq(5)
    end
  end
  
  describe &#39;.multiply&#39; do
    it &#39;multiplies two numbers&#39; do
      expect(described_class.multiply(2, 3)).to eq(6)
    end
  end
end
</code></pre>
<p><strong>Step 5: Build and install locally</strong></p>
<pre><code class="language-bash"># Build the gem
gem build my_awesome_gem.gemspec

# Install locally
gem install ./my_awesome_gem-0.1.0.gem

# Test it
irb
&gt; require &#39;my_awesome_gem&#39;
&gt; MyAwesomeGem::Calculator.add(5, 3)
# =&gt; 8
</code></pre>
<p><strong>Step 6: Publish to RubyGems.org</strong></p>
<pre><code class="language-bash"># First time setup
gem signin

# Push gem
gem push my_awesome_gem-0.1.0.gem
</code></pre>
<hr>
<h3>Real-World Gem Example</h3>
<p><strong>String Manipulation Gem:</strong></p>
<pre><code class="language-ruby"># lib/string_tools.rb
require_relative &quot;string_tools/version&quot;
require_relative &quot;string_tools/inflector&quot;
require_relative &quot;string_tools/sanitizer&quot;

module StringTools
  class Error &lt; StandardError; end
end
</code></pre>
<pre><code class="language-ruby"># lib/string_tools/inflector.rb
module StringTools
  class Inflector
    def self.pluralize(word)
      return word if word.end_with?(&#39;s&#39;)
      word + &#39;s&#39;
    end
    
    def self.singularize(word)
      word.end_with?(&#39;s&#39;) ? word[0..-2] : word
    end
    
    def self.titleize(text)
      text.split.map(&amp;:capitalize).join(&#39; &#39;)
    end
  end
end
</code></pre>
<pre><code class="language-ruby"># lib/string_tools/sanitizer.rb
module StringTools
  class Sanitizer
    def self.remove_html(text)
      text.gsub(/&lt;[^&gt;]+&gt;/, &#39;&#39;)
    end
    
    def self.strip_whitespace(text)
      text.strip.gsub(/\s+/, &#39; &#39;)
    end
    
    def self.slugify(text)
      text.downcase.gsub(/[^a-z0-9]+/, &#39;-&#39;).gsub(/-+$|^-+/, &#39;&#39;)
    end
  end
end
</code></pre>
<pre><code class="language-ruby"># string_tools.gemspec
Gem::Specification.new do |spec|
  spec.name          = &quot;string_tools&quot;
  spec.version       = &quot;1.0.0&quot;
  spec.authors       = [&quot;Developer&quot;]
  spec.email         = [&quot;dev@example.com&quot;]
  
  spec.summary       = &quot;String manipulation utilities&quot;
  spec.description   = &quot;A collection of useful string manipulation methods&quot;
  spec.homepage      = &quot;https://github.com/dev/string_tools&quot;
  spec.license       = &quot;MIT&quot;
  
  spec.files         = Dir[&quot;lib/**/*&quot;]
  spec.require_paths = [&quot;lib&quot;]
  
  spec.add_development_dependency &quot;rspec&quot;, &quot;~&gt; 3.12&quot;
end
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-ruby">require &#39;string_tools&#39;

StringTools::Inflector.pluralize(&quot;cat&quot;)  # &quot;cats&quot;
StringTools::Inflector.titleize(&quot;hello world&quot;)  # &quot;Hello World&quot;
StringTools::Sanitizer.slugify(&quot;Hello World!&quot;)  # &quot;hello-world&quot;
</code></pre>
<hr>
<h3>Gem with Executable</h3>
<p><strong>Add CLI tool:</strong></p>
<pre><code class="language-ruby"># bin/string_tools
#!/usr/bin/env ruby

require &#39;string_tools&#39;

command = ARGV[0]
text = ARGV[1..-1].join(&#39; &#39;)

case command
when &#39;slugify&#39;
  puts StringTools::Sanitizer.slugify(text)
when &#39;titleize&#39;
  puts StringTools::Inflector.titleize(text)
when &#39;pluralize&#39;
  puts StringTools::Inflector.pluralize(text)
else
  puts &quot;Usage: string_tools &lt;command&gt; &lt;text&gt;&quot;
  puts &quot;Commands: slugify, titleize, pluralize&quot;
end
</code></pre>
<p><strong>Update gemspec:</strong></p>
<pre><code class="language-ruby">spec.executables = [&quot;string_tools&quot;]
spec.bindir      = &quot;bin&quot;
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">string_tools slugify &quot;Hello World&quot;
# hello-world

string_tools titleize &quot;hello world&quot;
# Hello World
</code></pre>
<hr>
<h3>Gem with Configuration</h3>
<pre><code class="language-ruby"># lib/my_gem.rb
module MyGem
  class Configuration
    attr_accessor :api_key, :timeout, :retries
    
    def initialize
      @api_key = nil
      @timeout = 30
      @retries = 3
    end
  end
  
  class &lt;&lt; self
    attr_writer :configuration
    
    def configuration
      @configuration ||= Configuration.new
    end
    
    def configure
      yield(configuration)
    end
    
    def reset_configuration!
      @configuration = Configuration.new
    end
  end
end

# Usage:
MyGem.configure do |config|
  config.api_key = &quot;secret123&quot;
  config.timeout = 60
end
</code></pre>
<hr>
<h3>Rails Engine Gem</h3>
<pre><code class="language-ruby"># lib/my_engine.rb
require &quot;my_engine/engine&quot;
require &quot;my_engine/version&quot;

module MyEngine
end
</code></pre>
<pre><code class="language-ruby"># lib/my_engine/engine.rb
module MyEngine
  class Engine &lt; ::Rails::Engine
    isolate_namespace MyEngine
    
    initializer &quot;my_engine.load_config&quot; do
      # Initialization code
    end
  end
end
</code></pre>
<pre><code class="language-ruby"># app/controllers/my_engine/posts_controller.rb
module MyEngine
  class PostsController &lt; ApplicationController
    def index
      @posts = Post.all
    end
  end
end
</code></pre>
<p><strong>Mount in host app:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  mount MyEngine::Engine, at: &quot;/blog&quot;
end
</code></pre>
<hr>
<h3>Versioning</h3>
<p><strong>Semantic Versioning (MAJOR.MINOR.PATCH):</strong></p>
<pre><code class="language-ruby"># MAJOR: Breaking changes (1.0.0 -&gt; 2.0.0)
# MINOR: New features, backward compatible (1.0.0 -&gt; 1.1.0)
# PATCH: Bug fixes (1.0.0 -&gt; 1.0.1)

module MyGem
  VERSION = &quot;1.2.3&quot;
end
</code></pre>
<p><strong>Update version:</strong></p>
<pre><code class="language-ruby"># Increment patch
&quot;1.2.3&quot; -&gt; &quot;1.2.4&quot;

# Increment minor
&quot;1.2.3&quot; -&gt; &quot;1.3.0&quot;

# Increment major
&quot;1.2.3&quot; -&gt; &quot;2.0.0&quot;
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Clear naming:</strong></p>
<pre><code class="language-ruby"># Good
gem &quot;active_model_serializers&quot;
gem &quot;devise&quot;
gem &quot;pundit&quot;

# Avoid
gem &quot;my_cool_gem&quot;
gem &quot;utils&quot;
</code></pre>
<p><strong>2. Comprehensive README:</strong></p>
<pre><code class="language-markdown"># My Gem

## Installation
```ruby
gem &#39;my_gem&#39;
</code></pre>
<h2>Usage</h2>
<pre><code class="language-ruby">MyGem.do_something
</code></pre>
<h2>Configuration</h2>
<pre><code class="language-ruby">MyGem.configure do |config|
  config.option = &#39;value&#39;
end
</code></pre>
<pre><code>
**3. Semantic versioning:**
```ruby
# Breaking change
1.0.0 -&gt; 2.0.0

# New feature
1.0.0 -&gt; 1.1.0

# Bug fix
1.0.0 -&gt; 1.0.1
</code></pre>
<p><strong>4. Comprehensive tests:</strong></p>
<pre><code class="language-ruby"># spec/my_gem_spec.rb
RSpec.describe MyGem do
  describe &#39;.configure&#39; do
    it &#39;yields configuration&#39; do
      MyGem.configure do |config|
        config.api_key = &#39;test&#39;
      end
      
      expect(MyGem.configuration.api_key).to eq(&#39;test&#39;)
    end
  end
end
</code></pre>
<p><strong>5. Documentation:</strong></p>
<pre><code class="language-ruby"># Use YARD
# @param [String] name The user&#39;s name
# @return [String] A greeting message
def greet(name)
  &quot;Hello, #{name}!&quot;
end
</code></pre>
<hr>
<h3>Popular Gem Examples</h3>
<p><strong>Devise (Authentication):</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;devise&#39;

# Model
class User &lt; ApplicationRecord
  devise :database_authenticatable, :registerable
end
</code></pre>
<p><strong>Pundit (Authorization):</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;pundit&#39;

# Policy
class PostPolicy &lt; ApplicationPolicy
  def update?
    user.admin? || record.user == user
  end
end
</code></pre>
<p><strong>Sidekiq (Background Jobs):</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;sidekiq&#39;

# Worker
class HardWorker
  include Sidekiq::Worker
  
  def perform(name, count)
    # Do work
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Gems</strong> are Ruby&#39;s package management system</li>
<li><strong>Create with</strong> <code>bundle gem name</code></li>
<li><strong>Define metadata</strong> in <code>.gemspec</code> file</li>
<li><strong>Organize code</strong> in <code>lib/</code> directory</li>
<li><strong>Add executables</strong> in <code>bin/</code> directory</li>
<li><strong>Write tests</strong> in <code>spec/</code> or <code>test/</code></li>
<li><strong>Use semantic versioning</strong> (MAJOR.MINOR.PATCH)</li>
<li><strong>Publish to</strong> RubyGems.org with <code>gem push</code></li>
<li><strong>Good README</strong> and documentation essential</li>
<li><strong>Follow conventions</strong> for maintainability</li>
</ol>
<h1>Ruby Concurrency and Performance Interview Questions</h1>
<h2>Question 39: How does Ruby handle concurrency and parallelism?</h2>
<h3>Answer</h3>
<p>Ruby handles concurrency through <strong>threads</strong>, but true parallelism is limited by the <strong>Global Interpreter Lock (GIL)</strong> in MRI Ruby. Understanding this distinction is crucial for performance optimization.</p>
<hr>
<h3>Key Concepts</h3>
<p><strong>Concurrency:</strong> Multiple tasks making progress (not necessarily simultaneously)
<strong>Parallelism:</strong> Multiple tasks executing at the exact same time
<strong>GIL (Global Interpreter Lock):</strong> Prevents multiple Ruby threads from executing Ruby code simultaneously</p>
<hr>
<h3>The Global Interpreter Lock (GIL)</h3>
<p><strong>MRI/CRuby (default Ruby):</strong></p>
<pre><code class="language-ruby"># Threads are concurrent but NOT parallel
threads = 3.times.map do
  Thread.new do
    5.times { puts &quot;#{Thread.current.object_id}: Working&quot; }
  end
end

threads.each(&amp;:join)
# Threads interleave but don&#39;t run in parallel
# Only one thread executes Ruby code at a time
</code></pre>
<p><strong>Impact of GIL:</strong></p>
<ul>
<li>✅ I/O operations CAN run in parallel (network, disk, database)</li>
<li>❌ CPU-bound Ruby code CANNOT run in parallel</li>
<li>✅ Thread-safe by default (simpler)</li>
<li>❌ Can&#39;t utilize multiple CPU cores for pure Ruby code</li>
</ul>
<hr>
<h3>Thread Basics</h3>
<pre><code class="language-ruby"># Create a thread
thread = Thread.new do
  puts &quot;Hello from thread&quot;
  sleep 1
  puts &quot;Thread done&quot;
end

# Wait for thread to finish
thread.join

# Check thread status
thread.alive?  # false
thread.status  # nil (dead)
</code></pre>
<hr>
<h3>Multiple Threads</h3>
<pre><code class="language-ruby">threads = []

5.times do |i|
  threads &lt;&lt; Thread.new(i) do |num|
    puts &quot;Thread #{num} starting&quot;
    sleep rand(1..3)
    puts &quot;Thread #{num} done&quot;
  end
end

# Wait for all threads
threads.each(&amp;:join)
</code></pre>
<hr>
<h3>I/O-Bound vs CPU-Bound</h3>
<p><strong>I/O-Bound (threads help!):</strong></p>
<pre><code class="language-ruby">require &#39;net/http&#39;
require &#39;benchmark&#39;

urls = [
  &#39;https://example.com&#39;,
  &#39;https://google.com&#39;,
  &#39;https://github.com&#39;
]

# Sequential - slow
Benchmark.bm do |x|
  x.report(&quot;Sequential:&quot;) do
    urls.each { |url| Net::HTTP.get(URI(url)) }
  end
  
  # Parallel - fast!
  x.report(&quot;Threaded:&quot;) do
    threads = urls.map do |url|
      Thread.new { Net::HTTP.get(URI(url)) }
    end
    threads.each(&amp;:join)
  end
end

# Threaded is much faster for I/O!
</code></pre>
<p><strong>CPU-Bound (threads don&#39;t help!):</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

def fibonacci(n)
  return n if n &lt;= 1
  fibonacci(n - 1) + fibonacci(n - 2)
end

Benchmark.bm do |x|
  x.report(&quot;Sequential:&quot;) do
    3.times { fibonacci(35) }
  end
  
  x.report(&quot;Threaded:&quot;) do
    threads = 3.times.map do
      Thread.new { fibonacci(35) }
    end
    threads.each(&amp;:join)
  end
end

# Threaded is NOT faster (GIL prevents parallel execution)
</code></pre>
<hr>
<h3>Process Forking (True Parallelism)</h3>
<pre><code class="language-ruby"># Fork process - true parallelism!
pid = fork do
  puts &quot;Child process: #{Process.pid}&quot;
  sleep 2
  puts &quot;Child done&quot;
end

puts &quot;Parent process: #{Process.pid}&quot;
Process.wait(pid)  # Wait for child
puts &quot;Parent done&quot;
</code></pre>
<p><strong>Multiple forks:</strong></p>
<pre><code class="language-ruby">pids = []

3.times do |i|
  pids &lt;&lt; fork do
    puts &quot;Process #{i} (PID: #{Process.pid})&quot;
    result = expensive_calculation
    exit  # Exit child process
  end
end

# Wait for all children
pids.each { |pid| Process.wait(pid) }
</code></pre>
<hr>
<h3>Ractors (Ruby 3.0+)</h3>
<p><strong>True parallel execution without GIL!</strong></p>
<pre><code class="language-ruby"># Create ractor
ractor = Ractor.new do
  result = expensive_calculation
  result
end

# Get result
value = ractor.take  # Blocks until result ready
</code></pre>
<p><strong>Multiple ractors:</strong></p>
<pre><code class="language-ruby">ractors = 3.times.map do |i|
  Ractor.new(i) do |num|
    puts &quot;Ractor #{num} working&quot;
    sleep 1
    num * 2
  end
end

# Collect results
results = ractors.map(&amp;:take)
puts results.inspect  # [0, 2, 4]
</code></pre>
<hr>
<h3>Thread Safety</h3>
<p><strong>Thread-unsafe code:</strong></p>
<pre><code class="language-ruby">counter = 0
threads = []

100.times do
  threads &lt;&lt; Thread.new do
    1000.times { counter += 1 }
  end
end

threads.each(&amp;:join)
puts counter  # Not 100,000! (race condition)
</code></pre>
<p><strong>Thread-safe with Mutex:</strong></p>
<pre><code class="language-ruby">counter = 0
mutex = Mutex.new
threads = []

100.times do
  threads &lt;&lt; Thread.new do
    1000.times do
      mutex.synchronize { counter += 1 }
    end
  end
end

threads.each(&amp;:join)
puts counter  # 100,000 (correct!)
</code></pre>
<hr>
<h3>Real-World Concurrency Patterns</h3>
<p><strong>Example 1: Concurrent API Requests</strong></p>
<pre><code class="language-ruby">class APIFetcher
  def fetch_all(urls)
    threads = urls.map do |url|
      Thread.new do
        begin
          response = HTTP.get(url)
          { url: url, data: response.body, error: nil }
        rescue =&gt; e
          { url: url, data: nil, error: e.message }
        end
      end
    end
    
    threads.map(&amp;:value)  # Wait and collect results
  end
end

fetcher = APIFetcher.new
results = fetcher.fetch_all([
  &#39;https://api1.example.com/users&#39;,
  &#39;https://api2.example.com/posts&#39;,
  &#39;https://api3.example.com/comments&#39;
])
</code></pre>
<p><strong>Example 2: Background Worker Pool</strong></p>
<pre><code class="language-ruby">require &#39;thread&#39;

class WorkerPool
  def initialize(size)
    @size = size
    @queue = Queue.new
    @workers = []
    
    start_workers
  end
  
  def schedule(&amp;block)
    @queue &lt;&lt; block
  end
  
  def shutdown
    @size.times { @queue &lt;&lt; nil }  # Signal workers to stop
    @workers.each(&amp;:join)
  end
  
  private
  
  def start_workers
    @size.times do
      @workers &lt;&lt; Thread.new do
        loop do
          job = @queue.pop
          break if job.nil?
          
          begin
            job.call
          rescue =&gt; e
            puts &quot;Error: #{e.message}&quot;
          end
        end
      end
    end
  end
end

# Usage
pool = WorkerPool.new(5)

20.times do |i|
  pool.schedule do
    puts &quot;Job #{i} processing&quot;
    sleep 1
  end
end

pool.shutdown
</code></pre>
<hr>
<h3>Rails Concurrency</h3>
<p><strong>Puma (Threaded Server):</strong></p>
<pre><code class="language-ruby"># config/puma.rb
threads_count = ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 }
threads threads_count, threads_count

workers ENV.fetch(&quot;WEB_CONCURRENCY&quot;) { 2 }

preload_app!
</code></pre>
<p><strong>Sidekiq (Background Jobs):</strong></p>
<pre><code class="language-ruby"># Uses threads for concurrent job processing
class HardWorker
  include Sidekiq::Worker
  
  def perform(name, count)
    # This can run concurrently with other jobs
    process_data(name, count)
  end
end

# Configure concurrency
# config/sidekiq.yml
:concurrency: 10  # 10 threads processing jobs
</code></pre>
<hr>
<h3>Alternatives to MRI Ruby</h3>
<p><strong>JRuby:</strong></p>
<ul>
<li>No GIL!</li>
<li>True thread parallelism</li>
<li>Runs on JVM</li>
</ul>
<p><strong>TruffleRuby:</strong></p>
<ul>
<li>No GIL!</li>
<li>True thread parallelism</li>
<li>Very fast</li>
</ul>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash"># Install JRuby
rbenv install jruby-9.4.0.0

# Run with JRuby
jruby my_script.rb

# True parallel threads!
</code></pre>
<hr>
<h3>Concurrent Ruby Gem</h3>
<pre><code class="language-ruby">require &#39;concurrent&#39;

# Promises
promise = Concurrent::Promise.execute do
  expensive_operation
end

value = promise.value  # Blocks until ready

# Thread pool
pool = Concurrent::FixedThreadPool.new(5)

10.times do |i|
  pool.post do
    process_item(i)
  end
end

pool.shutdown
pool.wait_for_termination
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Use threads for I/O:</strong></p>
<pre><code class="language-ruby"># Good - I/O bound
threads = urls.map { |url| Thread.new { fetch(url) } }
threads.each(&amp;:join)
</code></pre>
<p><strong>2. Use processes for CPU:</strong></p>
<pre><code class="language-ruby"># Good - CPU bound
pids = tasks.map { |task| fork { calculate(task) } }
pids.each { |pid| Process.wait(pid) }
</code></pre>
<p><strong>3. Protect shared state:</strong></p>
<pre><code class="language-ruby"># Use Mutex
mutex = Mutex.new
mutex.synchronize { shared_resource.update }
</code></pre>
<p><strong>4. Use thread-safe data structures:</strong></p>
<pre><code class="language-ruby">require &#39;concurrent&#39;

# Thread-safe hash
hash = Concurrent::Hash.new

# Thread-safe array
array = Concurrent::Array.new
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>GIL limits parallelism</strong> in MRI Ruby</li>
<li><strong>Threads work for I/O</strong>, not CPU-bound tasks</li>
<li><strong>Processes give true parallelism</strong> but higher overhead</li>
<li><strong>Ractors (Ruby 3+)</strong> provide parallel execution</li>
<li><strong>Always use Mutex</strong> for shared mutable state</li>
<li><strong>Rails uses threads</strong> in Puma and Sidekiq</li>
<li><strong>JRuby/TruffleRuby</strong> have no GIL</li>
<li><strong>Consider concurrent-ruby gem</strong> for advanced patterns</li>
</ol>
<hr>
<h2>Question 40: Explain the difference between forking and multithreading in Ruby</h2>
<h3>Answer</h3>
<p><strong>Forking</strong> creates a new process (copy of the program). <strong>Multithreading</strong> creates multiple threads within the same process.</p>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Forking</th>
<th>Multithreading</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Isolation</strong></td>
<td>Complete (separate memory)</td>
<td>Shared memory</td>
</tr>
<tr>
<td><strong>Overhead</strong></td>
<td>High (copy process)</td>
<td>Low (same process)</td>
</tr>
<tr>
<td><strong>Parallelism</strong></td>
<td>True (multiple CPU cores)</td>
<td>Limited by GIL</td>
</tr>
<tr>
<td><strong>Communication</strong></td>
<td>IPC/Pipes</td>
<td>Shared variables</td>
</tr>
<tr>
<td><strong>Safety</strong></td>
<td>Very safe (isolated)</td>
<td>Need synchronization</td>
</tr>
<tr>
<td><strong>Speed</strong></td>
<td>Slower to create</td>
<td>Faster to create</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>CPU-intensive</td>
<td>I/O-intensive</td>
</tr>
</tbody></table>
<hr>
<h3>Forking</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby">puts &quot;Parent: #{Process.pid}&quot;

pid = fork do
  # Child process (complete copy)
  puts &quot;Child: #{Process.pid}&quot;
  puts &quot;Child has its own memory space&quot;
  result = expensive_calculation
  exit  # Exit child process
end

# Parent continues
puts &quot;Parent waiting for child...&quot;
Process.wait(pid)
puts &quot;Child finished&quot;
</code></pre>
<p><strong>Memory isolation:</strong></p>
<pre><code class="language-ruby">counter = 0

fork do
  counter = 100  # Changes child&#39;s copy only
  puts &quot;Child counter: #{counter}&quot;
end

Process.wait
puts &quot;Parent counter: #{counter}&quot;  # Still 0!
</code></pre>
<p><strong>Copy-on-Write (CoW):</strong></p>
<pre><code class="language-ruby"># Large data structure
big_data = Array.new(1_000_000) { rand }

pid = fork do
  # Child shares memory until it modifies
  puts big_data[0]  # Shared memory (fast)
  
  big_data[0] = 999  # Now copies! (slower)
end

Process.wait(pid)
</code></pre>
<hr>
<h3>Multithreading</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby">counter = 0

thread = Thread.new do
  # Same process, shared memory
  counter = 100
  puts &quot;Thread counter: #{counter}&quot;
end

thread.join
puts &quot;Main counter: #{counter}&quot;  # 100! (shared)
</code></pre>
<p><strong>Shared memory:</strong></p>
<pre><code class="language-ruby">data = { count: 0 }
threads = []

5.times do
  threads &lt;&lt; Thread.new do
    1000.times do
      data[:count] += 1  # All threads modify same hash
    end
  end
end

threads.each(&amp;:join)
puts data[:count]  # Race condition! Not 5000
</code></pre>
<hr>
<h3>When to Use Forking</h3>
<p><strong>1. CPU-intensive tasks:</strong></p>
<pre><code class="language-ruby"># Process complex calculations in parallel
results = []

pids = 4.times.map do |i|
  fork do
    result = complex_calculation(i)
    File.write(&quot;result_#{i}.txt&quot;, result)
    exit
  end
end

pids.each { |pid| Process.wait(pid) }

# Read results
results = 4.times.map { |i| File.read(&quot;result_#{i}.txt&quot;) }
</code></pre>
<p><strong>2. Isolation needed:</strong></p>
<pre><code class="language-ruby"># Process untrusted code safely
pid = fork do
  begin
    eval(untrusted_code)
  rescue =&gt; e
    puts &quot;Error in child: #{e}&quot;
  end
  exit
end

# Timeout protection
begin
  Timeout.timeout(5) { Process.wait(pid) }
rescue Timeout::Error
  Process.kill(&#39;KILL&#39;, pid)
  puts &quot;Process timed out&quot;
end
</code></pre>
<p><strong>3. Rails/Puma workers:</strong></p>
<pre><code class="language-ruby"># config/puma.rb
workers 4  # Fork 4 processes

preload_app!  # Load app before fork (CoW optimization)

before_fork do
  # Close connections before fork
  ActiveRecord::Base.connection_pool.disconnect!
end

on_worker_boot do
  # Reconnect in child process
  ActiveRecord::Base.establish_connection
end
</code></pre>
<hr>
<h3>When to Use Multithreading</h3>
<p><strong>1. I/O-intensive tasks:</strong></p>
<pre><code class="language-ruby"># Fetch multiple URLs concurrently
urls = [...]

threads = urls.map do |url|
  Thread.new { HTTP.get(url) }
end

responses = threads.map(&amp;:value)
</code></pre>
<p><strong>2. Shared state needed:</strong></p>
<pre><code class="language-ruby"># Multiple threads updating shared cache
cache = {}
mutex = Mutex.new
threads = []

10.times do |i|
  threads &lt;&lt; Thread.new do
    data = fetch_data(i)
    mutex.synchronize { cache[i] = data }
  end
end

threads.each(&amp;:join)
</code></pre>
<p><strong>3. Sidekiq jobs:</strong></p>
<pre><code class="language-ruby"># Sidekiq processes multiple jobs in threads
class EmailWorker
  include Sidekiq::Worker
  
  def perform(user_id)
    user = User.find(user_id)
    send_email(user)
  end
end

# Many jobs run concurrently in threads
100.times { |i| EmailWorker.perform_async(i) }
</code></pre>
<hr>
<h3>Inter-Process Communication (IPC)</h3>
<p><strong>Pipes:</strong></p>
<pre><code class="language-ruby">reader, writer = IO.pipe

pid = fork do
  reader.close
  writer.puts &quot;Hello from child&quot;
  writer.close
  exit
end

writer.close
message = reader.gets
reader.close

Process.wait(pid)
puts &quot;Received: #{message}&quot;
</code></pre>
<p><strong>Shared files:</strong></p>
<pre><code class="language-ruby">pid = fork do
  File.write(&#39;shared.txt&#39;, &#39;Child data&#39;)
  exit
end

Process.wait(pid)
data = File.read(&#39;shared.txt&#39;)
</code></pre>
<p><strong>Redis/Database:</strong></p>
<pre><code class="language-ruby"># Child writes to Redis
pid = fork do
  redis = Redis.new
  redis.set(&#39;result&#39;, complex_calculation)
  exit
end

Process.wait(pid)

# Parent reads from Redis
redis = Redis.new
result = redis.get(&#39;result&#39;)
</code></pre>
<hr>
<h3>Combining Both</h3>
<p><strong>Forking + Threading:</strong></p>
<pre><code class="language-ruby"># Rails: Multiple processes, each with threads
# config/puma.rb
workers 4      # Fork 4 processes
threads 5, 10  # Each process has 5-10 threads

# Result: 4 processes × 10 threads = 40 concurrent workers
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

def cpu_task
  1_000_000.times { Math.sqrt(rand) }
end

def io_task
  sleep 0.1  # Simulate I/O
end

# CPU-bound
Benchmark.bm do |x|
  x.report(&quot;Threads (CPU):&quot;) do
    threads = 4.times.map { Thread.new { cpu_task } }
    threads.each(&amp;:join)
  end
  
  x.report(&quot;Forks (CPU):&quot;) do
    pids = 4.times.map { fork { cpu_task; exit } }
    pids.each { |pid| Process.wait(pid) }
  end
end

# I/O-bound
Benchmark.bm do |x|
  x.report(&quot;Threads (I/O):&quot;) do
    threads = 4.times.map { Thread.new { io_task } }
    threads.each(&amp;:join)
  end
  
  x.report(&quot;Forks (I/O):&quot;) do
    pids = 4.times.map { fork { io_task; exit } }
    pids.each { |pid| Process.wait(pid) }
  end
end

# Results:
# CPU: Forks faster (true parallelism)
# I/O: Threads faster (less overhead)
</code></pre>
<hr>
<h3>Thread Safety with Forks</h3>
<pre><code class="language-ruby"># Thread-safe: Each process has own copy
@cache = {}

pid = fork do
  @cache[:key] = &quot;value&quot;  # Modifies child&#39;s copy only
end

Process.wait(pid)
@cache  # {} (unchanged in parent)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Forking</strong>: Separate processes, complete isolation</li>
<li><strong>Threading</strong>: Same process, shared memory</li>
<li><strong>Fork for CPU-bound</strong> tasks (true parallelism)</li>
<li><strong>Thread for I/O-bound</strong> tasks (less overhead)</li>
<li><strong>Fork overhead</strong>: Slower creation, more memory</li>
<li><strong>Thread overhead</strong>: Faster creation, less memory</li>
<li><strong>Communication</strong>: IPC for forks, shared vars for threads</li>
<li><strong>Rails uses both</strong>: Puma forks workers, each worker has threads</li>
</ol>
<hr>
<h2>Question 41: What are Thread Pools, and how do they work?</h2>
<h3>Answer</h3>
<p><strong>Thread pools</strong> are a collection of pre-initialized threads that wait for tasks to execute. Instead of creating a new thread for each task (expensive), you reuse threads from a pool (efficient).</p>
<hr>
<h3>Why Thread Pools?</h3>
<p><strong>Without Thread Pool (Inefficient):</strong></p>
<pre><code class="language-ruby"># Creates new thread for each task
1000.times do |i|
  Thread.new do
    process_task(i)
  end
end

# Problems:
# - Creating 1000 threads is expensive
# - Too many threads can overwhelm system
# - Thread creation overhead for each task
</code></pre>
<p><strong>With Thread Pool (Efficient):</strong></p>
<pre><code class="language-ruby"># Create pool of 10 threads
# Reuse them for 1000 tasks
pool = ThreadPool.new(10)

1000.times do |i|
  pool.schedule do
    process_task(i)
  end
end

# Benefits:
# - Only 10 threads created
# - Controlled concurrency
# - Threads are reused
</code></pre>
<hr>
<h3>Basic Thread Pool Implementation</h3>
<pre><code class="language-ruby">require &#39;thread&#39;

class ThreadPool
  def initialize(size)
    @size = size
    @jobs = Queue.new
    @pool = Array.new(size) do
      Thread.new do
        catch(:exit) do
          loop do
            job, args = @jobs.pop
            job.call(*args)
          end
        end
      end
    end
  end
  
  def schedule(*args, &amp;block)
    @jobs &lt;&lt; [block, args]
  end
  
  def shutdown
    @size.times do
      schedule { throw :exit }
    end
    @pool.each(&amp;:join)
  end
end

# Usage
pool = ThreadPool.new(5)

20.times do |i|
  pool.schedule do
    puts &quot;Task #{i} on thread #{Thread.current.object_id}&quot;
    sleep 1
  end
end

pool.shutdown
</code></pre>
<hr>
<h3>Advanced Thread Pool with Error Handling</h3>
<pre><code class="language-ruby">class RobustThreadPool
  attr_reader :size
  
  def initialize(size, max_queue: 100)
    @size = size
    @max_queue = max_queue
    @jobs = Queue.new
    @mutex = Mutex.new
    @shutdown = false
    @workers = []
    
    create_workers
  end
  
  def schedule(&amp;block)
    raise &quot;Pool is shutting down&quot; if @shutdown
    raise &quot;Queue is full&quot; if @jobs.size &gt;= @max_queue
    
    @jobs &lt;&lt; block
  end
  
  def shutdown(wait: true)
    @mutex.synchronize { @shutdown = true }
    
    if wait
      # Wait for all jobs to complete
      sleep 0.1 until @jobs.empty?
    end
    
    # Signal workers to stop
    @size.times { @jobs &lt;&lt; nil }
    @workers.each(&amp;:join)
  end
  
  def active_threads
    @workers.count(&amp;:alive?)
  end
  
  def queue_size
    @jobs.size
  end
  
  private
  
  def create_workers
    @size.times do
      @workers &lt;&lt; Thread.new do
        loop do
          job = @jobs.pop
          break if job.nil?  # Shutdown signal
          
          begin
            job.call
          rescue =&gt; e
            handle_error(e)
          end
        end
      end
    end
  end
  
  def handle_error(error)
    puts &quot;Error in thread pool: #{error.message}&quot;
    puts error.backtrace.first(5)
  end
end

# Usage
pool = RobustThreadPool.new(10, max_queue: 1000)

100.times do |i|
  pool.schedule do
    puts &quot;Processing job #{i}&quot;
    sleep rand(0.1..0.5)
  end
end

puts &quot;Active threads: #{pool.active_threads}&quot;
puts &quot;Queue size: #{pool.queue_size}&quot;

pool.shutdown(wait: true)
</code></pre>
<hr>
<h3>Concurrent-Ruby Gem (Production Ready)</h3>
<pre><code class="language-ruby">require &#39;concurrent&#39;

# Fixed thread pool
pool = Concurrent::FixedThreadPool.new(5)

20.times do |i|
  pool.post do
    puts &quot;Task #{i}&quot;
    sleep 1
  end
end

pool.shutdown
pool.wait_for_termination

# Cached thread pool (grows as needed)
pool = Concurrent::CachedThreadPool.new

100.times do |i|
  pool.post { process_task(i) }
end

pool.shutdown
pool.wait_for_termination
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Web Scraper with Thread Pool</strong></p>
<pre><code class="language-ruby">require &#39;concurrent&#39;

class WebScraper
  def initialize(num_threads: 5)
    @pool = Concurrent::FixedThreadPool.new(num_threads)
    @results = Concurrent::Array.new
    @errors = Concurrent::Array.new
  end
  
  def scrape(urls)
    urls.each do |url|
      @pool.post do
        begin
          html = fetch_page(url)
          data = parse_page(html)
          @results &lt;&lt; { url: url, data: data }
        rescue =&gt; e
          @errors &lt;&lt; { url: url, error: e.message }
        end
      end
    end
    
    shutdown_and_wait
    { results: @results, errors: @errors }
  end
  
  private
  
  def fetch_page(url)
    # HTTP request
    sleep rand(0.1..0.5)  # Simulate
    &quot;&lt;html&gt;content&lt;/html&gt;&quot;
  end
  
  def parse_page(html)
    # Parse HTML
    { title: &quot;Page Title&quot;, content: &quot;Content&quot; }
  end
  
  def shutdown_and_wait
    @pool.shutdown
    @pool.wait_for_termination
  end
end

urls = 100.times.map { |i| &quot;https://example.com/page#{i}&quot; }
scraper = WebScraper.new(num_threads: 10)
results = scraper.scrape(urls)

puts &quot;Scraped: #{results[:results].size}&quot;
puts &quot;Errors: #{results[:errors].size}&quot;
</code></pre>
<p><strong>Example 2: Image Processing Pipeline</strong></p>
<pre><code class="language-ruby">class ImageProcessor
  def initialize(pool_size: 4)
    @pool = Concurrent::FixedThreadPool.new(pool_size)
    @processed = Concurrent::AtomicFixnum.new
  end
  
  def process_batch(image_paths)
    futures = image_paths.map do |path|
      Concurrent::Future.execute(executor: @pool) do
        process_image(path)
      end
    end
    
    # Wait for all to complete
    futures.map(&amp;:value)
  ensure
    @pool.shutdown
    @pool.wait_for_termination
  end
  
  private
  
  def process_image(path)
    # Simulate image processing
    sleep 0.5
    @processed.increment
    
    {
      path: path,
      thumbnail: &quot;#{path}_thumb.jpg&quot;,
      processed_at: Time.now
    }
  end
end

images = 20.times.map { |i| &quot;image_#{i}.jpg&quot; }
processor = ImageProcessor.new(pool_size: 4)
results = processor.process_batch(images)

puts &quot;Processed #{results.size} images&quot;
</code></pre>
<p><strong>Example 3: Database Batch Operations</strong></p>
<pre><code class="language-ruby">class BatchProcessor
  def initialize(batch_size: 100, workers: 5)
    @batch_size = batch_size
    @pool = Concurrent::FixedThreadPool.new(workers)
  end
  
  def process_records(records)
    records.each_slice(@batch_size) do |batch|
      @pool.post do
        process_batch(batch)
      end
    end
    
    @pool.shutdown
    @pool.wait_for_termination
  end
  
  private
  
  def process_batch(batch)
    ActiveRecord::Base.transaction do
      batch.each do |record|
        record.update(processed: true)
      end
    end
  end
end

records = User.where(processed: false)
processor = BatchProcessor.new(batch_size: 100, workers: 5)
processor.process_records(records)
</code></pre>
<hr>
<h3>Rails with Sidekiq (Thread Pool)</h3>
<p><strong>Sidekiq uses thread pool internally:</strong></p>
<pre><code class="language-ruby"># config/sidekiq.yml
:concurrency: 10  # Thread pool size

# Sidekiq creates pool of 10 threads
# Each thread processes jobs from queue

class EmailWorker
  include Sidekiq::Worker
  
  def perform(user_id)
    user = User.find(user_id)
    send_email(user)
  end
end

# Enqueue 1000 jobs
1000.times do |i|
  EmailWorker.perform_async(i)
end

# Sidekiq&#39;s thread pool processes them
# Only 10 threads, handling 1000 jobs
</code></pre>
<hr>
<h3>Puma Thread Pool Configuration</h3>
<pre><code class="language-ruby"># config/puma.rb

# Number of worker processes
workers ENV.fetch(&quot;WEB_CONCURRENCY&quot;) { 2 }

# Thread pool size per worker
threads_count = ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 }
threads threads_count, threads_count

# Result:
# 2 workers × 5 threads = 10 concurrent requests

preload_app!

on_worker_boot do
  ActiveRecord::Base.establish_connection
end
</code></pre>
<hr>
<h3>Thread Pool Sizing</h3>
<p><strong>Calculate optimal size:</strong></p>
<pre><code class="language-ruby"># For I/O-bound tasks
pool_size = number_of_cores * 2

# For CPU-bound tasks
pool_size = number_of_cores

# Get number of cores
cores = Concurrent.processor_count
puts &quot;CPU cores: #{cores}&quot;

# Create appropriately sized pool
pool = Concurrent::FixedThreadPool.new(cores * 2)
</code></pre>
<p><strong>Dynamic sizing based on workload:</strong></p>
<pre><code class="language-ruby">class AdaptiveThreadPool
  def initialize(min: 2, max: 10)
    @min = min
    @max = max
    @current_size = min
    @pool = Concurrent::FixedThreadPool.new(min)
    @pending_jobs = Concurrent::AtomicFixnum.new
  end
  
  def post(&amp;block)
    @pending_jobs.increment
    
    # Grow pool if needed
    if should_grow?
      grow_pool
    end
    
    @pool.post do
      begin
        block.call
      ensure
        @pending_jobs.decrement
      end
    end
  end
  
  private
  
  def should_grow?
    @pending_jobs.value &gt; @current_size &amp;&amp; @current_size &lt; @max
  end
  
  def grow_pool
    # Recreate pool with more threads
    old_pool = @pool
    @current_size = [@current_size + 2, @max].min
    @pool = Concurrent::FixedThreadPool.new(@current_size)
    
    old_pool.shutdown
  end
end
</code></pre>
<hr>
<h3>Monitoring Thread Pools</h3>
<pre><code class="language-ruby">class MonitoredThreadPool
  def initialize(size)
    @pool = Concurrent::FixedThreadPool.new(size)
    @completed = Concurrent::AtomicFixnum.new
    @failed = Concurrent::AtomicFixnum.new
    @start_time = Time.now
  end
  
  def post(&amp;block)
    @pool.post do
      begin
        block.call
        @completed.increment
      rescue =&gt; e
        @failed.increment
        raise
      end
    end
  end
  
  def stats
    {
      completed: @completed.value,
      failed: @failed.value,
      rate: @completed.value / (Time.now - @start_time),
      queue_length: @pool.queue_length
    }
  end
  
  def shutdown
    @pool.shutdown
    @pool.wait_for_termination
    
    puts &quot;Final stats:&quot;
    puts stats.inspect
  end
end

pool = MonitoredThreadPool.new(10)

1000.times do |i|
  pool.post { process_task(i) }
end

# Monitor progress
loop do
  stats = pool.stats
  puts &quot;Completed: #{stats[:completed]}, Rate: #{stats[:rate]}/sec&quot;
  break if stats[:completed] &gt;= 1000
  sleep 1
end

pool.shutdown
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Size appropriately:</strong></p>
<pre><code class="language-ruby"># Too few threads
pool = ThreadPool.new(1)  # Serialized execution

# Too many threads
pool = ThreadPool.new(1000)  # Overhead, context switching

# Just right (I/O bound)
pool = ThreadPool.new(Concurrent.processor_count * 2)
</code></pre>
<p><strong>2. Handle errors:</strong></p>
<pre><code class="language-ruby">pool.post do
  begin
    risky_operation
  rescue =&gt; e
    logger.error(&quot;Task failed: #{e.message}&quot;)
  end
end
</code></pre>
<p><strong>3. Set queue limits:</strong></p>
<pre><code class="language-ruby">pool = RobustThreadPool.new(10, max_queue: 1000)

# Prevents memory exhaustion from unlimited queuing
</code></pre>
<p><strong>4. Always shutdown:</strong></p>
<pre><code class="language-ruby">pool = Concurrent::FixedThreadPool.new(5)

begin
  # Do work
ensure
  pool.shutdown
  pool.wait_for_termination
end
</code></pre>
<p><strong>5. Use thread-safe data structures:</strong></p>
<pre><code class="language-ruby">results = Concurrent::Array.new  # Thread-safe
counter = Concurrent::AtomicFixnum.new  # Thread-safe

pool.post do
  results &lt;&lt; process_data
  counter.increment
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Thread pools reuse threads</strong> for better performance</li>
<li><strong>Limit concurrency</strong> to prevent resource exhaustion</li>
<li><strong>Size based on workload</strong> (I/O vs CPU bound)</li>
<li><strong>Use concurrent-ruby gem</strong> for production</li>
<li><strong>Sidekiq and Puma</strong> use thread pools internally</li>
<li><strong>Always handle errors</strong> in thread pool tasks</li>
<li><strong>Monitor pool stats</strong> for optimization</li>
<li><strong>Set queue limits</strong> to prevent memory issues</li>
</ol>
<hr>
<h2>Question 42: How do you optimize Ruby code for high-performance applications?</h2>
<h3>Answer</h3>
<p>Optimizing Ruby for high performance involves profiling, identifying bottlenecks, and applying targeted optimizations. Here&#39;s a comprehensive guide.</p>
<hr>
<h3>1. Profiling and Benchmarking</h3>
<p><strong>Benchmark stdlib:</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

Benchmark.bm do |x|
  x.report(&quot;Method 1:&quot;) { method1 }
  x.report(&quot;Method 2:&quot;) { method2 }
end
</code></pre>
<p><strong>rack-mini-profiler (Rails):</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;rack-mini-profiler&#39;

# Shows performance metrics in browser
# http://localhost:3000?pp=help
</code></pre>
<p><strong>memory_profiler gem:</strong></p>
<pre><code class="language-ruby">require &#39;memory_profiler&#39;

report = MemoryProfiler.report do
  # Code to profile
  1000.times { User.new(&quot;John&quot;, &quot;john@example.com&quot;) }
end

report.pretty_print
</code></pre>
<p><strong>stackprof (sampling profiler):</strong></p>
<pre><code class="language-ruby">require &#39;stackprof&#39;

StackProf.run(mode: :cpu, out: &#39;tmp/stackprof.dump&#39;) do
  # Code to profile
  expensive_operation
end

# View results
# stackprof tmp/stackprof.dump
</code></pre>
<hr>
<h3>2. Database Optimization</h3>
<p><strong>N+1 Query Problem:</strong></p>
<pre><code class="language-ruby"># BAD - N+1 queries
users = User.all
users.each do |user|
  puts user.posts.count  # Separate query per user
end

# GOOD - Eager loading
users = User.includes(:posts)
users.each do |user|
  puts user.posts.count  # Already loaded
end
</code></pre>
<p><strong>Select only needed columns:</strong></p>
<pre><code class="language-ruby"># BAD - loads all columns
User.all

# GOOD - only needed columns
User.select(:id, :name, :email)
</code></pre>
<p><strong>Use pluck for simple data:</strong></p>
<pre><code class="language-ruby"># BAD - loads full objects
User.all.map(&amp;:email)

# GOOD - only emails
User.pluck(:email)
</code></pre>
<p><strong>Batch processing:</strong></p>
<pre><code class="language-ruby"># BAD - loads all at once
User.all.each { |user| process(user) }

# GOOD - processes in batches
User.find_each(batch_size: 1000) do |user|
  process(user)
end
</code></pre>
<p><strong>Database indices:</strong></p>
<pre><code class="language-ruby"># migration
class AddIndexToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :email
    add_index :posts, :user_id
    add_index :posts, [:user_id, :created_at]
  end
end
</code></pre>
<p><strong>Query caching:</strong></p>
<pre><code class="language-ruby"># Rails query cache (automatic in requests)
User.where(active: true).to_a  # Query
User.where(active: true).to_a  # Cached

# Manual caching
Rails.cache.fetch(&quot;active_users&quot;, expires_in: 1.hour) do
  User.where(active: true).to_a
end
</code></pre>
<hr>
<h3>3. Caching Strategies</h3>
<p><strong>Fragment caching:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/index.html.erb --&gt;
&lt;% @posts.each do |post| %&gt;
  &lt;% cache post do %&gt;
    &lt;%= render post %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>Russian Doll caching:</strong></p>
<pre><code class="language-erb">&lt;% cache @post do %&gt;
  &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
  
  &lt;% cache [&#39;comments&#39;, @post] do %&gt;
    &lt;% @post.comments.each do |comment| %&gt;
      &lt;% cache comment do %&gt;
        &lt;%= render comment %&gt;
      &lt;% end %&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>Low-level caching:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  def expensive_calculation
    Rails.cache.fetch(&quot;user_#{id}_calc&quot;, expires_in: 12.hours) do
      # Expensive operation
      complex_calculation
    end
  end
end
</code></pre>
<p><strong>Memoization:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  def full_name
    @full_name ||= &quot;#{first_name} #{last_name}&quot;
  end
  
  # Reset when needed
  def first_name=(value)
    @full_name = nil
    super
  end
end
</code></pre>
<hr>
<h3>4. String Optimization</h3>
<p><strong>Frozen strings:</strong></p>
<pre><code class="language-ruby"># At top of file
# frozen_string_literal: true

# Strings are frozen (memory efficient)
str1 = &quot;hello&quot;
str2 = &quot;hello&quot;
str1.object_id == str2.object_id  # true
</code></pre>
<p><strong>String concatenation:</strong></p>
<pre><code class="language-ruby"># BAD - creates many intermediate strings
result = &quot;&quot;
1000.times { |i| result += &quot;item#{i}&quot; }

# GOOD - uses array and join
result = []
1000.times { |i| result &lt;&lt; &quot;item#{i}&quot; }
result.join
</code></pre>
<p><strong>String interpolation vs concatenation:</strong></p>
<pre><code class="language-ruby"># Faster
&quot;Hello #{name}!&quot;

# Slower
&quot;Hello &quot; + name + &quot;!&quot;
</code></pre>
<hr>
<h3>5. Array and Hash Optimization</h3>
<p><strong>Use symbols for hash keys:</strong></p>
<pre><code class="language-ruby"># Faster - symbols
hash = { name: &quot;John&quot;, age: 30 }

# Slower - strings
hash = { &quot;name&quot; =&gt; &quot;John&quot;, &quot;age&quot; =&gt; 30 }
</code></pre>
<p><strong>Set for membership tests:</strong></p>
<pre><code class="language-ruby"># BAD - O(n) lookup
array = [1, 2, 3, ..., 1000]
array.include?(500)

# GOOD - O(1) lookup
require &#39;set&#39;
set = Set.new([1, 2, 3, ..., 1000])
set.include?(500)
</code></pre>
<p><strong>Avoid repeated allocations:</strong></p>
<pre><code class="language-ruby"># BAD
def process
  array = []  # Allocates every call
  array &lt;&lt; data
end

# GOOD
def initialize
  @array = []  # Allocate once
end

def process
  @array &lt;&lt; data
end
</code></pre>
<hr>
<h3>6. Method Optimization</h3>
<p><strong>Avoid method_missing:</strong></p>
<pre><code class="language-ruby"># SLOW - method_missing
def method_missing(name, *args)
  if name.to_s.start_with?(&#39;find_by_&#39;)
    # ...
  end
end

# FAST - define_method
def self.method_missing(name, *args)
  if name.to_s =~ /^find_by_(.+)$/
    # Define method for future calls
    define_singleton_method(name) do |value|
      where($1 =&gt; value).first
    end
    send(name, *args)
  else
    super
  end
end
</code></pre>
<p><strong>Inline critical methods:</strong></p>
<pre><code class="language-ruby"># In performance-critical loops
# Avoid method calls

# SLOW
1000000.times { expensive_method_call }

# FAST
result = expensive_method_call
1000000.times { result }
</code></pre>
<hr>
<h3>7. Background Jobs</h3>
<p><strong>Offload heavy work:</strong></p>
<pre><code class="language-ruby"># Slow - blocks request
def create
  @user = User.create(user_params)
  send_welcome_email(@user)      # Slow!
  generate_report(@user)           # Slow!
  notify_admins(@user)             # Slow!
  redirect_to @user
end

# Fast - background processing
def create
  @user = User.create(user_params)
  WelcomeEmailWorker.perform_async(@user.id)
  ReportWorker.perform_async(@user.id)
  AdminNotificationWorker.perform_async(@user.id)
  redirect_to @user
end
</code></pre>
<hr>
<h3>8. Asset Optimization</h3>
<p><strong>Precompile assets:</strong></p>
<pre><code class="language-bash">RAILS_ENV=production rails assets:precompile
</code></pre>
<p><strong>CDN for static assets:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.asset_host = &#39;https://cdn.example.com&#39;
</code></pre>
<p><strong>Lazy loading images:</strong></p>
<pre><code class="language-html">&lt;img src=&quot;placeholder.jpg&quot; data-src=&quot;actual-image.jpg&quot; loading=&quot;lazy&quot;&gt;
</code></pre>
<hr>
<h3>9. Server and Deployment</h3>
<p><strong>Use faster web server:</strong></p>
<pre><code class="language-ruby"># Puma (default, threaded)
# config/puma.rb
workers ENV.fetch(&quot;WEB_CONCURRENCY&quot;) { 2 }
threads_count = ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 }
threads threads_count, threads_count
</code></pre>
<p><strong>Enable caching in production:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.cache_classes = true
config.eager_load = true
config.consider_all_requests_local = false
config.action_controller.perform_caching = true
</code></pre>
<p><strong>Use Bootsnap:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;bootsnap&#39;, require: false

# config/boot.rb
require &#39;bootsnap/setup&#39;
</code></pre>
<hr>
<h3>10. Algorithm Optimization</h3>
<p><strong>Choose right algorithm:</strong></p>
<pre><code class="language-ruby"># BAD - O(n²)
def find_duplicates(array)
  duplicates = []
  array.each_with_index do |item, i|
    array.each_with_index do |other, j|
      duplicates &lt;&lt; item if i != j &amp;&amp; item == other
    end
  end
  duplicates.uniq
end

# GOOD - O(n)
def find_duplicates(array)
  seen = {}
  duplicates = []
  
  array.each do |item|
    if seen[item]
      duplicates &lt;&lt; item unless duplicates.include?(item)
    else
      seen[item] = true
    end
  end
  
  duplicates
end
</code></pre>
<hr>
<h3>Complete Optimization Example</h3>
<p><strong>Before optimization:</strong></p>
<pre><code class="language-ruby">class ReportsController &lt; ApplicationController
  def index
    @users = User.all
    
    @report = @users.map do |user|
      {
        name: user.first_name + &quot; &quot; + user.last_name,
        posts_count: user.posts.count,
        comments: user.posts.map(&amp;:comments).flatten,
        total_likes: user.posts.sum { |p| p.likes.count }
      }
    end
  end
end
</code></pre>
<p><strong>After optimization:</strong></p>
<pre><code class="language-ruby">class ReportsController &lt; ApplicationController
  def index
    # Cache the entire report
    @report = Rails.cache.fetch(&quot;user_report&quot;, expires_in: 1.hour) do
      generate_report
    end
  end
  
  private
  
  def generate_report
    # Eager load associations, select only needed columns
    User.includes(posts: [:comments, :likes])
        .select(:id, :first_name, :last_name)
        .map do |user|
      {
        name: &quot;#{user.first_name} #{user.last_name}&quot;,  # Interpolation
        posts_count: user.posts.size,  # Already loaded
        comments: user.posts.flat_map(&amp;:comments),  # Faster than map + flatten
        total_likes: user.posts.sum { |p| p.likes.size }  # Size, not count
      }
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Profile first</strong> - don&#39;t optimize blindly</li>
<li><strong>Database queries</strong> - biggest bottleneck in most apps</li>
<li><strong>Eager loading</strong> to prevent N+1 queries</li>
<li><strong>Cache aggressively</strong> - fragment, query, low-level</li>
<li><strong>Background jobs</strong> for heavy operations</li>
<li><strong>Frozen strings</strong> for memory efficiency</li>
<li><strong>Use symbols</strong> over strings for hash keys</li>
<li><strong>Batch processing</strong> for large datasets</li>
<li><strong>Choose right data structures</strong> (Set vs Array)</li>
<li><strong>Monitor in production</strong> with APM tools</li>
</ol>
<h1>Ruby Attributes and Accessors Interview Questions</h1>
<h2>Question 43: Explain <code>attr_accessor</code>, <code>attr_reader</code>, and <code>attr_writer</code></h2>
<h3>Answer</h3>
<p>These are Ruby metaprogramming methods that automatically create getter and/or setter methods for instance variables. They&#39;re syntactic sugar that saves you from writing repetitive code.</p>
<hr>
<h3>Manual Getter and Setter</h3>
<p><em><em>Without attr_</em> methods:</em>*</p>
<pre><code class="language-ruby">class User
  def initialize(name, email)
    @name = name
    @email = email
  end
  
  # Getter method
  def name
    @name
  end
  
  # Setter method
  def name=(value)
    @name = value
  end
  
  # Getter
  def email
    @email
  end
  
  # Setter
  def email=(value)
    @email = value
  end
end

user = User.new(&quot;John&quot;, &quot;john@example.com&quot;)
user.name           # &quot;John&quot; (calls getter)
user.name = &quot;Jane&quot;  # Calls setter
user.email          # &quot;john@example.com&quot;
</code></pre>
<hr>
<h3>attr_reader (Getter Only)</h3>
<p>Creates read-only accessor (getter method):</p>
<pre><code class="language-ruby">class User
  attr_reader :name, :email
  
  def initialize(name, email)
    @name = name
    @email = email
  end
end

user = User.new(&quot;John&quot;, &quot;john@example.com&quot;)
user.name   # &quot;John&quot; (works)
user.email  # &quot;john@example.com&quot; (works)

user.name = &quot;Jane&quot;  # NoMethodError (no setter)
</code></pre>
<p><strong>Equivalent to:</strong></p>
<pre><code class="language-ruby">class User
  def name
    @name
  end
  
  def email
    @email
  end
end
</code></pre>
<hr>
<h3>attr_writer (Setter Only)</h3>
<p>Creates write-only accessor (setter method):</p>
<pre><code class="language-ruby">class User
  attr_writer :password
  
  def initialize
    @password = nil
  end
end

user = User.new
user.password = &quot;secret123&quot;  # Works (setter)

user.password  # NoMethodError (no getter)
</code></pre>
<p><strong>Equivalent to:</strong></p>
<pre><code class="language-ruby">class User
  def password=(value)
    @password = value
  end
end
</code></pre>
<hr>
<h3>attr_accessor (Both Getter and Setter)</h3>
<p>Creates both read and write accessors:</p>
<pre><code class="language-ruby">class User
  attr_accessor :name, :email, :age
  
  def initialize(name, email, age)
    @name = name
    @email = email
    @age = age
  end
end

user = User.new(&quot;John&quot;, &quot;john@example.com&quot;, 30)

# Getters
user.name   # &quot;John&quot;
user.email  # &quot;john@example.com&quot;
user.age    # 30

# Setters
user.name = &quot;Jane&quot;
user.age = 31
</code></pre>
<p><strong>Equivalent to:</strong></p>
<pre><code class="language-ruby">class User
  def name
    @name
  end
  
  def name=(value)
    @name = value
  end
  
  def email
    @email
  end
  
  def email=(value)
    @email = value
  end
  
  # ... same for age
end
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Getter</th>
<th>Setter</th>
<th>Use Case</th>
</tr>
</thead>
<tbody><tr>
<td><code>attr_reader</code></td>
<td>✅</td>
<td>❌</td>
<td>Read-only attributes</td>
</tr>
<tr>
<td><code>attr_writer</code></td>
<td>❌</td>
<td>✅</td>
<td>Write-only attributes</td>
</tr>
<tr>
<td><code>attr_accessor</code></td>
<td>✅</td>
<td>✅</td>
<td>Read/write attributes</td>
</tr>
</tbody></table>
<hr>
<h3>Combining Different Types</h3>
<pre><code class="language-ruby">class User
  attr_reader :id, :created_at     # Read-only
  attr_writer :password            # Write-only
  attr_accessor :name, :email      # Read/write
  
  def initialize(id, name, email)
    @id = id
    @name = name
    @email = email
    @created_at = Time.now
  end
end

user = User.new(1, &quot;John&quot;, &quot;john@example.com&quot;)

# attr_reader - can read
user.id          # 1
user.created_at  # 2024-01-15 10:30:00

# attr_reader - cannot write
user.id = 2  # NoMethodError

# attr_writer - can write
user.password = &quot;secret&quot;

# attr_writer - cannot read
user.password  # NoMethodError

# attr_accessor - can read and write
user.name = &quot;Jane&quot;
user.name  # &quot;Jane&quot;
</code></pre>
<hr>
<h3>Custom Getter/Setter Logic</h3>
<p>You can override the generated methods:</p>
<pre><code class="language-ruby">class User
  attr_accessor :name, :email
  
  # Custom getter with logic
  def email
    @email.downcase if @email
  end
  
  # Custom setter with validation
  def email=(value)
    raise &quot;Invalid email&quot; unless value.include?(&#39;@&#39;)
    @email = value
  end
end

user = User.new
user.email = &quot;JOHN@EXAMPLE.COM&quot;
user.email  # &quot;john@example.com&quot; (downcased by getter)

user.email = &quot;invalid&quot;  # Raises error
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: User Model</strong></p>
<pre><code class="language-ruby">class User
  attr_reader :id, :created_at, :updated_at
  attr_accessor :name, :email, :age
  attr_writer :password  # Write-only for security
  
  def initialize(attributes = {})
    @id = attributes[:id]
    @name = attributes[:name]
    @email = attributes[:email]
    @age = attributes[:age]
    @created_at = Time.now
    @updated_at = Time.now
  end
  
  def update(attributes)
    attributes.each do |key, value|
      send(&quot;#{key}=&quot;, value) if respond_to?(&quot;#{key}=&quot;)
    end
    @updated_at = Time.now
  end
  
  def authenticate(password)
    @password == password
  end
end

user = User.new(id: 1, name: &quot;John&quot;, email: &quot;john@example.com&quot;)
user.password = &quot;secret123&quot;
user.authenticate(&quot;secret123&quot;)  # true
</code></pre>
<p><strong>Example 2: Product with Calculated Price</strong></p>
<pre><code class="language-ruby">class Product
  attr_accessor :name, :base_price, :tax_rate
  
  def initialize(name, base_price, tax_rate = 0.1)
    @name = name
    @base_price = base_price
    @tax_rate = tax_rate
  end
  
  # Custom getter - calculated value
  def total_price
    base_price * (1 + tax_rate)
  end
end

product = Product.new(&quot;Laptop&quot;, 1000)
product.base_price  # 1000
product.total_price # 1100 (with tax)
</code></pre>
<p><strong>Example 3: Account with Validation</strong></p>
<pre><code class="language-ruby">class BankAccount
  attr_reader :balance, :account_number
  
  def initialize(account_number, initial_balance = 0)
    @account_number = account_number
    @balance = initial_balance
  end
  
  # Custom setter with validation
  def balance=(amount)
    raise &quot;Balance cannot be negative&quot; if amount &lt; 0
    @balance = amount
  end
  
  def deposit(amount)
    self.balance = balance + amount
  end
  
  def withdraw(amount)
    self.balance = balance - amount
  end
end

account = BankAccount.new(&quot;12345&quot;, 1000)
account.deposit(500)
account.balance  # 1500

account.balance = -100  # Raises error
</code></pre>
<hr>
<h3>Rails ActiveRecord Examples</h3>
<p><strong>Model attributes:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Rails automatically creates accessors for DB columns
  # name, email, created_at, updated_at, etc.
  
  # Custom accessor for virtual attribute
  attr_accessor :password_confirmation
  
  # Custom getter
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
  
  # Custom setter
  def full_name=(name)
    parts = name.split(&#39; &#39;, 2)
    self.first_name = parts[0]
    self.last_name = parts[1]
  end
end

user = User.new
user.full_name = &quot;John Doe&quot;
user.first_name  # &quot;John&quot;
user.last_name   # &quot;Doe&quot;
user.full_name   # &quot;John Doe&quot;
</code></pre>
<hr>
<h3>Virtual Attributes</h3>
<p>Attributes that don&#39;t map to database columns:</p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  attr_accessor :terms_of_service
  
  validates :terms_of_service, acceptance: true
end

# In form
&lt;%= form_for @user do |f| %&gt;
  &lt;%= f.check_box :terms_of_service %&gt;
  &lt;%= f.submit %&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Private/Protected Accessors</h3>
<pre><code class="language-ruby">class User
  attr_reader :name
  
  private
  
  attr_accessor :ssn  # Private getter and setter
  
  def display_info
    &quot;#{name} (SSN: #{ssn})&quot;  # Can use internally
  end
end

user = User.new
user.name  # Works (public)
user.ssn   # NoMethodError (private)
</code></pre>
<hr>
<h3>Performance</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

class ManualAccessors
  def initialize(name)
    @name = name
  end
  
  def name
    @name
  end
  
  def name=(value)
    @name = value
  end
end

class AttrAccessors
  attr_accessor :name
  
  def initialize(name)
    @name = name
  end
end

n = 1_000_000

Benchmark.bm do |x|
  manual = ManualAccessors.new(&quot;John&quot;)
  x.report(&quot;Manual:&quot;) do
    n.times { manual.name; manual.name = &quot;Jane&quot; }
  end
  
  attr = AttrAccessors.new(&quot;John&quot;)
  x.report(&quot;attr_accessor:&quot;) do
    n.times { attr.name; attr.name = &quot;Jane&quot; }
  end
end

# Performance is identical (attr_* creates the same methods)
</code></pre>
<hr>
<h3>How attr_* Methods Work</h3>
<pre><code class="language-ruby"># Simplified implementation
class Module
  def attr_reader(*names)
    names.each do |name|
      define_method(name) do
        instance_variable_get(&quot;@#{name}&quot;)
      end
    end
  end
  
  def attr_writer(*names)
    names.each do |name|
      define_method(&quot;#{name}=&quot;) do |value|
        instance_variable_set(&quot;@#{name}&quot;, value)
      end
    end
  end
  
  def attr_accessor(*names)
    attr_reader(*names)
    attr_writer(*names)
  end
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Use appropriate accessor type:</strong></p>
<pre><code class="language-ruby">class User
  attr_reader :id              # ID shouldn&#39;t be changed
  attr_accessor :name, :email  # Can read and write
  attr_writer :password        # Security - write only
end
</code></pre>
<p><strong>2. Add validation in custom setters:</strong></p>
<pre><code class="language-ruby">class User
  attr_reader :email
  
  def email=(value)
    raise ArgumentError unless value =~ /@/
    @email = value.downcase
  end
end
</code></pre>
<p><strong>3. Use for simple attributes:</strong></p>
<pre><code class="language-ruby"># Good - simple attributes
class Point
  attr_accessor :x, :y
end

# Bad - complex logic in accessor
class User
  attr_accessor :name
  
  # Better as explicit method
  def formatted_name
    name.titleize
  end
end
</code></pre>
<p><strong>4. Document virtual attributes:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Virtual attribute for password confirmation
  # Not stored in database
  attr_accessor :password_confirmation
  
  validates :password, confirmation: true
end
</code></pre>
<hr>
<h3>Common Mistakes</h3>
<p><strong>1. Forgetting instance variable:</strong></p>
<pre><code class="language-ruby">class User
  attr_accessor :name
  
  def initialize(name)
    name = name  # WRONG - local variable
    @name = name # CORRECT - instance variable
  end
end
</code></pre>
<p><strong>2. Using attr_reader for mutable objects:</strong></p>
<pre><code class="language-ruby">class Team
  attr_reader :members  # Returns reference!
  
  def initialize
    @members = []
  end
end

team = Team.new
team.members &lt;&lt; &quot;John&quot;  # Modifies internal array!

# Better: return copy
def members
  @members.dup
end
</code></pre>
<p><strong>3. Over-using attr_accessor:</strong></p>
<pre><code class="language-ruby"># Bad - too open
class User
  attr_accessor :admin  # Anyone can make themselves admin!
end

# Good - controlled access
class User
  attr_reader :admin
  
  def promote_to_admin!
    # Add authorization logic
    @admin = true
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>attr_reader</code></strong> creates getter method only</li>
<li><strong><code>attr_writer</code></strong> creates setter method only</li>
<li><strong><code>attr_accessor</code></strong> creates both getter and setter</li>
<li><strong>Metaprogramming</strong> - dynamically creates methods</li>
<li><strong>Can override</strong> generated methods with custom logic</li>
<li><strong>Use appropriate type</strong> for security and clarity</li>
<li><strong>Rails uses extensively</strong> for model attributes</li>
<li><strong>Performance</strong> is identical to manual methods</li>
<li><strong>Private/protected</strong> modifiers apply to accessors</li>
<li><strong>Virtual attributes</strong> for form fields not in database</li>
</ol>
<h1>Rails Architecture and Patterns Interview Questions</h1>
<h2>Question 44: Explain ORM and MVC</h2>
<h3>Answer</h3>
<p><strong>ORM (Object-Relational Mapping)</strong> and <strong>MVC (Model-View-Controller)</strong> are fundamental architectural patterns in Rails that separate concerns and simplify database interactions.</p>
<hr>
<h3>ORM (Object-Relational Mapping)</h3>
<p><strong>Definition:</strong> ORM maps database tables to classes, rows to objects, and columns to attributes. It abstracts SQL operations into Ruby methods.</p>
<p><strong>In Rails:</strong> ActiveRecord is the ORM implementation.</p>
<p><strong>Without ORM (Raw SQL):</strong></p>
<pre><code class="language-ruby"># Direct SQL queries
result = database.execute(&quot;SELECT * FROM users WHERE id = 1&quot;)
user_data = result.first

name = user_data[&#39;name&#39;]
email = user_data[&#39;email&#39;]

# Update
database.execute(&quot;UPDATE users SET name = &#39;John&#39; WHERE id = 1&quot;)

# Insert
database.execute(&quot;INSERT INTO users (name, email) VALUES (&#39;Jane&#39;, &#39;jane@example.com&#39;)&quot;)
</code></pre>
<p><strong>With ORM (ActiveRecord):</strong></p>
<pre><code class="language-ruby"># Find
user = User.find(1)

# Access attributes
user.name
user.email

# Update
user.update(name: &#39;John&#39;)

# Create
User.create(name: &#39;Jane&#39;, email: &#39;jane@example.com&#39;)
</code></pre>
<hr>
<h3>How ORM Works in Rails</h3>
<p><strong>1. Database Table → Ruby Class</strong></p>
<pre><code class="language-ruby"># Database table: users
# Columns: id, name, email, created_at, updated_at

# Ruby class
class User &lt; ApplicationRecord
  # Automatically maps to &#39;users&#39; table
  # Attributes correspond to columns
end
</code></pre>
<p><strong>2. Table Rows → Ruby Objects</strong></p>
<pre><code class="language-ruby"># Database row:
# | id | name | email              |
# | 1  | John | john@example.com   |

# Ruby object:
user = User.find(1)
user.id     # 1
user.name   # &quot;John&quot;
user.email  # &quot;john@example.com&quot;
</code></pre>
<p><strong>3. SQL Operations → Ruby Methods</strong></p>
<pre><code class="language-ruby"># CREATE
User.create(name: &quot;Alice&quot;, email: &quot;alice@example.com&quot;)
# SQL: INSERT INTO users (name, email) VALUES (&#39;Alice&#39;, &#39;alice@example.com&#39;)

# READ
User.where(name: &quot;Alice&quot;)
# SQL: SELECT * FROM users WHERE name = &#39;Alice&#39;

# UPDATE
user.update(email: &quot;newemail@example.com&quot;)
# SQL: UPDATE users SET email = &#39;newemail@example.com&#39; WHERE id = 1

# DELETE
user.destroy
# SQL: DELETE FROM users WHERE id = 1
</code></pre>
<hr>
<h3>ORM Benefits</h3>
<p><strong>1. Database Abstraction:</strong></p>
<pre><code class="language-ruby"># Same code works with PostgreSQL, MySQL, SQLite
User.where(active: true)

# ORM generates appropriate SQL for each database
</code></pre>
<p><strong>2. Type Safety:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Automatic type conversion
  validates :age, numericality: true
  validates :email, format: { with: URI::MailTo::EMAIL_REGEXP }
end

user.age = &quot;30&quot;  # Converted to integer
user.created_at  # Returns DateTime object
</code></pre>
<p><strong>3. Associations:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :posts
  has_one :profile
  belongs_to :organization
end

# Easy relationship traversal
user.posts
user.profile
user.organization

# Automatic SQL joins
User.includes(:posts).where(posts: { published: true })
</code></pre>
<p><strong>4. Validations:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email, presence: true, uniqueness: true
  validates :age, numericality: { greater_than: 0 }
end

user = User.new(email: &quot;&quot;)
user.valid?  # false
user.errors.full_messages  # [&quot;Email can&#39;t be blank&quot;]
</code></pre>
<p><strong>5. Callbacks:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_save :normalize_email
  after_create :send_welcome_email
  
  private
  
  def normalize_email
    self.email = email.downcase.strip
  end
  
  def send_welcome_email
    UserMailer.welcome_email(self).deliver_later
  end
end
</code></pre>
<hr>
<h3>MVC (Model-View-Controller)</h3>
<p><strong>Definition:</strong> MVC separates application logic into three interconnected components.</p>
<p><strong>Architecture:</strong></p>
<pre><code>         ┌─────────────┐
         │   Browser   │
         └──────┬──────┘
                │ HTTP Request
                ▼
         ┌─────────────┐
         │  Controller │ ◄──── Routes
         └──────┬──────┘
                │
        ┌───────┼───────┐
        ▼       ▼       ▼
    ┌──────┐ ┌─────┐ ┌──────┐
    │ Model│ │View │ │Helper│
    └──────┘ └─────┘ └──────┘
        │       │
        ▼       │
    ┌──────────┐│
    │ Database ││
    └──────────┘│
                ▼
         ┌─────────────┐
         │   Browser   │
         └─────────────┘
</code></pre>
<hr>
<h3>Model (Business Logic &amp; Data)</h3>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Database interactions</li>
<li>Business logic</li>
<li>Data validation</li>
<li>Associations</li>
</ul>
<pre><code class="language-ruby"># app/models/post.rb
class Post &lt; ApplicationRecord
  # Associations
  belongs_to :user
  has_many :comments
  has_many_attached :images
  
  # Validations
  validates :title, presence: true, length: { minimum: 5 }
  validates :body, presence: true
  validates :user, presence: true
  
  # Scopes (business logic)
  scope :published, -&gt; { where(published: true) }
  scope :recent, -&gt; { order(created_at: :desc).limit(10) }
  
  # Instance methods
  def publish!
    update(published: true, published_at: Time.current)
  end
  
  def word_count
    body.split.size
  end
  
  # Class methods
  def self.most_commented
    left_joins(:comments)
      .group(:id)
      .order(&#39;COUNT(comments.id) DESC&#39;)
  end
  
  # Callbacks
  before_save :generate_slug
  after_create :notify_subscribers
  
  private
  
  def generate_slug
    self.slug = title.parameterize
  end
  
  def notify_subscribers
    NotificationJob.perform_later(id)
  end
end
</code></pre>
<hr>
<h3>View (Presentation)</h3>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Display data</li>
<li>User interface</li>
<li>Form rendering</li>
<li>No business logic</li>
</ul>
<pre><code class="language-erb">&lt;!-- app/views/posts/show.html.erb --&gt;
&lt;article class=&quot;post&quot;&gt;
  &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
  
  &lt;div class=&quot;meta&quot;&gt;
    Posted by &lt;%= @post.user.name %&gt;
    on &lt;%= @post.created_at.strftime(&quot;%B %d, %Y&quot;) %&gt;
  &lt;/div&gt;
  
  &lt;div class=&quot;content&quot;&gt;
    &lt;%= simple_format(@post.body) %&gt;
  &lt;/div&gt;
  
  &lt;% if @post.images.attached? %&gt;
    &lt;div class=&quot;images&quot;&gt;
      &lt;% @post.images.each do |image| %&gt;
        &lt;%= image_tag image, class: &#39;post-image&#39; %&gt;
      &lt;% end %&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
  
  &lt;div class=&quot;actions&quot;&gt;
    &lt;% if current_user == @post.user %&gt;
      &lt;%= link_to &#39;Edit&#39;, edit_post_path(@post), class: &#39;btn&#39; %&gt;
      &lt;%= link_to &#39;Delete&#39;, @post, method: :delete, 
                  data: { confirm: &#39;Are you sure?&#39; }, class: &#39;btn btn-danger&#39; %&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
  
  &lt;section class=&quot;comments&quot;&gt;
    &lt;h2&gt;Comments (&lt;%= @post.comments.count %&gt;)&lt;/h2&gt;
    &lt;%= render @post.comments %&gt;
  &lt;/section&gt;
&lt;/article&gt;
</code></pre>
<p><strong>View Helpers:</strong></p>
<pre><code class="language-ruby"># app/helpers/posts_helper.rb
module PostsHelper
  def post_status_badge(post)
    if post.published?
      content_tag :span, &#39;Published&#39;, class: &#39;badge badge-success&#39;
    else
      content_tag :span, &#39;Draft&#39;, class: &#39;badge badge-secondary&#39;
    end
  end
  
  def reading_time(post)
    words = post.word_count
    minutes = (words / 200.0).ceil
    &quot;#{minutes} min read&quot;
  end
end
</code></pre>
<hr>
<h3>Controller (Request Handling)</h3>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Handle HTTP requests</li>
<li>Process parameters</li>
<li>Coordinate Model and View</li>
<li>Manage session/cookies</li>
<li>Handle redirects/rendering</li>
</ul>
<pre><code class="language-ruby"># app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  before_action :authenticate_user!, except: [:index, :show]
  before_action :set_post, only: [:show, :edit, :update, :destroy]
  before_action :authorize_user!, only: [:edit, :update, :destroy]
  
  # GET /posts
  def index
    @posts = Post.published.recent.page(params[:page])
    
    respond_to do |format|
      format.html
      format.json { render json: @posts }
    end
  end
  
  # GET /posts/1
  def show
    @comments = @post.comments.includes(:user)
    
    # Track view
    @post.increment!(:views_count)
  end
  
  # GET /posts/new
  def new
    @post = current_user.posts.build
  end
  
  # POST /posts
  def create
    @post = current_user.posts.build(post_params)
    
    if @post.save
      redirect_to @post, notice: &#39;Post created successfully.&#39;
    else
      render :new, status: :unprocessable_entity
    end
  end
  
  # GET /posts/1/edit
  def edit
  end
  
  # PATCH/PUT /posts/1
  def update
    if @post.update(post_params)
      redirect_to @post, notice: &#39;Post updated successfully.&#39;
    else
      render :edit, status: :unprocessable_entity
    end
  end
  
  # DELETE /posts/1
  def destroy
    @post.destroy
    redirect_to posts_path, notice: &#39;Post deleted successfully.&#39;
  end
  
  private
  
  def set_post
    @post = Post.find(params[:id])
  end
  
  def authorize_user!
    unless @post.user == current_user || current_user.admin?
      redirect_to root_path, alert: &#39;Not authorized.&#39;
    end
  end
  
  def post_params
    params.require(:post).permit(:title, :body, :published, images: [])
  end
end
</code></pre>
<hr>
<h3>MVC Flow Example</h3>
<p><strong>Complete request flow:</strong></p>
<pre><code class="language-ruby"># 1. Routes
# config/routes.rb
Rails.application.routes.draw do
  resources :posts
end

# 2. Controller receives request
# app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])  # ← Model interaction
    # Renders view automatically
  end
end

# 3. Model fetches data
# app/models/post.rb
class Post &lt; ApplicationRecord
  belongs_to :user
  has_many :comments
end

# 4. View displays data
# app/views/posts/show.html.erb
&lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
&lt;p&gt;&lt;%= @post.body %&gt;&lt;/p&gt;
</code></pre>
<hr>
<h3>Benefits of MVC</h3>
<p><strong>1. Separation of Concerns:</strong></p>
<pre><code class="language-ruby"># Model: Business logic
class Order &lt; ApplicationRecord
  def total
    line_items.sum(:price)
  end
end

# Controller: Coordination
class OrdersController &lt; ApplicationController
  def create
    @order = Order.create(order_params)
    # ...
  end
end

# View: Presentation
&lt;h2&gt;Total: &lt;%= number_to_currency(@order.total) %&gt;&lt;/h2&gt;
</code></pre>
<p><strong>2. Testability:</strong></p>
<pre><code class="language-ruby"># Model test
RSpec.describe Post do
  it &#39;validates presence of title&#39; do
    post = Post.new(title: nil)
    expect(post).not_to be_valid
  end
end

# Controller test
RSpec.describe PostsController do
  describe &#39;GET #show&#39; do
    it &#39;assigns @post&#39; do
      post = create(:post)
      get :show, params: { id: post.id }
      expect(assigns(:post)).to eq(post)
    end
  end
end

# View test
RSpec.describe &#39;posts/show.html.erb&#39; do
  it &#39;displays post title&#39; do
    assign(:post, build(:post, title: &#39;Test&#39;))
    render
    expect(rendered).to include(&#39;Test&#39;)
  end
end
</code></pre>
<p><strong>3. Code Reusability:</strong></p>
<pre><code class="language-ruby"># Model used by multiple controllers
class User &lt; ApplicationRecord
  has_many :posts
  has_many :comments
end

# Used in PostsController
@posts = current_user.posts

# Used in CommentsController
@comments = current_user.comments

# Used in API
render json: current_user
</code></pre>
<p><strong>4. Parallel Development:</strong></p>
<ul>
<li>Frontend developers work on Views</li>
<li>Backend developers work on Models</li>
<li>Application developers work on Controllers</li>
</ul>
<hr>
<h3>ORM + MVC Together</h3>
<p><strong>Complete CRUD Example:</strong></p>
<pre><code class="language-ruby"># Model (ORM)
class Article &lt; ApplicationRecord
  validates :title, presence: true
  belongs_to :author, class_name: &#39;User&#39;
  
  def published?
    published_at.present?
  end
end

# Controller (MVC)
class ArticlesController &lt; ApplicationController
  def index
    @articles = Article.where(published: true)
                      .includes(:author)
                      .order(created_at: :desc)
  end
  
  def create
    @article = current_user.articles.build(article_params)
    
    if @article.save
      redirect_to @article
    else
      render :new
    end
  end
  
  private
  
  def article_params
    params.require(:article).permit(:title, :body)
  end
end

# View (MVC)
&lt;!-- app/views/articles/index.html.erb --&gt;
&lt;% @articles.each do |article| %&gt;
  &lt;article&gt;
    &lt;h2&gt;&lt;%= link_to article.title, article %&gt;&lt;/h2&gt;
    &lt;p&gt;By &lt;%= article.author.name %&gt;&lt;/p&gt;
    &lt;p&gt;&lt;%= truncate(article.body, length: 200) %&gt;&lt;/p&gt;
  &lt;/article&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<p><strong>ORM (ActiveRecord):</strong></p>
<ol>
<li>Maps database tables to Ruby classes</li>
<li>Converts SQL to Ruby methods</li>
<li>Provides associations, validations, callbacks</li>
<li>Database-agnostic abstraction</li>
<li>Reduces boilerplate SQL code</li>
</ol>
<p><strong>MVC Pattern:</strong></p>
<ol>
<li><strong>Model</strong>: Business logic and data</li>
<li><strong>View</strong>: User interface and presentation</li>
<li><strong>Controller</strong>: Request handling and coordination</li>
<li>Separates concerns for maintainability</li>
<li>Enables parallel development and testing</li>
</ol>
<p><strong>Together:</strong></p>
<ul>
<li>ORM handles database (Model layer)</li>
<li>MVC organizes application structure</li>
<li>Rails implements both patterns seamlessly</li>
</ul>
<hr>
<h2>Question 45: Explain Rails architecture (MVC pattern)</h2>
<h3>Answer</h3>
<p>Rails follows the <strong>MVC (Model-View-Controller)</strong> architectural pattern with additional components that work together to handle web requests efficiently.</p>
<hr>
<h3>Complete Rails Architecture</h3>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                      Browser/Client                      │
└────────────────────────┬────────────────────────────────┘
                         │ HTTP Request
                         ▼
┌─────────────────────────────────────────────────────────┐
│                     Web Server (Puma)                    │
└────────────────────────┬────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│                    Rack Middleware                       │
│  ┌──────────┬──────────┬──────────┬──────────────────┐  │
│  │ Logger   │ Session  │ Cookies  │ Static Files     │  │
│  └──────────┴──────────┴──────────┴──────────────────┘  │
└────────────────────────┬────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│                    Router (Routes.rb)                    │
│         Matches URL → Controller#Action                  │
└────────────────────────┬────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│                      CONTROLLER                          │
│  ┌───────────────────────────────────────────────────┐  │
│  │ - Receives request                                 │  │
│  │ - Processes parameters                             │  │
│  │ - Calls models                                     │  │
│  │ - Prepares data for view                           │  │
│  │ - Renders response                                 │  │
│  └─────────┬──────────────────────┬───────────────────┘  │
│            │                      │                       │
└────────────┼──────────────────────┼───────────────────────┘
             │                      │
             ▼                      ▼
    ┌───────────────┐      ┌───────────────┐
    │     MODEL     │      │     VIEW      │
    │               │      │               │
    │ - Business    │      │ - Templates   │
    │   Logic       │      │ - HTML/JSON   │
    │ - Validations │      │ - Helpers     │
    │ - Database    │      │ - Partials    │
    │   Operations  │      │               │
    └───────┬───────┘      └───────┬───────┘
            │                      │
            ▼                      │
    ┌───────────────┐              │
    │   Database    │              │
    │  (PostgreSQL) │              │
    └───────────────┘              │
                                   │
                                   ▼
                          ┌──────────────┐
                          │   Response   │
                          │   (HTML)     │
                          └──────────────┘
</code></pre>
<hr>
<h3>Detailed Component Breakdown</h3>
<h3>1. Router (Routes)</h3>
<p><strong>Purpose:</strong> Maps URLs to controller actions</p>
<pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  root &#39;home#index&#39;
  
  # RESTful resources
  resources :posts do
    member do
      post :publish
    end
    collection do
      get :archived
    end
    resources :comments, only: [:create, :destroy]
  end
  
  # Custom routes
  get &#39;about&#39;, to: &#39;pages#about&#39;
  get &#39;search&#39;, to: &#39;search#index&#39;
  
  # Namespace
  namespace :admin do
    resources :users
    resources :posts
  end
  
  # API routes
  namespace :api do
    namespace :v1 do
      resources :posts, defaults: { format: :json }
    end
  end
end
</code></pre>
<p><strong>Route inspection:</strong></p>
<pre><code class="language-bash">rails routes

# Output:
# Prefix         Verb   URI Pattern                  Controller#Action
# root           GET    /                            home#index
# posts          GET    /posts                       posts#index
# posts          POST   /posts                       posts#create
# post           GET    /posts/:id                   posts#show
# edit_post      GET    /posts/:id/edit              posts#edit
# post           PATCH  /posts/:id                   posts#update
# post           DELETE /posts/:id                   posts#destroy
# publish_post   POST   /posts/:id/publish           posts#publish
</code></pre>
<hr>
<h3>2. Controller Layer</h3>
<p><strong>Purpose:</strong> Handles requests, coordinates Model and View</p>
<p><strong>Structure:</strong></p>
<pre><code class="language-ruby"># app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::Base
  before_action :configure_permitted_parameters, if: :devise_controller?
  before_action :set_locale
  
  protect_from_forgery with: :exception
  
  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found
  rescue_from ActionController::ParameterMissing, with: :bad_request
  
  private
  
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
  helper_method :current_user
  
  def authenticate_user!
    redirect_to login_path unless current_user
  end
  
  def set_locale
    I18n.locale = params[:locale] || I18n.default_locale
  end
  
  def record_not_found
    render file: &#39;public/404.html&#39;, status: :not_found
  end
  
  def bad_request
    render json: { error: &#39;Bad request&#39; }, status: :bad_request
  end
end
</code></pre>
<p><strong>Resource Controller:</strong></p>
<pre><code class="language-ruby"># app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  before_action :authenticate_user!, except: [:index, :show]
  before_action :set_post, only: [:show, :edit, :update, :destroy]
  before_action :authorize_user!, only: [:edit, :update, :destroy]
  
  # GET /posts
  def index
    @posts = Post.published
                 .includes(:user, :tags)
                 .page(params[:page])
                 .per(20)
    
    respond_to do |format|
      format.html
      format.json { render json: @posts }
      format.xml  { render xml: @posts }
    end
  end
  
  # GET /posts/:id
  def show
    @comments = @post.comments.includes(:user).recent
    @related_posts = Post.where(category: @post.category)
                        .where.not(id: @post.id)
                        .limit(5)
    
    # Track analytics
    Analytics.track_view(@post)
  end
  
  # GET /posts/new
  def new
    @post = current_user.posts.build
    @categories = Category.all
  end
  
  # POST /posts
  def create
    @post = current_user.posts.build(post_params)
    
    respond_to do |format|
      if @post.save
        format.html { redirect_to @post, notice: &#39;Post created.&#39; }
        format.json { render json: @post, status: :created }
      else
        format.html { render :new, status: :unprocessable_entity }
        format.json { render json: @post.errors, status: :unprocessable_entity }
      end
    end
  end
  
  # PATCH /posts/:id
  def update
    if @post.update(post_params)
      redirect_to @post, notice: &#39;Post updated.&#39;
    else
      render :edit, status: :unprocessable_entity
    end
  end
  
  # DELETE /posts/:id
  def destroy
    @post.destroy
    redirect_to posts_path, notice: &#39;Post deleted.&#39;
  end
  
  # POST /posts/:id/publish
  def publish
    if @post.publish!
      redirect_to @post, notice: &#39;Post published.&#39;
    else
      redirect_to @post, alert: &#39;Could not publish post.&#39;
    end
  end
  
  private
  
  def set_post
    @post = Post.includes(:user, :tags).find(params[:id])
  end
  
  def authorize_user!
    unless @post.user == current_user || current_user.admin?
      redirect_to root_path, alert: &#39;Not authorized.&#39;
    end
  end
  
  def post_params
    params.require(:post).permit(
      :title, :body, :category_id, :published,
      :featured_image, tag_ids: [], images: []
    )
  end
end
</code></pre>
<hr>
<h3>3. Model Layer</h3>
<p><strong>Purpose:</strong> Business logic, validations, database operations</p>
<p><strong>Model with full features:</strong></p>
<pre><code class="language-ruby"># app/models/post.rb
class Post &lt; ApplicationRecord
  # Associations
  belongs_to :user
  belongs_to :category
  has_many :comments, dependent: :destroy
  has_many :taggings, dependent: :destroy
  has_many :tags, through: :taggings
  has_many :likes, dependent: :destroy
  has_many :likers, through: :likes, source: :user
  
  # Active Storage
  has_one_attached :featured_image
  has_many_attached :images
  
  # Validations
  validates :title, presence: true, length: { minimum: 5, maximum: 100 }
  validates :body, presence: true, length: { minimum: 50 }
  validates :user, presence: true
  validates :category, presence: true
  validates :slug, uniqueness: true, if: :slug?
  
  # Scopes
  scope :published, -&gt; { where(published: true) }
  scope :draft, -&gt; { where(published: false) }
  scope :recent, -&gt; { order(created_at: :desc) }
  scope :popular, -&gt; { order(views_count: :desc) }
  scope :featured, -&gt; { where(featured: true) }
  scope :by_category, -&gt;(category) { where(category: category) }
  scope :search, -&gt;(query) {
    where(&quot;title ILIKE ? OR body ILIKE ?&quot;, &quot;%#{query}%&quot;, &quot;%#{query}%&quot;)
  }
  
  # Callbacks
  before_validation :generate_slug
  before_save :sanitize_body
  after_create :notify_followers
  after_update :clear_cache, if: :saved_change_to_published?
  
  # Class methods
  def self.trending(limit = 10)
    published
      .where(&#39;created_at &gt; ?&#39;, 7.days.ago)
      .order(&#39;views_count DESC, likes_count DESC&#39;)
      .limit(limit)
  end
  
  def self.most_commented
    left_joins(:comments)
      .group(:id)
      .order(&#39;COUNT(comments.id) DESC&#39;)
  end
  
  # Instance methods
  def publish!
    update(published: true, published_at: Time.current)
  end
  
  def unpublish!
    update(published: false, published_at: nil)
  end
  
  def reading_time
    (body.split.size / 200.0).ceil
  end
  
  def liked_by?(user)
    likers.include?(user)
  end
  
  def excerpt(length = 200)
    body.truncate(length, separator: &#39; &#39;)
  end
  
  private
  
  def generate_slug
    self.slug ||= title.to_s.parameterize
  end
  
  def sanitize_body
    self.body = ActionController::Base.helpers.sanitize(body)
  end
  
  def notify_followers
    NotifyFollowersJob.perform_later(id)
  end
  
  def clear_cache
    Rails.cache.delete(&quot;post_#{id}&quot;)
  end
end
</code></pre>
<p><strong>Model Concerns:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/sluggable.rb
module Sluggable
  extend ActiveSupport::Concern
  
  included do
    before_validation :generate_slug
    validates :slug, presence: true, uniqueness: true
  end
  
  class_methods do
    def find_by_slug(slug)
      find_by(slug: slug)
    end
  end
  
  def to_param
    slug
  end
  
  private
  
  def generate_slug
    return if slug.present?
    
    base_slug = title.to_s.parameterize
    candidate = base_slug
    counter = 1
    
    while self.class.exists?(slug: candidate)
      candidate = &quot;#{base_slug}-#{counter}&quot;
      counter += 1
    end
    
    self.slug = candidate
  end
end

# Usage in model
class Post &lt; ApplicationRecord
  include Sluggable
end
</code></pre>
<hr>
<h3>4. View Layer</h3>
<p><strong>Purpose:</strong> Presentation and user interface</p>
<p><strong>Layout:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/layouts/application.html.erb --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;%= content_for?(:title) ? yield(:title) : &quot;My App&quot; %&gt;&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;
    &lt;%= csrf_meta_tags %&gt;
    &lt;%= csp_meta_tag %&gt;
    
    &lt;%= stylesheet_link_tag &quot;application&quot;, &quot;data-turbo-track&quot;: &quot;reload&quot; %&gt;
    &lt;%= javascript_importmap_tags %&gt;
  &lt;/head&gt;
  
  &lt;body&gt;
    &lt;%= render &#39;shared/header&#39; %&gt;
    
    &lt;main class=&quot;container&quot;&gt;
      &lt;%= render &#39;shared/flash_messages&#39; %&gt;
      &lt;%= yield %&gt;
    &lt;/main&gt;
    
    &lt;%= render &#39;shared/footer&#39; %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>View Template:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/show.html.erb --&gt;
&lt;% content_for :title, @post.title %&gt;

&lt;article class=&quot;post&quot;&gt;
  &lt;header&gt;
    &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
    
    &lt;div class=&quot;meta&quot;&gt;
      &lt;span class=&quot;author&quot;&gt;
        &lt;%= link_to @post.user.name, @post.user %&gt;
      &lt;/span&gt;
      
      &lt;time datetime=&quot;&lt;%= @post.created_at.iso8601 %&gt;&quot;&gt;
        &lt;%= @post.created_at.strftime(&quot;%B %d, %Y&quot;) %&gt;
      &lt;/time&gt;
      
      &lt;span class=&quot;reading-time&quot;&gt;
        &lt;%= @post.reading_time %&gt; min read
      &lt;/span&gt;
    &lt;/div&gt;
    
    &lt;% if @post.featured_image.attached? %&gt;
      &lt;%= image_tag @post.featured_image, class: &#39;featured-image&#39; %&gt;
    &lt;% end %&gt;
  &lt;/header&gt;
  
  &lt;div class=&quot;content&quot;&gt;
    &lt;%= sanitize @post.body %&gt;
  &lt;/div&gt;
  
  &lt;footer&gt;
    &lt;div class=&quot;tags&quot;&gt;
      &lt;% @post.tags.each do |tag| %&gt;
        &lt;%= link_to tag.name, tag_path(tag), class: &#39;tag&#39; %&gt;
      &lt;% end %&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;actions&quot;&gt;
      &lt;% if current_user %&gt;
        &lt;%= button_to like_post_path(@post), 
                     method: :post, 
                     class: &quot;btn-like #{&#39;active&#39; if @post.liked_by?(current_user)}&quot; do %&gt;
          ♥ &lt;%= @post.likes_count %&gt;
        &lt;% end %&gt;
      &lt;% end %&gt;
      
      &lt;% if policy(@post).edit? %&gt;
        &lt;%= link_to &#39;Edit&#39;, edit_post_path(@post), class: &#39;btn&#39; %&gt;
      &lt;% end %&gt;
      
      &lt;% if policy(@post).destroy? %&gt;
        &lt;%= button_to &#39;Delete&#39;, @post, 
                     method: :delete, 
                     data: { confirm: &#39;Are you sure?&#39; },
                     class: &#39;btn btn-danger&#39; %&gt;
      &lt;% end %&gt;
    &lt;/div&gt;
  &lt;/footer&gt;
&lt;/article&gt;

&lt;section class=&quot;comments&quot;&gt;
  &lt;h2&gt;Comments (&lt;%= @post.comments.count %&gt;)&lt;/h2&gt;
  
  &lt;% if current_user %&gt;
    &lt;%= render &#39;comments/form&#39;, post: @post %&gt;
  &lt;% else %&gt;
    &lt;p&gt;&lt;%= link_to &#39;Log in&#39;, login_path %&gt; to comment&lt;/p&gt;
  &lt;% end %&gt;
  
  &lt;%= render @comments %&gt;
&lt;/section&gt;

&lt;% if @related_posts.any? %&gt;
  &lt;section class=&quot;related-posts&quot;&gt;
    &lt;h2&gt;Related Posts&lt;/h2&gt;
    &lt;%= render @related_posts %&gt;
  &lt;/section&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>Partials:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/_post.html.erb --&gt;
&lt;article class=&quot;post-card&quot;&gt;
  &lt;%= link_to post do %&gt;
    &lt;% if post.featured_image.attached? %&gt;
      &lt;%= image_tag post.featured_image.variant(resize_to_limit: [300, 200]) %&gt;
    &lt;% end %&gt;
    
    &lt;h3&gt;&lt;%= post.title %&gt;&lt;/h3&gt;
    &lt;p&gt;&lt;%= post.excerpt %&gt;&lt;/p&gt;
    
    &lt;div class=&quot;meta&quot;&gt;
      &lt;span&gt;&lt;%= post.user.name %&gt;&lt;/span&gt;
      &lt;span&gt;&lt;%= time_ago_in_words(post.created_at) %&gt; ago&lt;/span&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;/article&gt;
</code></pre>
<p><strong>Helpers:</strong></p>
<pre><code class="language-ruby"># app/helpers/posts_helper.rb
module PostsHelper
  def post_status_badge(post)
    status = post.published? ? &#39;Published&#39; : &#39;Draft&#39;
    css_class = post.published? ? &#39;badge-success&#39; : &#39;badge-secondary&#39;
    
    content_tag :span, status, class: &quot;badge #{css_class}&quot;
  end
  
  def post_share_links(post)
    url = post_url(post)
    title = post.title
    
    links = []
    links &lt;&lt; link_to &#39;Twitter&#39;, twitter_share_url(url, title), target: &#39;_blank&#39;
    links &lt;&lt; link_to &#39;Facebook&#39;, facebook_share_url(url), target: &#39;_blank&#39;
    links &lt;&lt; link_to &#39;LinkedIn&#39;, linkedin_share_url(url, title), target: &#39;_blank&#39;
    
    safe_join(links, &#39; | &#39;)
  end
  
  private
  
  def twitter_share_url(url, title)
    &quot;https://twitter.com/intent/tweet?url=#{url}&amp;text=#{title}&quot;
  end
  
  def facebook_share_url(url)
    &quot;https://www.facebook.com/sharer/sharer.php?u=#{url}&quot;
  end
  
  def linkedin_share_url(url, title)
    &quot;https://www.linkedin.com/sharing/share-offsite/?url=#{url}&quot;
  end
end
</code></pre>
<hr>
<h3>5. Additional Components</h3>
<p><strong>Services (Business Logic):</strong></p>
<pre><code class="language-ruby"># app/services/post_publisher.rb
class PostPublisher
  def initialize(post, user)
    @post = post
    @user = user
  end
  
  def call
    return false unless can_publish?
    
    ActiveRecord::Base.transaction do
      @post.publish!
      notify_followers
      update_analytics
      clear_caches
    end
    
    true
  rescue =&gt; e
    Rails.logger.error(&quot;Failed to publish post: #{e.message}&quot;)
    false
  end
  
  private
  
  def can_publish?
    @post.draft? &amp;&amp; (@post.user == @user || @user.admin?)
  end
  
  def notify_followers
    NotifyFollowersJob.perform_later(@post.id)
  end
  
  def update_analytics
    Analytics.track(&#39;post_published&#39;, post_id: @post.id)
  end
  
  def clear_caches
    Rails.cache.delete_matched(&quot;posts/*&quot;)
  end
end

# Usage in controller
def publish
  if PostPublisher.new(@post, current_user).call
    redirect_to @post, notice: &#39;Post published successfully.&#39;
  else
    redirect_to @post, alert: &#39;Failed to publish post.&#39;
  end
end
</code></pre>
<p><strong>Jobs (Background Processing):</strong></p>
<pre><code class="language-ruby"># app/jobs/notify_followers_job.rb
class NotifyFollowersJob &lt; ApplicationJob
  queue_as :default
  
  def perform(post_id)
    post = Post.find(post_id)
    followers = post.user.followers
    
    followers.find_each do |follower|
      NotificationMailer.new_post(follower, post).deliver_later
    end
  end
end
</code></pre>
<p><strong>Mailers:</strong></p>
<pre><code class="language-ruby"># app/mailers/notification_mailer.rb
class NotificationMailer &lt; ApplicationMailer
  def new_post(user, post)
    @user = user
    @post = post
    
    mail(
      to: user.email,
      subject: &quot;#{post.user.name} published a new post&quot;
    )
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Router</strong>: Maps URLs to controller actions</li>
<li><strong>Controller</strong>: Coordinates request handling</li>
<li><strong>Model</strong>: Handles business logic and data</li>
<li><strong>View</strong>: Presents data to users</li>
<li><strong>Additional layers</strong>: Services, Jobs, Mailers</li>
<li><strong>Separation of concerns</strong>: Each component has specific responsibility</li>
<li><strong>Convention over configuration</strong>: Rails provides sensible defaults</li>
<li><strong>DRY principle</strong>: Code reusability through partials, helpers, concerns</li>
</ol>
<h1>Rails Request Lifecycle and Middleware Interview Questions</h1>
<h2>Question 46: Explain Rails Request Lifecycle from start to finish</h2>
<h3>Answer</h3>
<p>The Rails request lifecycle describes how a request flows through the framework from the moment it arrives until a response is sent back to the client.</p>
<hr>
<h3>Complete Request Lifecycle Diagram</h3>
<pre><code>1. Browser sends HTTP Request
         ↓
2. Web Server (Puma/Unicorn)
         ↓
3. Rack Interface
         ↓
4. Middleware Stack (20+ middlewares)
   ├─ Rack::Sendfile
   ├─ ActionDispatch::Static
   ├─ Rack::Lock
   ├─ Rack::Runtime
   ├─ Rack::MethodOverride
   ├─ ActionDispatch::RequestId
   ├─ ActionDispatch::RemoteIp
   ├─ Rails::Rack::Logger
   ├─ ActionDispatch::ShowExceptions
   ├─ ActionDispatch::DebugExceptions
   ├─ ActionDispatch::Reloader
   ├─ ActionDispatch::Callbacks
   ├─ ActionDispatch::Cookies
   ├─ ActionDispatch::Session::CookieStore
   ├─ ActionDispatch::Flash
   ├─ Rack::Head
   ├─ Rack::ConditionalGet
   ├─ Rack::ETag
   └─ Rack::TempfileReaper
         ↓
5. Router (Routes.rb)
         ↓
6. Controller Action
   ├─ before_action callbacks
   ├─ Action execution
   ├─ Model interactions
   ├─ after_action callbacks
   └─ Response rendering
         ↓
7. View Rendering (if HTML)
   ├─ Layout
   ├─ Template
   ├─ Partials
   └─ Helpers
         ↓
8. Middleware Stack (reverse order)
         ↓
9. Web Server
         ↓
10. HTTP Response to Browser
</code></pre>
<hr>
<h3>Detailed Step-by-Step Flow</h3>
<h3>Step 1: Browser Request</h3>
<pre><code>GET /posts/123 HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept: text/html
Cookie: _session_id=abc123
</code></pre>
<hr>
<h3>Step 2: Web Server (Puma)</h3>
<p><strong>Puma receives the request:</strong></p>
<pre><code class="language-ruby"># config/puma.rb
threads_count = ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 }
threads threads_count, threads_count

workers ENV.fetch(&quot;WEB_CONCURRENCY&quot;) { 2 }

# Puma creates a Rack environment hash
env = {
  &#39;REQUEST_METHOD&#39; =&gt; &#39;GET&#39;,
  &#39;PATH_INFO&#39; =&gt; &#39;/posts/123&#39;,
  &#39;HTTP_HOST&#39; =&gt; &#39;example.com&#39;,
  &#39;HTTP_COOKIE&#39; =&gt; &#39;_session_id=abc123&#39;,
  &#39;rack.input&#39; =&gt; request_body,
  # ... many more keys
}
</code></pre>
<hr>
<h3>Step 3: Rack Interface</h3>
<pre><code class="language-ruby"># Rails app is a Rack application
# config/application.rb
module MyApp
  class Application &lt; Rails::Application
    # ...
  end
end

# The Rails app responds to `call`
response = MyApp::Application.call(env)
# Returns: [status, headers, body]
# Example: [200, {&quot;Content-Type&quot; =&gt; &quot;text/html&quot;}, [&quot;&lt;html&gt;...&quot;]]
</code></pre>
<hr>
<h3>Step 4: Middleware Stack</h3>
<p><strong>Each middleware processes the request:</strong></p>
<pre><code class="language-ruby"># View middleware stack
rails middleware

# Example middleware flow:
class MyMiddleware
  def initialize(app)
    @app = app
  end
  
  def call(env)
    # Before processing
    puts &quot;Before: #{env[&#39;PATH_INFO&#39;]}&quot;
    
    # Call next middleware
    status, headers, body = @app.call(env)
    
    # After processing
    puts &quot;After: #{status}&quot;
    
    [status, headers, body]
  end
end
</code></pre>
<p><strong>Key middlewares in action:</strong></p>
<p><strong>ActionDispatch::Static</strong> (serves static files):</p>
<pre><code class="language-ruby"># If request is for /assets/application.js
# Serves from public/assets/application.js
# Never reaches router!
if file_exists?(env[&#39;PATH_INFO&#39;])
  serve_static_file
else
  @app.call(env)  # Continue to next middleware
end
</code></pre>
<p><strong>ActionDispatch::Session::CookieStore</strong> (loads session):</p>
<pre><code class="language-ruby"># Decrypts session cookie
session_data = decrypt_cookie(env[&#39;HTTP_COOKIE&#39;])
env[&#39;rack.session&#39;] = session_data

# Makes session available in controllers
session[:user_id]  # =&gt; 123
</code></pre>
<p><strong>ActionDispatch::Flash</strong> (flash messages):</p>
<pre><code class="language-ruby"># Loads flash from session
flash = session[:flash] || {}
env[&#39;action_dispatch.request.flash&#39;] = flash

# Available in controllers/views
flash[:notice] = &quot;Post created!&quot;
</code></pre>
<hr>
<h3>Step 5: Router</h3>
<p><strong>Routes.rb matches the request:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  resources :posts
end

# Router matches:
# GET /posts/123 → PostsController#show
# params: { controller: &#39;posts&#39;, action: &#39;show&#39;, id: &#39;123&#39; }

# Route recognition
route_set.recognize_path(&#39;/posts/123&#39;, method: :get)
# =&gt; { controller: &#39;posts&#39;, action: &#39;show&#39;, id: &#39;123&#39; }
</code></pre>
<p><strong>Route constraints:</strong></p>
<pre><code class="language-ruby"># Can have constraints
get &#39;/posts/:id&#39;, to: &#39;posts#show&#39;, constraints: { id: /\d+/ }

# Advanced routing
namespace :api do
  namespace :v1 do
    resources :posts
  end
end

# Generates: GET /api/v1/posts/:id → Api::V1::PostsController#show
</code></pre>
<hr>
<h3>Step 6: Controller Processing</h3>
<p><strong>Controller initialization and action execution:</strong></p>
<pre><code class="language-ruby"># app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  before_action :authenticate_user!
  before_action :set_post, only: [:show, :edit, :update]
  after_action :log_view, only: [:show]
  
  def show
    # Execution flow:
    
    # 1. before_action :authenticate_user!
    redirect_to login_path unless current_user
    
    # 2. before_action :set_post
    @post = Post.find(params[:id])
    
    # 3. Action body
    @comments = @post.comments.recent
    @related_posts = Post.where(category: @post.category).limit(5)
    
    # 4. Implicit render
    # render :show
    
    # 5. after_action :log_view
    Analytics.track(&#39;post_view&#39;, post_id: @post.id)
  end
  
  private
  
  def set_post
    @post = Post.find(params[:id])
  rescue ActiveRecord::RecordNotFound
    redirect_to posts_path, alert: &#39;Post not found&#39;
  end
  
  def log_view
    @post.increment!(:views_count)
  end
end
</code></pre>
<p><strong>Detailed callback flow:</strong></p>
<pre><code class="language-ruby"># Callback order:
1. before_action callbacks (in order)
2. around_action (before part)
3. Action method
4. around_action (after part)
5. after_action callbacks (in order)
</code></pre>
<hr>
<h3>Step 7: Model Interaction</h3>
<p><strong>Database queries:</strong></p>
<pre><code class="language-ruby"># In controller
@post = Post.find(params[:id])

# ActiveRecord generates SQL:
# SELECT * FROM posts WHERE id = 123

# Loads associations if eager loaded
@post = Post.includes(:user, :comments).find(params[:id])

# Generates optimized queries:
# SELECT * FROM posts WHERE id = 123
# SELECT * FROM users WHERE id IN (...)
# SELECT * FROM comments WHERE post_id IN (...)
</code></pre>
<p><strong>Model callbacks during query:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  after_find :track_access
  
  private
  
  def track_access
    # Called after record is found
    Rails.logger.info &quot;Post #{id} accessed&quot;
  end
end
</code></pre>
<hr>
<h3>Step 8: View Rendering</h3>
<p><strong>Rendering process:</strong></p>
<pre><code class="language-ruby"># Controller implicitly calls:
render :show
# Equivalent to:
render template: &#39;posts/show&#39;, layout: &#39;application&#39;

# Rendering flow:
1. Find layout: app/views/layouts/application.html.erb
2. Find template: app/views/posts/show.html.erb
3. Process ERB
4. Render partials
5. Execute helpers
6. Generate HTML

# Detailed rendering:
class ActionView::Renderer
  def render(context, options)
    # 1. Load layout
    layout = find_layout(options[:layout])
    
    # 2. Load template
    template = find_template(options[:template])
    
    # 3. Compile ERB
    compiled = compile_template(template)
    
    # 4. Execute in context
    html = compiled.render(context)
    
    # 5. Insert into layout
    layout_html = layout.render { html }
    
    layout_html
  end
end
</code></pre>
<p><strong>View execution:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/layouts/application.html.erb --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;%= yield :title %&gt;&lt;/title&gt;
    &lt;%= csrf_meta_tags %&gt;
    &lt;%= stylesheet_link_tag &quot;application&quot; %&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%= render &#39;shared/header&#39; %&gt;
    &lt;%= yield %&gt;  &lt;!-- Template inserted here --&gt;
    &lt;%= render &#39;shared/footer&#39; %&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;!-- app/views/posts/show.html.erb --&gt;
&lt;% content_for :title, @post.title %&gt;

&lt;article&gt;
  &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
  &lt;div class=&quot;meta&quot;&gt;
    Posted by &lt;%= @post.user.name %&gt;
    on &lt;%= @post.created_at.strftime(&quot;%B %d, %Y&quot;) %&gt;
  &lt;/div&gt;
  
  &lt;div class=&quot;content&quot;&gt;
    &lt;%= simple_format(@post.body) %&gt;
  &lt;/div&gt;
  
  &lt;%= render &#39;comments/list&#39;, comments: @comments %&gt;
&lt;/article&gt;

&lt;!-- Partial: app/views/comments/_list.html.erb --&gt;
&lt;section class=&quot;comments&quot;&gt;
  &lt;% comments.each do |comment| %&gt;
    &lt;%= render comment %&gt;
  &lt;% end %&gt;
&lt;/section&gt;
</code></pre>
<p><strong>Helper execution:</strong></p>
<pre><code class="language-ruby"># app/helpers/posts_helper.rb
module PostsHelper
  def formatted_date(date)
    date.strftime(&quot;%B %d, %Y&quot;)
  end
end

# In view:
&lt;%= formatted_date(@post.created_at) %&gt;
# Calls helper method
</code></pre>
<hr>
<h3>Step 9: Response Generation</h3>
<p><strong>Controller prepares response:</strong></p>
<pre><code class="language-ruby"># Response components:
status = 200  # HTTP status code
headers = {
  &#39;Content-Type&#39; =&gt; &#39;text/html; charset=utf-8&#39;,
  &#39;ETag&#39; =&gt; &#39;&quot;abc123&quot;&#39;,
  &#39;Cache-Control&#39; =&gt; &#39;max-age=0, private, must-revalidate&#39;,
  &#39;X-Request-Id&#39; =&gt; &#39;unique-request-id&#39;,
  &#39;X-Runtime&#39; =&gt; &#39;0.123456&#39;
}
body = &quot;&lt;html&gt;...&lt;/html&gt;&quot;  # Rendered HTML

# Rack response format:
response = [status, headers, [body]]
</code></pre>
<p><strong>Different response formats:</strong></p>
<pre><code class="language-ruby"># HTML (default)
render :show
# =&gt; Content-Type: text/html

# JSON
render json: @post
# =&gt; Content-Type: application/json
# =&gt; Body: {&quot;id&quot;:123,&quot;title&quot;:&quot;...&quot;}

# Status codes
render :show, status: :ok  # 200
render json: @errors, status: :unprocessable_entity  # 422
redirect_to @post, status: :see_other  # 303

# Custom headers
response.headers[&#39;X-Custom&#39;] = &#39;value&#39;
</code></pre>
<hr>
<h3>Step 10: Middleware Stack (Reverse)</h3>
<p><strong>Response passes through middlewares in reverse order:</strong></p>
<pre><code class="language-ruby"># Each middleware can modify response:

# ActionDispatch::Cookies (sets cookies)
headers[&#39;Set-Cookie&#39;] = &quot;session_id=abc123; path=/; HttpOnly&quot;

# Rack::ETag (adds ETag header)
headers[&#39;ETag&#39;] = Digest::MD5.hexdigest(body)

# Rack::Runtime (adds response time)
headers[&#39;X-Runtime&#39;] = &quot;#{Time.now - start_time}&quot;

# ActionDispatch::Static (adds cache headers for static files)
headers[&#39;Cache-Control&#39;] = &#39;public, max-age=31536000&#39;

# Rack::Sendfile (handles file downloads)
if headers[&#39;X-Sendfile&#39;]
  # Delegate to web server
end
</code></pre>
<hr>
<h3>Step 11: Web Server Response</h3>
<p><strong>Puma sends HTTP response:</strong></p>
<pre><code class="language-ruby"># Puma formats Rack response as HTTP:
status, headers, body = response

http_response = &quot;HTTP/1.1 #{status} OK\r\n&quot;
headers.each do |key, value|
  http_response &lt;&lt; &quot;#{key}: #{value}\r\n&quot;
end
http_response &lt;&lt; &quot;\r\n&quot;
http_response &lt;&lt; body.join

# Send to client
socket.write(http_response)
</code></pre>
<hr>
<h3>Step 12: Browser Receives Response</h3>
<pre><code>HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
ETag: &quot;abc123&quot;
Cache-Control: max-age=0, private
X-Request-Id: unique-id
X-Runtime: 0.045
Set-Cookie: _session_id=abc123; path=/; HttpOnly

&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;...&lt;/head&gt;
  &lt;body&gt;...&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<h3>Complete Timing Breakdown</h3>
<pre><code class="language-ruby"># Typical request timing:

Total: 45ms
├─ Middleware: 2ms
├─ Routing: 1ms
├─ Controller: 35ms
│  ├─ before_action: 5ms
│  ├─ Database query: 20ms
│  └─ Action logic: 10ms
├─ View rendering: 5ms
└─ Response: 2ms
</code></pre>
<hr>
<h3>Debugging the Lifecycle</h3>
<p><strong>Rails Logger shows the flow:</strong></p>
<pre><code>Started GET &quot;/posts/123&quot; for 127.0.0.1 at 2024-01-15 10:30:00 +0000
Processing by PostsController#show as HTML
  Parameters: {&quot;id&quot;=&gt;&quot;123&quot;}
  User Load (0.5ms)  SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;id&quot; = $1 LIMIT $2  [[&quot;id&quot;, 1], [&quot;LIMIT&quot;, 1]]
  Post Load (1.2ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; WHERE &quot;posts&quot;.&quot;id&quot; = $1 LIMIT $2  [[&quot;id&quot;, 123], [&quot;LIMIT&quot;, 1]]
  Comment Load (0.8ms)  SELECT &quot;comments&quot;.* FROM &quot;comments&quot; WHERE &quot;comments&quot;.&quot;post_id&quot; = $1 ORDER BY &quot;comments&quot;.&quot;created_at&quot; DESC  [[&quot;post_id&quot;, 123]]
  Rendering layout layouts/application.html.erb
  Rendering posts/show.html.erb within layouts/application
  Rendered posts/show.html.erb within layouts/application (Duration: 12.3ms | Allocations: 4567)
  Rendered layout layouts/application.html.erb (Duration: 23.4ms | Allocations: 8901)
Completed 200 OK in 45ms (Views: 15.6ms | ActiveRecord: 2.5ms | Allocations: 12345)
</code></pre>
<hr>
<h3>Exception Handling in Lifecycle</h3>
<pre><code class="language-ruby"># If exception occurs:

1. Exception raised in controller
   ↓
2. ActionDispatch::ShowExceptions catches it
   ↓
3. Looks for rescue_from handler
   ↓
4. If not handled, renders error page:
   - 404 for RecordNotFound
   - 500 for other exceptions
   ↓
5. Response sent with error status
</code></pre>
<p><strong>Custom exception handling:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found
  rescue_from ActionController::ParameterMissing, with: :bad_request
  
  private
  
  def record_not_found
    render file: &#39;public/404.html&#39;, status: :not_found, layout: false
  end
  
  def bad_request
    render json: { error: &#39;Bad request&#39; }, status: :bad_request
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Request starts</strong> at web server (Puma)</li>
<li><strong>Passes through</strong> 20+ middleware layers</li>
<li><strong>Router</strong> matches URL to controller#action</li>
<li><strong>Controller</strong> executes callbacks and action</li>
<li><strong>Model</strong> interacts with database</li>
<li><strong>View</strong> renders HTML response</li>
<li><strong>Middlewares</strong> process response in reverse</li>
<li><strong>Web server</strong> sends HTTP response</li>
<li><strong>Each step</strong> can be customized</li>
<li><strong>Entire process</strong> typically takes 20-100ms</li>
</ol>
<hr>
<h2>Question 47: How does Rails handle request and response of a web request?</h2>
<h3>Answer</h3>
<p>Rails handles requests and responses through a carefully orchestrated process involving Rack, middleware, routing, and the MVC stack.</p>
<hr>
<h3>Request Handling</h3>
<p><strong>1. Rack Environment Hash</strong></p>
<p>When a request arrives, it&#39;s converted to a Rack environment hash:</p>
<pre><code class="language-ruby"># Sample Rack env hash
env = {
  &#39;REQUEST_METHOD&#39; =&gt; &#39;POST&#39;,
  &#39;PATH_INFO&#39; =&gt; &#39;/posts&#39;,
  &#39;QUERY_STRING&#39; =&gt; &#39;page=1&amp;sort=recent&#39;,
  &#39;SERVER_NAME&#39; =&gt; &#39;example.com&#39;,
  &#39;SERVER_PORT&#39; =&gt; &#39;80&#39;,
  &#39;HTTP_HOST&#39; =&gt; &#39;example.com&#39;,
  &#39;HTTP_USER_AGENT&#39; =&gt; &#39;Mozilla/5.0...&#39;,
  &#39;HTTP_ACCEPT&#39; =&gt; &#39;text/html,application/json&#39;,
  &#39;HTTP_COOKIE&#39; =&gt; &#39;_session_id=abc123; user_id=1&#39;,
  &#39;rack.version&#39; =&gt; [1, 3],
  &#39;rack.input&#39; =&gt; #&lt;StringIO&gt;,  # Request body
  &#39;rack.errors&#39; =&gt; #&lt;IO&gt;,
  &#39;rack.multithread&#39; =&gt; true,
  &#39;rack.multiprocess&#39; =&gt; false,
  &#39;rack.run_once&#39; =&gt; false,
  &#39;rack.url_scheme&#39; =&gt; &#39;https&#39;,
  &#39;CONTENT_TYPE&#39; =&gt; &#39;application/x-www-form-urlencoded&#39;,
  &#39;CONTENT_LENGTH&#39; =&gt; &#39;248&#39;
}
</code></pre>
<p><strong>2. ActionDispatch::Request Wrapper</strong></p>
<p>Rails wraps the Rack env in a request object:</p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    # request object provides convenient methods
    request.method          # =&gt; &quot;POST&quot;
    request.path            # =&gt; &quot;/posts&quot;
    request.fullpath        # =&gt; &quot;/posts?page=1&quot;
    request.url             # =&gt; &quot;https://example.com/posts?page=1&quot;
    request.host            # =&gt; &quot;example.com&quot;
    request.port            # =&gt; 80
    request.protocol        # =&gt; &quot;https://&quot;
    request.query_string    # =&gt; &quot;page=1&amp;sort=recent&quot;
    request.remote_ip       # =&gt; &quot;192.168.1.1&quot;
    request.user_agent      # =&gt; &quot;Mozilla/5.0...&quot;
    
    # Request format
    request.format          # =&gt; :html or :json
    request.xhr?            # =&gt; true if AJAX
    request.get?            # =&gt; false
    request.post?           # =&gt; true
    
    # Headers
    request.headers[&#39;Authorization&#39;]  # =&gt; &quot;Bearer token123&quot;
    request.headers[&#39;User-Agent&#39;]      # =&gt; &quot;Mozilla/5.0...&quot;
    
    # Content
    request.body            # =&gt; #&lt;StringIO&gt; with request body
    request.raw_post        # =&gt; &quot;title=Hello&amp;body=World&quot;
    request.content_type    # =&gt; &quot;application/x-www-form-urlencoded&quot;
    request.content_length  # =&gt; 248
    
    # Cookies and session
    request.cookies         # =&gt; {&quot;user_id&quot; =&gt; &quot;1&quot;}
    request.session         # =&gt; {&quot;user_id&quot; =&gt; 123}
  end
end
</code></pre>
<p><strong>3. Parameter Parsing</strong></p>
<p>Rails automatically parses parameters:</p>
<pre><code class="language-ruby"># URL: /posts?page=2&amp;sort=recent
# Form data: title=Hello&amp;body=World
# JSON: {&quot;post&quot;: {&quot;title&quot;: &quot;Hello&quot;, &quot;body&quot;: &quot;World&quot;}}

class PostsController &lt; ApplicationController
  def create
    # Query parameters
    params[:page]  # =&gt; &quot;2&quot;
    params[:sort]  # =&gt; &quot;recent&quot;
    
    # Form/JSON parameters
    params[:title]  # =&gt; &quot;Hello&quot;
    params[:post][:title]  # =&gt; &quot;Hello&quot;
    params[:post][:body]   # =&gt; &quot;World&quot;
    
    # Nested parameters
    params[:post][:tags]  # =&gt; [&quot;ruby&quot;, &quot;rails&quot;]
    
    # Strong parameters
    post_params = params.require(:post).permit(:title, :body, tags: [])
  end
end
</code></pre>
<p><strong>Different formats handled automatically:</strong></p>
<pre><code class="language-ruby"># JSON request
curl -X POST https://example.com/posts \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;post&quot;: {&quot;title&quot;: &quot;Hello&quot;}}&#39;

# Rails parses automatically
params[:post][:title]  # =&gt; &quot;Hello&quot;

# Form data
curl -X POST https://example.com/posts \
  -d &quot;post[title]=Hello&amp;post[body]=World&quot;

params[:post][:title]  # =&gt; &quot;Hello&quot;

# File upload
curl -X POST https://example.com/posts \
  -F &quot;post[title]=Hello&quot; \
  -F &quot;post[image]=@photo.jpg&quot;

params[:post][:image]  # =&gt; #&lt;ActionDispatch::Http::UploadedFile&gt;
</code></pre>
<hr>
<h3>Response Handling</h3>
<p><strong>1. Response Object</strong></p>
<p>Controllers have access to a response object:</p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    # Response object
    response.status = 200
    response.headers[&#39;X-Custom&#39;] = &#39;value&#39;
    response.content_type = &#39;text/html&#39;
    response.charset = &#39;utf-8&#39;
    
    # Set cookies
    response.set_cookie(&#39;user_pref&#39;, value: &#39;dark_mode&#39;, expires: 1.year.from_now)
    
    # Delete cookies
    response.delete_cookie(&#39;temp_data&#39;)
  end
end
</code></pre>
<p><strong>2. Rendering Responses</strong></p>
<p>Multiple ways to generate responses:</p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    # Implicit render (most common)
    # Renders app/views/posts/show.html.erb
    
    # Explicit render
    render :show
    render template: &#39;posts/show&#39;
    render &#39;posts/show&#39;
    
    # Different template
    render &#39;posts/custom_show&#39;
    
    # Different layout
    render layout: &#39;admin&#39;
    render layout: false
    
    # Partial
    render partial: &#39;post&#39;, locals: { post: @post }
    
    # Plain text
    render plain: &#39;Hello World&#39;
    
    # HTML string
    render html: &#39;&lt;h1&gt;Hello&lt;/h1&gt;&#39;.html_safe
    
    # JSON
    render json: @post
    render json: @post, status: :created
    render json: { error: &#39;Not found&#39; }, status: :not_found
    
    # XML
    render xml: @post
    
    # JavaScript
    render js: &quot;alert(&#39;Hello&#39;);&quot;
    
    # File
    render file: &#39;/path/to/file.html&#39;
    
    # Nothing (204 No Content)
    head :no_content
    head :ok
  end
end
</code></pre>
<p><strong>3. Response Status Codes</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    if @post.save
      # 200 OK (default)
      render json: @post
      
      # 201 Created
      render json: @post, status: :created
      
      # 204 No Content
      head :no_content
    else
      # 422 Unprocessable Entity
      render json: @post.errors, status: :unprocessable_entity
      
      # 400 Bad Request
      render json: { error: &#39;Bad request&#39; }, status: :bad_request
    end
  end
  
  def show
    @post = Post.find(params[:id])
  rescue ActiveRecord::RecordNotFound
    # 404 Not Found
    head :not_found
  end
  
  def update
    if authorized?
      # ...
    else
      # 403 Forbidden
      head :forbidden
    end
  end
end
</code></pre>
<p><strong>Common status codes:</strong></p>
<pre><code class="language-ruby"># 2xx Success
:ok                   # 200
:created              # 201
:accepted             # 202
:no_content           # 204

# 3xx Redirection
:moved_permanently    # 301
:found                # 302
:see_other            # 303
:not_modified         # 304

# 4xx Client Error
:bad_request          # 400
:unauthorized         # 401
:forbidden            # 403
:not_found            # 404
:method_not_allowed   # 405
:unprocessable_entity # 422

# 5xx Server Error
:internal_server_error # 500
:not_implemented      # 501
:bad_gateway          # 502
:service_unavailable  # 503
</code></pre>
<p><strong>4. Response Headers</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    # Set headers
    response.headers[&#39;X-Frame-Options&#39;] = &#39;DENY&#39;
    response.headers[&#39;X-Content-Type-Options&#39;] = &#39;nosniff&#39;
    response.headers[&#39;Cache-Control&#39;] = &#39;public, max-age=3600&#39;
    
    # ETag for caching
    fresh_when(etag: @post, last_modified: @post.updated_at)
    
    # Expires header
    expires_in 1.hour, public: true
    
    # Custom headers
    response.headers[&#39;X-API-Version&#39;] = &#39;v1&#39;
    response.headers[&#39;X-Rate-Limit&#39;] = &#39;100&#39;
  end
end
</code></pre>
<p><strong>5. Content Negotiation</strong></p>
<p>Rails automatically handles different formats:</p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    
    respond_to do |format|
      format.html { render :show }
      format.json { render json: @post }
      format.xml  { render xml: @post }
      format.pdf  { render pdf: generate_pdf(@post) }
      format.csv  { send_data generate_csv(@post), filename: &#39;post.csv&#39; }
    end
  end
end

# Request determines format:
# GET /posts/1          → HTML
# GET /posts/1.json     → JSON
# GET /posts/1.xml      → XML
# Accept: application/json → JSON
</code></pre>
<p><strong>6. Redirects</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    @post = Post.create(post_params)
    
    if @post.persisted?
      # Redirect to show page
      redirect_to @post
      
      # Redirect with notice
      redirect_to @post, notice: &#39;Post created!&#39;
      
      # Redirect with status
      redirect_to @post, status: :see_other
      
      # Redirect back
      redirect_back fallback_location: root_path
      
      # Redirect to URL
      redirect_to &#39;https://example.com/success&#39;
      
      # Redirect to path
      redirect_to posts_path
      redirect_to post_path(@post)
    else
      render :new, status: :unprocessable_entity
    end
  end
end
</code></pre>
<hr>
<h3>Complete Request-Response Example</h3>
<pre><code class="language-ruby"># 1. REQUEST arrives
# GET /posts/123?page=2
# Headers:
#   Accept: application/json
#   Cookie: _session_id=abc123

# 2. ROUTER matches
# routes.rb: resources :posts
# Matches to: PostsController#show

# 3. CONTROLLER processes
class PostsController &lt; ApplicationController
  def show
    # Access request data
    @page = params[:page]  # &quot;2&quot;
    @post_id = params[:id]  # &quot;123&quot;
    
    # Check request format
    if request.format.json?
      # Query database
      @post = Post.includes(:comments).find(@post_id)
      
      # Set response headers
      response.headers[&#39;X-Total-Comments&#39;] = @post.comments.count.to_s
      
      # Render JSON response
      render json: {
        post: @post,
        comments: @post.comments.page(@page)
      }, status: :ok
    else
      render :show
    end
  end
end

# 4. RESPONSE generated
# Status: 200 OK
# Headers:
#   Content-Type: application/json
#   X-Total-Comments: 42
# Body:
#   {&quot;post&quot;: {...}, &quot;comments&quot;: [...]}

# 5. BROWSER receives
# Parses JSON and displays
</code></pre>
<hr>
<h3>Streaming Responses</h3>
<p><strong>For large files or real-time data:</strong></p>
<pre><code class="language-ruby">class FilesController &lt; ApplicationController
  def download
    send_file &#39;/path/to/large_file.pdf&#39;,
              type: &#39;application/pdf&#39;,
              disposition: &#39;attachment&#39;,
              stream: true
  end
  
  def export
    send_data generate_large_csv,
              filename: &#39;data.csv&#39;,
              type: &#39;text/csv&#39;,
              disposition: &#39;attachment&#39;
  end
  
  def stream
    response.headers[&#39;Content-Type&#39;] = &#39;text/event-stream&#39;
    
    10.times do |i|
      response.stream.write &quot;data: Message #{i}\n\n&quot;
      sleep 1
    end
  ensure
    response.stream.close
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Request</strong> arrives as Rack environment hash</li>
<li><strong>ActionDispatch::Request</strong> provides convenient methods</li>
<li><strong>Parameters</strong> automatically parsed from URL/body/JSON</li>
<li><strong>Response</strong> can be HTML, JSON, XML, files, etc.</li>
<li><strong>Status codes</strong> indicate success/failure</li>
<li><strong>Headers</strong> control caching, security, content type</li>
<li><strong>Content negotiation</strong> handles different formats</li>
<li><strong>Streaming</strong> supports large files and real-time data</li>
</ol>
<hr>
<h2>Question 48: What is middleware in Rails?</h2>
<h3>Answer</h3>
<p><strong>Middleware</strong> are software components that sit between the web server and your Rails application, processing requests before they reach your app and responses before they&#39;re sent to clients.</p>
<hr>
<h3>What is Middleware?</h3>
<p>Think of middleware as a stack of layers that each request passes through:</p>
<pre><code>Request Flow:
Client → Server → MW1 → MW2 → MW3 → Rails App → Response
Response Flow:
Client ← Server ← MW1 ← MW2 ← MW3 ← Rails App ← Processing
</code></pre>
<p>Each middleware can:</p>
<ul>
<li>Modify the request</li>
<li>Modify the response</li>
<li>Short-circuit the request</li>
<li>Add functionality</li>
</ul>
<hr>
<h3>Viewing Middleware Stack</h3>
<pre><code class="language-bash">rails middleware

# Output:
use Rack::Sendfile
use ActionDispatch::Static
use ActionDispatch::Executor
use ActionDispatch::ServerTiming
use Rack::Runtime
use Rack::MethodOverride
use ActionDispatch::RequestId
use ActionDispatch::RemoteIp
use Rails::Rack::Logger
use ActionDispatch::ShowExceptions
use ActionDispatch::DebugExceptions
use ActionDispatch::ActionableExceptions
use ActionDispatch::Reloader
use ActionDispatch::Callbacks
use ActionDispatch::Cookies
use ActionDispatch::Session::CookieStore
use ActionDispatch::Flash
use ActionDispatch::ContentSecurityPolicy::Middleware
use ActionDispatch::PermissionsPolicy::Middleware
use Rack::Head
use Rack::ConditionalGet
use Rack::ETag
use Rack::TempfileReaper
run MyApp::Application.routes
</code></pre>
<hr>
<h3>How Middleware Works</h3>
<p><strong>Basic middleware structure:</strong></p>
<pre><code class="language-ruby">class MyMiddleware
  def initialize(app)
    @app = app  # Next middleware or app
  end
  
  def call(env)
    # Before: Process request
    puts &quot;Before: #{env[&#39;PATH_INFO&#39;]}&quot;
    
    # Call next middleware/app
    status, headers, body = @app.call(env)
    
    # After: Process response
    puts &quot;After: Status #{status}&quot;
    
    # Return response
    [status, headers, body]
  end
end
</code></pre>
<p><strong>Request flow through middleware:</strong></p>
<pre><code class="language-ruby"># Request arrives
env = { &#39;PATH_INFO&#39; =&gt; &#39;/posts/123&#39; }

# MW1 processes
MW1: &quot;Before: /posts/123&quot;
  # MW2 processes
  MW2: &quot;Before: /posts/123&quot;
    # MW3 processes
    MW3: &quot;Before: /posts/123&quot;
      # Rails app processes
      Rails: &quot;Processing PostsController#show&quot;
      Rails: Returns [200, {...}, [&quot;&lt;html&gt;...&quot;]]
    MW3: &quot;After: Status 200&quot;
  MW2: &quot;After: Status 200&quot;
MW1: &quot;After: Status 200&quot;

# Response sent to client
</code></pre>
<hr>
<h3>Common Rails Middlewares</h3>
<p><strong>1. Rack::Sendfile</strong></p>
<pre><code class="language-ruby"># Delegates file serving to web server
# More efficient than Rails serving files

# In controller:
send_file &#39;/path/to/file.pdf&#39;

# Middleware adds X-Sendfile header:
headers[&#39;X-Sendfile&#39;] = &#39;/path/to/file.pdf&#39;

# Web server (Nginx/Apache) serves the file
</code></pre>
<p><strong>2. ActionDispatch::Static</strong></p>
<pre><code class="language-ruby"># Serves static files from public/
# GET /assets/application.js → public/assets/application.js

# Short-circuits if file exists:
if File.exist?(public_path)
  serve_file(public_path)
  # Never reaches Rails app!
else
  @app.call(env)  # Continue to next middleware
end
</code></pre>
<p><strong>3. Rack::Runtime</strong></p>
<pre><code class="language-ruby"># Adds X-Runtime header with request time

def call(env)
  start_time = Time.now
  status, headers, body = @app.call(env)
  
  runtime = Time.now - start_time
  headers[&#39;X-Runtime&#39;] = runtime.to_s
  
  [status, headers, body]
end

# Response includes:
# X-Runtime: 0.045  # 45ms
</code></pre>
<p><strong>4. ActionDispatch::RequestId</strong></p>
<pre><code class="language-ruby"># Adds unique ID to each request

def call(env)
  request_id = SecureRandom.uuid
  env[&#39;action_dispatch.request_id&#39;] = request_id
  
  status, headers, body = @app.call(env)
  
  headers[&#39;X-Request-Id&#39;] = request_id
  
  [status, headers, body]
end

# Useful for tracking requests in logs:
# [abc-123-def] Started GET &quot;/posts&quot;
# [abc-123-def] Processing by PostsController#index
</code></pre>
<p><strong>5. ActionDispatch::Session::CookieStore</strong></p>
<pre><code class="language-ruby"># Manages session data in encrypted cookies

def call(env)
  # Load session from cookie
  session_data = decrypt_cookie(env[&#39;HTTP_COOKIE&#39;])
  env[&#39;rack.session&#39;] = session_data
  
  status, headers, body = @app.call(env)
  
  # Save session to cookie
  cookie = encrypt_session(env[&#39;rack.session&#39;])
  headers[&#39;Set-Cookie&#39;] = cookie
  
  [status, headers, body]
end

# In controller:
session[:user_id] = 123
session[:cart] = { items: [] }
</code></pre>
<p><strong>6. ActionDispatch::Flash</strong></p>
<pre><code class="language-ruby"># Handles flash messages (one-time notices)

def call(env)
  # Load flash from session
  flash = env[&#39;rack.session&#39;][:flash] || {}
  env[&#39;action_dispatch.request.flash&#39;] = flash
  
  status, headers, body = @app.call(env)
  
  # Clear used flash, keep new flash
  sweep_flash(env)
  
  [status, headers, body]
end

# In controller:
flash[:notice] = &quot;Post created!&quot;
flash[:alert] = &quot;Error occurred&quot;

# In view:
&lt;%= flash[:notice] %&gt;
</code></pre>
<p><strong>7. Rack::ETag</strong></p>
<pre><code class="language-ruby"># Adds ETag header for caching

def call(env)
  status, headers, body = @app.call(env)
  
  # Generate ETag from response body
  etag = Digest::MD5.hexdigest(body.join)
  headers[&#39;ETag&#39;] = %(&quot;#{etag}&quot;)
  
  # Check If-None-Match header
  if env[&#39;HTTP_IF_NONE_MATCH&#39;] == etag
    # Return 304 Not Modified
    [304, headers, []]
  else
    [status, headers, body]
  end
end
</code></pre>
<p><strong>8. ActionDispatch::ShowExceptions</strong></p>
<pre><code class="language-ruby"># Catches exceptions and renders error pages

def call(env)
  begin
    @app.call(env)
  rescue Exception =&gt; exception
    render_exception(env, exception)
  end
end

def render_exception(env, exception)
  case exception
  when ActiveRecord::RecordNotFound
    [404, {...}, [render_404]]
  when ActionController::RoutingError
    [404, {...}, [render_404]]
  else
    [500, {...}, [render_500]]
  end
end
</code></pre>
<hr>
<h3>Custom Middleware</h3>
<p><strong>Example 1: Request Logger</strong></p>
<pre><code class="language-ruby"># lib/middleware/request_logger.rb
class RequestLogger
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request = Rack::Request.new(env)
    
    Rails.logger.info &quot;=&quot;*50
    Rails.logger.info &quot;Request: #{request.request_method} #{request.fullpath}&quot;
    Rails.logger.info &quot;IP: #{request.ip}&quot;
    Rails.logger.info &quot;User-Agent: #{request.user_agent}&quot;
    
    status, headers, body = @app.call(env)
    
    Rails.logger.info &quot;Response: #{status}&quot;
    Rails.logger.info &quot;=&quot;*50
    
    [status, headers, body]
  end
end

# config/application.rb
config.middleware.use RequestLogger
</code></pre>
<p><strong>Example 2: API Key Authentication</strong></p>
<pre><code class="language-ruby"># lib/middleware/api_key_authenticator.rb
class ApiKeyAuthenticator
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request = Rack::Request.new(env)
    
    # Only check API endpoints
    if request.path.start_with?(&#39;/api/&#39;)
      api_key = request.headers[&#39;X-API-Key&#39;]
      
      unless valid_api_key?(api_key)
        return [
          401,
          { &#39;Content-Type&#39; =&gt; &#39;application/json&#39; },
          [{ error: &#39;Invalid API key&#39; }.to_json]
        ]
      end
    end
    
    @app.call(env)
  end
  
  private
  
  def valid_api_key?(key)
    ApiKey.exists?(key: key, active: true)
  end
end

# config/application.rb
config.middleware.use ApiKeyAuthenticator
</code></pre>
<p><strong>Example 3: Request Timing</strong></p>
<pre><code class="language-ruby"># lib/middleware/request_timer.rb
class RequestTimer
  def initialize(app)
    @app = app
  end
  
  def call(env)
    start_time = Time.now
    
    status, headers, body = @app.call(env)
    
    end_time = Time.now
    duration = ((end_time - start_time) * 1000).round(2)
    
    # Log slow requests
    if duration &gt; 1000  # &gt; 1 second
      Rails.logger.warn &quot;Slow request: #{env[&#39;PATH_INFO&#39;]} took #{duration}ms&quot;
    end
    
    headers[&#39;X-Request-Time&#39;] = &quot;#{duration}ms&quot;
    
    [status, headers, body]
  end
end
</code></pre>
<p><strong>Example 4: CORS Headers</strong></p>
<pre><code class="language-ruby"># lib/middleware/cors.rb
class Cors
  def initialize(app)
    @app = app
  end
  
  def call(env)
    status, headers, body = @app.call(env)
    
    headers[&#39;Access-Control-Allow-Origin&#39;] = &#39;*&#39;
    headers[&#39;Access-Control-Allow-Methods&#39;] = &#39;GET, POST, PUT, DELETE, OPTIONS&#39;
    headers[&#39;Access-Control-Allow-Headers&#39;] = &#39;Content-Type, Authorization&#39;
    
    [status, headers, body]
  end
end

# config/application.rb
config.middleware.use Cors
</code></pre>
<hr>
<h3>Managing Middleware</h3>
<p><strong>Add middleware:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.middleware.use MyMiddleware

# Insert at specific position
config.middleware.insert_before ActionDispatch::Static, MyMiddleware
config.middleware.insert_after ActionDispatch::Static, MyMiddleware

# Insert at beginning or end
config.middleware.unshift MyMiddleware  # Beginning
config.middleware.use MyMiddleware      # End
</code></pre>
<p><strong>Remove middleware:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.middleware.delete Rack::ETag
config.middleware.delete ActionDispatch::Flash
</code></pre>
<p><strong>Swap middleware:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.middleware.swap ActionDispatch::ShowExceptions, MyExceptionHandler
</code></pre>
<hr>
<h3>Middleware vs. Before Filters</h3>
<p><strong>When to use Middleware:</strong></p>
<ul>
<li>Affects all requests (including non-Rails requests)</li>
<li>Needs to run before routing</li>
<li>Cross-cutting concerns (logging, authentication)</li>
<li>Performance-critical operations</li>
</ul>
<p><strong>When to use Before Filters:</strong></p>
<ul>
<li>Controller-specific logic</li>
<li>Needs access to controller methods</li>
<li>Resource-specific operations</li>
</ul>
<pre><code class="language-ruby"># Middleware - runs for ALL requests
class AuthMiddleware
  def call(env)
    # Runs before routing
  end
end

# Before Filter - runs for specific controller
class PostsController &lt; ApplicationController
  before_action :authenticate_user!
  # Runs after routing, before action
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Middleware</strong> sits between server and Rails app</li>
<li><strong>Each middleware</strong> can modify request/response</li>
<li><strong>Stack order matters</strong> - request flows through in order</li>
<li><strong>Common uses</strong>: sessions, cookies, logging, caching</li>
<li><strong>Custom middleware</strong> for cross-cutting concerns</li>
<li><strong>Rack interface</strong>: <code>call(env)</code> returns <code>[status, headers, body]</code></li>
<li><strong>Configured in</strong> <code>config/application.rb</code></li>
</ol>
<h1>Rails Middleware Customization and Deep Dive</h1>
<h2>Question 49: How does Rails handle middleware, and how can you customize it?</h2>
<h3>Answer</h3>
<p>Rails provides a sophisticated middleware stack built on Rack, with extensive customization options. Understanding how to manage this stack is crucial for adding cross-cutting concerns and optimizing request processing.</p>
<hr>
<h3>How Rails Handles Middleware</h3>
<p><strong>1. Middleware Stack Initialization</strong></p>
<p>When Rails boots, it builds the middleware stack:</p>
<pre><code class="language-ruby"># config/application.rb
module MyApp
  class Application &lt; Rails::Application
    # Rails automatically loads default middleware
    # You can view it with: rails middleware
  end
end
</code></pre>
<p><strong>Default stack structure:</strong></p>
<pre><code class="language-ruby"># Rails builds middleware in this order:
ActionDispatch::HostAuthorization
Rack::Sendfile
ActionDispatch::Static
ActionDispatch::Executor
ActionDispatch::ServerTiming
ActiveSupport::Cache::Strategy::LocalCache::Middleware
Rack::Runtime
Rack::MethodOverride
ActionDispatch::RequestId
ActionDispatch::RemoteIp
Sprockets::Rails::QuietAssets
Rails::Rack::Logger
ActionDispatch::ShowExceptions
WebConsole::Middleware
ActionDispatch::DebugExceptions
ActionDispatch::ActionableExceptions
ActionDispatch::Reloader
ActionDispatch::Callbacks
ActiveRecord::Migration::CheckPending
ActionDispatch::Cookies
ActionDispatch::Session::CookieStore
ActionDispatch::Flash
ActionDispatch::ContentSecurityPolicy::Middleware
ActionDispatch::PermissionsPolicy::Middleware
Rack::Head
Rack::ConditionalGet
Rack::ETag
Rack::TempfileReaper
</code></pre>
<p><strong>2. Middleware Configuration</strong></p>
<p>Rails provides a <code>config.middleware</code> API:</p>
<pre><code class="language-ruby"># config/application.rb
module MyApp
  class Application &lt; Rails::Application
    # The middleware stack is built here
    config.middleware.use MyMiddleware
  end
end
</code></pre>
<hr>
<h3>Customizing Middleware</h3>
<h3>1. Adding Middleware</h3>
<p><strong>At the end of the stack:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.middleware.use MyMiddleware
config.middleware.use ApiKeyAuthenticator
config.middleware.use RequestLogger

# These run after all default middleware
</code></pre>
<p><strong>At the beginning of the stack:</strong></p>
<pre><code class="language-ruby">config.middleware.unshift MyMiddleware

# Runs before any other middleware
# Useful for early request rejection
</code></pre>
<p><strong>At specific position:</strong></p>
<pre><code class="language-ruby"># Insert before specific middleware
config.middleware.insert_before ActionDispatch::Static, MyMiddleware

# Insert after specific middleware
config.middleware.insert_after ActionDispatch::Static, MyMiddleware

# Insert at specific index
config.middleware.insert(0, MyMiddleware)  # First position
</code></pre>
<hr>
<h3>2. Removing Middleware</h3>
<pre><code class="language-ruby"># Remove specific middleware
config.middleware.delete Rack::Runtime
config.middleware.delete ActionDispatch::Flash

# Remove if you don&#39;t need flash messages
config.middleware.delete ActionDispatch::Flash

# Remove if API-only (no sessions)
config.middleware.delete ActionDispatch::Session::CookieStore
config.middleware.delete ActionDispatch::Cookies

# Remove if no static files
config.middleware.delete ActionDispatch::Static
</code></pre>
<hr>
<h3>3. Swapping Middleware</h3>
<pre><code class="language-ruby"># Replace default middleware with custom version
config.middleware.swap ActionDispatch::ShowExceptions, CustomExceptionHandler
config.middleware.swap ActionDispatch::Session::CookieStore, ActionDispatch::Session::RedisStore
</code></pre>
<hr>
<h3>4. Moving Middleware</h3>
<pre><code class="language-ruby"># Move to different position
config.middleware.move_before ActionDispatch::Flash, MyMiddleware
config.middleware.move_after ActionDispatch::Flash, MyMiddleware
</code></pre>
<hr>
<h3>Complete Customization Examples</h3>
<p><strong>Example 1: API-Only Application</strong></p>
<pre><code class="language-ruby"># config/application.rb
module ApiApp
  class Application &lt; Rails::Application
    config.api_only = true
    
    # Remove unnecessary middleware for API
    config.middleware.delete ActionDispatch::Flash
    config.middleware.delete ActionDispatch::Static
    config.middleware.delete ActionDispatch::Cookies
    config.middleware.delete ActionDispatch::Session::CookieStore
    
    # Add API-specific middleware
    config.middleware.use Rack::Attack
    config.middleware.use Rack::Cors
    config.middleware.use ApiKeyAuthenticator
    config.middleware.use RateLimiter
  end
end
</code></pre>
<p><strong>Example 2: Custom Exception Handler</strong></p>
<pre><code class="language-ruby"># lib/middleware/custom_exception_handler.rb
class CustomExceptionHandler
  def initialize(app)
    @app = app
  end
  
  def call(env)
    @app.call(env)
  rescue StandardError =&gt; e
    handle_exception(env, e)
  end
  
  private
  
  def handle_exception(env, exception)
    request = ActionDispatch::Request.new(env)
    
    case exception
    when ActiveRecord::RecordNotFound
      render_error(404, &#39;Resource not found&#39;, request)
    when ActionController::ParameterMissing
      render_error(400, &#39;Missing required parameter&#39;, request)
    when JWT::DecodeError
      render_error(401, &#39;Invalid authentication token&#39;, request)
    when Pundit::NotAuthorizedError
      render_error(403, &#39;Not authorized&#39;, request)
    else
      log_exception(exception)
      render_error(500, &#39;Internal server error&#39;, request)
    end
  end
  
  def render_error(status, message, request)
    body = {
      error: message,
      status: status,
      timestamp: Time.current.iso8601
    }
    
    headers = { &#39;Content-Type&#39; =&gt; &#39;application/json&#39; }
    
    [status, headers, [body.to_json]]
  end
  
  def log_exception(exception)
    Rails.logger.error &quot;Exception: #{exception.class} - #{exception.message}&quot;
    Rails.logger.error exception.backtrace.join(&quot;\n&quot;)
    
    # Send to error tracking service
    Sentry.capture_exception(exception) if defined?(Sentry)
  end
end

# config/application.rb
config.middleware.swap ActionDispatch::ShowExceptions, CustomExceptionHandler
</code></pre>
<p><strong>Example 3: Request/Response Logger</strong></p>
<pre><code class="language-ruby"># lib/middleware/detailed_logger.rb
class DetailedLogger
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request = Rack::Request.new(env)
    
    log_request(request)
    start_time = Time.now
    
    status, headers, body = @app.call(env)
    
    duration = ((Time.now - start_time) * 1000).round(2)
    log_response(request, status, duration)
    
    [status, headers, body]
  end
  
  private
  
  def log_request(request)
    Rails.logger.info &quot;=&quot;*80
    Rails.logger.info &quot;REQUEST: #{request.request_method} #{request.fullpath}&quot;
    Rails.logger.info &quot;IP: #{request.ip}&quot;
    Rails.logger.info &quot;User-Agent: #{request.user_agent}&quot;
    Rails.logger.info &quot;Referer: #{request.referer}&quot;
    
    # Log headers
    if Rails.env.development?
      important_headers(request).each do |key, value|
        Rails.logger.debug &quot;  #{key}: #{value}&quot;
      end
    end
    
    # Log body for POST/PUT/PATCH
    if %w[POST PUT PATCH].include?(request.request_method)
      begin
        body = request.body.read
        request.body.rewind
        Rails.logger.debug &quot;Body: #{body[0..500]}&quot; if body.present?
      rescue =&gt; e
        Rails.logger.debug &quot;Could not read body: #{e.message}&quot;
      end
    end
  end
  
  def log_response(request, status, duration)
    Rails.logger.info &quot;RESPONSE: #{status} in #{duration}ms&quot;
    
    # Log slow requests
    if duration &gt; 1000
      Rails.logger.warn &quot;SLOW REQUEST: #{request.request_method} #{request.fullpath} took #{duration}ms&quot;
    end
    
    Rails.logger.info &quot;=&quot;*80
  end
  
  def important_headers(request)
    {
      &#39;Authorization&#39; =&gt; request.get_header(&#39;HTTP_AUTHORIZATION&#39;),
      &#39;Content-Type&#39; =&gt; request.content_type,
      &#39;Accept&#39; =&gt; request.get_header(&#39;HTTP_ACCEPT&#39;),
      &#39;X-Request-Id&#39; =&gt; request.get_header(&#39;HTTP_X_REQUEST_ID&#39;)
    }.compact
  end
end

# config/application.rb
config.middleware.use DetailedLogger if Rails.env.development?
</code></pre>
<p><strong>Example 4: Authentication Middleware</strong></p>
<pre><code class="language-ruby"># lib/middleware/jwt_authenticator.rb
class JwtAuthenticator
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request = Rack::Request.new(env)
    
    # Skip authentication for public endpoints
    return @app.call(env) if public_endpoint?(request)
    
    # Extract token
    token = extract_token(request)
    
    unless token
      return unauthorized_response(&#39;Missing authentication token&#39;)
    end
    
    # Verify token
    begin
      payload = JWT.decode(token, secret_key, true, algorithm: &#39;HS256&#39;)[0]
      env[&#39;current_user_id&#39;] = payload[&#39;user_id&#39;]
      env[&#39;current_user_role&#39;] = payload[&#39;role&#39;]
    rescue JWT::DecodeError =&gt; e
      return unauthorized_response(&#39;Invalid token&#39;)
    rescue JWT::ExpiredSignature
      return unauthorized_response(&#39;Token expired&#39;)
    end
    
    @app.call(env)
  end
  
  private
  
  def public_endpoint?(request)
    public_paths = [
      &#39;/api/v1/login&#39;,
      &#39;/api/v1/signup&#39;,
      &#39;/api/v1/health&#39;,
      &#39;/api/v1/docs&#39;
    ]
    
    public_paths.any? { |path| request.path.start_with?(path) }
  end
  
  def extract_token(request)
    auth_header = request.get_header(&#39;HTTP_AUTHORIZATION&#39;)
    return nil unless auth_header
    
    # Bearer token format: &quot;Bearer &lt;token&gt;&quot;
    auth_header.split(&#39; &#39;).last if auth_header.start_with?(&#39;Bearer &#39;)
  end
  
  def unauthorized_response(message)
    [
      401,
      { &#39;Content-Type&#39; =&gt; &#39;application/json&#39; },
      [{ error: message }.to_json]
    ]
  end
  
  def secret_key
    Rails.application.credentials.secret_key_base
  end
end

# config/application.rb
config.middleware.use JwtAuthenticator
</code></pre>
<p><strong>Example 5: Rate Limiter</strong></p>
<pre><code class="language-ruby"># lib/middleware/rate_limiter.rb
class RateLimiter
  def initialize(app, options = {})
    @app = app
    @limit = options[:limit] || 100
    @period = options[:period] || 3600  # 1 hour
    @redis = Redis.new
  end
  
  def call(env)
    request = Rack::Request.new(env)
    key = rate_limit_key(request)
    
    current = @redis.get(key).to_i
    
    if current &gt;= @limit
      return rate_limit_exceeded_response
    end
    
    # Increment counter
    @redis.multi do
      @redis.incr(key)
      @redis.expire(key, @period) if current == 0
    end
    
    status, headers, body = @app.call(env)
    
    # Add rate limit headers
    headers[&#39;X-RateLimit-Limit&#39;] = @limit.to_s
    headers[&#39;X-RateLimit-Remaining&#39;] = (@limit - current - 1).to_s
    headers[&#39;X-RateLimit-Reset&#39;] = (@redis.ttl(key) + Time.now.to_i).to_s
    
    [status, headers, body]
  end
  
  private
  
  def rate_limit_key(request)
    # Rate limit by IP and endpoint
    identifier = request.ip
    endpoint = request.path
    &quot;rate_limit:#{identifier}:#{endpoint}&quot;
  end
  
  def rate_limit_exceeded_response
    [
      429,
      { 
        &#39;Content-Type&#39; =&gt; &#39;application/json&#39;,
        &#39;Retry-After&#39; =&gt; @period.to_s
      },
      [{ error: &#39;Rate limit exceeded&#39; }.to_json]
    ]
  end
end

# config/application.rb
config.middleware.use RateLimiter, limit: 1000, period: 3600
</code></pre>
<p><strong>Example 6: CORS Middleware</strong></p>
<pre><code class="language-ruby"># lib/middleware/cors.rb
class Cors
  def initialize(app, options = {})
    @app = app
    @allowed_origins = options[:allowed_origins] || [&#39;*&#39;]
    @allowed_methods = options[:allowed_methods] || [&#39;GET&#39;, &#39;POST&#39;, &#39;PUT&#39;, &#39;DELETE&#39;, &#39;OPTIONS&#39;]
    @allowed_headers = options[:allowed_headers] || [&#39;Content-Type&#39;, &#39;Authorization&#39;]
    @max_age = options[:max_age] || 86400
  end
  
  def call(env)
    request = Rack::Request.new(env)
    origin = request.get_header(&#39;HTTP_ORIGIN&#39;)
    
    # Handle preflight request
    if request.request_method == &#39;OPTIONS&#39;
      return preflight_response(origin)
    end
    
    # Process actual request
    status, headers, body = @app.call(env)
    
    # Add CORS headers
    if origin &amp;&amp; allowed_origin?(origin)
      headers[&#39;Access-Control-Allow-Origin&#39;] = origin
      headers[&#39;Access-Control-Allow-Credentials&#39;] = &#39;true&#39;
      headers[&#39;Vary&#39;] = &#39;Origin&#39;
    end
    
    [status, headers, body]
  end
  
  private
  
  def allowed_origin?(origin)
    @allowed_origins.include?(&#39;*&#39;) || @allowed_origins.include?(origin)
  end
  
  def preflight_response(origin)
    headers = {
      &#39;Content-Type&#39; =&gt; &#39;text/plain&#39;,
      &#39;Access-Control-Allow-Methods&#39; =&gt; @allowed_methods.join(&#39;, &#39;),
      &#39;Access-Control-Allow-Headers&#39; =&gt; @allowed_headers.join(&#39;, &#39;),
      &#39;Access-Control-Max-Age&#39; =&gt; @max_age.to_s
    }
    
    if origin &amp;&amp; allowed_origin?(origin)
      headers[&#39;Access-Control-Allow-Origin&#39;] = origin
      headers[&#39;Access-Control-Allow-Credentials&#39;] = &#39;true&#39;
    end
    
    [200, headers, []]
  end
end

# config/application.rb
config.middleware.insert_before 0, Cors,
  allowed_origins: [&#39;https://example.com&#39;, &#39;https://app.example.com&#39;],
  allowed_methods: [&#39;GET&#39;, &#39;POST&#39;, &#39;PUT&#39;, &#39;DELETE&#39;, &#39;PATCH&#39;, &#39;OPTIONS&#39;],
  allowed_headers: [&#39;Content-Type&#39;, &#39;Authorization&#39;, &#39;X-Request-Id&#39;]
</code></pre>
<p><strong>Example 7: Request ID Tracker</strong></p>
<pre><code class="language-ruby"># lib/middleware/request_tracker.rb
class RequestTracker
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request_id = generate_request_id(env)
    
    # Store in env for access in controllers
    env[&#39;HTTP_X_REQUEST_ID&#39;] = request_id
    
    # Set thread-local variable
    Thread.current[:request_id] = request_id
    
    # Add to Rails logger
    Rails.logger.tagged(request_id) do
      status, headers, body = @app.call(env)
      
      # Add to response headers
      headers[&#39;X-Request-Id&#39;] = request_id
      
      [status, headers, body]
    end
  ensure
    Thread.current[:request_id] = nil
  end
  
  private
  
  def generate_request_id(env)
    # Use existing request ID or generate new one
    env[&#39;HTTP_X_REQUEST_ID&#39;] || SecureRandom.uuid
  end
end

# config/application.rb
config.middleware.use RequestTracker
</code></pre>
<hr>
<h3>Environment-Specific Middleware</h3>
<pre><code class="language-ruby"># config/environments/development.rb
Rails.application.configure do
  # Development-only middleware
  config.middleware.use DetailedLogger
  config.middleware.use BetterErrors::Middleware
end

# config/environments/production.rb
Rails.application.configure do
  # Production-only middleware
  config.middleware.use Rack::Attack
  config.middleware.use Rack::Deflater  # Gzip compression
  
  # Remove development middleware
  config.middleware.delete WebConsole::Middleware
end

# config/environments/test.rb
Rails.application.configure do
  # Minimal middleware for tests
  config.middleware.delete Rack::Runtime
end
</code></pre>
<hr>
<h3>Conditional Middleware</h3>
<pre><code class="language-ruby"># config/application.rb
module MyApp
  class Application &lt; Rails::Application
    # Only in production
    if Rails.env.production?
      config.middleware.use Rack::Attack
      config.middleware.use Rack::Deflater
    end
    
    # Only if Redis available
    if ENV[&#39;REDIS_URL&#39;].present?
      config.middleware.use RedisCacheMiddleware
    end
    
    # Only for API subdomain
    if ENV[&#39;SUBDOMAIN&#39;] == &#39;api&#39;
      config.middleware.delete ActionDispatch::Flash
      config.middleware.delete ActionDispatch::Session::CookieStore
    end
  end
end
</code></pre>
<hr>
<h3>Middleware with Configuration</h3>
<pre><code class="language-ruby"># lib/middleware/configurable_middleware.rb
class ConfigurableMiddleware
  def initialize(app, options = {})
    @app = app
    @enabled = options.fetch(:enabled, true)
    @log_level = options.fetch(:log_level, :info)
    @timeout = options.fetch(:timeout, 30)
  end
  
  def call(env)
    return @app.call(env) unless @enabled
    
    # Use configuration
    Timeout.timeout(@timeout) do
      status, headers, body = @app.call(env)
      
      log(env, status) if should_log?
      
      [status, headers, body]
    end
  rescue Timeout::Error
    timeout_response
  end
  
  private
  
  def should_log?
    Rails.logger.level &lt;= Logger.const_get(@log_level.to_s.upcase)
  end
  
  def log(env, status)
    Rails.logger.send(@log_level, &quot;Request: #{env[&#39;PATH_INFO&#39;]} - Status: #{status}&quot;)
  end
  
  def timeout_response
    [
      504,
      { &#39;Content-Type&#39; =&gt; &#39;application/json&#39; },
      [{ error: &#39;Request timeout&#39; }.to_json]
    ]
  end
end

# config/application.rb
config.middleware.use ConfigurableMiddleware,
  enabled: Rails.env.production?,
  log_level: :debug,
  timeout: 60
</code></pre>
<hr>
<h3>Testing Middleware</h3>
<pre><code class="language-ruby"># spec/middleware/my_middleware_spec.rb
require &#39;rails_helper&#39;

RSpec.describe MyMiddleware do
  let(:app) { -&gt;(env) { [200, {}, [&#39;OK&#39;]] } }
  let(:middleware) { described_class.new(app) }
  let(:env) { Rack::MockRequest.env_for(&#39;http://example.com/test&#39;) }
  
  describe &#39;#call&#39; do
    it &#39;passes request to app&#39; do
      expect(app).to receive(:call).with(env)
      middleware.call(env)
    end
    
    it &#39;adds custom header&#39; do
      status, headers, body = middleware.call(env)
      expect(headers[&#39;X-Custom&#39;]).to eq(&#39;value&#39;)
    end
    
    it &#39;modifies response status&#39; do
      status, headers, body = middleware.call(env)
      expect(status).to eq(200)
    end
    
    context &#39;when authentication fails&#39; do
      let(:env) { Rack::MockRequest.env_for(&#39;http://example.com/test&#39;, {}) }
      
      it &#39;returns 401&#39; do
        status, headers, body = middleware.call(env)
        expect(status).to eq(401)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Use <code>config.middleware</code></strong> to customize stack</li>
<li><strong>Insert, delete, swap, move</strong> middleware as needed</li>
<li><strong>Position matters</strong> - order affects functionality</li>
<li><strong>Environment-specific</strong> middleware in config files</li>
<li><strong>Custom middleware</strong> follows Rack interface</li>
<li><strong>Test middleware</strong> independently</li>
<li><strong>Configure with options</strong> in initialize</li>
<li><strong>Chain properly</strong> with <code>@app.call(env)</code></li>
</ol>
<hr>
<h2>Question 50: Explain Rails ActionDispatch and Rack Middleware in depth</h2>
<h3>Answer</h3>
<p><strong>ActionDispatch</strong> is Rails&#39; implementation of Rack middleware, providing essential HTTP request/response handling. Understanding the relationship between Rack and ActionDispatch is crucial for mastering Rails internals.</p>
<hr>
<h3>Rack Foundation</h3>
<p><strong>What is Rack?</strong></p>
<p>Rack is a minimal interface between web servers and Ruby frameworks. It provides a standard way to process HTTP requests.</p>
<p><strong>Rack Specification:</strong></p>
<pre><code class="language-ruby"># A Rack application is any Ruby object that responds to #call
# and returns [status, headers, body]

class RackApp
  def call(env)
    # env: Hash with request information
    status = 200
    headers = { &#39;Content-Type&#39; =&gt; &#39;text/html&#39; }
    body = [&#39;&lt;h1&gt;Hello from Rack&lt;/h1&gt;&#39;]
    
    [status, headers, body]
  end
end

# Run with any Rack-compatible server:
# rackup config.ru
</code></pre>
<p><strong>Rack Environment Hash:</strong></p>
<pre><code class="language-ruby">env = {
  # Required CGI variables
  &#39;REQUEST_METHOD&#39; =&gt; &#39;GET&#39;,
  &#39;PATH_INFO&#39; =&gt; &#39;/posts/123&#39;,
  &#39;QUERY_STRING&#39; =&gt; &#39;page=1&#39;,
  &#39;SERVER_NAME&#39; =&gt; &#39;example.com&#39;,
  &#39;SERVER_PORT&#39; =&gt; &#39;80&#39;,
  &#39;SCRIPT_NAME&#39; =&gt; &#39;&#39;,
  
  # HTTP Headers (prefixed with HTTP_)
  &#39;HTTP_HOST&#39; =&gt; &#39;example.com&#39;,
  &#39;HTTP_USER_AGENT&#39; =&gt; &#39;Mozilla/5.0...&#39;,
  &#39;HTTP_ACCEPT&#39; =&gt; &#39;text/html&#39;,
  &#39;HTTP_COOKIE&#39; =&gt; &#39;_session_id=abc123&#39;,
  &#39;HTTP_AUTHORIZATION&#39; =&gt; &#39;Bearer token123&#39;,
  
  # Rack-specific variables
  &#39;rack.version&#39; =&gt; [1, 3],
  &#39;rack.input&#39; =&gt; #&lt;StringIO&gt;,      # Request body
  &#39;rack.errors&#39; =&gt; #&lt;IO&gt;,           # Error stream
  &#39;rack.multithread&#39; =&gt; true,
  &#39;rack.multiprocess&#39; =&gt; false,
  &#39;rack.run_once&#39; =&gt; false,
  &#39;rack.url_scheme&#39; =&gt; &#39;https&#39;,
  
  # Request body
  &#39;CONTENT_TYPE&#39; =&gt; &#39;application/json&#39;,
  &#39;CONTENT_LENGTH&#39; =&gt; &#39;248&#39;,
  
  # Rails/ActionDispatch additions
  &#39;action_dispatch.request.path_parameters&#39; =&gt; { controller: &#39;posts&#39;, action: &#39;show&#39;, id: &#39;123&#39; },
  &#39;action_dispatch.request.formats&#39; =&gt; [:html],
  &#39;action_dispatch.routes&#39; =&gt; #&lt;ActionDispatch::Routing::RouteSet&gt;
}
</code></pre>
<hr>
<h3>ActionDispatch Overview</h3>
<p><strong>ActionDispatch</strong> is Rails&#39; collection of Rack middleware that handles:</p>
<ul>
<li>Request processing</li>
<li>Response generation</li>
<li>Session management</li>
<li>Cookie handling</li>
<li>Parameter parsing</li>
<li>Error handling</li>
<li>Security features</li>
</ul>
<p><strong>Location in Rails:</strong></p>
<pre><code class="language-ruby"># Rails is built on Rack
Rails::Application &lt; Rails::Engine &lt; Rack::Engine

# Rails app IS a Rack app
MyApp::Application.call(env)  # Returns [status, headers, body]
</code></pre>
<hr>
<h3>Core ActionDispatch Components</h3>
<h3>1. ActionDispatch::Request</h3>
<p>Wraps Rack env with convenient methods:</p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    # ActionDispatch::Request instance
    request = ActionDispatch::Request.new(env)
    
    # Path methods
    request.path              # &quot;/posts/123&quot;
    request.fullpath          # &quot;/posts/123?page=1&quot;
    request.original_fullpath # With overrides
    request.url               # &quot;https://example.com/posts/123&quot;
    request.base_url          # &quot;https://example.com&quot;
    request.host              # &quot;example.com&quot;
    request.host_with_port    # &quot;example.com:443&quot;
    request.port              # 443
    request.domain            # &quot;example.com&quot;
    request.subdomain         # &quot;www&quot; (if www.example.com)
    request.protocol          # &quot;https://&quot;
    request.ssl?              # true
    
    # Request method
    request.method            # &quot;GET&quot;
    request.request_method    # &quot;GET&quot;
    request.get?              # true
    request.post?             # false
    request.put?              # false
    request.delete?           # false
    request.patch?            # false
    request.head?             # false
    
    # Headers
    request.headers[&#39;Authorization&#39;]     # &quot;Bearer token&quot;
    request.headers[&#39;User-Agent&#39;]        # &quot;Mozilla...&quot;
    request.env[&#39;HTTP_AUTHORIZATION&#39;]    # Same as above
    
    # Content
    request.content_type      # &quot;application/json&quot;
    request.media_type        # &quot;application/json&quot;
    request.content_length    # 248
    request.body              # #&lt;StringIO&gt;
    request.raw_post          # Body as string
    
    # Client info
    request.remote_ip         # &quot;192.168.1.1&quot;
    request.user_agent        # &quot;Mozilla/5.0...&quot;
    request.referer           # &quot;https://google.com&quot;
    
    # Format and variants
    request.format            # Mime[:html]
    request.format.html?      # true
    request.format.json?      # false
    request.variant           # [:mobile, :tablet]
    
    # AJAX
    request.xhr?              # true if XMLHttpRequest
    request.local?            # true if from localhost
    
    # Parameters
    request.query_parameters  # From query string
    request.request_parameters # From body
    request.path_parameters   # From route
    request.parameters        # All merged
    
    # Session and cookies
    request.session           # Session hash
    request.cookies           # Cookies hash
    request.cookie_jar        # Cookie jar object
    
    # UUID
    request.uuid              # Request ID
    request.request_id        # Same
  end
end
</code></pre>
<hr>
<h3>2. ActionDispatch::Response</h3>
<p>Manages the response:</p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    # ActionDispatch::Response instance
    
    # Status
    response.status = 200
    response.status = :ok
    response.status = :created  # 201
    response.status = :not_found  # 404
    
    # Headers
    response.headers[&#39;X-Custom&#39;] = &#39;value&#39;
    response.headers[&#39;Cache-Control&#39;] = &#39;no-cache&#39;
    response.content_type = &#39;application/json&#39;
    response.charset = &#39;utf-8&#39;
    
    # Cookies
    response.set_cookie(&#39;user_pref&#39;, {
      value: &#39;dark_mode&#39;,
      expires: 1.year.from_now,
      httponly: true,
      secure: true,
      same_site: :lax
    })
    
    response.delete_cookie(&#39;temp_data&#39;)
    
    # Body
    response.body = &#39;&lt;h1&gt;Hello&lt;/h1&gt;&#39;
    response.body = { success: true }.to_json
    
    # Stream
    response.stream.write(&quot;chunk 1\n&quot;)
    response.stream.write(&quot;chunk 2\n&quot;)
    response.stream.close
    
    # Cache
    response.cache_control[:public] = true
    response.cache_control[:max_age] = 3600
    response.etag = Digest::MD5.hexdigest(body)
    
    # Sending
    response.commit!  # Finalizes response
  end
end
</code></pre>
<hr>
<h3>3. ActionDispatch Middleware Stack</h3>
<p><strong>Complete middleware breakdown:</strong></p>
<h4>a. ActionDispatch::HostAuthorization</h4>
<pre><code class="language-ruby"># Prevents DNS rebinding attacks
# Whitelist allowed hosts

# config/environments/production.rb
config.hosts &lt;&lt; &quot;example.com&quot;
config.hosts &lt;&lt; &quot;www.example.com&quot;
config.hosts &lt;&lt; /.*\.example\.com/  # Wildcard subdomain

# Middleware checks:
def call(env)
  request = ActionDispatch::Request.new(env)
  
  unless allowed_host?(request.host)
    return [
      403,
      { &#39;Content-Type&#39; =&gt; &#39;text/plain&#39; },
      [&#39;Forbidden&#39;]
    ]
  end
  
  @app.call(env)
end
</code></pre>
<h4>b. Rack::Sendfile</h4>
<pre><code class="language-ruby"># Delegates file serving to web server (Nginx/Apache)

def call(env)
  status, headers, body = @app.call(env)
  
  # If X-Sendfile header present
  if path = headers.delete(&#39;X-Sendfile&#39;)
    # Web server serves file
    # More efficient than Rails
    headers[&#39;X-Accel-Redirect&#39;] = path  # For Nginx
  end
  
  [status, headers, body]
end

# In controller:
send_file &#39;/path/to/large_file.pdf&#39;
# Sets X-Sendfile header
</code></pre>
<h4>c. ActionDispatch::Static</h4>
<pre><code class="language-ruby"># Serves static files from public/

def call(env)
  path = env[&#39;PATH_INFO&#39;]
  
  # Check if static file exists
  if file = match_public_path(path)
    # Serve directly
    serve_static_file(file)
  else
    # Pass to next middleware
    @app.call(env)
  end
end

# Examples:
# /assets/application.js → public/assets/application.js
# /images/logo.png → public/images/logo.png
# /robots.txt → public/robots.txt
</code></pre>
<h4>d. ActionDispatch::Executor</h4>
<pre><code class="language-ruby"># Wraps request in executor callbacks
# Manages database connections, cache clearing

def call(env)
  ActiveSupport::Executor.wrap do
    # Before callbacks
    ActiveSupport::Reloader.prepare!
    
    # Process request
    status, headers, body = @app.call(env)
    
    # After callbacks
    ActiveSupport::Reloader.complete!
    ActiveRecord::Base.clear_active_connections!
    
    [status, headers, body]
  end
end
</code></pre>
<h4>e. Rack::Runtime</h4>
<pre><code class="language-ruby"># Adds X-Runtime header with request time

def call(env)
  start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
  
  status, headers, body = @app.call(env)
  
  end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
  runtime = end_time - start_time
  
  headers[&#39;X-Runtime&#39;] = sprintf(&quot;%.6f&quot;, runtime)
  
  [status, headers, body]
end
</code></pre>
<h4>f. ActionDispatch::RequestId</h4>
<pre><code class="language-ruby"># Generates unique ID for each request

def call(env)
  request_id = make_request_id(env)
  env[&#39;action_dispatch.request_id&#39;] = request_id
  
  status, headers, body = @app.call(env)
  
  headers[&#39;X-Request-Id&#39;] = request_id
  
  [status, headers, body]
end

def make_request_id(env)
  # Use existing or generate new
  env[&#39;HTTP_X_REQUEST_ID&#39;] || SecureRandom.uuid
end
</code></pre>
<h4>g. ActionDispatch::RemoteIp</h4>
<pre><code class="language-ruby"># Determines actual client IP from headers

def call(env)
  request = ActionDispatch::Request.new(env)
  
  # Check X-Forwarded-For (from proxies)
  forwarded_ips = request.get_header(&#39;HTTP_X_FORWARDED_FOR&#39;)
  
  # Filter out private/local IPs
  remote_ip = calculate_ip(forwarded_ips)
  
  env[&#39;action_dispatch.remote_ip&#39;] = remote_ip
  
  @app.call(env)
end

# Handles:
# - Direct connection
# - Through proxy
# - Through load balancer
# - Through CDN
</code></pre>
<h4>h. ActionDispatch::Cookies</h4>
<pre><code class="language-ruby"># Manages cookies

def call(env)
  request = ActionDispatch::Request.new(env)
  
  # Parse cookies from header
  cookies = parse_cookies(request.get_header(&#39;HTTP_COOKIE&#39;))
  env[&#39;action_dispatch.cookies&#39;] = cookies
  
  status, headers, body = @app.call(env)
  
  # Set cookies in response
  set_cookies(headers, cookies)
  
  [status, headers, body]
end

# In controller:
cookies[:user_theme] = &#39;dark&#39;
cookies.encrypted[:user_id] = 123
cookies.signed[:cart_id] = &#39;abc&#39;
</code></pre>
<h4>i. ActionDispatch::Session::CookieStore</h4>
<pre><code class="language-ruby"># Manages session in encrypted cookie

def call(env)
  # Decrypt session from cookie
  session_data = decrypt_cookie(env[&#39;HTTP_COOKIE&#39;])
  env[&#39;rack.session&#39;] = session_data
  
  status, headers, body = @app.call(env)
  
  # Encrypt and save session
  cookie = encrypt_session(env[&#39;rack.session&#39;])
  headers[&#39;Set-Cookie&#39;] = cookie
  
  [status, headers, body]
end

# Session stored in encrypted cookie
# Max size: 4KB
# Signed with secret_key_base
</code></pre>
<h4>j. ActionDispatch::Flash</h4>
<pre><code class="language-ruby"># One-time messages across requests

def call(env)
  # Load flash from session
  session = env[&#39;rack.session&#39;]
  flash = session[:flash] || {}
  
  # Separate current and new flash
  env[&#39;action_dispatch.request.flash&#39;] = flash
  
  status, headers, body = @app.call(env)
  
  # Save new flash, discard used flash
  sweep_flash(session, flash)
  
  [status, headers, body]
end

# In controller:
flash[:notice] = &quot;Saved!&quot;  # Next request
flash.now[:error] = &quot;Error!&quot;  # Current request
</code></pre>
<hr>
<h3>ActionDispatch vs Rack Middleware</h3>
<p><strong>Similarities:</strong></p>
<ul>
<li>Both follow Rack spec: <code>call(env)</code> → <code>[status, headers, body]</code></li>
<li>Both can modify request/response</li>
<li>Both can short-circuit</li>
</ul>
<p><strong>Differences:</strong></p>
<pre><code class="language-ruby"># Rack middleware - pure Rack
class RackMiddleware
  def initialize(app)
    @app = app
  end
  
  def call(env)
    # Only has env hash
    path = env[&#39;PATH_INFO&#39;]
    
    status, headers, body = @app.call(env)
    [status, headers, body]
  end
end

# ActionDispatch middleware - Rails-aware
class ActionDispatchMiddleware
  def initialize(app)
    @app = app
  end
  
  def call(env)
    # Can use ActionDispatch::Request
    request = ActionDispatch::Request.new(env)
    
    # Access Rails features
    request.session
    request.flash
    request.cookies
    
    # Access routing
    Rails.application.routes.recognize_path(request.path)
    
    status, headers, body = @app.call(env)
    [status, headers, body]
  end
end
</code></pre>
<hr>
<h3>Building Custom ActionDispatch Middleware</h3>
<p><strong>Full-featured example:</strong></p>
<pre><code class="language-ruby"># lib/middleware/advanced_middleware.rb
class AdvancedMiddleware
  def initialize(app, options = {})
    @app = app
    @options = options
  end
  
  def call(env)
    # Use ActionDispatch::Request
    request = ActionDispatch::Request.new(env)
    
    # Access Rails routing
    route_info = recognize_route(request)
    
    # Check authentication
    unless authenticated?(request)
      return unauthorized_response
    end
    
    # Add request metadata
    env[&#39;custom.user_id&#39;] = current_user_id(request)
    env[&#39;custom.route&#39;] = route_info
    
    # Process request
    status, headers, body = @app.call(env)
    
    # Use ActionDispatch::Response
    response = ActionDispatch::Response.new(status, headers, body)
    
    # Modify response
    response.set_header(&#39;X-Custom-Header&#39;, &#39;value&#39;)
    
    # Add timing
    response.set_header(&#39;X-Processing-Time&#39;, calculate_time)
    
    # Return Rack triplet
    response.finish
  end
  
  private
  
  def recognize_route(request)
    Rails.application.routes.recognize_path(
      request.path,
      method: request.method
    )
  rescue ActionController::RoutingError
    nil
  end
  
  def authenticated?(request)
    request.session[:user_id].present?
  end
  
  def current_user_id(request)
    request.session[:user_id]
  end
  
  def unauthorized_response
    response = ActionDispatch::Response.new
    response.status = 401
    response.content_type = &#39;application/json&#39;
    response.body = { error: &#39;Unauthorized&#39; }.to_json
    response.finish
  end
  
  def calculate_time
    # Implementation
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Rack</strong> provides standard interface for Ruby web apps</li>
<li><strong>ActionDispatch</strong> is Rails&#39; Rack middleware collection</li>
<li><strong>Middleware stack</strong> processes every request</li>
<li><strong>ActionDispatch::Request</strong> wraps env hash</li>
<li><strong>ActionDispatch::Response</strong> manages responses</li>
<li><strong>Each middleware</strong> has specific responsibility</li>
<li><strong>Custom middleware</strong> can use Rails features</li>
<li><strong>Order matters</strong> - request flows through stack</li>
<li><strong>Understanding stack</strong> essential for debugging</li>
<li><strong>Customize carefully</strong> - can impact performance</li>
</ol>
<h1>Rails Routing Interview Questions</h1>
<h2>Question 51: What is the difference between REST resource and Rails routes?</h2>
<h3>Answer</h3>
<p><strong>REST (Representational State Transfer)</strong> is an architectural pattern for web services, while <strong>Rails routes</strong> are the implementation of RESTful routing in Rails applications.</p>
<hr>
<h3>REST Resource</h3>
<p><strong>REST</strong> is an architectural style with these principles:</p>
<p><strong>1. Resources:</strong> Everything is a resource (users, posts, comments)
<strong>2. URIs:</strong> Resources identified by URIs
<strong>3. HTTP Verbs:</strong> Standard methods (GET, POST, PUT, DELETE)
<strong>4. Stateless:</strong> Each request is independent
<strong>5. Representations:</strong> Resources have multiple formats (JSON, XML, HTML)</p>
<p><strong>RESTful Principles:</strong></p>
<pre><code>Resource: User
URI: /users/123
Methods:
- GET    /users      → List all users
- GET    /users/123  → Show specific user
- POST   /users      → Create new user
- PUT    /users/123  → Update entire user
- PATCH  /users/123  → Update partial user
- DELETE /users/123  → Delete user
</code></pre>
<hr>
<h3>Rails Routes</h3>
<p>Rails routes are the <strong>implementation</strong> of REST in Rails:</p>
<pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  # RESTful resource
  resources :posts
  
  # Generates 7 standard routes:
  # GET    /posts          → posts#index   (list)
  # GET    /posts/new      → posts#new     (new form)
  # POST   /posts          → posts#create  (create)
  # GET    /posts/:id      → posts#show    (show one)
  # GET    /posts/:id/edit → posts#edit    (edit form)
  # PATCH  /posts/:id      → posts#update  (update)
  # DELETE /posts/:id      → posts#destroy (delete)
end
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>REST</th>
<th>Rails Routes</th>
</tr>
</thead>
<tbody><tr>
<td><strong>What</strong></td>
<td>Architectural pattern</td>
<td>Implementation</td>
</tr>
<tr>
<td><strong>Scope</strong></td>
<td>Universal web standard</td>
<td>Rails-specific</td>
</tr>
<tr>
<td><strong>Flexibility</strong></td>
<td>Conceptual guidelines</td>
<td>Concrete DSL</td>
</tr>
<tr>
<td><strong>Actions</strong></td>
<td>HTTP verbs only</td>
<td>7 standard actions + custom</td>
</tr>
<tr>
<td><strong>Forms</strong></td>
<td>No concept</td>
<td>Adds <code>new</code> and <code>edit</code> actions</td>
</tr>
</tbody></table>
<hr>
<h3>REST Resource (Concept)</h3>
<p>Pure REST has only 4 operations:</p>
<pre><code>Resource: Article

CREATE   → POST   /articles
READ     → GET    /articles/:id
UPDATE   → PUT    /articles/:id
DELETE   → DELETE /articles/:id
</code></pre>
<hr>
<h3>Rails Routes (Implementation)</h3>
<p>Rails extends REST with convenience actions:</p>
<pre><code class="language-ruby">resources :articles

# Standard 7 actions:
GET    /articles          # index  - list all
GET    /articles/new      # new    - form to create (Rails addition)
POST   /articles          # create - create new
GET    /articles/:id      # show   - display one
GET    /articles/:id/edit # edit   - form to update (Rails addition)
PATCH  /articles/:id      # update - update existing
DELETE /articles/:id      # destroy - delete

# Why Rails adds &#39;new&#39; and &#39;edit&#39;:
# REST doesn&#39;t care about HTML forms
# Rails apps need forms, so Rails adds these routes
</code></pre>
<hr>
<h3>Example: Blog Application</h3>
<p><strong>Pure REST approach:</strong></p>
<pre><code class="language-ruby"># Just 4 routes (pure REST)
get    &#39;/posts/:id&#39;, to: &#39;posts#show&#39;
post   &#39;/posts&#39;,     to: &#39;posts#create&#39;
put    &#39;/posts/:id&#39;, to: &#39;posts#update&#39;
delete &#39;/posts/:id&#39;, to: &#39;posts#destroy&#39;

# Problem: Where do users fill out forms?
# No route to display creation form
# No route to display edit form
</code></pre>
<p><strong>Rails RESTful approach:</strong></p>
<pre><code class="language-ruby">resources :posts

# 7 routes (REST + Rails conveniences)
# Includes form routes:
GET /posts/new       # Display creation form
GET /posts/:id/edit  # Display edit form

# These make Rails web apps more practical
</code></pre>
<hr>
<h3>Rails Goes Beyond Basic REST</h3>
<p><strong>Custom actions:</strong></p>
<pre><code class="language-ruby">resources :posts do
  member do
    post :publish      # POST /posts/:id/publish
    post :archive      # POST /posts/:id/archive
  end
  
  collection do
    get :archived      # GET /posts/archived
    get :featured      # GET /posts/featured
  end
end

# These are NOT pure REST
# But Rails allows them for convenience
</code></pre>
<hr>
<h3>Complete Comparison</h3>
<p><strong>Pure REST (4 operations):</strong></p>
<pre><code>POST   /api/users          → Create
GET    /api/users/:id      → Read
PUT    /api/users/:id      → Update
DELETE /api/users/:id      → Delete
</code></pre>
<p><strong>Rails RESTful Routes (7 actions):</strong></p>
<pre><code class="language-ruby">resources :users

# CRUD operations (REST-compliant):
POST   /users              → create
GET    /users/:id          → show
PATCH  /users/:id          → update
DELETE /users/:id          → destroy

# Additional Rails conveniences:
GET    /users              → index  (list all)
GET    /users/new          → new    (creation form)
GET    /users/:id/edit     → edit   (edit form)
</code></pre>
<hr>
<h3>API vs Web Application Routes</h3>
<p><strong>API (Pure REST):</strong></p>
<pre><code class="language-ruby"># config/routes.rb
namespace :api do
  namespace :v1 do
    resources :posts, only: [:index, :show, :create, :update, :destroy]
    # No need for &#39;new&#39; and &#39;edit&#39; - APIs don&#39;t render forms
  end
end

# Generates:
# GET    /api/v1/posts
# POST   /api/v1/posts
# GET    /api/v1/posts/:id
# PATCH  /api/v1/posts/:id
# DELETE /api/v1/posts/:id
</code></pre>
<p><strong>Web Application (Rails RESTful):</strong></p>
<pre><code class="language-ruby">resources :posts

# Needs all 7 actions including forms:
# GET /posts/new       → Render creation form
# GET /posts/:id/edit  → Render edit form
</code></pre>
<hr>
<h3>Naming Conventions</h3>
<p><strong>REST:</strong></p>
<pre><code>Resources are nouns (plural):
/users
/posts
/comments

Actions are HTTP verbs:
GET, POST, PUT, DELETE
</code></pre>
<p><strong>Rails:</strong></p>
<pre><code>Resources are nouns (plural):
resources :users
resources :posts

Actions are Ruby methods:
index, show, new, create, edit, update, destroy
</code></pre>
<hr>
<h3>Practical Example</h3>
<p><strong>Blog Post Management:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
resources :posts do
  # RESTful nested resource
  resources :comments, only: [:create, :destroy]
  
  # Custom member actions (not pure REST)
  member do
    post :publish
    post :unpublish
  end
  
  # Custom collection actions (not pure REST)
  collection do
    get :drafts
  end
end

# Generated routes:
#
# Standard RESTful:
# GET    /posts                    → posts#index
# POST   /posts                    → posts#create
# GET    /posts/new                → posts#new
# GET    /posts/:id                → posts#show
# GET    /posts/:id/edit           → posts#edit
# PATCH  /posts/:id                → posts#update
# DELETE /posts/:id                → posts#destroy
#
# Nested RESTful:
# POST   /posts/:post_id/comments  → comments#create
# DELETE /posts/:post_id/comments/:id → comments#destroy
#
# Custom actions:
# POST   /posts/:id/publish        → posts#publish
# POST   /posts/:id/unpublish      → posts#unpublish
# GET    /posts/drafts             → posts#drafts
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>REST</strong> is the architectural pattern</li>
<li><strong>Rails routes</strong> implement REST with extras</li>
<li><strong>Rails adds</strong> <code>new</code> and <code>edit</code> for forms</li>
<li><strong>Rails allows</strong> custom actions beyond REST</li>
<li><strong>APIs use</strong> pure REST (no form routes)</li>
<li><strong>Web apps use</strong> all 7 Rails actions</li>
<li><strong>Both follow</strong> resource-oriented design</li>
</ol>
<hr>
<h2>Question 52: How many types of routes are there in Ruby on Rails?</h2>
<h3>Answer</h3>
<p>Rails provides <strong>several types of routes</strong> to handle different URL patterns and use cases. Let&#39;s explore each type in detail.</p>
<hr>
<h3>1. RESTful Resource Routes</h3>
<p><strong>Most common type - follows REST conventions:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
resources :posts

# Generates 7 standard routes:
Prefix        Verb   URI Pattern              Controller#Action
posts         GET    /posts                   posts#index
posts         POST   /posts                   posts#create
new_post      GET    /posts/new               posts#new
edit_post     GET    /posts/:id/edit          posts#edit
post          GET    /posts/:id               posts#show
post          PATCH  /posts/:id               posts#update
post          PUT    /posts/:id               posts#update
post          DELETE /posts/:id               posts#destroy
</code></pre>
<p><strong>Limiting RESTful routes:</strong></p>
<pre><code class="language-ruby">resources :posts, only: [:index, :show]
resources :comments, except: [:destroy]
</code></pre>
<hr>
<h3>2. Singular Resource Routes</h3>
<p><strong>For resources without IDs (current_user, profile):</strong></p>
<pre><code class="language-ruby">resource :profile  # Singular!

# Generates 6 routes (no index, no :id):
Prefix         Verb   URI Pattern           Controller#Action
new_profile    GET    /profile/new          profiles#new
edit_profile   GET    /profile/edit         profiles#edit
profile        GET    /profile              profiles#show
profile        POST   /profile              profiles#create
profile        PATCH  /profile              profiles#update
profile        DELETE /profile              profiles#destroy
</code></pre>
<p><strong>Use cases:</strong></p>
<pre><code class="language-ruby"># User&#39;s own profile
resource :account

# Dashboard (only one per user)
resource :dashboard

# Current user&#39;s settings
resource :settings
</code></pre>
<hr>
<h3>3. Nested Routes</h3>
<p><strong>Resources within resources:</strong></p>
<pre><code class="language-ruby">resources :posts do
  resources :comments
end

# Generates nested routes:
# GET    /posts/:post_id/comments
# POST   /posts/:post_id/comments
# GET    /posts/:post_id/comments/:id
# ...

# In controller:
class CommentsController &lt; ApplicationController
  def index
    @post = Post.find(params[:post_id])
    @comments = @post.comments
  end
end
</code></pre>
<p><strong>Shallow nesting (best practice):</strong></p>
<pre><code class="language-ruby">resources :posts do
  resources :comments, shallow: true
end

# Shallow routes:
# GET    /posts/:post_id/comments     (index - needs post)
# POST   /posts/:post_id/comments     (create - needs post)
# GET    /comments/:id                (show - has comment ID)
# GET    /comments/:id/edit           (edit - has comment ID)
# PATCH  /comments/:id                (update - has comment ID)
# DELETE /comments/:id                (destroy - has comment ID)
</code></pre>
<hr>
<h3>4. Member Routes</h3>
<p><strong>Routes for individual resources:</strong></p>
<pre><code class="language-ruby">resources :posts do
  member do
    post :publish
    post :unpublish
    get :preview
  end
end

# Generates:
# POST /posts/:id/publish
# POST /posts/:id/unpublish
# GET  /posts/:id/preview

# In controller:
class PostsController &lt; ApplicationController
  def publish
    @post = Post.find(params[:id])
    @post.publish!
    redirect_to @post
  end
end
</code></pre>
<p><strong>Alternative syntax:</strong></p>
<pre><code class="language-ruby">resources :posts do
  post :publish, on: :member
  get :preview, on: :member
end
</code></pre>
<hr>
<h3>5. Collection Routes</h3>
<p><strong>Routes for the entire collection:</strong></p>
<pre><code class="language-ruby">resources :posts do
  collection do
    get :archived
    get :search
    get :featured
  end
end

# Generates:
# GET /posts/archived
# GET /posts/search
# GET /posts/featured

# In controller:
class PostsController &lt; ApplicationController
  def archived
    @posts = Post.where(archived: true)
  end
  
  def search
    @posts = Post.where(&quot;title LIKE ?&quot;, &quot;%#{params[:q]}%&quot;)
  end
end
</code></pre>
<p><strong>Alternative syntax:</strong></p>
<pre><code class="language-ruby">resources :posts do
  get :archived, on: :collection
  get :search, on: :collection
end
</code></pre>
<hr>
<h3>6. Namespace Routes</h3>
<p><strong>Organize routes into logical groups:</strong></p>
<pre><code class="language-ruby">namespace :admin do
  resources :posts
  resources :users
end

# Generates:
# GET /admin/posts     → Admin::PostsController#index
# GET /admin/users     → Admin::UsersController#index

# Controller location:
# app/controllers/admin/posts_controller.rb
module Admin
  class PostsController &lt; ApplicationController
    # ...
  end
end
</code></pre>
<hr>
<h3>7. Scope Routes</h3>
<p><strong>Group routes without affecting controller namespace:</strong></p>
<pre><code class="language-ruby"># Scope with module
scope module: &#39;admin&#39; do
  resources :posts  # Uses Admin::PostsController
end
# GET /posts → Admin::PostsController#index

# Scope with path
scope path: &#39;/admin&#39; do
  resources :posts  # Uses PostsController
end
# GET /admin/posts → PostsController#index

# Scope with both
scope path: &#39;/admin&#39;, module: &#39;admin&#39; do
  resources :posts
end
# GET /admin/posts → Admin::PostsController#index
</code></pre>
<hr>
<h3>8. Custom/Match Routes</h3>
<p><strong>Define custom URL patterns:</strong></p>
<pre><code class="language-ruby"># Specific route
get &#39;/about&#39;, to: &#39;pages#about&#39;
post &#39;/contact&#39;, to: &#39;pages#contact&#39;

# Match any HTTP verb
match &#39;/photos/:id&#39;, to: &#39;photos#show&#39;, via: [:get, :post]
match &#39;/photos&#39;, to: &#39;photos#index&#39;, via: :all

# Pattern matching
get &#39;/posts/:year/:month/:day&#39;, to: &#39;posts#archive&#39;

# In controller:
def archive
  @year = params[:year]
  @month = params[:month]
  @day = params[:day]
end
</code></pre>
<hr>
<h3>9. Root Route</h3>
<p><strong>Homepage route:</strong></p>
<pre><code class="language-ruby">root &#39;pages#home&#39;
# Same as: get &#39;/&#39;, to: &#39;pages#home&#39;

# Generates:
# GET / → pages#home

# Conditional root
authenticated :user do
  root &#39;dashboard#index&#39;, as: :authenticated_root
end

root &#39;pages#home&#39;
</code></pre>
<hr>
<h3>10. Direct Routes</h3>
<p><strong>Create custom URL helpers:</strong></p>
<pre><code class="language-ruby">direct :homepage do
  &quot;https://www.example.com&quot;
end

# Use in views:
&lt;%= link_to &quot;Home&quot;, homepage_url %&gt;
# Generates: https://www.example.com

# With parameters
direct :post_preview do |post|
  &quot;https://preview.example.com/posts/#{post.id}&quot;
end

&lt;%= link_to &quot;Preview&quot;, post_preview_url(@post) %&gt;
</code></pre>
<hr>
<h3>11. Concern Routes</h3>
<p><strong>Reusable route sets:</strong></p>
<pre><code class="language-ruby">concern :commentable do
  resources :comments
end

concern :image_attachable do
  post :attach_image, on: :member
end

resources :posts, concerns: [:commentable, :image_attachable]
resources :articles, concerns: :commentable

# Generates for both posts and articles:
# /posts/:post_id/comments
# /articles/:article_id/comments
# POST /posts/:id/attach_image
</code></pre>
<hr>
<h3>12. Redirect Routes</h3>
<p><strong>Redirect old URLs:</strong></p>
<pre><code class="language-ruby"># Simple redirect
get &#39;/old-path&#39;, to: redirect(&#39;/new-path&#39;)

# With status code
get &#39;/old-path&#39;, to: redirect(&#39;/new-path&#39;, status: 301)

# Dynamic redirect
get &#39;/posts/:id&#39;, to: redirect { |path_params, req|
  &quot;/articles/#{path_params[:id]}&quot;
}

# Redirect to external URL
get &#39;/blog&#39;, to: redirect(&#39;https://blog.example.com&#39;)
</code></pre>
<hr>
<h3>13. Constraint Routes</h3>
<p><strong>Routes with conditions:</strong></p>
<pre><code class="language-ruby"># Subdomain constraints
constraints subdomain: &#39;api&#39; do
  namespace :api do
    resources :posts
  end
end

# Format constraints
get &#39;/posts/:id&#39;, to: &#39;posts#show&#39;, constraints: { format: &#39;json&#39; }

# Custom constraints
class MobileConstraint
  def matches?(request)
    request.user_agent =~ /Mobile/
  end
end

constraints MobileConstraint.new do
  get &#39;/&#39;, to: &#39;mobile#index&#39;
end

# Parameter constraints
get &#39;/posts/:id&#39;, to: &#39;posts#show&#39;, constraints: { id: /\d+/ }
</code></pre>
<hr>
<h3>14. Globbing Routes</h3>
<p><strong>Catch-all routes:</strong></p>
<pre><code class="language-ruby"># Match any number of segments
get &#39;/files/*path&#39;, to: &#39;files#show&#39;

# GET /files/documents/2024/report.pdf
# params[:path] = &quot;documents/2024/report.pdf&quot;

# Named globbing
get &#39;/pages/*section/:page&#39;, to: &#39;pages#show&#39;

# GET /pages/docs/ruby/basics
# params[:section] = &quot;docs/ruby&quot;
# params[:page] = &quot;basics&quot;
</code></pre>
<hr>
<h3>15. Mounting Engines/Rack Apps</h3>
<p><strong>Mount external applications:</strong></p>
<pre><code class="language-ruby"># Mount Rails engine
mount Sidekiq::Web =&gt; &#39;/sidekiq&#39;

# Mount Rack app
mount API::App =&gt; &#39;/api&#39;

# Mount with constraints
authenticate :user, -&gt;(user) { user.admin? } do
  mount Sidekiq::Web =&gt; &#39;/sidekiq&#39;
end
</code></pre>
<hr>
<h3>Complete Route Types Example</h3>
<pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  # 1. Root route
  root &#39;home#index&#39;
  
  # 2. Custom routes
  get &#39;/about&#39;, to: &#39;pages#about&#39;
  get &#39;/contact&#39;, to: &#39;pages#contact&#39;
  
  # 3. RESTful resources
  resources :posts do
    # 4. Nested resources
    resources :comments, shallow: true
    
    # 5. Member routes
    member do
      post :publish
      get :preview
    end
    
    # 6. Collection routes
    collection do
      get :archived
      get :search
    end
  end
  
  # 7. Singular resource
  resource :profile, only: [:show, :edit, :update]
  
  # 8. Namespace
  namespace :admin do
    resources :users
    resources :posts
  end
  
  # 9. Scope
  scope module: &#39;api&#39; do
    namespace :v1 do
      resources :articles
    end
  end
  
  # 10. Concerns
  concern :likeable do
    post :like, on: :member
    post :unlike, on: :member
  end
  
  resources :photos, concerns: :likeable
  resources :videos, concerns: :likeable
  
  # 11. Constraints
  constraints subdomain: &#39;api&#39; do
    scope module: &#39;api&#39; do
      resources :posts
    end
  end
  
  # 12. Redirects
  get &#39;/old-blog/:id&#39;, to: redirect(&#39;/posts/%{id}&#39;)
  
  # 13. Globbing
  get &#39;/docs/*path&#39;, to: &#39;docs#show&#39;
  
  # 14. Mount engines
  mount Sidekiq::Web =&gt; &#39;/sidekiq&#39;
  
  # 15. Catch-all (must be last)
  match &#39;*path&#39;, to: &#39;errors#not_found&#39;, via: :all
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>RESTful resources</strong> - Most common (7 routes)</li>
<li><strong>Singular resources</strong> - No ID needed (6 routes)</li>
<li><strong>Nested routes</strong> - Parent-child relationships</li>
<li><strong>Member routes</strong> - Actions on single resource</li>
<li><strong>Collection routes</strong> - Actions on entire collection</li>
<li><strong>Namespace/Scope</strong> - Organize routes</li>
<li><strong>Custom routes</strong> - Flexible patterns</li>
<li><strong>Concerns</strong> - Reusable route sets</li>
<li><strong>Constraints</strong> - Conditional routing</li>
<li><strong>Root route</strong> - Homepage</li>
<li><strong>Redirects</strong> - Old URL handling</li>
<li><strong>Mounting</strong> - External apps</li>
<li><strong>Globbing</strong> - Catch-all paths</li>
<li><strong>Direct routes</strong> - Custom URL helpers</li>
</ol>
<hr>
<h2>Question 53: What is the difference between <code>resources</code> and <code>resource</code>?</h2>
<h3>Answer</h3>
<p><code>resources</code> (plural) is for collections with multiple items, while <code>resource</code> (singular) is for singleton resources where there&#39;s only one per user/context.</p>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>resources</code> (plural)</th>
<th><code>resource</code> (singular)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Routes</strong></td>
<td>7 routes</td>
<td>6 routes (no index)</td>
</tr>
<tr>
<td><strong>ID param</strong></td>
<td>Uses <code>:id</code></td>
<td>No ID param</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Multiple items</td>
<td>Single item per user</td>
</tr>
<tr>
<td><strong>Index</strong></td>
<td>Yes (lists all)</td>
<td>No</td>
</tr>
<tr>
<td><strong>Example</strong></td>
<td>Posts, Comments</td>
<td>Profile, Account</td>
</tr>
</tbody></table>
<hr>
<h3><code>resources</code> (Plural)</h3>
<p><strong>For collections with multiple items:</strong></p>
<pre><code class="language-ruby">resources :posts

# Generates 7 routes:
Prefix       Verb   URI Pattern            Controller#Action
posts        GET    /posts                 posts#index
posts        POST   /posts                 posts#create
new_post     GET    /posts/new             posts#new
edit_post    GET    /posts/:id/edit        posts#edit
post         GET    /posts/:id             posts#show
post         PATCH  /posts/:id             posts#update
post         DELETE /posts/:id             posts#destroy
</code></pre>
<p><strong>Controller:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def index
    @posts = Post.all  # List ALL posts
  end
  
  def show
    @post = Post.find(params[:id])  # Find by ID
  end
  
  def create
    @post = Post.new(post_params)
    @post.save
  end
end
</code></pre>
<p><strong>View helpers:</strong></p>
<pre><code class="language-erb">&lt;%= link_to &#39;All Posts&#39;, posts_path %&gt;
&lt;!-- /posts --&gt;

&lt;%= link_to &#39;New Post&#39;, new_post_path %&gt;
&lt;!-- /posts/new --&gt;

&lt;%= link_to &#39;View Post&#39;, post_path(@post) %&gt;
&lt;!-- /posts/123 --&gt;

&lt;%= link_to &#39;Edit Post&#39;, edit_post_path(@post) %&gt;
&lt;!-- /posts/123/edit --&gt;

&lt;%= link_to &#39;Delete&#39;, post_path(@post), method: :delete %&gt;
&lt;!-- DELETE /posts/123 --&gt;
</code></pre>
<hr>
<h3><code>resource</code> (Singular)</h3>
<p><strong>For singleton resources (one per user/context):</strong></p>
<pre><code class="language-ruby">resource :profile  # Singular!

# Generates 6 routes (NO index, NO :id):
Prefix         Verb   URI Pattern         Controller#Action
new_profile    GET    /profile/new        profiles#new
edit_profile   GET    /profile/edit       profiles#edit
profile        GET    /profile            profiles#show
profile        POST   /profile            profiles#create
profile        PATCH  /profile            profiles#update
profile        DELETE /profile            profiles#destroy
</code></pre>
<p><strong>Controller:</strong></p>
<pre><code class="language-ruby">class ProfileController &lt; ApplicationController
  # Note: Controller is SINGULAR too!
  
  def show
    # No ID needed - it&#39;s always the current user&#39;s profile
    @profile = current_user.profile
  end
  
  def update
    @profile = current_user.profile
    @profile.update(profile_params)
  end
  
  # No index action - there&#39;s only one profile per user
end
</code></pre>
<p><strong>View helpers:</strong></p>
<pre><code class="language-erb">&lt;%= link_to &#39;My Profile&#39;, profile_path %&gt;
&lt;!-- /profile (no ID!) --&gt;

&lt;%= link_to &#39;Edit Profile&#39;, edit_profile_path %&gt;
&lt;!-- /profile/edit (no ID!) --&gt;

&lt;%= form_with model: @profile, url: profile_path do |f| %&gt;
  &lt;!-- PATCH /profile --&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong><code>resources</code> (plural) - Multiple items:</strong></p>
<pre><code class="language-ruby">resources :posts       # Blog posts
resources :comments    # Comments
resources :products    # E-commerce products
resources :users       # Admin user management
resources :orders      # Customer orders
resources :photos      # Photo gallery
</code></pre>
<p><strong><code>resource</code> (singular) - One per user:</strong></p>
<pre><code class="language-ruby">resource :profile      # User&#39;s profile
resource :account      # User&#39;s account
resource :dashboard    # User&#39;s dashboard
resource :settings     # User&#39;s settings
resource :cart         # Shopping cart
resource :subscription # User&#39;s subscription
</code></pre>
<hr>
<h3>Practical Examples</h3>
<p><strong>Example 1: User Profile</strong></p>
<pre><code class="language-ruby"># config/routes.rb
resource :profile

# app/controllers/profile_controller.rb
class ProfileController &lt; ApplicationController
  before_action :authenticate_user!
  
  def show
    @profile = current_user.profile
  end
  
  def edit
    @profile = current_user.profile
  end
  
  def update
    @profile = current_user.profile
    if @profile.update(profile_params)
      redirect_to profile_path, notice: &#39;Profile updated&#39;
    else
      render :edit
    end
  end
  
  private
  
  def profile_params
    params.require(:profile).permit(:bio, :avatar, :website)
  end
end

# app/views/profile/show.html.erb
&lt;h1&gt;My Profile&lt;/h1&gt;
&lt;%= @profile.bio %&gt;
&lt;%= link_to &#39;Edit Profile&#39;, edit_profile_path %&gt;

# Usage in views:
profile_path         # /profile
edit_profile_path    # /profile/edit
</code></pre>
<p><strong>Example 2: Blog Posts</strong></p>
<pre><code class="language-ruby"># config/routes.rb
resources :posts

# app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  def index
    @posts = Post.all  # Need index - multiple posts
  end
  
  def show
    @post = Post.find(params[:id])  # Need ID
  end
  
  def create
    @post = current_user.posts.build(post_params)
    @post.save
  end
end

# Usage in views:
posts_path           # /posts (index)
post_path(@post)     # /posts/123
new_post_path        # /posts/new
edit_post_path(@post) # /posts/123/edit
</code></pre>
<p><strong>Example 3: Account Settings</strong></p>
<pre><code class="language-ruby"># config/routes.rb
resource :account do
  member do
    patch :change_password
    delete :close_account
  end
end

# Wait! &#39;member&#39; doesn&#39;t work with singular resource
# Use this instead:
resource :account do
  patch :change_password, on: :member
end

# Better approach for singular:
resource :account
patch &#39;/account/change_password&#39;, to: &#39;accounts#change_password&#39;
</code></pre>
<hr>
<h3>Nested Resources vs Nested Resource</h3>
<p><strong>Nested <code>resources</code> (plural):</strong></p>
<pre><code class="language-ruby">resources :posts do
  resources :comments
end

# POST /posts/:post_id/comments
# GET  /posts/:post_id/comments/:id
</code></pre>
<p><strong>Nested <code>resource</code> (singular):</strong></p>
<pre><code class="language-ruby">resources :users do
  resource :profile
end

# GET  /users/:user_id/profile      (no profile ID)
# GET  /users/:user_id/profile/edit
# PATCH /users/:user_id/profile
</code></pre>
<hr>
<h3>When to Use Which?</h3>
<p><strong>Use <code>resources</code> when:</strong></p>
<ul>
<li>Multiple items exist</li>
<li>Need an index page</li>
<li>Users can view different items</li>
<li>Items have unique IDs</li>
</ul>
<pre><code class="language-ruby">resources :articles  # Many articles
resources :products  # Many products
resources :photos    # Many photos
</code></pre>
<p><strong>Use <code>resource</code> when:</strong></p>
<ul>
<li>Only one item per user/context</li>
<li>No need for index page</li>
<li>Always refers to current user&#39;s item</li>
<li>No ID needed in URL</li>
</ul>
<pre><code class="language-ruby">resource :profile      # One profile per user
resource :dashboard    # One dashboard per user
resource :settings     # One settings per user
</code></pre>
<hr>
<h3>Converting Between Them</h3>
<p><strong>From resources to resource:</strong></p>
<pre><code class="language-ruby"># If users can only have one blog:
# Before:
resources :blogs  # /blogs, /blogs/:id

# After:
resource :blog    # /blog (always current user&#39;s blog)
</code></pre>
<p><strong>From resource to resources:</strong></p>
<pre><code class="language-ruby"># If users can have multiple profiles:
# Before:
resource :profile  # /profile

# After:
resources :profiles  # /profiles, /profiles/:id
</code></pre>
<hr>
<h3>REST API Example</h3>
<p><strong>API for blog posts (plural):</strong></p>
<pre><code class="language-ruby">namespace :api do
  namespace :v1 do
    resources :posts, only: [:index, :show, :create, :update, :destroy]
  end
end

# GET    /api/v1/posts
# POST   /api/v1/posts
# GET    /api/v1/posts/:id
# PATCH  /api/v1/posts/:id
# DELETE /api/v1/posts/:id
</code></pre>
<p><strong>API for user profile (singular):</strong></p>
<pre><code class="language-ruby">namespace :api do
  namespace :v1 do
    resource :profile, only: [:show, :update]
  end
end

# GET   /api/v1/profile
# PATCH /api/v1/profile
# (No index, no ID!)
</code></pre>
<hr>
<h3>Common Mistakes</h3>
<p><strong>Mistake 1: Using resource when you need resources:</strong></p>
<pre><code class="language-ruby"># WRONG
resource :posts  # Only 6 routes, no index!

# RIGHT
resources :posts  # 7 routes, has index
</code></pre>
<p><strong>Mistake 2: Forgetting singular controller name:</strong></p>
<pre><code class="language-ruby"># WRONG
resource :profile  # Looks for ProfilesController

# RIGHT
resource :profile  # Should use ProfileController (singular)
</code></pre>
<p><strong>Mistake 3: Trying to find by ID with singular resource:</strong></p>
<pre><code class="language-ruby"># WRONG
def show
  @profile = Profile.find(params[:id])  # No :id param!
end

# RIGHT
def show
  @profile = current_user.profile  # No ID needed
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>resources</code></strong> = plural, 7 routes, has index, uses ID</li>
<li><strong><code>resource</code></strong> = singular, 6 routes, no index, no ID</li>
<li><strong>Use <code>resources</code></strong> for multiple items</li>
<li><strong>Use <code>resource</code></strong> for one item per user</li>
<li><strong>Singular resource</strong> controller is also singular</li>
<li><strong>No index action</strong> with singular resource</li>
<li><strong>Routes don&#39;t include <code>:id</code></strong> with singular resource</li>
<li><strong>View helpers</strong> omit ID with singular resource</li>
</ol>
<hr>
<h2>Question 54: What is the difference between namespace routing and scope routing?</h2>
<h3>Answer</h3>
<p><strong>Namespace</strong> affects both URL path and controller organization, while <strong>scope</strong> offers more granular control over each aspect independently.</p>
<hr>
<h3>Namespace Routing</h3>
<p><strong>Changes URL, module, and controller path:</strong></p>
<pre><code class="language-ruby">namespace :admin do
  resources :posts
  resources :users
end

# Generates:
# URL:        /admin/posts
# Controller: Admin::PostsController
# Path:       app/controllers/admin/posts_controller.rb
</code></pre>
<p><strong>Complete namespace example:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
namespace :admin do
  resources :posts
end

# app/controllers/admin/posts_controller.rb
module Admin
  class PostsController &lt; ApplicationController
    def index
      @posts = Post.all
    end
  end
end

# Generated routes:
#        Prefix Verb   URI Pattern                Controller#Action
#   admin_posts GET    /admin/posts               admin/posts#index
#               POST   /admin/posts               admin/posts#create
# new_admin_post GET   /admin/posts/new           admin/posts#new
# edit_admin_post GET  /admin/posts/:id/edit      admin/posts#edit
#    admin_post GET    /admin/posts/:id           admin/posts#show
#               PATCH  /admin/posts/:id           admin/posts#update
#               DELETE /admin/posts/:id           admin/posts#destroy
</code></pre>
<hr>
<h3>Scope Routing</h3>
<p><strong>More flexible - change URL and/or module independently:</strong></p>
<p><strong>1. Scope with path only:</strong></p>
<pre><code class="language-ruby">scope path: &#39;/admin&#39; do
  resources :posts
end

# URL:        /admin/posts
# Controller: PostsController (no namespace!)
# Path:       app/controllers/posts_controller.rb
</code></pre>
<p><strong>2. Scope with module only:</strong></p>
<pre><code class="language-ruby">scope module: &#39;admin&#39; do
  resources :posts
end

# URL:        /posts (no /admin prefix!)
# Controller: Admin::PostsController
# Path:       app/controllers/admin/posts_controller.rb
</code></pre>
<p><strong>3. Scope with both (same as namespace):</strong></p>
<pre><code class="language-ruby">scope path: &#39;/admin&#39;, module: &#39;admin&#39; do
  resources :posts
end

# Equivalent to:
namespace :admin do
  resources :posts
end

# URL:        /admin/posts
# Controller: Admin::PostsController
</code></pre>
<hr>
<h3>Key Differences Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Namespace</th>
<th>Scope</th>
</tr>
</thead>
<tbody><tr>
<td><strong>URL prefix</strong></td>
<td>Automatic</td>
<td>Optional (use <code>path:</code>)</td>
</tr>
<tr>
<td><strong>Module</strong></td>
<td>Automatic</td>
<td>Optional (use <code>module:</code>)</td>
</tr>
<tr>
<td><strong>Controller name</strong></td>
<td>Namespaced</td>
<td>Configurable</td>
</tr>
<tr>
<td><strong>Flexibility</strong></td>
<td>All or nothing</td>
<td>Mix and match</td>
</tr>
<tr>
<td><strong>Route names</strong></td>
<td>Prefixed</td>
<td>Configurable</td>
</tr>
</tbody></table>
<hr>
<h3>Detailed Comparisons</h3>
<p><strong>Example 1: Admin Panel</strong></p>
<pre><code class="language-ruby"># NAMESPACE - Everything namespaced
namespace :admin do
  resources :posts
end

# Routes:
# /admin/posts → Admin::PostsController
# Helper: admin_posts_path

# SCOPE (path only) - URL namespaced, controller not
scope path: &#39;/admin&#39; do
  resources :posts
end

# Routes:
# /admin/posts → PostsController
# Helper: posts_path

# SCOPE (module only) - Controller namespaced, URL not
scope module: &#39;admin&#39; do
  resources :posts
end

# Routes:
# /posts → Admin::PostsController
# Helper: posts_path
</code></pre>
<hr>
<h3>Use Cases</h3>
<p><strong>Use Namespace when:</strong></p>
<ul>
<li>Building admin panel</li>
<li>Creating API versions</li>
<li>Organizing by feature/domain</li>
<li>Want URL and code structure to match</li>
</ul>
<pre><code class="language-ruby"># Admin area
namespace :admin do
  resources :users
  resources :posts
  resources :settings
end

# API versioning
namespace :api do
  namespace :v1 do
    resources :posts
  end
  
  namespace :v2 do
    resources :posts
  end
end
</code></pre>
<p><strong>Use Scope when:</strong></p>
<ul>
<li>Need custom URL structure</li>
<li>Share controllers across different URLs</li>
<li>Want different URL than module name</li>
<li>Need fine-grained control</li>
</ul>
<pre><code class="language-ruby"># Different URL structure
scope path: &#39;/account&#39;, module: &#39;users&#39; do
  resource :profile
  resource :settings
end
# URL: /account/profile
# Controller: Users::ProfileController

# Localized routes
scope path: &#39;/:locale&#39; do
  resources :posts
end
# URL: /en/posts, /es/posts
# Controller: PostsController
</code></pre>
<hr>
<h3>Advanced Scope Options</h3>
<p><strong>1. Custom URL prefix:</strong></p>
<pre><code class="language-ruby">scope path: &#39;/management&#39; do
  resources :posts
  # URL: /management/posts
  # Controller: PostsController
end
</code></pre>
<p><strong>2. Custom module:</strong></p>
<pre><code class="language-ruby">scope module: &#39;backend&#39; do
  resources :posts
  # URL: /posts
  # Controller: Backend::PostsController
end
</code></pre>
<p><strong>3. As (change route names):</strong></p>
<pre><code class="language-ruby">scope as: &#39;admin&#39; do
  resources :posts
end

# Helpers:
# admin_posts_path instead of posts_path
</code></pre>
<p><strong>4. Constraints:</strong></p>
<pre><code class="language-ruby">scope constraints: { subdomain: &#39;api&#39; } do
  resources :posts
end

# Only matches api.example.com
</code></pre>
<p><strong>5. Defaults:</strong></p>
<pre><code class="language-ruby">scope defaults: { format: &#39;json&#39; } do
  resources :posts
end

# All routes default to JSON format
</code></pre>
<hr>
<h3>Complex Example</h3>
<pre><code class="language-ruby"># config/routes.rb

# 1. NAMESPACE - Admin panel
namespace :admin do
  resources :users
  resources :posts
  root &#39;dashboard#index&#39;
end
# URLs: /admin/users, /admin/posts, /admin
# Controllers: Admin::UsersController, Admin::PostsController

# 2. SCOPE - API with version in URL but not module
scope path: &#39;/api/v1&#39;, module: &#39;api&#39; do
  resources :posts
end
# URL: /api/v1/posts
# Controller: Api::PostsController (not Api::V1::PostsController)

# 3. SCOPE - Localization
scope path: &#39;/:locale&#39;, locale: /en|es|fr/ do
  resources :posts
  root &#39;home#index&#39;
end
# URLs: /en/posts, /es/posts, /fr/posts
# Controller: PostsController
# params[:locale] = &#39;en&#39;, &#39;es&#39;, or &#39;fr&#39;

# 4. SCOPE - Mobile subdomain
scope constraints: { subdomain: &#39;mobile&#39; }, module: &#39;mobile&#39; do
  resources :posts
end
# URL: mobile.example.com/posts
# Controller: Mobile::PostsController

# 5. NAMESPACE - API with versioned modules
namespace :api do
  namespace :v1 do
    resources :posts
  end
  
  namespace :v2 do
    resources :posts
  end
end
# URLs: /api/v1/posts, /api/v2/posts
# Controllers: Api::V1::PostsController, Api::V2::PostsController
</code></pre>
<hr>
<h3>Combining Namespace and Scope</h3>
<pre><code class="language-ruby">namespace :admin do
  # Scope within namespace
  scope :reports do
    get :sales, to: &#39;reports#sales&#39;
    get :users, to: &#39;reports#users&#39;
  end
end

# URLs:
# /admin/reports/sales → Admin::ReportsController#sales
# /admin/reports/users → Admin::ReportsController#users
</code></pre>
<hr>
<h3>Real-World Example: Multi-tenant Application</h3>
<pre><code class="language-ruby"># config/routes.rb
constraints(TenantConstraint.new) do
  scope path: &#39;/:tenant_id&#39; do
    resources :posts
    resources :users
    
    namespace :admin do
      resources :settings
    end
  end
end

# URLs:
# /company-a/posts → PostsController
# /company-b/posts → PostsController
# /company-a/admin/settings → Admin::SettingsController

# lib/tenant_constraint.rb
class TenantConstraint
  def matches?(request)
    Tenant.exists?(slug: request.params[:tenant_id])
  end
end
</code></pre>
<hr>
<h3>Helper Methods</h3>
<p><strong>Namespace:</strong></p>
<pre><code class="language-ruby">namespace :admin do
  resources :posts
end

# Helpers:
admin_posts_path          # /admin/posts
new_admin_post_path       # /admin/posts/new
edit_admin_post_path(@post) # /admin/posts/1/edit
</code></pre>
<p><strong>Scope (path only):</strong></p>
<pre><code class="language-ruby">scope path: &#39;/admin&#39; do
  resources :posts
end

# Helpers (no admin prefix):
posts_path          # /admin/posts
new_post_path       # /admin/posts/new
edit_post_path(@post) # /admin/posts/1/edit
</code></pre>
<p><strong>Scope with &#39;as&#39;:</strong></p>
<pre><code class="language-ruby">scope path: &#39;/admin&#39;, as: &#39;admin&#39; do
  resources :posts
end

# Helpers (admin prefix):
admin_posts_path          # /admin/posts
new_admin_post_path       # /admin/posts/new
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Namespace</strong> = path + module + name prefix</li>
<li><strong>Scope</strong> = flexible, choose what changes</li>
<li><strong>Namespace</strong> for organized admin/API areas</li>
<li><strong>Scope</strong> for custom URL structures</li>
<li><strong>Scope path:</strong> changes URL only</li>
<li><strong>Scope module:</strong> changes controller only</li>
<li><strong>Scope as:</strong> changes helper names</li>
<li><strong>Can combine</strong> namespace and scope</li>
</ol>
<hr>
<h2>Question 55: What is the difference between <code>member</code> and <code>collection</code> routes?</h2>
<h3>Answer</h3>
<p><strong>Member routes</strong> operate on a single resource (needs ID), while <strong>collection routes</strong> operate on the entire collection (no ID needed).</p>
<hr>
<h3>Member Routes</h3>
<p><strong>Actions on individual resources - requires <code>:id</code>:</strong></p>
<pre><code class="language-ruby">resources :posts do
  member do
    post :publish
    post :unpublish
    get :preview
    patch :feature
  end
end

# OR shorter syntax:
resources :posts do
  post :publish, on: :member
  get :preview, on: :member
end

# Generated routes:
# POST  /posts/:id/publish     → posts#publish
# POST  /posts/:id/unpublish   → posts#unpublish
# GET   /posts/:id/preview     → posts#preview
# PATCH /posts/:id/feature     → posts#feature
</code></pre>
<p><strong>Controller:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  # Member action - operates on ONE post
  def publish
    @post = Post.find(params[:id])  # ID is available
    
    if @post.publish!
      redirect_to @post, notice: &#39;Post published&#39;
    else
      redirect_to @post, alert: &#39;Could not publish&#39;
    end
  end
  
  def preview
    @post = Post.find(params[:id])
    render layout: false  # Preview without layout
  end
end
</code></pre>
<p><strong>Usage in views:</strong></p>
<pre><code class="language-erb">&lt;% @posts.each do |post| %&gt;
  &lt;%= link_to &#39;Publish&#39;, publish_post_path(post), method: :post %&gt;
  &lt;%= link_to &#39;Preview&#39;, preview_post_path(post) %&gt;
  &lt;%= link_to &#39;Feature&#39;, feature_post_path(post), method: :patch %&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Collection Routes</h3>
<p><strong>Actions on the entire collection - no ID:</strong></p>
<pre><code class="language-ruby">resources :posts do
  collection do
    get :archived
    get :search
    post :bulk_delete
    get :export
  end
end

# OR shorter syntax:
resources :posts do
  get :archived, on: :collection
  post :bulk_delete, on: :collection
end

# Generated routes:
# GET  /posts/archived      → posts#archived
# GET  /posts/search        → posts#search
# POST /posts/bulk_delete   → posts#bulk_delete
# GET  /posts/export        → posts#export
</code></pre>
<p><strong>Controller:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  # Collection action - operates on MULTIPLE posts
  def archived
    @posts = Post.where(archived: true)
    # No specific post ID
  end
  
  def search
    @posts = Post.where(&quot;title LIKE ?&quot;, &quot;%#{params[:q]}%&quot;)
  end
  
  def bulk_delete
    Post.where(id: params[:post_ids]).destroy_all
    redirect_to posts_path, notice: &#39;Posts deleted&#39;
  end
  
  def export
    @posts = Post.all
    send_data generate_csv(@posts), filename: &#39;posts.csv&#39;
  end
end
</code></pre>
<p><strong>Usage in views:</strong></p>
<pre><code class="language-erb">&lt;%= link_to &#39;Archived Posts&#39;, archived_posts_path %&gt;
&lt;%= link_to &#39;Export All&#39;, export_posts_path %&gt;

&lt;%= form_tag bulk_delete_posts_path, method: :post do %&gt;
  &lt;% @posts.each do |post| %&gt;
    &lt;%= check_box_tag &#39;post_ids[]&#39;, post.id %&gt;
    &lt;%= post.title %&gt;
  &lt;% end %&gt;
  &lt;%= submit_tag &#39;Delete Selected&#39; %&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Member Route</th>
<th>Collection Route</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Operates on</strong></td>
<td>Single resource</td>
<td>Multiple resources</td>
</tr>
<tr>
<td><strong>URL pattern</strong></td>
<td><code>/resources/:id/action</code></td>
<td><code>/resources/action</code></td>
</tr>
<tr>
<td><strong>Requires ID</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Example</strong></td>
<td><code>/posts/1/publish</code></td>
<td><code>/posts/archived</code></td>
</tr>
<tr>
<td><strong>params[:id]</strong></td>
<td>Present</td>
<td>Not present</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Publish one post</td>
<td>Export all posts</td>
</tr>
</tbody></table>
<hr>
<h3>Complete Example</h3>
<pre><code class="language-ruby"># config/routes.rb
resources :articles do
  # MEMBER routes - need article ID
  member do
    post :publish       # Publish specific article
    post :unpublish     # Unpublish specific article
    get :preview        # Preview specific article
    post :archive       # Archive specific article
    post :feature       # Feature specific article
  end
  
  # COLLECTION routes - work on all articles
  collection do
    get :drafts         # List all drafts
    get :published      # List all published
    get :archived       # List all archived
    get :search         # Search all articles
    post :bulk_delete   # Delete multiple articles
    post :bulk_publish  # Publish multiple articles
    get :export         # Export all to CSV
  end
end

# Generated routes:
#
# MEMBER (with :id):
# POST /articles/:id/publish
# POST /articles/:id/unpublish
# GET  /articles/:id/preview
# POST /articles/:id/archive
# POST /articles/:id/feature
#
# COLLECTION (without :id):
# GET  /articles/drafts
# GET  /articles/published
# GET  /articles/archived
# GET  /articles/search
# POST /articles/bulk_delete
# POST /articles/bulk_publish
# GET  /articles/export
</code></pre>
<p><strong>Controller implementation:</strong></p>
<pre><code class="language-ruby">class ArticlesController &lt; ApplicationController
  # Standard RESTful actions
  def index
    @articles = Article.all
  end
  
  def show
    @article = Article.find(params[:id])
  end
  
  # MEMBER ROUTES
  def publish
    @article = Article.find(params[:id])
    @article.update(published: true, published_at: Time.current)
    redirect_to @article, notice: &#39;Article published&#39;
  end
  
  def unpublish
    @article = Article.find(params[:id])
    @article.update(published: false, published_at: nil)
    redirect_to @article, notice: &#39;Article unpublished&#39;
  end
  
  def preview
    @article = Article.find(params[:id])
    render layout: &#39;preview&#39;
  end
  
  def archive
    @article = Article.find(params[:id])
    @article.update(archived: true)
    redirect_to @article, notice: &#39;Article archived&#39;
  end
  
  # COLLECTION ROUTES
  def drafts
    @articles = Article.where(published: false)
    render :index
  end
  
  def published
    @articles = Article.where(published: true)
    render :index
  end
  
  def archived
    @articles = Article.where(archived: true)
    render :index
  end
  
  def search
    @articles = Article.where(&quot;title LIKE ?&quot;, &quot;%#{params[:q]}%&quot;)
    render :index
  end
  
  def bulk_delete
    Article.where(id: params[:article_ids]).destroy_all
    redirect_to articles_path, notice: &#39;Articles deleted&#39;
  end
  
  def bulk_publish
    Article.where(id: params[:article_ids])
           .update_all(published: true, published_at: Time.current)
    redirect_to articles_path, notice: &#39;Articles published&#39;
  end
  
  def export
    @articles = Article.all
    respond_to do |format|
      format.csv { send_data generate_csv(@articles) }
      format.json { render json: @articles }
    end
  end
  
  private
  
  def generate_csv(articles)
    CSV.generate do |csv|
      csv &lt;&lt; [&#39;Title&#39;, &#39;Author&#39;, &#39;Published&#39;]
      articles.each do |article|
        csv &lt;&lt; [article.title, article.author, article.published?]
      end
    end
  end
end
</code></pre>
<hr>
<h3>View Examples</h3>
<p><strong>Member route usage:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/articles/show.html.erb --&gt;
&lt;h1&gt;&lt;%= @article.title %&gt;&lt;/h1&gt;

&lt;div class=&quot;actions&quot;&gt;
  &lt;% if @article.published? %&gt;
    &lt;%= button_to &#39;Unpublish&#39;, unpublish_article_path(@article) %&gt;
  &lt;% else %&gt;
    &lt;%= button_to &#39;Publish&#39;, publish_article_path(@article) %&gt;
  &lt;% end %&gt;
  
  &lt;%= link_to &#39;Preview&#39;, preview_article_path(@article), target: &#39;_blank&#39; %&gt;
  &lt;%= button_to &#39;Archive&#39;, archive_article_path(@article) %&gt;
  &lt;%= button_to &#39;Feature&#39;, feature_article_path(@article) %&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Collection route usage:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/articles/index.html.erb --&gt;
&lt;nav&gt;
  &lt;%= link_to &#39;All Articles&#39;, articles_path %&gt;
  &lt;%= link_to &#39;Drafts&#39;, drafts_articles_path %&gt;
  &lt;%= link_to &#39;Published&#39;, published_articles_path %&gt;
  &lt;%= link_to &#39;Archived&#39;, archived_articles_path %&gt;
  &lt;%= link_to &#39;Export CSV&#39;, export_articles_path(format: :csv) %&gt;
&lt;/nav&gt;

&lt;%= form_tag search_articles_path, method: :get do %&gt;
  &lt;%= text_field_tag :q, params[:q] %&gt;
  &lt;%= submit_tag &#39;Search&#39; %&gt;
&lt;% end %&gt;

&lt;%= form_tag bulk_delete_articles_path, method: :post do %&gt;
  &lt;table&gt;
    &lt;% @articles.each do |article| %&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;%= check_box_tag &#39;article_ids[]&#39;, article.id %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= article.title %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= link_to &#39;Publish&#39;, publish_article_path(article), method: :post %&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;% end %&gt;
  &lt;/table&gt;
  
  &lt;%= submit_tag &#39;Delete Selected&#39; %&gt;
  &lt;%= submit_tag &#39;Publish Selected&#39;, formaction: bulk_publish_articles_path %&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use Member Routes when:</strong></p>
<ul>
<li>Action affects ONE specific resource</li>
<li>Need to identify which resource to act on</li>
<li>Examples:<ul>
<li>Publish specific post</li>
<li>Star specific photo</li>
<li>Like specific comment</li>
<li>Clone specific project</li>
</ul>
</li>
</ul>
<p><strong>Use Collection Routes when:</strong></p>
<ul>
<li>Action affects MULTIPLE resources</li>
<li>Filtering or searching</li>
<li>Bulk operations</li>
<li>Reports or exports</li>
<li>Examples:<ul>
<li>Search all posts</li>
<li>Export all users to CSV</li>
<li>Delete multiple items</li>
<li>View archived items</li>
</ul>
</li>
</ul>
<hr>
<h3>Common Patterns</h3>
<p><strong>Member route patterns:</strong></p>
<pre><code class="language-ruby">resources :posts do
  member do
    post :like          # Like this post
    delete :unlike      # Unlike this post
    post :star          # Star this post
    post :flag          # Flag this post
    get :share          # Share this post
    post :duplicate     # Duplicate this post
  end
end
</code></pre>
<p><strong>Collection route patterns:</strong></p>
<pre><code class="language-ruby">resources :posts do
  collection do
    get :search         # Search posts
    get :filter         # Filter posts
    get :trending       # Trending posts
    get :recent         # Recent posts
    post :import        # Import posts
    get :export         # Export posts
    post :bulk_update   # Update multiple
  end
end
</code></pre>
<hr>
<h3>API Example</h3>
<pre><code class="language-ruby"># config/routes.rb
namespace :api do
  namespace :v1 do
    resources :posts do
      member do
        patch :publish
        patch :unpublish
      end
      
      collection do
        get :trending
        get :search
      end
    end
  end
end

# API Controller
module Api
  module V1
    class PostsController &lt; ApplicationController
      # Member
      def publish
        post = Post.find(params[:id])
        post.publish!
        render json: post
      end
      
      # Collection
      def trending
        posts = Post.trending.limit(10)
        render json: posts
      end
      
      def search
        posts = Post.where(&quot;title LIKE ?&quot;, &quot;%#{params[:q]}%&quot;)
        render json: posts
      end
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Member</strong> = single resource, requires <code>:id</code></li>
<li><strong>Collection</strong> = multiple resources, no <code>:id</code></li>
<li><strong>Member URL</strong>: <code>/resources/:id/action</code></li>
<li><strong>Collection URL</strong>: <code>/resources/action</code></li>
<li><strong>Use member</strong> for individual actions</li>
<li><strong>Use collection</strong> for bulk/filter/search</li>
<li><strong>Both support</strong> all HTTP verbs</li>
<li><strong>Helpers</strong> auto-generated for both</li>
</ol>
<hr>
<h2>Question 56: What is the difference between <code>PUT</code> vs <code>PATCH</code>?</h2>
<h3>Answer</h3>
<p><strong>PUT</strong> replaces the entire resource, while <strong>PATCH</strong> partially updates a resource. Both are used for updates, but with different semantics.</p>
<hr>
<h3>HTTP Specification</h3>
<p><strong>PUT (Replace Entire Resource):</strong></p>
<ul>
<li>Idempotent (same result if called multiple times)</li>
<li>Sends complete resource representation</li>
<li>Replaces entire resource</li>
<li>Missing fields set to null/default</li>
</ul>
<p><strong>PATCH (Partial Update):</strong></p>
<ul>
<li>Idempotent (usually)</li>
<li>Sends only changed fields</li>
<li>Updates specific fields</li>
<li>Leaves other fields unchanged</li>
</ul>
<hr>
<h3>Rails Implementation</h3>
<p><strong>Both PUT and PATCH map to <code>update</code> action:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
resources :posts

# Generated routes:
# PUT   /posts/:id → posts#update
# PATCH /posts/:id → posts#update

# Rails accepts both verbs for the same action
</code></pre>
<p><strong>Controller:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def update
    @post = Post.find(params[:id])
    
    # Rails doesn&#39;t distinguish between PUT and PATCH
    # Both execute the same code
    if @post.update(post_params)
      redirect_to @post
    else
      render :edit
    end
  end
  
  private
  
  def post_params
    params.require(:post).permit(:title, :body, :published)
  end
end
</code></pre>
<hr>
<h3>Semantic Difference</h3>
<p><strong>PUT - Full replacement:</strong></p>
<pre><code class="language-ruby"># Client sends ENTIRE resource
PUT /api/posts/1
Content-Type: application/json

{
  &quot;title&quot;: &quot;Updated Title&quot;,
  &quot;body&quot;: &quot;Updated body&quot;,
  &quot;published&quot;: true,
  &quot;author_id&quot;: 1,
  &quot;category_id&quot;: 2
}

# Expected behavior:
# - Replace entire post with this data
# - Missing fields should be set to null
</code></pre>
<p><strong>PATCH - Partial update:</strong></p>
<pre><code class="language-ruby"># Client sends ONLY changed fields
PATCH /api/posts/1
Content-Type: application/json

{
  &quot;title&quot;: &quot;Updated Title&quot;
}

# Expected behavior:
# - Update only title
# - Keep all other fields unchanged
</code></pre>
<hr>
<h3>Rails Form Helpers</h3>
<p><strong>Rails uses PATCH by default:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/edit.html.erb --&gt;
&lt;%= form_with model: @post do |f| %&gt;
  &lt;%= f.text_field :title %&gt;
  &lt;%= f.text_area :body %&gt;
  &lt;%= f.submit %&gt;
&lt;% end %&gt;

&lt;!-- Generated HTML: --&gt;
&lt;form action=&quot;/posts/1&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;patch&quot;&gt;
  &lt;!-- Rails uses PATCH, not PUT --&gt;
&lt;/form&gt;
</code></pre>
<p><strong>Can explicitly use PUT:</strong></p>
<pre><code class="language-erb">&lt;%= form_with model: @post, method: :put do |f| %&gt;
  &lt;!-- Generates PUT request --&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>API Example</h3>
<p><strong>Proper REST API implementation:</strong></p>
<pre><code class="language-ruby"># app/controllers/api/v1/posts_controller.rb
module Api
  module V1
    class PostsController &lt; ApplicationController
      # PUT - full replacement
      def replace
        @post = Post.find(params[:id])
        
        # Replace entire resource
        if @post.update(replace_params)
          render json: @post
        else
          render json: @post.errors, status: :unprocessable_entity
        end
      end
      
      # PATCH - partial update
      def update
        @post = Post.find(params[:id])
        
        # Update only provided fields
        if @post.update(update_params)
          render json: @post
        else
          render json: @post.errors, status: :unprocessable_entity
        end
      end
      
      private
      
      def replace_params
        # Require ALL fields for PUT
        params.require(:post).permit(
          :title, :body, :published, :author_id, :category_id
        )
      end
      
      def update_params
        # Allow any subset of fields for PATCH
        params.require(:post).permit(
          :title, :body, :published, :author_id, :category_id
        )
      end
    end
  end
end

# config/routes.rb
namespace :api do
  namespace :v1 do
    resources :posts do
      put :replace, on: :member  # Full replacement
    end
  end
end
</code></pre>
<hr>
<h3>Detailed Comparison</h3>
<p><strong>Example Resource:</strong></p>
<pre><code class="language-ruby"># Original Post
{
  id: 1,
  title: &quot;Original Title&quot;,
  body: &quot;Original body&quot;,
  published: false,
  author_id: 1,
  category_id: 1,
  tags: [&quot;ruby&quot;, &quot;rails&quot;]
}
</code></pre>
<p><strong>PUT Request (Replace):</strong></p>
<pre><code class="language-ruby">PUT /posts/1
{
  title: &quot;New Title&quot;,
  body: &quot;New body&quot;
}

# Expected result (strict PUT):
{
  id: 1,
  title: &quot;New Title&quot;,
  body: &quot;New body&quot;,
  published: null,      # Reset to null (not provided)
  author_id: null,      # Reset to null
  category_id: null,    # Reset to null
  tags: []              # Reset to empty
}

# Rails default behavior (lenient):
# Only updates provided fields, keeps others
</code></pre>
<p><strong>PATCH Request (Partial Update):</strong></p>
<pre><code class="language-ruby">PATCH /posts/1
{
  title: &quot;New Title&quot;
}

# Expected result:
{
  id: 1,
  title: &quot;New Title&quot;,     # Updated
  body: &quot;Original body&quot;,  # Unchanged
  published: false,       # Unchanged
  author_id: 1,          # Unchanged
  category_id: 1,        # Unchanged
  tags: [&quot;ruby&quot;, &quot;rails&quot;] # Unchanged
}
</code></pre>
<hr>
<h3>Idempotency</h3>
<p><strong>PUT is idempotent:</strong></p>
<pre><code class="language-ruby"># Call PUT multiple times → same result
PUT /posts/1 { &quot;title&quot;: &quot;New Title&quot; }
# Result: title = &quot;New Title&quot;

PUT /posts/1 { &quot;title&quot;: &quot;New Title&quot; }
# Result: title = &quot;New Title&quot; (same)

PUT /posts/1 { &quot;title&quot;: &quot;New Title&quot; }
# Result: title = &quot;New Title&quot; (same)
</code></pre>
<p><strong>PATCH can be idempotent:</strong></p>
<pre><code class="language-ruby"># If updating to specific value → idempotent
PATCH /posts/1 { &quot;title&quot;: &quot;New Title&quot; }
# Result: title = &quot;New Title&quot;

PATCH /posts/1 { &quot;title&quot;: &quot;New Title&quot; }
# Result: title = &quot;New Title&quot; (same)

# If incrementing → not idempotent
PATCH /posts/1 { &quot;views&quot;: &quot;+1&quot; }
# Result: views = 11

PATCH /posts/1 { &quot;views&quot;: &quot;+1&quot; }
# Result: views = 12 (different!)
</code></pre>
<hr>
<h3>Rails Conventions</h3>
<p><strong>Modern Rails (4.0+):</strong></p>
<pre><code class="language-ruby"># Rails switched from PUT to PATCH
# Before Rails 4: PUT for updates
# Rails 4+: PATCH for updates

# Both are supported:
resources :posts  # Generates both PUT and PATCH routes

# Routes generated:
# PATCH /posts/:id → posts#update
# PUT   /posts/:id → posts#update (for backward compatibility)
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>For Web Applications:</strong></p>
<pre><code class="language-ruby"># Use PATCH (Rails default)
resources :posts

# Form helpers automatically use PATCH
&lt;%= form_with model: @post do |f| %&gt;
  &lt;!-- Uses PATCH --&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>For APIs:</strong></p>
<pre><code class="language-ruby"># Be explicit about semantics
namespace :api do
  namespace :v1 do
    resources :posts, only: [:index, :show, :create, :destroy] do
      patch :update, on: :member   # Partial update
      put :replace, on: :member    # Full replacement (optional)
    end
  end
end

# API documentation should clarify:
# PATCH /api/v1/posts/:id - Update specific fields
# PUT   /api/v1/posts/:id - Replace entire resource
</code></pre>
<hr>
<h3>Testing</h3>
<pre><code class="language-ruby"># spec/requests/posts_spec.rb
RSpec.describe &#39;Posts&#39;, type: :request do
  let(:post) { create(:post, title: &#39;Original&#39;, body: &#39;Original body&#39;) }
  
  describe &#39;PATCH /posts/:id&#39; do
    it &#39;updates only provided fields&#39; do
      patch post_path(post), params: {
        post: { title: &#39;Updated&#39; }
      }
      
      post.reload
      expect(post.title).to eq(&#39;Updated&#39;)
      expect(post.body).to eq(&#39;Original body&#39;)  # Unchanged
    end
  end
  
  describe &#39;PUT /posts/:id&#39; do
    it &#39;also updates only provided fields (Rails behavior)&#39; do
      put post_path(post), params: {
        post: { title: &#39;Updated&#39; }
      }
      
      post.reload
      expect(post.title).to eq(&#39;Updated&#39;)
      expect(post.body).to eq(&#39;Original body&#39;)  # Also unchanged in Rails
    end
  end
end
</code></pre>
<hr>
<h3>cURL Examples</h3>
<pre><code class="language-bash"># PATCH request
curl -X PATCH https://api.example.com/posts/1 \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;title&quot;: &quot;Updated Title&quot;}&#39;

# PUT request
curl -X PUT https://api.example.com/posts/1 \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
    &quot;title&quot;: &quot;New Title&quot;,
    &quot;body&quot;: &quot;New body&quot;,
    &quot;published&quot;: true
  }&#39;
</code></pre>
<hr>
<h3>JSON API Standard</h3>
<pre><code class="language-ruby"># Following JSON API spec (jsonapi.org)
PATCH /articles/1
Content-Type: application/vnd.api+json

{
  &quot;data&quot;: {
    &quot;type&quot;: &quot;articles&quot;,
    &quot;id&quot;: &quot;1&quot;,
    &quot;attributes&quot;: {
      &quot;title&quot;: &quot;Updated Title&quot;
    }
  }
}

# Only updates title, other attributes unchanged
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>PUT</strong> = full resource replacement</li>
<li><strong>PATCH</strong> = partial resource update</li>
<li><strong>Rails accepts both</strong> for update action</li>
<li><strong>Rails defaults to PATCH</strong> (since 4.0)</li>
<li><strong>Semantically different</strong> but often same behavior</li>
<li><strong>Use PATCH</strong> for most updates</li>
<li><strong>Use PUT</strong> when replacing entire resource</li>
<li><strong>Both are idempotent</strong> (usually)</li>
<li><strong>Form helpers use PATCH</strong> by default</li>
<li><strong>APIs should document</strong> which to use</li>
</ol>
<h1>ActiveRecord Associations and Database Interview Questions</h1>
<h2>Question 57: Explain associations and migrations</h2>
<h3>Answer</h3>
<p><strong>Associations</strong> define relationships between ActiveRecord models, while <strong>migrations</strong> modify the database schema to support these relationships. They work together to create the data structure and business logic for your application.</p>
<hr>
<h3>Associations Overview</h3>
<p>Associations connect models through foreign keys and define how data relates:</p>
<p><strong>Types of Associations:</strong></p>
<ol>
<li><code>belongs_to</code> - One-to-one (child side)</li>
<li><code>has_one</code> - One-to-one (parent side)</li>
<li><code>has_many</code> - One-to-many</li>
<li><code>has_many :through</code> - Many-to-many with join model</li>
<li><code>has_and_belongs_to_many</code> - Many-to-many without join model</li>
<li>Polymorphic associations - Belongs to multiple models</li>
</ol>
<hr>
<h3>1. belongs_to / has_many</h3>
<p><strong>One-to-many relationship:</strong></p>
<pre><code class="language-ruby"># Models
class User &lt; ApplicationRecord
  has_many :posts
end

class Post &lt; ApplicationRecord
  belongs_to :user
end

# Migration
class CreatePosts &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :posts do |t|
      t.string :title
      t.text :body
      t.references :user, null: false, foreign_key: true
      # t.references creates:
      # - user_id column (bigint)
      # - index on user_id
      # - foreign key constraint
      
      t.timestamps
    end
  end
end

# Or manually:
class CreatePosts &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :posts do |t|
      t.string :title
      t.bigint :user_id, null: false
      t.timestamps
    end
    
    add_index :posts, :user_id
    add_foreign_key :posts, :users
  end
end

# Usage:
user = User.create(name: &quot;John&quot;)
post = user.posts.create(title: &quot;Hello&quot;)
post.user  # =&gt; User object
user.posts # =&gt; [Post, Post, ...]
</code></pre>
<hr>
<h3>2. has_one / belongs_to</h3>
<p><strong>One-to-one relationship:</strong></p>
<pre><code class="language-ruby"># Models
class User &lt; ApplicationRecord
  has_one :profile
end

class Profile &lt; ApplicationRecord
  belongs_to :user
end

# Migration
class CreateProfiles &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :profiles do |t|
      t.references :user, null: false, foreign_key: true, index: { unique: true }
      t.string :bio
      t.string :avatar_url
      
      t.timestamps
    end
  end
end

# Usage:
user = User.create(name: &quot;John&quot;)
profile = user.create_profile(bio: &quot;Software developer&quot;)
user.profile  # =&gt; Profile object
profile.user  # =&gt; User object
</code></pre>
<hr>
<h3>3. has_many :through</h3>
<p><strong>Many-to-many with join model:</strong></p>
<pre><code class="language-ruby"># Models
class Student &lt; ApplicationRecord
  has_many :enrollments
  has_many :courses, through: :enrollments
end

class Course &lt; ApplicationRecord
  has_many :enrollments
  has_many :students, through: :enrollments
end

class Enrollment &lt; ApplicationRecord
  belongs_to :student
  belongs_to :course
end

# Migrations
class CreateStudents &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :students do |t|
      t.string :name
      t.timestamps
    end
  end
end

class CreateCourses &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :courses do |t|
      t.string :name
      t.timestamps
    end
  end
end

class CreateEnrollments &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :enrollments do |t|
      t.references :student, null: false, foreign_key: true
      t.references :course, null: false, foreign_key: true
      t.date :enrolled_on
      t.string :grade
      
      t.timestamps
    end
    
    # Composite unique index
    add_index :enrollments, [:student_id, :course_id], unique: true
  end
end

# Usage:
student = Student.create(name: &quot;Alice&quot;)
course = Course.create(name: &quot;Math 101&quot;)

# Create through join model
student.enrollments.create(course: course, enrolled_on: Date.today)

# Access through association
student.courses  # =&gt; [Course]
course.students  # =&gt; [Student]

# Access join model
student.enrollments.first.grade = &quot;A&quot;
</code></pre>
<hr>
<h3>4. has_and_belongs_to_many</h3>
<p><strong>Many-to-many without join model:</strong></p>
<pre><code class="language-ruby"># Models
class Author &lt; ApplicationRecord
  has_and_belongs_to_many :books
end

class Book &lt; ApplicationRecord
  has_and_belongs_to_many :authors
end

# Migration - Join table (no id, no timestamps)
class CreateAuthorsBooks &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :authors_books, id: false do |t|
      t.references :author, null: false, foreign_key: true
      t.references :book, null: false, foreign_key: true
    end
    
    add_index :authors_books, [:author_id, :book_id], unique: true
  end
end

# Naming convention: alphabetical order
# authors_books NOT books_authors

# Usage:
author = Author.create(name: &quot;Jane&quot;)
book = Book.create(title: &quot;Rails Guide&quot;)

author.books &lt;&lt; book
author.books  # =&gt; [Book]
book.authors  # =&gt; [Author]
</code></pre>
<hr>
<h3>5. Polymorphic Associations</h3>
<p><strong>One model belongs to multiple models:</strong></p>
<pre><code class="language-ruby"># Models
class Comment &lt; ApplicationRecord
  belongs_to :commentable, polymorphic: true
end

class Post &lt; ApplicationRecord
  has_many :comments, as: :commentable
end

class Photo &lt; ApplicationRecord
  has_many :comments, as: :commentable
end

# Migration
class CreateComments &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :comments do |t|
      t.text :body
      t.references :commentable, polymorphic: true, null: false
      # Creates:
      # - commentable_type (string) - stores &quot;Post&quot; or &quot;Photo&quot;
      # - commentable_id (bigint) - stores the ID
      
      t.timestamps
    end
    
    add_index :comments, [:commentable_type, :commentable_id]
  end
end

# Or manually:
class CreateComments &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :comments do |t|
      t.text :body
      t.string :commentable_type, null: false
      t.bigint :commentable_id, null: false
      t.timestamps
    end
    
    add_index :comments, [:commentable_type, :commentable_id]
  end
end

# Usage:
post = Post.create(title: &quot;Hello&quot;)
photo = Photo.create(url: &quot;image.jpg&quot;)

post.comments.create(body: &quot;Great post!&quot;)
photo.comments.create(body: &quot;Nice photo!&quot;)

comment = Comment.first
comment.commentable  # =&gt; Post or Photo object
comment.commentable_type  # =&gt; &quot;Post&quot; or &quot;Photo&quot;
</code></pre>
<hr>
<h3>6. Self-Referential Association</h3>
<p><strong>Model associated with itself:</strong></p>
<pre><code class="language-ruby"># Model
class User &lt; ApplicationRecord
  has_many :friendships
  has_many :friends, through: :friendships
end

class Friendship &lt; ApplicationRecord
  belongs_to :user
  belongs_to :friend, class_name: &#39;User&#39;
end

# Migration
class CreateFriendships &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :friendships do |t|
      t.references :user, null: false, foreign_key: true
      t.references :friend, null: false, foreign_key: { to_table: :users }
      
      t.timestamps
    end
    
    add_index :friendships, [:user_id, :friend_id], unique: true
  end
end

# Usage:
alice = User.create(name: &quot;Alice&quot;)
bob = User.create(name: &quot;Bob&quot;)

alice.friendships.create(friend: bob)
alice.friends  # =&gt; [Bob]
</code></pre>
<hr>
<h3>Complete Association Example</h3>
<p><strong>Blog Application:</strong></p>
<pre><code class="language-ruby"># Models with all association types

class User &lt; ApplicationRecord
  has_one :profile
  has_many :posts
  has_many :comments
  has_many :likes
end

class Profile &lt; ApplicationRecord
  belongs_to :user
end

class Post &lt; ApplicationRecord
  belongs_to :user
  has_many :comments, as: :commentable, dependent: :destroy
  has_many :likes, as: :likeable, dependent: :destroy
  has_many :post_tags
  has_many :tags, through: :post_tags
end

class Comment &lt; ApplicationRecord
  belongs_to :user
  belongs_to :commentable, polymorphic: true
  has_many :likes, as: :likeable, dependent: :destroy
end

class Like &lt; ApplicationRecord
  belongs_to :user
  belongs_to :likeable, polymorphic: true
end

class Tag &lt; ApplicationRecord
  has_many :post_tags
  has_many :posts, through: :post_tags
end

class PostTag &lt; ApplicationRecord
  belongs_to :post
  belongs_to :tag
end

# Migrations

# Users table
class CreateUsers &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      t.string :name, null: false
      t.string :email, null: false
      
      t.timestamps
    end
    
    add_index :users, :email, unique: true
  end
end

# Profiles table
class CreateProfiles &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :profiles do |t|
      t.references :user, null: false, foreign_key: true, index: { unique: true }
      t.text :bio
      t.string :avatar_url
      t.string :website
      
      t.timestamps
    end
  end
end

# Posts table
class CreatePosts &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :posts do |t|
      t.references :user, null: false, foreign_key: true
      t.string :title, null: false
      t.text :body
      t.boolean :published, default: false
      
      t.timestamps
    end
    
    add_index :posts, [:user_id, :created_at]
    add_index :posts, :published
  end
end

# Comments table (polymorphic)
class CreateComments &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :comments do |t|
      t.references :user, null: false, foreign_key: true
      t.references :commentable, polymorphic: true, null: false
      t.text :body, null: false
      
      t.timestamps
    end
    
    add_index :comments, [:commentable_type, :commentable_id]
  end
end

# Likes table (polymorphic)
class CreateLikes &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :likes do |t|
      t.references :user, null: false, foreign_key: true
      t.references :likeable, polymorphic: true, null: false
      
      t.timestamps
    end
    
    add_index :likes, [:likeable_type, :likeable_id]
    add_index :likes, [:user_id, :likeable_type, :likeable_id], 
              unique: true, name: &#39;unique_likes&#39;
  end
end

# Tags table
class CreateTags &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :tags do |t|
      t.string :name, null: false
      
      t.timestamps
    end
    
    add_index :tags, :name, unique: true
  end
end

# Join table for posts and tags
class CreatePostTags &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :post_tags do |t|
      t.references :post, null: false, foreign_key: true
      t.references :tag, null: false, foreign_key: true
      
      t.timestamps
    end
    
    add_index :post_tags, [:post_id, :tag_id], unique: true
  end
end
</code></pre>
<hr>
<h3>Association Options</h3>
<p><strong>Common options:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :posts, 
           dependent: :destroy,      # Delete posts when user deleted
           inverse_of: :user,        # Performance optimization
           class_name: &#39;Article&#39;,    # Use different class name
           foreign_key: &#39;author_id&#39;, # Custom foreign key
           primary_key: &#39;id&#39;,        # Custom primary key
           counter_cache: true,      # Cache count
           validate: true,           # Validate associated records
           autosave: true            # Auto-save associated records
  
  has_one :profile,
          dependent: :destroy,
          required: true              # Profile must exist
  
  belongs_to :organization,
             optional: true,           # Can be nil
             touch: true,              # Update parent&#39;s updated_at
             counter_cache: :members_count
end

# dependent options:
# - :destroy    - Call destroy on associated records
# - :delete_all - Delete without callbacks (faster)
# - :nullify    - Set foreign key to null
# - :restrict_with_exception - Raise error if records exist
# - :restrict_with_error - Add error if records exist
</code></pre>
<hr>
<h3>Migration Helpers</h3>
<p><strong>Common migration methods:</strong></p>
<pre><code class="language-ruby">class AddReferences &lt; ActiveRecord::Migration[7.0]
  def change
    # Add reference
    add_reference :posts, :category, foreign_key: true
    
    # Add polymorphic reference
    add_reference :comments, :commentable, polymorphic: true
    
    # Remove reference
    remove_reference :posts, :category
    
    # Add foreign key
    add_foreign_key :posts, :users
    
    # Remove foreign key
    remove_foreign_key :posts, :users
    
    # Add index
    add_index :posts, :user_id
    add_index :posts, [:user_id, :published]
    add_index :posts, :slug, unique: true
    
    # Remove index
    remove_index :posts, :user_id
    remove_index :posts, name: &#39;index_posts_on_user_id&#39;
  end
end
</code></pre>
<hr>
<h3>Query Examples</h3>
<p><strong>Using associations:</strong></p>
<pre><code class="language-ruby"># Eager loading (N+1 prevention)
users = User.includes(:posts, :profile).all

# Joins
User.joins(:posts).where(posts: { published: true })

# Includes with conditions
User.includes(:posts).where(posts: { published: true }).references(:posts)

# Count with association
user.posts.count
user.posts.size  # Uses counter_cache if available

# Build vs Create
user.posts.build(title: &quot;New Post&quot;)  # Not saved
user.posts.create(title: &quot;New Post&quot;) # Saved

# Create association
user.posts &lt;&lt; Post.new(title: &quot;Another&quot;)

# Delete association
user.posts.delete(post)  # Removes association
user.posts.destroy(post) # Destroys record
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Associations</strong> define model relationships</li>
<li><strong>Migrations</strong> create database structure</li>
<li><strong>Foreign keys</strong> enforce referential integrity</li>
<li><strong>Indexes</strong> improve query performance</li>
<li><strong>belongs_to</strong> requires foreign key on table</li>
<li><strong>has_many/has_one</strong> doesn&#39;t change table</li>
<li><strong>Polymorphic</strong> adds type and id columns</li>
<li><strong>:through</strong> uses join model</li>
<li><strong>HABTM</strong> uses join table (no model)</li>
<li><strong>Options</strong> customize behavior</li>
</ol>
<hr>
<h2>Question 58: What is the difference between <code>has_many :through</code> and <code>has_and_belongs_to_many</code>?</h2>
<h3>Answer</h3>
<p>Both create many-to-many relationships, but <strong><code>has_many :through</code></strong> uses a join model (with additional attributes), while <strong><code>has_and_belongs_to_many</code></strong> uses a simple join table (no attributes).</p>
<hr>
<h3>Key Differences Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>has_many :through</code></th>
<th><code>has_and_belongs_to_many</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Join model</strong></td>
<td>Yes (full model)</td>
<td>No (just table)</td>
</tr>
<tr>
<td><strong>Extra attributes</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Validations</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Callbacks</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>ID column</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Timestamps</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Flexibility</strong></td>
<td>High</td>
<td>Low</td>
</tr>
<tr>
<td><strong>Complexity</strong></td>
<td>More</td>
<td>Less</td>
</tr>
<tr>
<td><strong>Recommended</strong></td>
<td>Yes</td>
<td>No (deprecated)</td>
</tr>
</tbody></table>
<hr>
<h3>has_many :through</h3>
<p><strong>Uses a full ActiveRecord model for the join:</strong></p>
<pre><code class="language-ruby"># Models
class Doctor &lt; ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Patient &lt; ApplicationRecord
  has_many :appointments
  has_many :doctors, through: :appointments
end

class Appointment &lt; ApplicationRecord  # Full model!
  belongs_to :doctor
  belongs_to :patient
  
  # Can have attributes
  validates :appointment_date, presence: true
  
  # Can have methods
  def formatted_date
    appointment_date.strftime(&quot;%B %d, %Y&quot;)
  end
  
  # Can have callbacks
  after_create :send_confirmation_email
end

# Migration
class CreateDoctors &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :doctors do |t|
      t.string :name
      t.timestamps
    end
  end
end

class CreatePatients &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :patients do |t|
      t.string :name
      t.timestamps
    end
  end
end

class CreateAppointments &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :appointments do |t|  # Has ID!
      t.references :doctor, null: false, foreign_key: true
      t.references :patient, null: false, foreign_key: true
      t.datetime :appointment_date
      t.string :status
      t.text :notes
      
      t.timestamps  # Has timestamps!
    end
    
    add_index :appointments, [:doctor_id, :patient_id]
  end
end

# Usage with extra attributes
doctor = Doctor.create(name: &quot;Dr. Smith&quot;)
patient = Patient.create(name: &quot;John Doe&quot;)

# Create appointment with extra data
appointment = doctor.appointments.create(
  patient: patient,
  appointment_date: Time.current,
  status: &#39;scheduled&#39;,
  notes: &#39;Annual checkup&#39;
)

# Access through association
doctor.patients  # =&gt; [Patient]
patient.doctors  # =&gt; [Doctor]

# Access join model
doctor.appointments.first.status  # =&gt; &quot;scheduled&quot;
doctor.appointments.first.notes   # =&gt; &quot;Annual checkup&quot;

# Query through join model
doctor.appointments.where(status: &#39;scheduled&#39;)
patient.appointments.where(&#39;appointment_date &gt; ?&#39;, Date.today)
</code></pre>
<hr>
<h3>has_and_belongs_to_many (HABTM)</h3>
<p><strong>Uses a simple join table (no model):</strong></p>
<pre><code class="language-ruby"># Models
class Student &lt; ApplicationRecord
  has_and_belongs_to_many :courses
end

class Course &lt; ApplicationRecord
  has_and_belongs_to_many :students
end

# No join model!

# Migration
class CreateStudents &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :students do |t|
      t.string :name
      t.timestamps
    end
  end
end

class CreateCourses &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :courses do |t|
      t.string :name
      t.timestamps
    end
  end
end

class CreateCoursesStudents &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :courses_students, id: false do |t|  # NO ID!
      t.references :course, null: false, foreign_key: true
      t.references :student, null: false, foreign_key: true
    end
    # NO timestamps!
    
    add_index :courses_students, [:course_id, :student_id], unique: true
  end
end

# Table naming: alphabetical order!
# courses_students NOT students_courses

# Usage - simple association only
student = Student.create(name: &quot;Alice&quot;)
course = Course.create(name: &quot;Math 101&quot;)

# Add association
student.courses &lt;&lt; course

# Access association
student.courses  # =&gt; [Course]
course.students  # =&gt; [Student]

# Remove association
student.courses.delete(course)

# Cannot add extra attributes!
# No enrollment date, grade, status, etc.
</code></pre>
<hr>
<h3>When to Use Which?</h3>
<p><strong>Use <code>has_many :through</code> when:</strong></p>
<p>✅ Need extra attributes (dates, status, metadata)</p>
<pre><code class="language-ruby"># Need enrollment date, grade
class Enrollment &lt; ApplicationRecord
  belongs_to :student
  belongs_to :course
  
  validates :grade, inclusion: { in: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;F&#39;] }
end
</code></pre>
<p>✅ Need validations on relationship</p>
<pre><code class="language-ruby">class Enrollment &lt; ApplicationRecord
  validates :student_id, uniqueness: { scope: :course_id }
  validate :enrollment_date_cannot_be_in_the_past
end
</code></pre>
<p>✅ Need callbacks</p>
<pre><code class="language-ruby">class Enrollment &lt; ApplicationRecord
  after_create :send_welcome_email
  before_destroy :check_if_course_started
end
</code></pre>
<p>✅ Need to query join records</p>
<pre><code class="language-ruby"># Find all active enrollments
Enrollment.where(status: &#39;active&#39;)

# Find enrollments by date range
Enrollment.where(created_at: 1.month.ago..Date.today)
</code></pre>
<p>✅ Recommended by Rails best practices</p>
<pre><code class="language-ruby"># Modern Rails apps prefer has_many :through
</code></pre>
<p><strong>Use <code>has_and_belongs_to_many</code> when:</strong></p>
<p>❓ Simple many-to-many (no extra data)</p>
<pre><code class="language-ruby"># Tags on posts - just the association
class Post &lt; ApplicationRecord
  has_and_belongs_to_many :tags
end
</code></pre>
<p>❌ But even for simple cases, <code>has_many :through</code> is better:</p>
<pre><code class="language-ruby"># Better: Can add attributes later without migration pain
class Post &lt; ApplicationRecord
  has_many :post_tags
  has_many :tags, through: :post_tags
end

class PostTag &lt; ApplicationRecord
  belongs_to :post
  belongs_to :tag
  # Easy to add: t.integer :order later
end
</code></pre>
<hr>
<h3>Real-World Comparison</h3>
<p><strong>Scenario: Social Network</strong></p>
<p><strong>HABTM (Limited):</strong></p>
<pre><code class="language-ruby"># Can only track friendship, nothing else
class User &lt; ApplicationRecord
  has_and_belongs_to_many :friends,
    class_name: &#39;User&#39;,
    join_table: &#39;friendships&#39;,
    foreign_key: &#39;user_id&#39;,
    association_foreign_key: &#39;friend_id&#39;
end

# Migration
create_table :friendships, id: false do |t|
  t.bigint :user_id
  t.bigint :friend_id
end

# Problems:
# - Can&#39;t track when friendship started
# - Can&#39;t track friendship status (pending, accepted)
# - Can&#39;t add friendship notes
# - Can&#39;t validate uniqueness properly
</code></pre>
<p><strong>has_many :through (Flexible):</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :friendships
  has_many :friends, through: :friendships
end

class Friendship &lt; ApplicationRecord
  belongs_to :user
  belongs_to :friend, class_name: &#39;User&#39;
  
  validates :user_id, uniqueness: { scope: :friend_id }
  validates :status, inclusion: { in: [&#39;pending&#39;, &#39;accepted&#39;, &#39;blocked&#39;] }
  
  scope :accepted, -&gt; { where(status: &#39;accepted&#39;) }
  scope :pending, -&gt; { where(status: &#39;pending&#39;) }
  
  after_create :send_friend_request_notification
end

# Migration
create_table :friendships do |t|
  t.references :user, foreign_key: true
  t.references :friend, foreign_key: { to_table: :users }
  t.string :status, default: &#39;pending&#39;
  t.datetime :accepted_at
  t.text :notes
  t.timestamps
end

# Benefits:
user.friendships.create(friend: other_user, status: &#39;pending&#39;)
user.friendships.accepted
user.friendships.where(&#39;created_at &gt; ?&#39;, 1.week.ago)
</code></pre>
<hr>
<h3>Migration from HABTM to has_many :through</h3>
<p><strong>If you start with HABTM and need to add attributes:</strong></p>
<pre><code class="language-ruby"># Step 1: Create join model
class CreateEnrollments &lt; ActiveRecord::Migration[7.0]
  def change
    # Rename table and add id
    rename_table :courses_students, :enrollments
    
    # Add id column
    add_column :enrollments, :id, :primary_key
    
    # Add timestamps
    add_timestamps :enrollments, default: Time.current
    change_column_default :enrollments, :created_at, from: Time.current, to: nil
    change_column_default :enrollments, :updated_at, from: Time.current, to: nil
    
    # Add new columns
    add_column :enrollments, :grade, :string
    add_column :enrollments, :enrollment_date, :date
  end
end

# Step 2: Create model
class Enrollment &lt; ApplicationRecord
  belongs_to :student
  belongs_to :course
end

# Step 3: Update associations
class Student &lt; ApplicationRecord
  # Remove: has_and_belongs_to_many :courses
  has_many :enrollments
  has_many :courses, through: :enrollments
end

class Course &lt; ApplicationRecord
  # Remove: has_and_belongs_to_many :students
  has_many :enrollments
  has_many :students, through: :enrollments
end
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<p><strong>Both have similar query performance:</strong></p>
<pre><code class="language-ruby"># has_many :through
doctor.patients
# SELECT * FROM patients
# INNER JOIN appointments ON appointments.patient_id = patients.id
# WHERE appointments.doctor_id = 1

# has_and_belongs_to_many
student.courses
# SELECT * FROM courses
# INNER JOIN courses_students ON courses_students.course_id = courses.id
# WHERE courses_students.student_id = 1

# Similar SQL, similar performance
</code></pre>
<p><strong>But <code>has_many :through</code> allows optimization:</strong></p>
<pre><code class="language-ruby"># Can eager load join model
Doctor.includes(appointments: :patient)

# Can add conditions on join
doctor.patients.merge(Appointment.where(status: &#39;scheduled&#39;))

# Can count efficiently
doctor.appointments.count
</code></pre>
<hr>
<h3>Complete Example</h3>
<p><strong>E-commerce: Products and Categories</strong></p>
<pre><code class="language-ruby"># has_many :through (Recommended)
class Product &lt; ApplicationRecord
  has_many :categorizations
  has_many :categories, through: :categorizations
end

class Category &lt; ApplicationRecord
  has_many :categorizations
  has_many :products, through: :categorizations
end

class Categorization &lt; ApplicationRecord
  belongs_to :product
  belongs_to :category
  
  # Extra attributes
  validates :position, numericality: { only_integer: true }
  validates :featured, inclusion: { in: [true, false] }
  
  scope :featured, -&gt; { where(featured: true) }
  scope :ordered, -&gt; { order(:position) }
end

# Migration
class CreateCategorizations &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :categorizations do |t|
      t.references :product, foreign_key: true
      t.references :category, foreign_key: true
      t.integer :position, default: 0
      t.boolean :featured, default: false
      
      t.timestamps
    end
    
    add_index :categorizations, [:product_id, :category_id], unique: true
  end
end

# Usage with rich features
product = Product.create(name: &quot;Laptop&quot;)
category = Category.create(name: &quot;Electronics&quot;)

categorization = product.categorizations.create(
  category: category,
  position: 1,
  featured: true
)

# Query with join model
category.categorizations.featured.ordered
product.categorizations.where(&#39;position &lt; ?&#39;, 5)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>has_many :through</code></strong> uses join model</li>
<li><strong>HABTM</strong> uses join table only</li>
<li><strong><code>:through</code></strong> supports attributes, validations, callbacks</li>
<li><strong>HABTM</strong> is simpler but inflexible</li>
<li><strong>Modern Rails</strong> recommends <code>:through</code></li>
<li><strong>Join table</strong> naming: alphabetical order (HABTM)</li>
<li><strong>Join model</strong> naming: descriptive (<code>:through</code>)</li>
<li><strong>Always use <code>:through</code></strong> unless extremely simple</li>
<li><strong>Migration path</strong> exists from HABTM to <code>:through</code></li>
<li><strong>Performance</strong> is similar for both</li>
</ol>
<hr>
<h2>Question 59: How do you implement polymorphic associations in Rails?</h2>
<h3>Answer</h3>
<p><strong>Polymorphic associations</strong> allow a model to belong to multiple different models using a single association. This is implemented using a type column and an id column.</p>
<hr>
<h3>Basic Polymorphic Association</h3>
<p><strong>Example: Comments on Posts and Photos</strong></p>
<pre><code class="language-ruby"># Models
class Comment &lt; ApplicationRecord
  belongs_to :commentable, polymorphic: true
  belongs_to :user
end

class Post &lt; ApplicationRecord
  has_many :comments, as: :commentable, dependent: :destroy
end

class Photo &lt; ApplicationRecord
  has_many :comments, as: :commentable, dependent: :destroy
end

# Migration
class CreateComments &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :comments do |t|
      t.text :body, null: false
      t.references :user, null: false, foreign_key: true
      
      # Polymorphic columns
      t.references :commentable, polymorphic: true, null: false
      # Creates two columns:
      # - commentable_type (string) - stores &quot;Post&quot; or &quot;Photo&quot;
      # - commentable_id (bigint) - stores the ID
      
      t.timestamps
    end
    
    # Composite index for performance
    add_index :comments, [:commentable_type, :commentable_id]
  end
end

# Manual migration (equivalent)
class CreateComments &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :comments do |t|
      t.text :body
      t.references :user, foreign_key: true
      t.string :commentable_type, null: false
      t.bigint :commentable_id, null: false
      t.timestamps
    end
    
    add_index :comments, [:commentable_type, :commentable_id]
  end
end
</code></pre>
<hr>
<h3>How It Works</h3>
<p><strong>Database structure:</strong></p>
<pre><code>comments table:
+----+------+---------+------------------+----------------+
| id | body | user_id | commentable_type | commentable_id |
+----+------+---------+------------------+----------------+
| 1  | Nice | 1       | Post             | 5              |
| 2  | Cool | 2       | Photo            | 10             |
| 3  | Wow  | 1       | Post             | 7              |
+----+------+---------+------------------+----------------+
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-ruby"># Create comments on different models
post = Post.create(title: &quot;Hello&quot;)
photo = Photo.create(url: &quot;image.jpg&quot;)
user = User.create(name: &quot;John&quot;)

# Comment on post
comment1 = post.comments.create(body: &quot;Great post!&quot;, user: user)
comment1.commentable_type  # =&gt; &quot;Post&quot;
comment1.commentable_id    # =&gt; 5
comment1.commentable       # =&gt; Post object

# Comment on photo
comment2 = photo.comments.create(body: &quot;Nice photo!&quot;, user: user)
comment2.commentable_type  # =&gt; &quot;Photo&quot;
comment2.commentable_id    # =&gt; 10
comment2.commentable       # =&gt; Photo object

# Access from parent
post.comments   # =&gt; [Comment, Comment, ...]
photo.comments  # =&gt; [Comment, Comment, ...]

# Query
Comment.where(commentable_type: &#39;Post&#39;)
Comment.where(commentable: post)
</code></pre>
<hr>
<h3>Complete Polymorphic Example</h3>
<p><strong>Taggable System:</strong></p>
<pre><code class="language-ruby"># Tag model - polymorphic child
class Tag &lt; ApplicationRecord
  belongs_to :taggable, polymorphic: true
  
  validates :name, presence: true
end

# Multiple parent models
class Article &lt; ApplicationRecord
  has_many :tags, as: :taggable, dependent: :destroy
end

class Video &lt; ApplicationRecord
  has_many :tags, as: :taggable, dependent: :destroy
end

class Product &lt; ApplicationRecord
  has_many :tags, as: :taggable, dependent: :destroy
end

# Migration
class CreateTags &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :tags do |t|
      t.string :name, null: false
      t.references :taggable, polymorphic: true, null: false
      
      t.timestamps
    end
    
    add_index :tags, [:taggable_type, :taggable_id]
    add_index :tags, [:name, :taggable_type, :taggable_id], unique: true
  end
end

# Usage
article = Article.create(title: &quot;Rails Guide&quot;)
video = Video.create(title: &quot;Ruby Tutorial&quot;)

article.tags.create(name: &quot;ruby&quot;)
article.tags.create(name: &quot;rails&quot;)

video.tags.create(name: &quot;ruby&quot;)
video.tags.create(name: &quot;tutorial&quot;)

# Query
article.tags.pluck(:name)  # =&gt; [&quot;ruby&quot;, &quot;rails&quot;]
Tag.where(taggable_type: &#39;Article&#39;)
Tag.where(name: &#39;ruby&#39;)    # Tags across all models
</code></pre>
<hr>
<h3>Advanced: Multiple Polymorphic Associations</h3>
<p><strong>Likes system with polymorphic user and likeable:</strong></p>
<pre><code class="language-ruby">class Like &lt; ApplicationRecord
  belongs_to :user
  belongs_to :likeable, polymorphic: true
  
  validates :user_id, uniqueness: { scope: [:likeable_type, :likeable_id] }
end

class Post &lt; ApplicationRecord
  has_many :likes, as: :likeable
  has_many :likers, through: :likes, source: :user
end

class Comment &lt; ApplicationRecord
  has_many :likes, as: :likeable
  has_many :likers, through: :likes, source: :user
end

class Photo &lt; ApplicationRecord
  has_many :likes, as: :likeable
  has_many :likers, through: :likes, source: :user
end

# Migration
class CreateLikes &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :likes do |t|
      t.references :user, null: false, foreign_key: true
      t.references :likeable, polymorphic: true, null: false
      
      t.timestamps
    end
    
    add_index :likes, [:user_id, :likeable_type, :likeable_id], 
              unique: true, name: &#39;unique_user_likes&#39;
  end
end

# Usage
user = User.create(name: &quot;Alice&quot;)
post = Post.create(title: &quot;Hello&quot;)
comment = Comment.create(body: &quot;Nice!&quot;)

# Like different things
user.likes.create(likeable: post)
user.likes.create(likeable: comment)

# Check if liked
post.likers.include?(user)
user.likes.exists?(likeable: post)

# Count likes
post.likes.count
</code></pre>
<hr>
<h3>Polymorphic with STI (Single Table Inheritance)</h3>
<p><strong>Special consideration:</strong></p>
<pre><code class="language-ruby">class Vehicle &lt; ApplicationRecord
  has_many :parts, as: :partable
end

class Car &lt; Vehicle
end

class Motorcycle &lt; Vehicle
end

class Part &lt; ApplicationRecord
  belongs_to :partable, polymorphic: true
end

# Problem: partable_type will be &quot;Car&quot; or &quot;Motorcycle&quot;
# Not &quot;Vehicle&quot;

car = Car.create
car.parts.create(name: &quot;Wheel&quot;)

part = Part.last
part.partable_type  # =&gt; &quot;Car&quot; (not &quot;Vehicle&quot;)

# Solution: Store base class
class Part &lt; ApplicationRecord
  belongs_to :partable, polymorphic: true
  
  before_validation :set_base_class_type
  
  private
  
  def set_base_class_type
    self.partable_type = partable.class.base_class.name if partable
  end
end
</code></pre>
<hr>
<h3>Querying Polymorphic Associations</h3>
<p><strong>Eager loading:</strong></p>
<pre><code class="language-ruby"># N+1 query problem
comments = Comment.all
comments.each do |comment|
  puts comment.commentable.title  # N+1!
end

# Solution 1: includes (works but not ideal for polymorphic)
comments = Comment.includes(:commentable).all
# Still performs separate queries for each type

# Solution 2: Manual eager loading
comments = Comment.all
post_ids = comments.where(commentable_type: &#39;Post&#39;).pluck(:commentable_id)
photo_ids = comments.where(commentable_type: &#39;Photo&#39;).pluck(:commentable_id)

posts = Post.where(id: post_ids).index_by(&amp;:id)
photos = Photo.where(id: photo_ids).index_by(&amp;:id)

comments.each do |comment|
  commentable = if comment.commentable_type == &#39;Post&#39;
    posts[comment.commentable_id]
  else
    photos[comment.commentable_id]
  end
end
</code></pre>
<p><strong>Filtering by type:</strong></p>
<pre><code class="language-ruby"># All comments on posts
Comment.where(commentable_type: &#39;Post&#39;)

# All comments on specific post
Comment.where(commentable: post)
Comment.where(commentable_type: &#39;Post&#39;, commentable_id: post.id)

# Count by type
Comment.group(:commentable_type).count
# =&gt; {&quot;Post&quot; =&gt; 10, &quot;Photo&quot; =&gt; 5}

# Join with specific type
Comment.joins(&quot;INNER JOIN posts ON posts.id = comments.commentable_id&quot;)
       .where(commentable_type: &#39;Post&#39;)
       .where(posts: { published: true })
</code></pre>
<hr>
<h3>Polymorphic Concerns</h3>
<p><strong>Reusable polymorphic behavior:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/commentable.rb
module Commentable
  extend ActiveSupport::Concern
  
  included do
    has_many :comments, as: :commentable, dependent: :destroy
  end
  
  def comments_count
    comments.count
  end
  
  def commented_by?(user)
    comments.exists?(user: user)
  end
end

# Usage in models
class Post &lt; ApplicationRecord
  include Commentable
end

class Photo &lt; ApplicationRecord
  include Commentable
end

class Video &lt; ApplicationRecord
  include Commentable
end

# Now all have comments association and methods
post.comments_count
photo.commented_by?(user)
</code></pre>
<hr>
<h3>Real-World Example: Activity Feed</h3>
<pre><code class="language-ruby"># Activity model - polymorphic
class Activity &lt; ApplicationRecord
  belongs_to :actor, class_name: &#39;User&#39;
  belongs_to :trackable, polymorphic: true
  
  scope :recent, -&gt; { order(created_at: :desc).limit(20) }
end

# Trackable models
class Post &lt; ApplicationRecord
  has_many :activities, as: :trackable
  
  after_create :create_activity
  
  private
  
  def create_activity
    activities.create(
      actor: user,
      action: &#39;created_post&#39;
    )
  end
end

class Comment &lt; ApplicationRecord
  has_many :activities, as: :trackable
  
  after_create :create_activity
  
  private
  
  def create_activity
    activities.create(
      actor: user,
      action: &#39;created_comment&#39;
    )
  end
end

class Like &lt; ApplicationRecord
  has_many :activities, as: :trackable
  
  after_create :create_activity
  
  private
  
  def create_activity
    activities.create(
      actor: user,
      action: &#39;liked_item&#39;
    )
  end
end

# Migration
class CreateActivities &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :activities do |t|
      t.references :actor, foreign_key: { to_table: :users }
      t.references :trackable, polymorphic: true
      t.string :action
      
      t.timestamps
    end
    
    add_index :activities, [:trackable_type, :trackable_id]
    add_index :activities, :created_at
  end
end

# Usage - activity feed
recent_activities = Activity.recent.includes(:actor, :trackable)

recent_activities.each do |activity|
  case activity.trackable_type
  when &#39;Post&#39;
    &quot;#{activity.actor.name} created a post: #{activity.trackable.title}&quot;
  when &#39;Comment&#39;
    &quot;#{activity.actor.name} commented: #{activity.trackable.body}&quot;
  when &#39;Like&#39;
    &quot;#{activity.actor.name} liked something&quot;
  end
end
</code></pre>
<hr>
<h3>Performance Optimization</h3>
<p><strong>Counter caches with polymorphic:</strong></p>
<pre><code class="language-ruby">class Comment &lt; ApplicationRecord
  belongs_to :commentable, polymorphic: true, counter_cache: true
end

# Add counter columns to each parent
class AddCommentsCountToPosts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :posts, :comments_count, :integer, default: 0
    add_column :photos, :comments_count, :integer, default: 0
    
    # Backfill existing counts
    Post.find_each do |post|
      Post.reset_counters(post.id, :comments)
    end
    
    Photo.find_each do |photo|
      Photo.reset_counters(photo.id, :comments)
    end
  end
end

# Now you can:
post.comments_count  # No database query!
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Polymorphic</strong> = one model belongs to multiple models</li>
<li><strong>Two columns</strong>: <code>type</code> (string) and <code>id</code> (bigint)</li>
<li><strong>Use <code>polymorphic: true</code></strong> in belongs_to</li>
<li><strong>Use <code>as: :name</code></strong> in has_many</li>
<li><strong>Index</strong> both type and id columns</li>
<li><strong>Type stores</strong> model class name as string</li>
<li><strong>Concerns</strong> for reusable polymorphic behavior</li>
<li><strong>Eager loading</strong> more complex with polymorphic</li>
<li><strong>Counter caches</strong> need columns on each parent</li>
<li><strong>Great for</strong> comments, tags, likes, activities</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 60: What is Single Table Inheritance (STI) in Rails?</h2>
<h3>Answer</h3>
<p><strong>Single Table Inheritance (STI)</strong> is a pattern where multiple models inherit from a base model and share the same database table. Rails uses a <code>type</code> column to distinguish between different subclasses.</p>
<hr>
<h3>How STI Works</h3>
<p><strong>One table stores multiple types:</strong></p>
<pre><code>vehicles table:
+----+------+-------+-----------+------------+
| id | type | name  | doors     | cargo_cap  |
+----+------+-------+-----------+------------+
| 1  | Car  | Civic | 4         | NULL       |
| 2  | Truck| F-150 | 2         | 1000       |
| 3  | Car  | Camry | 4         | NULL       |
+----+------+-------+-----------+------------+

type column determines which model:
- &quot;Car&quot; → Car model
- &quot;Truck&quot; → Truck model
</code></pre>
<hr>
<h3>Basic STI Implementation</h3>
<pre><code class="language-ruby"># Base model
class Vehicle &lt; ApplicationRecord
  # Shared attributes and methods
  validates :name, presence: true
  
  def display_name
    &quot;#{type}: #{name}&quot;
  end
end

# Subclasses
class Car &lt; Vehicle
  # Car-specific methods
  validates :doors, presence: true
  
  def passenger_capacity
    doors == 2 ? 2 : 5
  end
end

class Truck &lt; Vehicle
  # Truck-specific methods
  validates :cargo_capacity, presence: true
  
  def can_haul?(weight)
    weight &lt;= cargo_capacity
  end
end

class Motorcycle &lt; Vehicle
  def passenger_capacity
    2
  end
end

# Migration - Single table for all types
class CreateVehicles &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :vehicles do |t|
      t.string :type, null: false  # STI discriminator column
      t.string :name, null: false
      
      # Car-specific
      t.integer :doors
      
      # Truck-specific
      t.integer :cargo_capacity
      
      # Shared
      t.string :color
      t.integer :year
      
      t.timestamps
    end
    
    add_index :vehicles, :type
  end
end

# Usage
car = Car.create(name: &quot;Civic&quot;, doors: 4, color: &quot;Blue&quot;)
truck = Truck.create(name: &quot;F-150&quot;, cargo_capacity: 1000)
motorcycle = Motorcycle.create(name: &quot;Harley&quot;)

car.type  # =&gt; &quot;Car&quot;
truck.type  # =&gt; &quot;Truck&quot;

# Queries
Car.all         # SELECT * FROM vehicles WHERE type = &#39;Car&#39;
Truck.all       # SELECT * FROM vehicles WHERE type = &#39;Truck&#39;
Vehicle.all     # SELECT * FROM vehicles (all types)

# Type checking
car.is_a?(Car)      # =&gt; true
car.is_a?(Vehicle)  # =&gt; true
car.class           # =&gt; Car
</code></pre>
<hr>
<h3>When to Use STI</h3>
<p><strong>Good use cases:</strong></p>
<p>✅ <strong>Similar models with slight differences:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
end

class Admin &lt; User
  def can_delete_users?
    true
  end
end

class Moderator &lt; User
  def can_moderate?
    true
  end
end

class Guest &lt; User
  def limited_access?
    true
  end
end
</code></pre>
<p>✅ <strong>Shared behavior with type-specific methods:</strong></p>
<pre><code class="language-ruby">class Animal &lt; ApplicationRecord
  def make_sound
    raise NotImplementedError
  end
end

class Dog &lt; Animal
  def make_sound
    &quot;Woof!&quot;
  end
end

class Cat &lt; Animal
  def make_sound
    &quot;Meow!&quot;
  end
end
</code></pre>
<p>✅ <strong>Few type-specific attributes:</strong></p>
<pre><code class="language-ruby"># Most columns shared, few differences
class Product &lt; ApplicationRecord
  validates :name, :price, presence: true
end

class DigitalProduct &lt; Product
  validates :download_url, presence: true
end

class PhysicalProduct &lt; Product
  validates :weight, :dimensions, presence: true
end
</code></pre>
<hr>
<h3>When NOT to Use STI</h3>
<p><strong>Avoid STI when:</strong></p>
<p>❌ <strong>Many NULL columns:</strong></p>
<pre><code class="language-ruby"># Bad - lots of unused columns per type
class Content &lt; ApplicationRecord
  # 20 video-specific columns (NULL for articles)
  # 15 article-specific columns (NULL for videos)
  # 10 podcast-specific columns (NULL for others)
end

# Better - separate tables
class Article &lt; ApplicationRecord
end

class Video &lt; ApplicationRecord
end

class Podcast &lt; ApplicationRecord
end
</code></pre>
<p>❌ <strong>Very different models:</strong></p>
<pre><code class="language-ruby"># Bad - too different
class Item &lt; ApplicationRecord
end

class Car &lt; Item  # Has: doors, engine_type, fuel_type
end

class Book &lt; Item  # Has: author, isbn, pages
end

class Food &lt; Item  # Has: calories, expiry_date, ingredients
end

# Better - separate tables or polymorphic
</code></pre>
<p>❌ <strong>Performance concerns with large tables:</strong></p>
<pre><code class="language-ruby"># STI creates one huge table
# Queries always scan type column
# Better to separate if tables get large
</code></pre>
<hr>
<h3>Complete STI Example</h3>
<p><strong>Employee management system:</strong></p>
<pre><code class="language-ruby"># Base model
class Employee &lt; ApplicationRecord
  validates :name, :email, presence: true
  validates :email, uniqueness: true
  
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
  
  def display_role
    type.underscore.humanize
  end
end

# Subclasses
class Manager &lt; Employee
  has_many :direct_reports, 
           class_name: &#39;Employee&#39;,
           foreign_key: &#39;manager_id&#39;
  
  validates :department, presence: true
  
  def team_size
    direct_reports.count
  end
end

class Developer &lt; Employee
  validates :programming_languages, presence: true
  
  def senior?
    years_of_experience &gt;= 5
  end
  
  def can_review_code?
    senior?
  end
end

class Designer &lt; Employee
  validates :design_tools, presence: true
  
  def portfolio_url
    &quot;https://portfolio.example.com/#{id}&quot;
  end
end

class Intern &lt; Employee
  belongs_to :mentor, class_name: &#39;Employee&#39;, optional: true
  
  validates :school, :graduation_date, presence: true
  
  def days_until_graduation
    (graduation_date - Date.today).to_i
  end
end

# Migration
class CreateEmployees &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :employees do |t|
      # STI column
      t.string :type, null: false
      
      # Shared columns
      t.string :first_name, null: false
      t.string :last_name, null: false
      t.string :email, null: false
      t.date :hire_date
      t.decimal :salary, precision: 10, scale: 2
      
      # Manager-specific
      t.string :department
      t.references :manager, foreign_key: { to_table: :employees }
      
      # Developer-specific
      t.text :programming_languages
      t.integer :years_of_experience
      
      # Designer-specific
      t.text :design_tools
      
      # Intern-specific
      t.string :school
      t.date :graduation_date
      t.references :mentor, foreign_key: { to_table: :employees }
      
      t.timestamps
    end
    
    add_index :employees, :type
    add_index :employees, :email, unique: true
  end
end

# Usage
manager = Manager.create(
  first_name: &quot;John&quot;,
  last_name: &quot;Smith&quot;,
  email: &quot;john@example.com&quot;,
  department: &quot;Engineering&quot;
)

developer = Developer.create(
  first_name: &quot;Jane&quot;,
  last_name: &quot;Doe&quot;,
  email: &quot;jane@example.com&quot;,
  programming_languages: &quot;Ruby, JavaScript&quot;,
  years_of_experience: 6,
  manager: manager
)

intern = Intern.create(
  first_name: &quot;Bob&quot;,
  last_name: &quot;Wilson&quot;,
  email: &quot;bob@example.com&quot;,
  school: &quot;MIT&quot;,
  graduation_date: 6.months.from_now,
  mentor: developer
)

# Queries
Manager.all
Developer.where(years_of_experience: 5..)
Intern.where(&quot;graduation_date &lt; ?&quot;, 3.months.from_now)

manager.direct_reports  # =&gt; [Developer, Intern, ...]
developer.senior?       # =&gt; true
intern.mentor           # =&gt; Developer object
</code></pre>
<hr>
<h3>Customizing STI</h3>
<p><strong>Custom type column name:</strong></p>
<pre><code class="language-ruby">class Vehicle &lt; ApplicationRecord
  self.inheritance_column = &#39;vehicle_type&#39;  # Instead of &#39;type&#39;
end

# Migration
create_table :vehicles do |t|
  t.string :vehicle_type, null: false
  # ...
end
</code></pre>
<p><strong>Disable STI:</strong></p>
<pre><code class="language-ruby">class Vehicle &lt; ApplicationRecord
  self.inheritance_column = nil  # Disable STI
  # Now &#39;type&#39; is just a regular column
end
</code></pre>
<p><strong>Store subclass in module:</strong></p>
<pre><code class="language-ruby">module Vehicles
  class Car &lt; ::Vehicle
  end
end

# Type column stores: &quot;Vehicles::Car&quot;
</code></pre>
<hr>
<h3>Querying STI</h3>
<p><strong>Type-specific queries:</strong></p>
<pre><code class="language-ruby"># All cars
Car.all
# SELECT * FROM vehicles WHERE type = &#39;Car&#39;

# All vehicles
Vehicle.all
# SELECT * FROM vehicles

# Specific subclass
Vehicle.where(type: &#39;Car&#39;)
Car.all  # Same result

# Multiple types
Vehicle.where(type: [&#39;Car&#39;, &#39;Truck&#39;])

# Excluding types
Vehicle.where.not(type: &#39;Motorcycle&#39;)

# Joins with STI
User.joins(:vehicle).where(vehicles: { type: &#39;Car&#39; })

# Count by type
Vehicle.group(:type).count
# =&gt; {&quot;Car&quot; =&gt; 10, &quot;Truck&quot; =&gt; 5, &quot;Motorcycle&quot; =&gt; 3}
</code></pre>
<hr>
<h3>STI with Associations</h3>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :vehicles
  has_many :cars
  has_many :trucks
end

class Vehicle &lt; ApplicationRecord
  belongs_to :user
end

class Car &lt; Vehicle
end

class Truck &lt; Vehicle
end

# Usage
user = User.first
user.vehicles  # All vehicle types
user.cars      # Only cars
user.trucks    # Only trucks

# Create through association
user.cars.create(name: &quot;Civic&quot;, doors: 4)
user.trucks.create(name: &quot;F-150&quot;, cargo_capacity: 1000)
</code></pre>
<hr>
<h3>STI Best Practices</h3>
<p><strong>1. Keep shared columns:</strong></p>
<pre><code class="language-ruby"># Good - most columns shared
class Product &lt; ApplicationRecord
  # Shared: name, price, description, image_url
end

class DigitalProduct &lt; Product
  # Adds: download_url
end

class PhysicalProduct &lt; Product
  # Adds: weight, dimensions
end
</code></pre>
<p><strong>2. Use scopes for common queries:</strong></p>
<pre><code class="language-ruby">class Employee &lt; ApplicationRecord
  scope :active, -&gt; { where(active: true) }
  scope :hired_after, -&gt;(date) { where(&#39;hire_date &gt; ?&#39;, date) }
end

class Developer &lt; Employee
  scope :senior, -&gt; { where(&#39;years_of_experience &gt;= ?&#39;, 5) }
  scope :knows_language, -&gt;(lang) {
    where(&quot;programming_languages LIKE ?&quot;, &quot;%#{lang}%&quot;)
  }
end

# Usage
Developer.senior.active
Developer.knows_language(&#39;Ruby&#39;).hired_after(1.year.ago)
</code></pre>
<p><strong>3. Validate type-specific attributes:</strong></p>
<pre><code class="language-ruby">class Employee &lt; ApplicationRecord
  # Don&#39;t validate subclass-specific columns in base class
end

class Manager &lt; Employee
  validates :department, presence: true  # Only for managers
end

class Developer &lt; Employee
  validates :programming_languages, presence: true  # Only for developers
end
</code></pre>
<p><strong>4. Handle NULL columns gracefully:</strong></p>
<pre><code class="language-ruby">class Vehicle &lt; ApplicationRecord
  def doors_display
    doors.present? ? &quot;#{doors} doors&quot; : &quot;N/A&quot;
  end
  
  def cargo_capacity_display
    cargo_capacity.present? ? &quot;#{cargo_capacity} lbs&quot; : &quot;N/A&quot;
  end
end
</code></pre>
<hr>
<h3>Alternatives to STI</h3>
<p><strong>1. Polymorphic associations:</strong></p>
<pre><code class="language-ruby"># Instead of STI, use polymorphic
class Comment &lt; ApplicationRecord
  belongs_to :commentable, polymorphic: true
end

class Post &lt; ApplicationRecord
  has_many :comments, as: :commentable
end

class Photo &lt; ApplicationRecord
  has_many :comments, as: :commentable
end
</code></pre>
<p><strong>2. Separate tables:</strong></p>
<pre><code class="language-ruby"># Each type has its own table
class Car &lt; ApplicationRecord
end

class Truck &lt; ApplicationRecord
end

class Motorcycle &lt; ApplicationRecord
end
</code></pre>
<p><strong>3. Delegation pattern:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_one :role
  delegate :can_delete?, :can_moderate?, to: :role
end

class Role &lt; ApplicationRecord
  belongs_to :user
end

class AdminRole &lt; Role
  def can_delete?
    true
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>STI</strong> stores multiple models in one table</li>
<li><strong><code>type</code> column</strong> discriminates between models</li>
<li><strong>Inheritance</strong> provides shared behavior</li>
<li><strong>Good for</strong> similar models with slight differences</li>
<li><strong>Avoid when</strong> many NULL columns</li>
<li><strong>Index</strong> the type column</li>
<li><strong>Queries</strong> automatically filter by type</li>
<li><strong>Associations</strong> work with STI</li>
<li><strong>Can customize</strong> inheritance column name</li>
<li><strong>Consider alternatives</strong> if models too different</li>
</ol>
<hr>
<h2>Question 61: What is a self-join in SQL?</h2>
<h3>Answer</h3>
<p>A <strong>self-join</strong> is when a table is joined to itself, typically used to model hierarchical or network relationships within the same model. In Rails, this is implemented using associations that reference the same model.</p>
<hr>
<h3>Basic Self-Join Concept</h3>
<p><strong>SQL Example:</strong></p>
<pre><code class="language-sql">-- employees table
+----+-------+------------+
| id | name  | manager_id |
+----+-------+------------+
| 1  | CEO   | NULL       |
| 2  | VP    | 1          |
| 3  | Dev   | 2          |
| 4  | QA    | 2          |
+----+-------+------------+

-- Self-join query
SELECT 
  e.name AS employee,
  m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;

Result:
+-----------+---------+
| employee  | manager |
+-----------+---------+
| CEO       | NULL    |
| VP        | CEO     |
| Dev       | VP      |
| QA        | VP      |
+-----------+---------+
</code></pre>
<hr>
<h3>Rails Implementation</h3>
<p><strong>1. Employee-Manager Relationship:</strong></p>
<pre><code class="language-ruby"># Model
class Employee &lt; ApplicationRecord
  # Manager association (belongs_to)
  belongs_to :manager, 
             class_name: &#39;Employee&#39;,
             optional: true
  
  # Subordinates association (has_many)
  has_many :subordinates,
           class_name: &#39;Employee&#39;,
           foreign_key: &#39;manager_id&#39;
end

# Migration
class CreateEmployees &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :employees do |t|
      t.string :name, null: false
      t.string :title
      t.references :manager, foreign_key: { to_table: :employees }
      
      t.timestamps
    end
  end
end

# Usage
ceo = Employee.create(name: &quot;John&quot;, title: &quot;CEO&quot;)
vp = Employee.create(name: &quot;Jane&quot;, title: &quot;VP&quot;, manager: ceo)
dev = Employee.create(name: &quot;Bob&quot;, title: &quot;Developer&quot;, manager: vp)
qa = Employee.create(name: &quot;Alice&quot;, title: &quot;QA&quot;, manager: vp)

# Navigate up
dev.manager          # =&gt; VP
dev.manager.manager  # =&gt; CEO

# Navigate down
ceo.subordinates     # =&gt; [VP]
vp.subordinates      # =&gt; [Developer, QA]

# Check relationships
dev.manager == vp    # =&gt; true
vp.subordinates.include?(dev)  # =&gt; true
</code></pre>
<hr>
<h3>2. Social Network (Friendships)</h3>
<p><strong>Bidirectional friendship:</strong></p>
<pre><code class="language-ruby"># Model
class User &lt; ApplicationRecord
  # Outgoing friendships
  has_many :friendships, foreign_key: &#39;user_id&#39;
  has_many :friends, through: :friendships
  
  # Incoming friendships
  has_many :inverse_friendships, 
           class_name: &#39;Friendship&#39;,
           foreign_key: &#39;friend_id&#39;
  has_many :inverse_friends,
           through: :inverse_friendships,
           source: :user
  
  # All friends (both directions)
  def all_friends
    friends + inverse_friends
  end
end

class Friendship &lt; ApplicationRecord
  belongs_to :user
  belongs_to :friend, class_name: &#39;User&#39;
  
  validates :user_id, uniqueness: { scope: :friend_id }
  validate :not_self_friendship
  
  private
  
  def not_self_friendship
    errors.add(:friend, &quot;can&#39;t be yourself&quot;) if user_id == friend_id
  end
end

# Migration
class CreateFriendships &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :friendships do |t|
      t.references :user, null: false, foreign_key: true
      t.references :friend, null: false, foreign_key: { to_table: :users }
      
      t.timestamps
    end
    
    add_index :friendships, [:user_id, :friend_id], unique: true
  end
end

# Usage
alice = User.create(name: &quot;Alice&quot;)
bob = User.create(name: &quot;Bob&quot;)
charlie = User.create(name: &quot;Charlie&quot;)

# Create friendship
alice.friendships.create(friend: bob)
bob.friendships.create(friend: charlie)

# Alice&#39;s friends
alice.friends          # =&gt; [Bob]
alice.inverse_friends  # =&gt; [] (no one friended Alice)

# Bob&#39;s friends
bob.friends           # =&gt; [Charlie]
bob.inverse_friends   # =&gt; [Alice]
bob.all_friends       # =&gt; [Charlie, Alice]
</code></pre>
<hr>
<h3>3. Hierarchical Categories</h3>
<p><strong>Tree structure:</strong></p>
<pre><code class="language-ruby"># Model
class Category &lt; ApplicationRecord
  # Parent association
  belongs_to :parent, 
             class_name: &#39;Category&#39;,
             optional: true
  
  # Children association
  has_many :children,
           class_name: &#39;Category&#39;,
           foreign_key: &#39;parent_id&#39;
  
  # Get all ancestors (recursive)
  def ancestors
    return [] unless parent
    [parent] + parent.ancestors
  end
  
  # Get all descendants (recursive)
  def descendants
    children + children.flat_map(&amp;:descendants)
  end
  
  # Root?
  def root?
    parent_id.nil?
  end
  
  # Leaf?
  def leaf?
    children.empty?
  end
  
  # Level in hierarchy
  def level
    ancestors.count
  end
end

# Migration
class CreateCategories &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :categories do |t|
      t.string :name, null: false
      t.references :parent, foreign_key: { to_table: :categories }
      
      t.timestamps
    end
  end
end

# Usage - build tree
electronics = Category.create(name: &quot;Electronics&quot;)
computers = Category.create(name: &quot;Computers&quot;, parent: electronics)
laptops = Category.create(name: &quot;Laptops&quot;, parent: computers)
desktops = Category.create(name: &quot;Desktops&quot;, parent: computers)

# Navigate tree
laptops.parent              # =&gt; Computers
laptops.parent.parent       # =&gt; Electronics
laptops.ancestors           # =&gt; [Computers, Electronics]

electronics.children        # =&gt; [Computers]
electronics.descendants     # =&gt; [Computers, Laptops, Desktops]

computers.root?             # =&gt; false
electronics.root?           # =&gt; true
laptops.leaf?               # =&gt; true
computers.leaf?             # =&gt; false

laptops.level               # =&gt; 2
</code></pre>
<hr>
<h3>4. Comment Threading (Nested Comments)</h3>
<p><strong>Reddit-style comment threads:</strong></p>
<pre><code class="language-ruby"># Model
class Comment &lt; ApplicationRecord
  belongs_to :post
  belongs_to :user
  
  # Parent comment
  belongs_to :parent_comment,
             class_name: &#39;Comment&#39;,
             optional: true
  
  # Replies
  has_many :replies,
           class_name: &#39;Comment&#39;,
           foreign_key: &#39;parent_comment_id&#39;,
           dependent: :destroy
  
  # Validation
  validate :same_post_as_parent
  
  # Top-level comments
  scope :top_level, -&gt; { where(parent_comment_id: nil) }
  
  def top_level?
    parent_comment_id.nil?
  end
  
  def thread_depth
    parent_comment ? 1 + parent_comment.thread_depth : 0
  end
  
  private
  
  def same_post_as_parent
    if parent_comment &amp;&amp; parent_comment.post_id != post_id
      errors.add(:parent_comment, &quot;must be in the same post&quot;)
    end
  end
end

# Migration
class CreateComments &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :comments do |t|
      t.references :post, null: false, foreign_key: true
      t.references :user, null: false, foreign_key: true
      t.references :parent_comment, foreign_key: { to_table: :comments }
      t.text :body, null: false
      
      t.timestamps
    end
  end
end

# Usage
post = Post.create(title: &quot;Hello&quot;)
user = User.create(name: &quot;Alice&quot;)

# Top-level comment
comment1 = post.comments.create(
  user: user,
  body: &quot;Great post!&quot;
)

# Reply to comment
reply1 = Comment.create(
  post: post,
  user: user,
  parent_comment: comment1,
  body: &quot;Thanks!&quot;
)

# Reply to reply
reply2 = Comment.create(
  post: post,
  user: user,
  parent_comment: reply1,
  body: &quot;You&#39;re welcome!&quot;
)

# Navigate
comment1.replies              # =&gt; [reply1]
reply1.parent_comment         # =&gt; comment1
reply1.replies                # =&gt; [reply2]

# Query top-level
post.comments.top_level       # =&gt; [comment1]

# Check depth
comment1.thread_depth         # =&gt; 0
reply1.thread_depth           # =&gt; 1
reply2.thread_depth           # =&gt; 2
</code></pre>
<hr>
<h3>5. Product Recommendations</h3>
<p><strong>Related products:</strong></p>
<pre><code class="language-ruby"># Model
class Product &lt; ApplicationRecord
  has_many :product_recommendations, foreign_key: &#39;product_id&#39;
  has_many :recommended_products,
           through: :product_recommendations,
           source: :recommended_product
  
  has_many :inverse_recommendations,
           class_name: &#39;ProductRecommendation&#39;,
           foreign_key: &#39;recommended_product_id&#39;
  has_many :recommended_by_products,
           through: :inverse_recommendations,
           source: :product
end

class ProductRecommendation &lt; ApplicationRecord
  belongs_to :product
  belongs_to :recommended_product, class_name: &#39;Product&#39;
  
  validates :product_id, uniqueness: { scope: :recommended_product_id }
  validate :not_self_recommendation
  
  private
  
  def not_self_recommendation
    if product_id == recommended_product_id
      errors.add(:recommended_product, &quot;can&#39;t be the same product&quot;)
    end
  end
end

# Migration
class CreateProductRecommendations &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :product_recommendations do |t|
      t.references :product, null: false, foreign_key: true
      t.references :recommended_product, 
                   null: false,
                   foreign_key: { to_table: :products }
      t.integer :score, default: 0
      
      t.timestamps
    end
    
    add_index :product_recommendations, 
              [:product_id, :recommended_product_id],
              unique: true,
              name: &#39;unique_product_recommendations&#39;
  end
end

# Usage
laptop = Product.create(name: &quot;Laptop&quot;)
mouse = Product.create(name: &quot;Mouse&quot;)
keyboard = Product.create(name: &quot;Keyboard&quot;)

laptop.product_recommendations.create(
  recommended_product: mouse,
  score: 10
)

laptop.product_recommendations.create(
  recommended_product: keyboard,
  score: 8
)

laptop.recommended_products  # =&gt; [Mouse, Keyboard]
mouse.recommended_by_products  # =&gt; [Laptop]
</code></pre>
<hr>
<h3>Querying Self-Joins</h3>
<p><strong>Complex queries:</strong></p>
<pre><code class="language-ruby"># Find all employees under a specific manager (including sub-levels)
class Employee &lt; ApplicationRecord
  def self.under_manager(manager)
    where(manager_id: manager.id)
      .or(where(manager_id: manager.subordinates.pluck(:id)))
  end
  
  # Recursive query with CTE (Common Table Expression)
  def self.all_under_manager(manager_id)
    query = &lt;&lt;-SQL
      WITH RECURSIVE subordinates AS (
        SELECT id, name, manager_id
        FROM employees
        WHERE id = ?
        
        UNION ALL
        
        SELECT e.id, e.name, e.manager_id
        FROM employees e
        INNER JOIN subordinates s ON e.manager_id = s.id
      )
      SELECT * FROM subordinates WHERE id != ?
    SQL
    
    find_by_sql([query, manager_id, manager_id])
  end
end

# Usage
manager = Employee.find_by(name: &quot;VP&quot;)
Employee.all_under_manager(manager.id)
# Returns all employees under VP at any level
</code></pre>
<hr>
<h3>Performance Optimization</h3>
<p><strong>1. Eager loading:</strong></p>
<pre><code class="language-ruby"># N+1 problem
employees = Employee.all
employees.each do |emp|
  puts emp.manager.name  # N+1!
end

# Solution
employees = Employee.includes(:manager)
employees.each do |emp|
  puts emp.manager&amp;.name  # Efficient
end
</code></pre>
<p><strong>2. Counter caches:</strong></p>
<pre><code class="language-ruby">class Employee &lt; ApplicationRecord
  belongs_to :manager,
             class_name: &#39;Employee&#39;,
             counter_cache: :subordinates_count,
             optional: true
  
  has_many :subordinates,
           class_name: &#39;Employee&#39;,
           foreign_key: &#39;manager_id&#39;
end

# Migration
add_column :employees, :subordinates_count, :integer, default: 0

# Usage
manager.subordinates_count  # No query!
</code></pre>
<p><strong>3. Materialized paths (for deep hierarchies):</strong></p>
<pre><code class="language-ruby">class Category &lt; ApplicationRecord
  # Store full path: &quot;Electronics/Computers/Laptops&quot;
  before_save :set_path
  
  def set_path
    self.path = parent ? &quot;#{parent.path}/#{name}&quot; : name
  end
  
  def self.under_path(path)
    where(&quot;path LIKE ?&quot;, &quot;#{path}%&quot;)
  end
end

# Much faster than recursive queries for deep trees
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Self-join</strong> joins table to itself</li>
<li><strong>Uses</strong> <code>class_name</code> option in associations</li>
<li><strong>Foreign key</strong> references same table</li>
<li><strong>Common uses</strong>: hierarchies, friendships, recommendations</li>
<li><strong>Two directions</strong>: parent/child, friend/friend</li>
<li><strong>Recursive queries</strong> for deep trees</li>
<li><strong>Watch for</strong> N+1 queries</li>
<li><strong>Validate</strong> to prevent self-reference</li>
<li><strong>Index</strong> foreign keys</li>
<li><strong>Consider</strong> counter caches for performance</li>
</ol>
<h1>ActiveRecord Querying Interview Questions</h1>
<h2>Question 62: What is the difference between <code>include</code> vs <code>joins</code> vs <code>preload</code>?</h2>
<h3>Answer</h3>
<p>All three methods deal with associations, but they use different strategies: <strong><code>includes</code></strong> is smart eager loading, <strong><code>joins</code></strong> creates SQL JOINs without loading associated records, and <strong><code>preload</code></strong> always uses separate queries.</p>
<hr>
<h3>Quick Comparison Table</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>SQL Strategy</th>
<th>Loads Associated Records</th>
<th>N+1 Prevention</th>
<th>Filtering on Association</th>
</tr>
</thead>
<tbody><tr>
<td><code>includes</code></td>
<td>Adaptive (JOIN or separate)</td>
<td>✅ Yes</td>
<td>✅ Yes</td>
<td>✅ Yes (with references)</td>
</tr>
<tr>
<td><code>joins</code></td>
<td>INNER JOIN</td>
<td>❌ No</td>
<td>❌ No</td>
<td>✅ Yes</td>
</tr>
<tr>
<td><code>preload</code></td>
<td>Separate queries</td>
<td>✅ Yes</td>
<td>✅ Yes</td>
<td>❌ No</td>
</tr>
<tr>
<td><code>eager_load</code></td>
<td>LEFT OUTER JOIN</td>
<td>✅ Yes</td>
<td>✅ Yes</td>
<td>✅ Yes</td>
</tr>
</tbody></table>
<hr>
<h3><code>includes</code> - Smart Eager Loading</h3>
<p><strong>Automatically chooses best strategy:</strong></p>
<pre><code class="language-ruby"># Basic usage
users = User.includes(:posts)

# Rails decides:
# If no WHERE on posts → uses preload (2 queries)
# If WHERE on posts → uses eager_load (LEFT JOIN)

users.each do |user|
  user.posts.each do |post|  # No N+1!
    puts post.title
  end
end

# Generated SQL (preload strategy):
# SELECT * FROM users
# SELECT * FROM posts WHERE posts.user_id IN (1, 2, 3, ...)

# With WHERE clause (eager_load strategy):
users = User.includes(:posts).where(posts: { published: true })
# SELECT users.*, posts.* FROM users 
# LEFT OUTER JOIN posts ON posts.user_id = users.id
# WHERE posts.published = true
</code></pre>
<p><strong>Multiple associations:</strong></p>
<pre><code class="language-ruby"># Eager load multiple associations
User.includes(:posts, :comments, :profile)

# Nested includes
User.includes(posts: [:comments, :tags])

# Complex nesting
User.includes(
  posts: {
    comments: :user,
    tags: :category
  },
  profile: :avatar
)

# Generated queries:
# SELECT * FROM users
# SELECT * FROM posts WHERE user_id IN (...)
# SELECT * FROM comments WHERE post_id IN (...)
# SELECT * FROM tags ...
# SELECT * FROM profiles WHERE user_id IN (...)
</code></pre>
<hr>
<h3><code>joins</code> - SQL JOIN (No Loading)</h3>
<p><strong>Creates JOIN but doesn&#39;t load associated records:</strong></p>
<pre><code class="language-ruby"># Basic join
users = User.joins(:posts)

# Generated SQL:
# SELECT users.* FROM users
# INNER JOIN posts ON posts.user_id = users.id

# Associated records NOT loaded
users.each do |user|
  user.posts.each do |post|  # N+1 PROBLEM!
    puts post.title
  end
end

# Use joins for filtering, not for accessing associations
users = User.joins(:posts).where(posts: { published: true })
# Gets users who have published posts
# But user.posts will still trigger queries!
</code></pre>
<p><strong>When to use <code>joins</code>:</strong></p>
<pre><code class="language-ruby"># 1. Filtering by association attributes
User.joins(:posts).where(posts: { published: true }).distinct

# 2. Counting
User.joins(:posts).group(&#39;users.id&#39;).count

# 3. Ordering by association
User.joins(:profile).order(&#39;profiles.created_at DESC&#39;)

# 4. WHERE conditions on association
Post.joins(:user).where(users: { active: true })

# 5. Complex queries with multiple tables
User.joins(:posts, :comments)
    .where(posts: { published: true })
    .where(comments: { approved: true })
    .distinct
</code></pre>
<p><strong>Multiple joins:</strong></p>
<pre><code class="language-ruby"># Join multiple associations
User.joins(:posts, :comments)

# Nested joins
User.joins(posts: :comments)

# Complex joins
User.joins(posts: [:comments, :tags])

# Generated SQL:
# SELECT users.* FROM users
# INNER JOIN posts ON posts.user_id = users.id
# INNER JOIN comments ON comments.post_id = posts.id
# INNER JOIN tags ...
</code></pre>
<hr>
<h3><code>preload</code> - Always Separate Queries</h3>
<p><strong>Forces separate queries strategy:</strong></p>
<pre><code class="language-ruby"># Always uses separate queries
users = User.preload(:posts)

# Generated SQL (always):
# SELECT * FROM users
# SELECT * FROM posts WHERE posts.user_id IN (1, 2, 3, ...)

# No N+1
users.each do |user|
  user.posts.each do |post|
    puts post.title
  end
end

# Cannot use WHERE on association
User.preload(:posts).where(posts: { published: true })
# ERROR! Can&#39;t reference posts in WHERE with preload

# Must use includes or eager_load instead
User.includes(:posts).where(posts: { published: true }).references(:posts)
</code></pre>
<p><strong>When to use <code>preload</code>:</strong></p>
<pre><code class="language-ruby"># 1. When you want separate queries for sure
User.preload(:posts)

# 2. When you have many associations
User.preload(:posts, :comments, :profile)
# 4 queries total (better than 1 huge JOIN)

# 3. Large datasets
# Separate queries can be faster than huge JOINs
User.limit(1000).preload(:posts, :comments)
</code></pre>
<hr>
<h3><code>eager_load</code> - Always LEFT JOIN</h3>
<p><strong>Forces LEFT OUTER JOIN strategy:</strong></p>
<pre><code class="language-ruby"># Always uses LEFT OUTER JOIN
users = User.eager_load(:posts)

# Generated SQL (always):
# SELECT users.*, posts.* FROM users
# LEFT OUTER JOIN posts ON posts.user_id = users.id

# Can use WHERE on association
users = User.eager_load(:posts).where(posts: { published: true })

# Can order by association
users = User.eager_load(:posts).order(&#39;posts.created_at DESC&#39;)
</code></pre>
<hr>
<h3>Complete Comparison Example</h3>
<pre><code class="language-ruby"># Setup
class User &lt; ApplicationRecord
  has_many :posts
  has_many :comments
end

# 1. includes - Smart choice
users = User.includes(:posts)
# Strategy: Preload (2 queries)
# SQL:
#   SELECT * FROM users
#   SELECT * FROM posts WHERE user_id IN (...)
# Loads associated records: YES
# Can filter on association: Only with .references

users = User.includes(:posts).where(posts: { published: true }).references(:posts)
# Strategy: Eager load (1 query with JOIN)
# SQL:
#   SELECT users.*, posts.* FROM users
#   LEFT OUTER JOIN posts ON posts.user_id = users.id
#   WHERE posts.published = true

# 2. joins - Only JOIN
users = User.joins(:posts)
# SQL:
#   SELECT users.* FROM users
#   INNER JOIN posts ON posts.user_id = users.id
# Loads associated records: NO
# Can filter on association: YES

users.each do |user|
  user.posts  # N+1 query!
end

# 3. preload - Always separate
users = User.preload(:posts)
# SQL:
#   SELECT * FROM users
#   SELECT * FROM posts WHERE user_id IN (...)
# Loads associated records: YES
# Can filter on association: NO

# 4. eager_load - Always JOIN
users = User.eager_load(:posts)
# SQL:
#   SELECT users.*, posts.* FROM users
#   LEFT OUTER JOIN posts ON posts.user_id = users.id
# Loads associated records: YES
# Can filter on association: YES
</code></pre>
<hr>
<h3>Real-World Scenarios</h3>
<p><strong>Scenario 1: Display users with post counts</strong></p>
<pre><code class="language-ruby"># WRONG - N+1
users = User.all
users.each do |user|
  puts &quot;#{user.name}: #{user.posts.count} posts&quot;  # N+1!
end

# OPTION 1: joins + group + count
users = User.joins(:posts).group(&#39;users.id&#39;).count
# Returns: {1 =&gt; 5, 2 =&gt; 10, ...}

# OPTION 2: Counter cache (best)
class Post &lt; ApplicationRecord
  belongs_to :user, counter_cache: true
end

users = User.all
users.each do |user|
  puts &quot;#{user.name}: #{user.posts_count} posts&quot;  # No query!
end
</code></pre>
<p><strong>Scenario 2: Display users and their posts</strong></p>
<pre><code class="language-ruby"># WRONG - N+1
users = User.all
users.each do |user|
  user.posts.each do |post|  # N+1!
    puts post.title
  end
end

# RIGHT - includes
users = User.includes(:posts)
users.each do |user|
  user.posts.each do |post|  # No extra query!
    puts post.title
  end
end
</code></pre>
<p><strong>Scenario 3: Filter users by post attributes</strong></p>
<pre><code class="language-ruby"># OPTION 1: joins (if not accessing posts)
users = User.joins(:posts)
            .where(posts: { published: true })
            .distinct

# Don&#39;t access posts:
users.each do |user|
  puts user.name  # Only user data
end

# OPTION 2: includes (if accessing posts)
users = User.includes(:posts)
            .where(posts: { published: true })
            .references(:posts)

users.each do |user|
  user.posts.each do |post|  # Can access posts
    puts post.title
  end
end
</code></pre>
<p><strong>Scenario 4: Complex nested associations</strong></p>
<pre><code class="language-ruby"># Load users with posts, comments, and tags
users = User.includes(
  posts: [:comments, :tags],
  profile: :avatar
)

# Generated queries:
# SELECT * FROM users
# SELECT * FROM posts WHERE user_id IN (...)
# SELECT * FROM comments WHERE post_id IN (...)
# SELECT * FROM tags ...
# SELECT * FROM profiles WHERE user_id IN (...)
# SELECT * FROM avatars WHERE profile_id IN (...)

# No N+1 anywhere:
users.each do |user|
  user.posts.each do |post|
    post.comments.each { |c| puts c.body }
    post.tags.each { |t| puts t.name }
  end
end
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<p><strong>Small dataset:</strong></p>
<pre><code class="language-ruby"># includes/preload: Better (separate queries)
User.limit(10).includes(:posts)
# 2 small queries

# eager_load: Worse (cartesian product)
User.limit(10).eager_load(:posts)
# 1 query but potentially many duplicate rows
</code></pre>
<p><strong>Large dataset with filtering:</strong></p>
<pre><code class="language-ruby"># joins: Better (only what you need)
User.joins(:posts)
    .where(posts: { published: true })
    .distinct
    .select(&#39;users.*&#39;)

# includes: Worse (loads everything)
User.includes(:posts)
    .where(posts: { published: true })
    .references(:posts)
# Loads all posts for all users
</code></pre>
<p><strong>Multiple associations:</strong></p>
<pre><code class="language-ruby"># preload: Often better
User.preload(:posts, :comments, :profile)
# 4 queries

# eager_load: Can be slower
User.eager_load(:posts, :comments, :profile)
# 1 huge query with cartesian product
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>includes</code></strong> - Default choice, smart strategy</li>
<li><strong><code>joins</code></strong> - Filter only, don&#39;t load associations</li>
<li><strong><code>preload</code></strong> - Force separate queries</li>
<li><strong><code>eager_load</code></strong> - Force LEFT JOIN</li>
<li><strong>Use <code>includes</code></strong> when accessing associations</li>
<li><strong>Use <code>joins</code></strong> when filtering by associations</li>
<li><strong>Use <code>preload</code></strong> for many associations</li>
<li><strong>Always avoid N+1</strong> queries</li>
<li><strong><code>distinct</code></strong> often needed with joins</li>
<li><strong>Profile queries</strong> to find the best strategy</li>
</ol>
<hr>
<h2>Question 63: What is lazy loading vs eager loading in Rails?</h2>
<h3>Answer</h3>
<p><strong>Lazy loading</strong> loads data only when accessed (default ActiveRecord behavior), while <strong>eager loading</strong> loads associated data upfront to prevent N+1 queries.</p>
<hr>
<h3>Lazy Loading (Default)</h3>
<p><strong>Queries execute only when data is accessed:</strong></p>
<pre><code class="language-ruby"># Query doesn&#39;t execute yet
users = User.where(active: true)
# No SQL yet!

# Query executes when accessed
users.each do |user|  # NOW SQL executes
  puts user.name
end

# SQL:
# SELECT * FROM users WHERE active = true
</code></pre>
<p><strong>Lazy loading associations:</strong></p>
<pre><code class="language-ruby"># Get user (1 query)
user = User.find(1)
# SELECT * FROM users WHERE id = 1

# Access posts (another query)
user.posts.each do |post|  # Lazy load
  puts post.title
end
# SELECT * FROM posts WHERE user_id = 1

# Each association loads separately
user.comments  # Another query
user.profile   # Another query
</code></pre>
<p><strong>N+1 Problem with lazy loading:</strong></p>
<pre><code class="language-ruby"># 1 query for users
users = User.limit(10)

# N queries for posts (10 queries)
users.each do |user|
  user.posts.each do |post|  # Lazy load for EACH user
    puts post.title
  end
end

# Total: 11 queries (1 + 10)
# SQL:
# SELECT * FROM users LIMIT 10
# SELECT * FROM posts WHERE user_id = 1
# SELECT * FROM posts WHERE user_id = 2
# ...
# SELECT * FROM posts WHERE user_id = 10
</code></pre>
<hr>
<h3>Eager Loading</h3>
<p><strong>Loads all data upfront:</strong></p>
<pre><code class="language-ruby"># Eager load posts with users
users = User.includes(:posts)

# Only 2 queries total
users.each do |user|
  user.posts.each do |post|  # No additional query!
    puts post.title
  end
end

# SQL:
# SELECT * FROM users
# SELECT * FROM posts WHERE user_id IN (1, 2, 3, ...)
</code></pre>
<hr>
<h3>Comparison Examples</h3>
<p><strong>Example 1: Blog Posts</strong></p>
<p><strong>Lazy loading (N+1 problem):</strong></p>
<pre><code class="language-ruby"># Controller
def index
  @posts = Post.all  # 1 query
end

# View
&lt;% @posts.each do |post| %&gt;
  &lt;h2&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
  &lt;p&gt;By &lt;%= post.user.name %&gt;&lt;/p&gt;  &lt;!-- N queries! --&gt;
  
  &lt;% post.comments.each do |comment| %&gt;  &lt;!-- N queries! --&gt;
    &lt;p&gt;&lt;%= comment.body %&gt;&lt;/p&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

# SQL (for 10 posts):
# SELECT * FROM posts
# SELECT * FROM users WHERE id = 1
# SELECT * FROM users WHERE id = 2
# ...
# SELECT * FROM comments WHERE post_id = 1
# SELECT * FROM comments WHERE post_id = 2
# ...
# Total: 21 queries! (1 + 10 + 10)
</code></pre>
<p><strong>Eager loading (efficient):</strong></p>
<pre><code class="language-ruby"># Controller
def index
  @posts = Post.includes(:user, :comments)  # Eager load
end

# View (same as above)
&lt;% @posts.each do |post| %&gt;
  &lt;h2&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
  &lt;p&gt;By &lt;%= post.user.name %&gt;&lt;/p&gt;  &lt;!-- No query! --&gt;
  
  &lt;% post.comments.each do |comment| %&gt;  &lt;!-- No query! --&gt;
    &lt;p&gt;&lt;%= comment.body %&gt;&lt;/p&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

# SQL:
# SELECT * FROM posts
# SELECT * FROM users WHERE id IN (...)
# SELECT * FROM comments WHERE post_id IN (...)
# Total: 3 queries!
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use Lazy Loading when:</strong></p>
<p>✅ <strong>Working with single records:</strong></p>
<pre><code class="language-ruby">user = User.find(1)
user.update(name: &quot;New Name&quot;)
# Don&#39;t need to load associations
</code></pre>
<p>✅ <strong>Conditional access:</strong></p>
<pre><code class="language-ruby">users = User.all

users.each do |user|
  if user.admin?
    # Only load posts for admins
    user.posts.each { |p| puts p.title }
  end
end
</code></pre>
<p>✅ <strong>Memory constraints:</strong></p>
<pre><code class="language-ruby"># Processing huge dataset
User.find_each(batch_size: 100) do |user|
  # Lazy load associations per batch
  process_user(user)
end
</code></pre>
<p><strong>Use Eager Loading when:</strong></p>
<p>✅ <strong>Accessing associations in loops:</strong></p>
<pre><code class="language-ruby"># Always eager load in loops
users = User.includes(:posts)
users.each do |user|
  user.posts.each { |p| puts p.title }
end
</code></pre>
<p>✅ <strong>View rendering:</strong></p>
<pre><code class="language-ruby"># Eager load for views
@posts = Post.includes(:user, :comments)
</code></pre>
<p>✅ <strong>API responses:</strong></p>
<pre><code class="language-ruby"># Eager load for JSON serialization
users = User.includes(:posts, :profile)
render json: users, include: [:posts, :profile]
</code></pre>
<p>✅ <strong>Nested associations:</strong></p>
<pre><code class="language-ruby"># Deep nesting
posts = Post.includes(comments: [:user, :likes])
</code></pre>
<hr>
<h3>Advanced Eager Loading</h3>
<p><strong>Nested associations:</strong></p>
<pre><code class="language-ruby"># Multiple levels
users = User.includes(
  posts: [
    :tags,
    comments: [:user, :likes]
  ]
)

# SQL:
# SELECT * FROM users
# SELECT * FROM posts WHERE user_id IN (...)
# SELECT * FROM tags ...
# SELECT * FROM comments WHERE post_id IN (...)
# SELECT * FROM users WHERE id IN (...)
# SELECT * FROM likes WHERE comment_id IN (...)
</code></pre>
<p><strong>Conditional eager loading:</strong></p>
<pre><code class="language-ruby"># Eager load based on parameter
associations = [:posts]
associations &lt;&lt; :comments if params[:include_comments]
associations &lt;&lt; :profile if params[:include_profile]

users = User.includes(associations)
</code></pre>
<p><strong>Polymorphic associations:</strong></p>
<pre><code class="language-ruby"># Eager load polymorphic
comments = Comment.includes(:commentable)

# For better performance, load each type separately
post_comments = Comment.where(commentable_type: &#39;Post&#39;)
                      .includes(:commentable)
photo_comments = Comment.where(commentable_type: &#39;Photo&#39;)
                        .includes(:commentable)
</code></pre>
<hr>
<h3>Lazy Loading Features</h3>
<p><strong>Lazy evaluation of queries:</strong></p>
<pre><code class="language-ruby"># Build query (no SQL yet)
query = User.where(active: true)
             .order(created_at: :desc)
             .limit(10)

# Can modify before execution
query = query.where(&#39;age &gt; ?&#39;, 18) if params[:adults_only]

# SQL executes only when accessed
users = query.to_a
</code></pre>
<p><strong>Lazy loading with scopes:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  scope :active, -&gt; { where(active: true) }
  scope :recent, -&gt; { order(created_at: :desc) }
end

# Scopes are lazy
users = User.active.recent  # No SQL yet
users = users.limit(10)     # Still no SQL

# Execute now
users.each { |u| puts u.name }  # SQL executes
</code></pre>
<hr>
<h3>Real-World Pattern</h3>
<p><strong>Repository pattern:</strong></p>
<pre><code class="language-ruby">class UserRepository
  def all_with_posts
    User.includes(:posts)  # Eager load
  end
  
  def find_with_associations(id)
    User.includes(:posts, :comments, :profile).find(id)
  end
  
  def search(query)
    # Lazy load - don&#39;t know if associations needed
    User.where(&quot;name LIKE ?&quot;, &quot;%#{query}%&quot;)
  end
end

# Usage
repo = UserRepository.new

# Eager loading when we know we need associations
users = repo.all_with_posts
users.each { |u| u.posts.each { |p| puts p.title } }

# Lazy loading when uncertain
results = repo.search(&quot;john&quot;)
# Load associations only if needed
</code></pre>
<hr>
<h3>Detecting N+1 Queries</h3>
<p><strong>Bullet gem:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;bullet&#39;, group: :development

# config/environments/development.rb
config.after_initialize do
  Bullet.enable = true
  Bullet.alert = true
  Bullet.bullet_logger = true
  Bullet.console = true
  Bullet.rails_logger = true
end

# Bullet will warn:
# USE eager loading detected
#   User =&gt; [:posts]
# Add to your finder: :includes =&gt; [:posts]
</code></pre>
<p><strong>Manual detection:</strong></p>
<pre><code class="language-ruby"># Check query count
ActiveRecord::Base.logger = Logger.new(STDOUT)

users = User.limit(10)
users.each do |user|
  user.posts.each { |p| puts p.title }
end

# Console shows all queries
# Count them to detect N+1
</code></pre>
<hr>
<h3>Performance Impact</h3>
<p><strong>Benchmark:</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

# Lazy loading (N+1)
time_lazy = Benchmark.measure do
  users = User.limit(100)
  users.each do |user|
    user.posts.count
  end
end

# Eager loading
time_eager = Benchmark.measure do
  users = User.includes(:posts).limit(100)
  users.each do |user|
    user.posts.size  # Use size, not count
  end
end

puts &quot;Lazy:  #{time_lazy.real}s&quot;  # ~2.5s
puts &quot;Eager: #{time_eager.real}s&quot; # ~0.1s
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Lazy loading</strong> delays queries until needed</li>
<li><strong>Eager loading</strong> loads data upfront</li>
<li><strong>N+1 problem</strong> caused by lazy loading in loops</li>
<li><strong>Use <code>includes</code></strong> for eager loading</li>
<li><strong>Lazy loading</strong> is default behavior</li>
<li><strong>Eager loading</strong> prevents N+1 queries</li>
<li><strong>Use Bullet gem</strong> to detect N+1</li>
<li><strong>Eager load in views</strong> and loops</li>
<li><strong>Lazy load</strong> for single records</li>
<li><strong>Profile queries</strong> to optimize</li>
</ol>
<hr>
<h2>Question 64: How do you identify and fix N+1 query problems in Rails?</h2>
<h3>Answer</h3>
<p><strong>N+1 queries</strong> occur when you query for N records, then make 1 additional query per record for associations. Identify using logging or gems like Bullet, and fix with eager loading.</p>
<hr>
<h3>What is N+1 Problem?</h3>
<p><strong>Example scenario:</strong></p>
<pre><code class="language-ruby"># Get 10 users (1 query)
users = User.limit(10)

# Access posts for each user (10 queries)
users.each do |user|
  puts user.posts.count  # 1 query per user!
end

# Total: 11 queries (1 + 10)
# This is N+1 problem!
</code></pre>
<p><strong>SQL generated:</strong></p>
<pre><code class="language-sql">-- Query 1: Get users
SELECT * FROM users LIMIT 10

-- Query 2-11: Get posts for each user
SELECT * FROM posts WHERE user_id = 1
SELECT * FROM posts WHERE user_id = 2
SELECT * FROM posts WHERE user_id = 3
...
SELECT * FROM posts WHERE user_id = 10
</code></pre>
<hr>
<h3>Identifying N+1 Queries</h3>
<p><strong>Method 1: Check Rails logs</strong></p>
<pre><code class="language-ruby"># config/environments/development.rb
config.log_level = :debug

# In console or server logs:
Started GET &quot;/users&quot;
User Load (0.5ms)  SELECT &quot;users&quot;.* FROM &quot;users&quot;
Post Load (0.3ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; WHERE &quot;posts&quot;.&quot;user_id&quot; = 1
Post Load (0.3ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; WHERE &quot;posts&quot;.&quot;user_id&quot; = 2
Post Load (0.3ms)  SELECT &quot;posts&quot;.* FROM &quot;posts&quot; WHERE &quot;posts&quot;.&quot;user_id&quot; = 3
# ... repeating pattern indicates N+1
</code></pre>
<p><strong>Method 2: Bullet gem (Recommended)</strong></p>
<pre><code class="language-ruby"># Gemfile
group :development do
  gem &#39;bullet&#39;
end

# config/environments/development.rb
config.after_initialize do
  Bullet.enable = true
  
  # Alert in browser
  Bullet.alert = true
  
  # Log to Rails logger
  Bullet.rails_logger = true
  
  # Log to separate file
  Bullet.bullet_logger = true
  
  # Show in console
  Bullet.console = true
  
  # Add footer to page
  Bullet.add_footer = true
end

# Bullet will show:
# N+1 Query detected
#   User =&gt; [:posts]
# Add to your finder: :includes =&gt; [:posts]
</code></pre>
<p><strong>Method 3: ActiveRecord query counter</strong></p>
<pre><code class="language-ruby"># Count queries manually
ActiveRecord::Base.connection.query_cache.clear

query_count = 0
ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do
  query_count += 1
end

# Your code here
users = User.limit(10)
users.each { |u| u.posts.count }

puts &quot;Total queries: #{query_count}&quot;
# Shows high number for N+1
</code></pre>
<p><strong>Method 4: Prosopite gem</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;prosopite&#39;

# config/environments/development.rb
Prosopite.rails_logger = true
Prosopite.prosopite_logger = true
Prosopite.enabled = true

# Automatically detects N+1
</code></pre>
<hr>
<h3>Common N+1 Patterns</h3>
<p><strong>Pattern 1: Loop with association access</strong></p>
<pre><code class="language-ruby"># BAD - N+1
users.each do |user|
  puts user.posts.count      # N queries
  puts user.profile.bio      # N queries
  puts user.comments.size    # N queries
end

# GOOD - Eager load
users = User.includes(:posts, :profile, :comments)
users.each do |user|
  puts user.posts.size       # No query (use size, not count)
  puts user.profile.bio      # No query
  puts user.comments.size    # No query
end
</code></pre>
<p><strong>Pattern 2: View rendering</strong></p>
<pre><code class="language-ruby"># BAD - Controller
def index
  @posts = Post.all
end

# BAD - View
&lt;% @posts.each do |post| %&gt;
  &lt;h2&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
  &lt;p&gt;By &lt;%= post.user.name %&gt;&lt;/p&gt;      &lt;!-- N+1 --&gt;
  &lt;p&gt;&lt;%= post.comments.count %&gt; comments&lt;/p&gt;  &lt;!-- N+1 --&gt;
&lt;% end %&gt;

# GOOD - Controller
def index
  @posts = Post.includes(:user).with_comments_count
end

# GOOD - Model
class Post &lt; ApplicationRecord
  scope :with_comments_count, -&gt; {
    left_joins(:comments)
      .group(:id)
      .select(&#39;posts.*, COUNT(comments.id) as comments_count&#39;)
  }
end

# GOOD - View
&lt;% @posts.each do |post| %&gt;
  &lt;h2&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
  &lt;p&gt;By &lt;%= post.user.name %&gt;&lt;/p&gt;      &lt;!-- No query --&gt;
  &lt;p&gt;&lt;%= post.comments_count %&gt; comments&lt;/p&gt;  &lt;!-- No query --&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>Pattern 3: JSON serialization</strong></p>
<pre><code class="language-ruby"># BAD
def index
  users = User.all
  render json: users, include: :posts  # N+1!
end

# GOOD
def index
  users = User.includes(:posts)
  render json: users, include: :posts
end
</code></pre>
<p><strong>Pattern 4: Nested associations</strong></p>
<pre><code class="language-ruby"># BAD
posts = Post.all
posts.each do |post|
  post.comments.each do |comment|  # N+1
    puts comment.user.name         # N+1
  end
end

# GOOD
posts = Post.includes(comments: :user)
posts.each do |post|
  post.comments.each do |comment|
    puts comment.user.name
  end
end
</code></pre>
<hr>
<h3>Fixing N+1 Queries</h3>
<p><strong>Solution 1: includes (most common)</strong></p>
<pre><code class="language-ruby"># Single association
User.includes(:posts)

# Multiple associations
User.includes(:posts, :comments, :profile)

# Nested associations
Post.includes(:user, comments: [:user, :likes])

# Deep nesting
User.includes(
  posts: {
    comments: [:user, :likes],
    tags: :category
  }
)
</code></pre>
<p><strong>Solution 2: preload (when includes doesn&#39;t work)</strong></p>
<pre><code class="language-ruby"># Force separate queries
User.preload(:posts, :comments)

# Useful for large datasets
User.limit(1000).preload(:posts)
</code></pre>
<p><strong>Solution 3: eager_load (when you need to filter)</strong></p>
<pre><code class="language-ruby"># Force LEFT JOIN
User.eager_load(:posts)
    .where(posts: { published: true })
</code></pre>
<p><strong>Solution 4: joins + select (for counts)</strong></p>
<pre><code class="language-ruby"># BAD - N+1
users.each { |u| puts u.posts.count }

# GOOD - Join and count
users = User.left_joins(:posts)
            .group(&#39;users.id&#39;)
            .select(&#39;users.*, COUNT(posts.id) as posts_count&#39;)

users.each { |u| puts u.posts_count }
</code></pre>
<p><strong>Solution 5: Counter cache (best for counts)</strong></p>
<pre><code class="language-ruby"># Migration
class AddPostsCountToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :posts_count, :integer, default: 0
    
    # Backfill existing counts
    User.find_each do |user|
      User.reset_counters(user.id, :posts)
    end
  end
end

# Model
class Post &lt; ApplicationRecord
  belongs_to :user, counter_cache: true
end

# Usage - no query!
user.posts_count  # Instant!
</code></pre>
<p><strong>Solution 6: Pluck (for simple data)</strong></p>
<pre><code class="language-ruby"># BAD - loads full objects
users.map { |u| u.posts.map(&amp;:title) }

# GOOD - pluck only needed data
User.joins(:posts).pluck(&#39;users.name&#39;, &#39;posts.title&#39;)
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Dashboard</strong></p>
<pre><code class="language-ruby"># BAD - Multiple N+1 issues
class DashboardController &lt; ApplicationController
  def show
    @user = current_user
    @recent_posts = @user.posts.recent
    # Will cause N+1 when accessing:
    # - post.comments
    # - post.likes
    # - post.tags
  end
end

# GOOD - Eager load everything
class DashboardController &lt; ApplicationController
  def show
    @user = current_user
    @recent_posts = @user.posts
                        .recent
                        .includes(:comments, :likes, :tags)
  end
end
</code></pre>
<p><strong>Example 2: API endpoint</strong></p>
<pre><code class="language-ruby"># BAD
class Api::UsersController &lt; ApplicationController
  def index
    users = User.all
    
    render json: users.map { |u|
      {
        name: u.name,
        posts_count: u.posts.count,        # N+1
        comments_count: u.comments.count,  # N+1
        recent_post: u.posts.first&amp;.title  # N+1
      }
    }
  end
end

# GOOD
class Api::UsersController &lt; ApplicationController
  def index
    users = User.left_joins(:posts, :comments)
                .group(&#39;users.id&#39;)
                .select(
                  &#39;users.*&#39;,
                  &#39;COUNT(DISTINCT posts.id) as posts_count&#39;,
                  &#39;COUNT(DISTINCT comments.id) as comments_count&#39;
                )
                .includes(:posts)
    
    render json: users.map { |u|
      {
        name: u.name,
        posts_count: u.posts_count,
        comments_count: u.comments_count,
        recent_post: u.posts.first&amp;.title
      }
    }
  end
end
</code></pre>
<p><strong>Example 3: Search results</strong></p>
<pre><code class="language-ruby"># BAD
class SearchController &lt; ApplicationController
  def index
    @results = Post.search(params[:q])
    # View will access:
    # - post.user
    # - post.comments_count
    # - post.tags
  end
end

# GOOD
class SearchController &lt; ApplicationController
  def index
    @results = Post.search(params[:q])
                   .includes(:user, :tags)
                   .with_comments_count
  end
end

# Model
class Post &lt; ApplicationRecord
  def self.search(query)
    where(&quot;title LIKE ? OR body LIKE ?&quot;, &quot;%#{query}%&quot;, &quot;%#{query}%&quot;)
  end
  
  scope :with_comments_count, -&gt; {
    left_joins(:comments)
      .group(&#39;posts.id&#39;)
      .select(&#39;posts.*, COUNT(comments.id) as comments_count&#39;)
  }
end
</code></pre>
<hr>
<h3>Testing for N+1</h3>
<p><strong>RSpec with query counter:</strong></p>
<pre><code class="language-ruby"># spec/support/query_counter.rb
RSpec.configure do |config|
  config.around(:each, :n_plus_one) do |example|
    query_count = 0
    
    counter = lambda do |_name, _started, _finished, _unique_id, payload|
      query_count += 1 unless payload[:name] == &#39;SCHEMA&#39;
    end
    
    ActiveSupport::Notifications.subscribed(counter, &#39;sql.active_record&#39;) do
      example.run
    end
    
    expect(query_count).to be &lt;= example.metadata[:query_limit]
  end
end

# Usage in specs
describe &#39;Users#index&#39;, :n_plus_one, query_limit: 3 do
  it &#39;does not have N+1 queries&#39; do
    create_list(:user, 10, :with_posts)
    
    get :index
    
    # Will fail if more than 3 queries
  end
end
</code></pre>
<p><strong>Prosopite in tests:</strong></p>
<pre><code class="language-ruby"># spec/rails_helper.rb
RSpec.configure do |config|
  config.before(:each) do
    Prosopite.scan
  end
  
  config.after(:each) do
    Prosopite.finish
  end
end

# Will raise error if N+1 detected in tests
</code></pre>
<hr>
<h3>Prevention Strategies</h3>
<p><strong>1. Always eager load in controllers:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  # Set default eager loading
  def default_includes
    []
  end
  
  def index
    @records = model_class.includes(default_includes)
  end
end

class UsersController &lt; ApplicationController
  def default_includes
    [:posts, :profile]
  end
end
</code></pre>
<p><strong>2. Use view helpers:</strong></p>
<pre><code class="language-ruby"># app/helpers/application_helper.rb
module ApplicationHelper
  def render_with_associations(collection, partial, associations: [])
    collection = collection.includes(associations) if associations.any?
    render partial: partial, collection: collection
  end
end

# View
&lt;%= render_with_associations(@posts, &#39;post&#39;, associations: [:user, :comments]) %&gt;
</code></pre>
<p><strong>3. Serializer pattern:</strong></p>
<pre><code class="language-ruby">class UserSerializer
  def initialize(user)
    @user = user
  end
  
  def as_json
    {
      id: @user.id,
      name: @user.name,
      posts: @user.posts.map { |p| PostSerializer.new(p).as_json }
    }
  end
  
  def self.collection(users)
    # Eager load for entire collection
    users = users.includes(:posts)
    users.map { |u| new(u).as_json }
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>N+1</strong> = 1 query + N queries per record</li>
<li><strong>Identify</strong> with Bullet gem or logs</li>
<li><strong>Fix</strong> with <code>includes</code>, <code>preload</code>, or <code>eager_load</code></li>
<li><strong>Counter cache</strong> for counts</li>
<li><strong>Eager load in views</strong> always</li>
<li><strong>Test for N+1</strong> in specs</li>
<li><strong>Profile queries</strong> regularly</li>
<li><strong>Use Bullet in development</strong> always</li>
<li><strong>Pluck</strong> for simple data</li>
<li><strong>Joins + select</strong> for aggregates</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 65: Explain the <code>load</code> method</h2>
<h3>Answer</h3>
<p>The <strong><code>load</code></strong> method forces immediate execution of a query and loads results into memory. It&#39;s used to trigger query execution in lazy-loaded ActiveRecord relations.</p>
<hr>
<h3>How <code>load</code> Works</h3>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-ruby"># Build query (no SQL yet - lazy)
users = User.where(active: true)
# No SQL executed

# Force execution with load
users.load
# SQL executes NOW: SELECT * FROM users WHERE active = true

# Results cached in memory
users.to_a   # No additional query
users.first  # No additional query
users.count  # No additional query (uses loaded records)
</code></pre>
<hr>
<h3>Lazy vs Loaded Queries</h3>
<p><strong>Without load (lazy):</strong></p>
<pre><code class="language-ruby">users = User.where(active: true).order(:name)
# No SQL yet

# Query executes on first access
users.each { |u| puts u.name }
# SQL: SELECT * FROM users WHERE active = true ORDER BY name

# Query executes AGAIN if collection not cached
users.first
# SQL: SELECT * FROM users WHERE active = true ORDER BY name LIMIT 1
</code></pre>
<p><strong>With load (eager):</strong></p>
<pre><code class="language-ruby">users = User.where(active: true).order(:name).load
# SQL executes immediately: SELECT * FROM users WHERE active = true ORDER BY name
# Results stored in memory

# Uses cached results (no additional queries)
users.each { |u| puts u.name }  # No SQL
users.first                     # No SQL
users.count                     # No SQL
users.empty?                    # No SQL
</code></pre>
<hr>
<h3>When to Use <code>load</code></h3>
<p><strong>Use case 1: Conditional loading</strong></p>
<pre><code class="language-ruby">def users_list
  users = User.where(active: true)
  
  # Apply filters based on params
  users = users.where(role: params[:role]) if params[:role]
  users = users.where(&#39;age &gt; ?&#39;, params[:min_age]) if params[:min_age]
  
  # Load once, use many times
  users.load
  
  # These don&#39;t trigger new queries
  @total = users.count
  @users = users.to_a
  @first_user = users.first
end
</code></pre>
<p><strong>Use case 2: Multiple operations on same query</strong></p>
<pre><code class="language-ruby">posts = Post.published.recent.load

# All use cached results
puts &quot;Total: #{posts.count}&quot;
puts &quot;First: #{posts.first.title}&quot;
puts &quot;Last: #{posts.last.title}&quot;
posts.each { |p| process(p) }
</code></pre>
<p><strong>Use case 3: Checking existence before iteration</strong></p>
<pre><code class="language-ruby">users = User.where(active: true).load

if users.any?  # Uses loaded results
  users.each { |u| send_email(u) }  # Uses loaded results
else
  # Handle empty case
end
</code></pre>
<p><strong>Use case 4: Background jobs</strong></p>
<pre><code class="language-ruby">class ReportJob &lt; ApplicationJob
  def perform
    # Load all data at once
    users = User.includes(:posts).where(active: true).load
    
    # Process without additional queries
    users.each do |user|
      generate_report(user)
    end
  end
end
</code></pre>
<hr>
<h3><code>load</code> vs Other Methods</h3>
<p><strong><code>load</code> vs <code>to_a</code>:</strong></p>
<pre><code class="language-ruby"># load - executes and returns ActiveRecord::Relation
users = User.where(active: true).load
users.class  # =&gt; User::ActiveRecord_Relation
users.where(role: &#39;admin&#39;)  # Can chain more queries

# to_a - executes and returns Array
users = User.where(active: true).to_a
users.class  # =&gt; Array
users.where(role: &#39;admin&#39;)  # ERROR! Can&#39;t chain
</code></pre>
<p><strong><code>load</code> vs <code>all</code>:</strong></p>
<pre><code class="language-ruby"># all - returns ActiveRecord::Relation (lazy)
users = User.all
users.class  # =&gt; User::ActiveRecord_Relation
# No SQL yet

# load - executes query immediately
users = User.all.load
# SQL executes: SELECT * FROM users
# Still returns ActiveRecord::Relation
</code></pre>
<p><strong><code>load</code> vs <code>find</code>:</strong></p>
<pre><code class="language-ruby"># find - executes immediately
user = User.find(1)
# SQL: SELECT * FROM users WHERE id = 1

# load - executes query for collection
users = User.where(active: true).load
# SQL: SELECT * FROM users WHERE active = true
</code></pre>
<hr>
<h3>Advanced Usage</h3>
<p><strong>Preloading associations:</strong></p>
<pre><code class="language-ruby"># Load users and associations
users = User.includes(:posts, :comments).where(active: true).load

# No additional queries
users.each do |user|
  user.posts.each { |p| puts p.title }      # Cached
  user.comments.each { |c| puts c.body }    # Cached
end
</code></pre>
<p><strong>Checking if loaded:</strong></p>
<pre><code class="language-ruby">users = User.where(active: true)

users.loaded?  # =&gt; false

users.load

users.loaded?  # =&gt; true
</code></pre>
<p><strong>Reloading:</strong></p>
<pre><code class="language-ruby">users = User.where(active: true).load
users.loaded?  # =&gt; true

# Reload from database
users.reload

# Or create new query
users = User.where(active: true)
users.loaded?  # =&gt; false
</code></pre>
<p><strong>Loading with limit:</strong></p>
<pre><code class="language-ruby"># Load first 100 users
users = User.where(active: true).limit(100).load

# Operations use only loaded records
users.count  # =&gt; 100 (no query)
users.size   # =&gt; 100 (no query)

# But these still query database
User.where(active: true).count  # Queries database
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<p><strong>Memory usage:</strong></p>
<pre><code class="language-ruby"># BAD - loads everything into memory
users = User.all.load  # Loads 100,000 records!
users.each { |u| process(u) }

# GOOD - use batches
User.find_each(batch_size: 1000) do |user|
  process(user)
end
</code></pre>
<p><strong>When load helps:</strong></p>
<pre><code class="language-ruby"># Multiple operations on same data
posts = Post.recent.limit(20).load

# Single query, multiple uses
@posts_count = posts.count
@first_post = posts.first
@last_post = posts.last
# ... more operations
</code></pre>
<p><strong>When load hurts:</strong></p>
<pre><code class="language-ruby"># BAD - loads all, uses few
users = User.all.load  # Loads 100,000 records
users.first            # Only needed 1!

# GOOD - lazy load
user = User.first      # Loads only 1 record
</code></pre>
<hr>
<h3>Practical Examples</h3>
<p><strong>Example 1: Report generation</strong></p>
<pre><code class="language-ruby">class SalesReport
  def generate
    # Load all data upfront
    @orders = Order.includes(:items, :customer)
                   .where(created_at: 1.month.ago..Date.today)
                   .load
    
    # Multiple calculations without additional queries
    {
      total_orders: @orders.count,
      total_revenue: @orders.sum(&amp;:total),
      average_order: @orders.sum(&amp;:total) / @orders.count,
      top_customer: find_top_customer,
      top_product: find_top_product
    }
  end
  
  private
  
  def find_top_customer
    @orders.group_by(&amp;:customer)
           .max_by { |_, orders| orders.sum(&amp;:total) }
           .first
  end
  
  def find_top_product
    # Uses already loaded items
    @orders.flat_map(&amp;:items)
           .group_by(&amp;:product_id)
           .max_by { |_, items| items.sum(&amp;:quantity) }
  end
end
</code></pre>
<p><strong>Example 2: Conditional display</strong></p>
<pre><code class="language-ruby">class DashboardController &lt; ApplicationController
  def show
    # Load data once
    @posts = current_user.posts.recent.load
    
    # Multiple checks without queries
    @has_posts = @posts.any?
    @posts_count = @posts.count
    @first_post = @posts.first
    @recent_posts = @posts.limit(5).to_a
  end
end
</code></pre>
<p><strong>Example 3: Caching with load</strong></p>
<pre><code class="language-ruby">def trending_posts
  Rails.cache.fetch(&#39;trending_posts&#39;, expires_in: 1.hour) do
    Post.where(&#39;created_at &gt; ?&#39;, 24.hours.ago)
        .order(views_count: :desc)
        .limit(10)
        .load
        .to_a  # Convert to array for caching
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>load</code></strong> forces immediate query execution</li>
<li><strong>Returns</strong> ActiveRecord::Relation</li>
<li><strong>Caches</strong> results in memory</li>
<li><strong>Prevents</strong> multiple queries for same data</li>
<li><strong>Use</strong> when multiple operations on same data</li>
<li><strong>Don&#39;t use</strong> for large datasets (memory)</li>
<li><strong>Check</strong> <code>loaded?</code> to see if executed</li>
<li><strong>Reload</strong> to refresh from database</li>
<li><strong>Different</strong> from <code>to_a</code> (returns Array)</li>
<li><strong>Useful</strong> for reports and dashboards</li>
</ol>
<hr>
<h2>Question 66: How do you use <code>pluck</code> vs <code>select</code> in ActiveRecord?</h2>
<h3>Answer</h3>
<p><strong><code>pluck</code></strong> fetches specific columns directly from database and returns an array, while <strong><code>select</code></strong> loads ActiveRecord objects with specified columns.</p>
<hr>
<h3>Quick Comparison</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>pluck</code></th>
<th><code>select</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Returns</strong></td>
<td>Array of values</td>
<td>ActiveRecord objects</td>
</tr>
<tr>
<td><strong>SQL</strong></td>
<td>SELECT columns</td>
<td>SELECT columns</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>Low</td>
<td>Higher</td>
</tr>
<tr>
<td><strong>Speed</strong></td>
<td>Fast</td>
<td>Slower</td>
</tr>
<tr>
<td><strong>Methods</strong></td>
<td>Array methods only</td>
<td>Model methods available</td>
</tr>
<tr>
<td><strong>Lazy</strong></td>
<td>No (executes immediately)</td>
<td>Yes (lazy loaded)</td>
</tr>
<tr>
<td><strong>Associations</strong></td>
<td>Not accessible</td>
<td>Accessible</td>
</tr>
</tbody></table>
<hr>
<h3><code>pluck</code> - Direct Database to Array</h3>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-ruby"># Single column
User.pluck(:name)
# =&gt; [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]
# SQL: SELECT users.name FROM users

# Multiple columns
User.pluck(:id, :name)
# =&gt; [[1, &quot;Alice&quot;], [2, &quot;Bob&quot;], [3, &quot;Charlie&quot;]]
# SQL: SELECT users.id, users.name FROM users

# With conditions
User.where(active: true).pluck(:email)
# =&gt; [&quot;alice@example.com&quot;, &quot;bob@example.com&quot;]
</code></pre>
<p><strong>Returns plain values:</strong></p>
<pre><code class="language-ruby">names = User.pluck(:name)
names.class  # =&gt; Array
names.first  # =&gt; &quot;Alice&quot; (String, not User object)

# Can use array methods
names.map(&amp;:upcase)
names.select { |n| n.starts_with?(&#39;A&#39;) }
names.join(&#39;, &#39;)
</code></pre>
<p><strong>Immediate execution:</strong></p>
<pre><code class="language-ruby"># Executes immediately
ids = User.where(active: true).pluck(:id)
# SQL runs NOW

# Cannot chain ActiveRecord methods after pluck
User.pluck(:name).where(...)  # ERROR!
</code></pre>
<hr>
<h3><code>select</code> - Load Specific Columns as Objects</h3>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-ruby"># Single column
users = User.select(:name)
# Returns ActiveRecord::Relation

users.first
# =&gt; #&lt;User id: nil, name: &quot;Alice&quot;&gt;
# SQL: SELECT users.name FROM users

# Multiple columns
users = User.select(:id, :name, :email)
users.first
# =&gt; #&lt;User id: 1, name: &quot;Alice&quot;, email: &quot;alice@example.com&quot;&gt;

# With conditions
users = User.select(:id, :name).where(active: true)
</code></pre>
<p><strong>Returns ActiveRecord objects:</strong></p>
<pre><code class="language-ruby">users = User.select(:id, :name)
users.class  # =&gt; User::ActiveRecord_Relation
users.first.class  # =&gt; User

# Can access model methods
users.first.name
users.first.respond_to?(:posts)  # =&gt; true

# But unselected attributes are nil
users.first.email  # =&gt; nil (not selected)
</code></pre>
<p><strong>Lazy evaluation:</strong></p>
<pre><code class="language-ruby"># No SQL yet
users = User.select(:name)

# Can chain more conditions
users = users.where(active: true)
users = users.order(:name)

# SQL executes on access
users.to_a
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<p><strong>Memory usage:</strong></p>
<pre><code class="language-ruby"># SLOW - loads full objects
users = User.all
emails = users.map(&amp;:email)
# Loads ALL columns for ALL users

# FAST - plucks only emails
emails = User.pluck(:email)
# Loads ONLY email column
</code></pre>
<p><strong>Benchmark:</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

Benchmark.bm do |x|
  x.report(&quot;All + map:&quot;) do
    User.all.map(&amp;:email)
  end
  # Time: 0.150s, Memory: 50MB
  
  x.report(&quot;Select + map:&quot;) do
    User.select(:email).map(&amp;:email)
  end
  # Time: 0.080s, Memory: 25MB
  
  x.report(&quot;Pluck:&quot;) do
    User.pluck(:email)
  end
  # Time: 0.040s, Memory: 10MB
end
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use <code>pluck</code> when:</strong></p>
<p>✅ <strong>Need only column values:</strong></p>
<pre><code class="language-ruby"># Get list of IDs
post_ids = Post.where(published: true).pluck(:id)
User.where(id: post_ids)
</code></pre>
<p>✅ <strong>Populating dropdowns:</strong></p>
<pre><code class="language-ruby"># View helper
def category_options
  Category.pluck(:name, :id)
  # =&gt; [[&quot;Ruby&quot;, 1], [&quot;Rails&quot;, 2]]
end

# In view
&lt;%= select_tag :category_id, options_for_select(category_options) %&gt;
</code></pre>
<p>✅ <strong>Aggregation:</strong></p>
<pre><code class="language-ruby"># Sum prices
total = Order.where(status: &#39;paid&#39;).pluck(:amount).sum

# Average
avg_age = User.pluck(:age).sum / User.count.to_f
</code></pre>
<p>✅ <strong>Checking existence:</strong></p>
<pre><code class="language-ruby"># Check if any emails contain domain
User.pluck(:email).any? { |e| e.end_with?(&#39;@example.com&#39;) }
</code></pre>
<p><strong>Use <code>select</code> when:</strong></p>
<p>✅ <strong>Need model methods:</strong></p>
<pre><code class="language-ruby">users = User.select(:id, :name, :created_at)

users.each do |user|
  puts user.display_name  # Model method
  puts user.created_at.strftime(&quot;%Y-%m-%d&quot;)
end
</code></pre>
<p>✅ <strong>Need associations:</strong></p>
<pre><code class="language-ruby">posts = Post.select(:id, :title, :user_id)
              .includes(:user)

posts.each do |post|
  puts post.user.name  # Association accessible
end
</code></pre>
<p>✅ <strong>JSON serialization:</strong></p>
<pre><code class="language-ruby">users = User.select(:id, :name, :email)
render json: users
</code></pre>
<p>✅ <strong>Building complex queries:</strong></p>
<pre><code class="language-ruby"># Can chain
users = User.select(:id, :name)
            .where(active: true)
            .order(:name)
            .limit(10)
</code></pre>
<hr>
<h3>Advanced Usage</h3>
<p><strong>Pluck with calculations:</strong></p>
<pre><code class="language-ruby"># Calculated columns
User.pluck(&#39;DISTINCT role&#39;)
# =&gt; [&quot;admin&quot;, &quot;user&quot;, &quot;moderator&quot;]

User.pluck(&#39;UPPER(name)&#39;)
# =&gt; [&quot;ALICE&quot;, &quot;BOB&quot;, &quot;CHARLIE&quot;]

# SQL functions
Post.pluck(&#39;DATE(created_at)&#39;, :title)
# =&gt; [[&quot;2024-01-15&quot;, &quot;Title 1&quot;], [&quot;2024-01-16&quot;, &quot;Title 2&quot;]]
</code></pre>
<p><strong>Select with SQL:</strong></p>
<pre><code class="language-ruby"># Custom SQL in select
users = User.select(&#39;users.*, COUNT(posts.id) as posts_count&#39;)
            .left_joins(:posts)
            .group(&#39;users.id&#39;)

users.first.posts_count  # =&gt; 10 (from SQL)
</code></pre>
<p><strong>Pluck with joins:</strong></p>
<pre><code class="language-ruby"># Pluck from joined tables
Post.joins(:user).pluck(&#39;users.name&#39;, &#39;posts.title&#39;)
# =&gt; [[&quot;Alice&quot;, &quot;Post 1&quot;], [&quot;Bob&quot;, &quot;Post 2&quot;]]

# Multiple tables
Comment.joins(:user, :post)
       .pluck(&#39;users.name&#39;, &#39;posts.title&#39;, &#39;comments.body&#39;)
</code></pre>
<p><strong>Select with distinct:</strong></p>
<pre><code class="language-ruby"># Distinct values
User.select(:role).distinct
# =&gt; Users with unique roles

# Equivalent to:
User.pluck(:role).uniq
User.distinct.pluck(:role)
</code></pre>
<hr>
<h3>Common Patterns</h3>
<p><strong>Pattern 1: IDs for IN query</strong></p>
<pre><code class="language-ruby"># Get IDs and query another table
active_user_ids = User.where(active: true).pluck(:id)
Post.where(user_id: active_user_ids)

# Or use subquery (better)
Post.where(user_id: User.where(active: true).select(:id))
</code></pre>
<p><strong>Pattern 2: Dropdown options</strong></p>
<pre><code class="language-ruby"># Controller
@categories = Category.order(:name).pluck(:name, :id)

# View
&lt;%= select_tag :category, options_for_select(@categories) %&gt;
</code></pre>
<p><strong>Pattern 3: Bulk operations</strong></p>
<pre><code class="language-ruby"># Get IDs, perform bulk operation
post_ids = Post.where(draft: true).pluck(:id)
Post.where(id: post_ids).update_all(published: true)
</code></pre>
<p><strong>Pattern 4: Counting unique values</strong></p>
<pre><code class="language-ruby"># Unique roles
User.distinct.pluck(:role).count
# Better than: User.pluck(:role).uniq.count

# Count by role
User.group(:role).count
</code></pre>
<p><strong>Pattern 5: Building hash</strong></p>
<pre><code class="language-ruby"># ID to name mapping
user_names = User.pluck(:id, :name).to_h
# =&gt; {1 =&gt; &quot;Alice&quot;, 2 =&gt; &quot;Bob&quot;}

# Use in view
user_names[post.user_id]
</code></pre>
<hr>
<h3>Performance Best Practices</h3>
<p><strong>1. Pluck for simple data:</strong></p>
<pre><code class="language-ruby"># BAD - loads full objects
User.all.map(&amp;:email)

# GOOD - pluck only emails
User.pluck(:email)
</code></pre>
<p><strong>2. Select for model methods:</strong></p>
<pre><code class="language-ruby"># BAD - loads all columns
User.where(active: true).map(&amp;:display_name)

# GOOD - select only needed
User.select(:id, :first_name, :last_name)
    .where(active: true)
    .map(&amp;:display_name)
</code></pre>
<p><strong>3. Avoid pluck in chains:</strong></p>
<pre><code class="language-ruby"># BAD - can&#39;t chain after pluck
User.pluck(:id).where(...)  # ERROR!

# GOOD - use select
User.select(:id).where(...)
</code></pre>
<p><strong>4. Use pluck for large datasets:</strong></p>
<pre><code class="language-ruby"># BAD - loads 100k objects
User.all.map(&amp;:id)

# GOOD - pluck only IDs
User.pluck(:id)
</code></pre>
<hr>
<h3>Common Mistakes</h3>
<p><strong>Mistake 1: Accessing unselected attributes</strong></p>
<pre><code class="language-ruby">users = User.select(:name)
users.first.email  # =&gt; nil (not loaded!)

# Fix: select all needed columns
users = User.select(:name, :email)
</code></pre>
<p><strong>Mistake 2: Using count after pluck</strong></p>
<pre><code class="language-ruby"># BAD - loads all, then counts
User.pluck(:id).count

# GOOD - count in database
User.count
</code></pre>
<p><strong>Mistake 3: Pluck with associations</strong></p>
<pre><code class="language-ruby"># BAD - can&#39;t access associations
users = User.pluck(:id, :name)
users.first.posts  # ERROR! It&#39;s an array

# GOOD - use select
users = User.select(:id, :name).includes(:posts)
users.first.posts  # Works!
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>pluck</code></strong> returns array of values</li>
<li><strong><code>select</code></strong> returns ActiveRecord objects</li>
<li><strong><code>pluck</code></strong> is faster and uses less memory</li>
<li><strong><code>select</code></strong> allows model methods and associations</li>
<li><strong>Use <code>pluck</code></strong> for simple data extraction</li>
<li><strong>Use <code>select</code></strong> when need objects</li>
<li><strong><code>pluck</code></strong> executes immediately</li>
<li><strong><code>select</code></strong> is lazy</li>
<li><strong>Both</strong> can use SQL expressions</li>
<li><strong>Profile</strong> to choose best option</li>
</ol>
<hr>
<h2>Question 67: How do you use <code>find_by_sql</code> in Rails?</h2>
<h3>Answer</h3>
<p><strong><code>find_by_sql</code></strong> executes raw SQL queries and returns ActiveRecord objects. Use it for complex queries that are difficult or impossible to express with ActiveRecord query interface.</p>
<hr>
<h3>Basic Usage</h3>
<pre><code class="language-ruby"># Simple query
users = User.find_by_sql(&quot;SELECT * FROM users WHERE active = true&quot;)

# Returns array of User objects
users.class  # =&gt; Array
users.first.class  # =&gt; User
users.first.name  # Model methods available

# With ORDER and LIMIT
users = User.find_by_sql(&quot;
  SELECT * FROM users
  WHERE active = true
  ORDER BY created_at DESC
  LIMIT 10
&quot;)
</code></pre>
<hr>
<h3>SQL Interpolation (Dangerous!)</h3>
<pre><code class="language-ruby"># NEVER DO THIS - SQL injection vulnerability!
role = params[:role]
users = User.find_by_sql(&quot;SELECT * FROM users WHERE role = &#39;#{role}&#39;&quot;)
# If role = &quot;admin&#39; OR &#39;1&#39;=&#39;1&quot;
# SQL: SELECT * FROM users WHERE role = &#39;admin&#39; OR &#39;1&#39;=&#39;1&#39;
# Returns ALL users!
</code></pre>
<hr>
<h3>Safe Parameter Binding</h3>
<p><strong>Using question marks:</strong></p>
<pre><code class="language-ruby"># Safe - using placeholders
role = params[:role]
users = User.find_by_sql([
  &quot;SELECT * FROM users WHERE role = ?&quot;,
  role
])

# Multiple parameters
users = User.find_by_sql([
  &quot;SELECT * FROM users WHERE role = ? AND active = ?&quot;,
  params[:role],
  true
])
</code></pre>
<p><strong>Using named placeholders:</strong></p>
<pre><code class="language-ruby"># Named placeholders
users = User.find_by_sql([
  &quot;SELECT * FROM users WHERE role = :role AND age &gt; :min_age&quot;,
  { role: params[:role], min_age: 18 }
])

# More readable for complex queries
query = &lt;&lt;-SQL
  SELECT *
  FROM users
  WHERE role = :role
    AND created_at &gt; :since
    AND active = :active
  ORDER BY name
SQL

users = User.find_by_sql([query, {
  role: &#39;admin&#39;,
  since: 30.days.ago,
  active: true
}])
</code></pre>
<hr>
<h3>Complex Queries</h3>
<p><strong>JOIN queries:</strong></p>
<pre><code class="language-ruby"># Complex join
query = &lt;&lt;-SQL
  SELECT users.*,
         COUNT(posts.id) as posts_count,
         MAX(posts.created_at) as last_post_at
  FROM users
  LEFT JOIN posts ON posts.user_id = users.id
  WHERE users.active = true
  GROUP BY users.id
  HAVING COUNT(posts.id) &gt; ?
  ORDER BY posts_count DESC
  LIMIT 10
SQL

users = User.find_by_sql([query, 5])

# Access calculated columns
users.first.posts_count  # From SQL
users.first.last_post_at  # From SQL
</code></pre>
<p><strong>Subqueries:</strong></p>
<pre><code class="language-ruby">query = &lt;&lt;-SQL
  SELECT *
  FROM users
  WHERE id IN (
    SELECT user_id
    FROM posts
    WHERE published = true
    GROUP BY user_id
    HAVING COUNT(*) &gt; 10
  )
SQL

users = User.find_by_sql(query)
</code></pre>
<p><strong>Window functions:</strong></p>
<pre><code class="language-ruby">query = &lt;&lt;-SQL
  SELECT users.*,
         ROW_NUMBER() OVER (PARTITION BY role ORDER BY created_at) as rank
  FROM users
  WHERE active = true
SQL

users = User.find_by_sql(query)
users.first.rank  # From window function
</code></pre>
<hr>
<h3>When to Use <code>find_by_sql</code></h3>
<p><strong>Use <code>find_by_sql</code> when:</strong></p>
<p>✅ <strong>Complex aggregations:</strong></p>
<pre><code class="language-ruby"># Complex statistics
query = &lt;&lt;-SQL
  SELECT
    DATE_TRUNC(&#39;day&#39;, created_at) as day,
    COUNT(*) as count,
    AVG(amount) as avg_amount,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY amount) as median
  FROM orders
  WHERE created_at &gt; ?
  GROUP BY DATE_TRUNC(&#39;day&#39;, created_at)
  ORDER BY day DESC
SQL

results = Order.find_by_sql([query, 30.days.ago])
</code></pre>
<p>✅ <strong>Database-specific features:</strong></p>
<pre><code class="language-ruby"># PostgreSQL full-text search
query = &lt;&lt;-SQL
  SELECT *, ts_rank(search_vector, query) as rank
  FROM posts,
       to_tsquery(&#39;english&#39;, ?) query
  WHERE search_vector @@ query
  ORDER BY rank DESC
SQL

posts = Post.find_by_sql([query, params[:search]])
</code></pre>
<p>✅ <strong>Performance optimization:</strong></p>
<pre><code class="language-ruby"># Optimized query with hints
query = &lt;&lt;-SQL
  SELECT /*+ INDEX(users idx_users_email) */ *
  FROM users
  WHERE email LIKE ?
SQL

users = User.find_by_sql([query, &quot;%@example.com%&quot;])
</code></pre>
<p><strong>Don&#39;t use when ActiveRecord can handle it:</strong></p>
<p>❌ <strong>Simple queries:</strong></p>
<pre><code class="language-ruby"># BAD - use ActiveRecord
User.find_by_sql(&quot;SELECT * FROM users WHERE active = true&quot;)

# GOOD
User.where(active: true)
</code></pre>
<p>❌ <strong>Basic joins:</strong></p>
<pre><code class="language-ruby"># BAD
User.find_by_sql(&quot;
  SELECT users.* FROM users
  INNER JOIN posts ON posts.user_id = users.id
&quot;)

# GOOD
User.joins(:posts)
</code></pre>
<hr>
<h3>Returning Different Types</h3>
<p><strong>Using connection directly:</strong></p>
<pre><code class="language-ruby"># Returns array of hashes (not objects)
results = ActiveRecord::Base.connection.execute(&quot;
  SELECT role, COUNT(*) as count
  FROM users
  GROUP BY role
&quot;)

results.to_a
# =&gt; [{&quot;role&quot;=&gt;&quot;admin&quot;, &quot;count&quot;=&gt;&quot;5&quot;}, {&quot;role&quot;=&gt;&quot;user&quot;, &quot;count&quot;=&gt;&quot;100&quot;}]
</code></pre>
<p><strong>Using <code>select_all</code>:</strong></p>
<pre><code class="language-ruby"># Returns ActiveRecord::Result
results = ActiveRecord::Base.connection.select_all(&quot;
  SELECT role, COUNT(*) as count
  FROM users
  GROUP BY role
&quot;)

results.to_a
results.to_hash
results.columns  # =&gt; [&quot;role&quot;, &quot;count&quot;]
results.rows     # =&gt; [[&quot;admin&quot;, 5], [&quot;user&quot;, 100]]
</code></pre>
<hr>
<h3>Advanced Examples</h3>
<p><strong>Example 1: Leaderboard</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  def self.leaderboard(limit = 10)
    query = &lt;&lt;-SQL
      SELECT users.*,
             COUNT(DISTINCT posts.id) as posts_count,
             COUNT(DISTINCT comments.id) as comments_count,
             (COUNT(DISTINCT posts.id) * 10 + 
              COUNT(DISTINCT comments.id) * 5) as score
      FROM users
      LEFT JOIN posts ON posts.user_id = users.id
      LEFT JOIN comments ON comments.user_id = users.id
      WHERE users.active = true
      GROUP BY users.id
      ORDER BY score DESC
      LIMIT ?
    SQL
    
    find_by_sql([query, limit])
  end
end

# Usage
leaders = User.leaderboard(10)
leaders.each do |user|
  puts &quot;#{user.name}: #{user.score} points&quot;
end
</code></pre>
<p><strong>Example 2: Recursive CTE</strong></p>
<pre><code class="language-ruby">class Category &lt; ApplicationRecord
  def self.tree_from(root_id)
    query = &lt;&lt;-SQL
      WITH RECURSIVE category_tree AS (
        SELECT *, 0 as level
        FROM categories
        WHERE id = ?
        
        UNION ALL
        
        SELECT c.*, ct.level + 1
        FROM categories c
        INNER JOIN category_tree ct ON c.parent_id = ct.id
      )
      SELECT * FROM category_tree
      ORDER BY level, name
    SQL
    
    find_by_sql([query, root_id])
  end
end

# Usage
tree = Category.tree_from(1)
tree.each do |cat|
  puts &quot;#{&#39;  &#39; * cat.level}#{cat.name}&quot;
end
</code></pre>
<p><strong>Example 3: Time-series analysis</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  def self.daily_stats(start_date, end_date)
    query = &lt;&lt;-SQL
      SELECT
        DATE(created_at) as date,
        COUNT(*) as orders_count,
        SUM(amount) as total_amount,
        AVG(amount) as avg_amount,
        LAG(COUNT(*)) OVER (ORDER BY DATE(created_at)) as prev_day_count
      FROM orders
      WHERE created_at BETWEEN ? AND ?
      GROUP BY DATE(created_at)
      ORDER BY date
    SQL
    
    find_by_sql([query, start_date, end_date])
  end
end
</code></pre>
<hr>
<h3>Testing with <code>find_by_sql</code></h3>
<pre><code class="language-ruby"># spec/models/user_spec.rb
RSpec.describe User do
  describe &#39;.leaderboard&#39; do
    it &#39;returns top users by score&#39; do
      user1 = create(:user)
      user2 = create(:user)
      
      create_list(:post, 5, user: user1)
      create_list(:post, 2, user: user2)
      
      leaders = User.leaderboard(2)
      
      expect(leaders.first).to eq(user1)
      expect(leaders.first.posts_count).to eq(5)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>find_by_sql</code></strong> executes raw SQL</li>
<li><strong>Returns</strong> array of ActiveRecord objects</li>
<li><strong>Use placeholders</strong> for parameters (prevent SQL injection)</li>
<li><strong>Named placeholders</strong> more readable</li>
<li><strong>Access</strong> calculated columns as attributes</li>
<li><strong>Use for</strong> complex queries ActiveRecord can&#39;t handle</li>
<li><strong>Avoid</strong> for simple queries</li>
<li><strong>Model methods</strong> available on results</li>
<li><strong>Can&#39;t chain</strong> ActiveRecord methods after</li>
<li><strong>Always sanitize</strong> user input</li>
</ol>
<hr>
<h2>Question 68: How do you retrieve only specific columns in ActiveRecord?</h2>
<h3>Answer</h3>
<p>You can retrieve specific columns using <strong><code>select</code></strong>, <strong><code>pluck</code></strong>, or <strong><code>pick</code></strong> methods, which reduce memory usage and improve query performance.</p>
<hr>
<h3>Method 1: <code>select</code></h3>
<p><strong>Load specific columns as ActiveRecord objects:</strong></p>
<pre><code class="language-ruby"># Single column
users = User.select(:name)
# SQL: SELECT users.name FROM users

users.first.name  # =&gt; &quot;Alice&quot;
users.first.email # =&gt; nil (not loaded)

# Multiple columns
users = User.select(:id, :name, :email)
# SQL: SELECT users.id, users.name, users.email FROM users

# Using array
columns = [:id, :name, :created_at]
users = User.select(columns)

# SQL string
users = User.select(&#39;id, UPPER(name) as name, email&#39;)
</code></pre>
<p><strong>With conditions:</strong></p>
<pre><code class="language-ruby">users = User.select(:id, :name)
            .where(active: true)
            .order(:name)

# Chain normally
users.limit(10).offset(20)
</code></pre>
<hr>
<h3>Method 2: <code>pluck</code></h3>
<p><strong>Get column values directly as array:</strong></p>
<pre><code class="language-ruby"># Single column
names = User.pluck(:name)
# =&gt; [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]
# SQL: SELECT users.name FROM users

# Multiple columns
data = User.pluck(:id, :name, :email)
# =&gt; [[1, &quot;Alice&quot;, &quot;a@ex.com&quot;], [2, &quot;Bob&quot;, &quot;b@ex.com&quot;]]

# With conditions
emails = User.where(active: true).pluck(:email)
# =&gt; [&quot;alice@example.com&quot;, &quot;bob@example.com&quot;]
</code></pre>
<p><strong>Create hash:</strong></p>
<pre><code class="language-ruby"># ID to name mapping
mapping = User.pluck(:id, :name).to_h
# =&gt; {1 =&gt; &quot;Alice&quot;, 2 =&gt; &quot;Bob&quot;, 3 =&gt; &quot;Charlie&quot;}

# Use in lookups
user_name = mapping[user_id]
</code></pre>
<hr>
<h3>Method 3: <code>pick</code></h3>
<p><strong>Get single value (Rails 6+):</strong></p>
<pre><code class="language-ruby"># Single value from single record
name = User.where(id: 1).pick(:name)
# =&gt; &quot;Alice&quot;
# SQL: SELECT users.name FROM users WHERE id = 1 LIMIT 1

# Multiple columns
id, name = User.where(active: true).pick(:id, :name)
# =&gt; [1, &quot;Alice&quot;]

# Equivalent to:
User.where(id: 1).pluck(:name).first
# But pick is more efficient (adds LIMIT 1)
</code></pre>
<hr>
<h3>Method 4: Raw SQL with <code>select_all</code></h3>
<p><strong>For complex cases:</strong></p>
<pre><code class="language-ruby"># Using connection
result = ActiveRecord::Base.connection.select_all(&quot;
  SELECT id, name, email
  FROM users
  WHERE active = true
&quot;)

result.to_a
# =&gt; [{&quot;id&quot;=&gt;1, &quot;name&quot;=&gt;&quot;Alice&quot;, &quot;email&quot;=&gt;&quot;...&quot;}, ...]

result.rows
# =&gt; [[1, &quot;Alice&quot;, &quot;...&quot;], [2, &quot;Bob&quot;, &quot;...&quot;]]
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<p><strong>Full object vs Select:</strong></p>
<pre><code class="language-ruby"># SLOW - loads all columns
users = User.all
emails = users.map(&amp;:email)
# SQL: SELECT users.* FROM users
# Memory: ~50MB for 10,000 users

# FAST - loads only needed column
users = User.select(:email)
emails = users.map(&amp;:email)
# SQL: SELECT users.email FROM users
# Memory: ~25MB

# FASTEST - pluck (no objects)
emails = User.pluck(:email)
# SQL: SELECT users.email FROM users
# Memory: ~10MB
</code></pre>
<p><strong>Benchmark:</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

Benchmark.bm(15) do |x|
  x.report(&quot;All + map:&quot;) do
    User.all.map(&amp;:email)
  end
  # Time: 150ms, Memory: 50MB
  
  x.report(&quot;Select + map:&quot;) do
    User.select(:email).map(&amp;:email)
  end
  # Time: 80ms, Memory: 25MB
  
  x.report(&quot;Pluck:&quot;) do
    User.pluck(:email)
  end
  # Time: 40ms, Memory: 10MB
end
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong>Use Case 1: Dropdown options</strong></p>
<pre><code class="language-ruby"># Controller
@categories = Category.order(:name).pluck(:name, :id)

# View
&lt;%= select_tag :category, options_for_select(@categories) %&gt;
</code></pre>
<p><strong>Use Case 2: IDs for bulk operations</strong></p>
<pre><code class="language-ruby"># Get IDs
user_ids = User.where(inactive: true).pluck(:id)

# Bulk delete
User.where(id: user_ids).delete_all

# Or use directly
User.where(inactive: true).delete_all
</code></pre>
<p><strong>Use Case 3: API response</strong></p>
<pre><code class="language-ruby"># Slim JSON response
users = User.select(:id, :name, :email)
            .where(active: true)

render json: users
</code></pre>
<p><strong>Use Case 4: Reporting</strong></p>
<pre><code class="language-ruby"># Only data needed for report
report_data = Order.select(:id, :amount, :created_at)
                   .where(created_at: 1.month.ago..Date.today)

total = report_data.sum(:amount)
average = total / report_data.count
</code></pre>
<p><strong>Use Case 5: Checking existence</strong></p>
<pre><code class="language-ruby"># Check if email exists
exists = User.where(email: email).pick(:id).present?

# Or better:
exists = User.exists?(email: email)
</code></pre>
<hr>
<h3>Advanced Techniques</h3>
<p><strong>Calculated columns:</strong></p>
<pre><code class="language-ruby"># SQL expressions
users = User.select(
  :id,
  :first_name,
  :last_name,
  &quot;CONCAT(first_name, &#39; &#39;, last_name) as full_name&quot;,
  &quot;EXTRACT(YEAR FROM created_at) as join_year&quot;
)

users.first.full_name  # From SQL
users.first.join_year  # From SQL
</code></pre>
<p><strong>Distinct values:</strong></p>
<pre><code class="language-ruby"># Distinct columns
roles = User.select(:role).distinct
# or
roles = User.distinct.pluck(:role)

# Multiple columns
pairs = User.select(:role, :department).distinct
</code></pre>
<p><strong>With joins:</strong></p>
<pre><code class="language-ruby"># Select from multiple tables
data = Post.joins(:user)
           .select(
             &#39;posts.id&#39;,
             &#39;posts.title&#39;,
             &#39;users.name as author_name&#39;
           )

data.first.author_name  # From joined table
</code></pre>
<p><strong>Aggregations:</strong></p>
<pre><code class="language-ruby"># Select with aggregations
stats = User.select(
  :role,
  &#39;COUNT(*) as count&#39;,
  &#39;AVG(age) as avg_age&#39;
).group(:role)

stats.first.count    # From COUNT
stats.first.avg_age  # From AVG
</code></pre>
<hr>
<h3>Avoiding Common Pitfalls</h3>
<p><strong>Pitfall 1: Accessing unselected columns</strong></p>
<pre><code class="language-ruby"># BAD
users = User.select(:name)
users.first.email  # =&gt; nil (not loaded!)

# GOOD - select all needed
users = User.select(:name, :email)
users.first.email  # =&gt; &quot;alice@example.com&quot;
</code></pre>
<p><strong>Pitfall 2: Using model methods on partial objects</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
end

# BAD
users = User.select(:first_name)
users.first.full_name  # Error! last_name not loaded

# GOOD
users = User.select(:first_name, :last_name)
users.first.full_name  # Works!
</code></pre>
<p><strong>Pitfall 3: Forgetting to include ID</strong></p>
<pre><code class="language-ruby"># BAD
users = User.select(:name)
user = users.first
user.update(name: &quot;New&quot;)  # Error! ID not loaded

# GOOD
users = User.select(:id, :name)
user = users.first
user.update(name: &quot;New&quot;)  # Works!
</code></pre>
<p><strong>Pitfall 4: Using count after pluck</strong></p>
<pre><code class="language-ruby"># BAD
User.pluck(:id).count  # Loads all IDs, then counts

# GOOD
User.count  # Counts in database
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Export to CSV</strong></p>
<pre><code class="language-ruby">require &#39;csv&#39;

CSV.open(&#39;users.csv&#39;, &#39;w&#39;) do |csv|
  csv &lt;&lt; [&#39;ID&#39;, &#39;Name&#39;, &#39;Email&#39;, &#39;Created&#39;]
  
  # Only load needed columns
  User.select(:id, :name, :email, :created_at)
      .find_each(batch_size: 1000) do |user|
    csv &lt;&lt; [user.id, user.name, user.email, user.created_at]
  end
end
</code></pre>
<p><strong>Example 2: Autocomplete</strong></p>
<pre><code class="language-ruby">class UsersController &lt; ApplicationController
  def autocomplete
    query = params[:q]
    
    # Only load name and ID
    users = User.select(:id, :name)
                .where(&quot;name LIKE ?&quot;, &quot;%#{query}%&quot;)
                .limit(10)
    
    render json: users.map { |u| { id: u.id, name: u.name } }
  end
end
</code></pre>
<p><strong>Example 3: Dashboard stats</strong></p>
<pre><code class="language-ruby">class DashboardController &lt; ApplicationController
  def stats
    # Efficient queries for stats
    @user_count = User.count
    @active_users = User.where(active: true).count
    @admin_names = User.where(role: &#39;admin&#39;).pluck(:name)
    @recent_signups = User.where(&#39;created_at &gt; ?&#39;, 7.days.ago)
                          .select(:id, :name, :created_at)
                          .order(created_at: :desc)
                          .limit(10)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>select</code></strong> for ActiveRecord objects with specific columns</li>
<li><strong><code>pluck</code></strong> for arrays of column values</li>
<li><strong><code>pick</code></strong> for single value (Rails 6+)</li>
<li><strong>Always select ID</strong> if you&#39;ll update records</li>
<li><strong>Use pluck</strong> when only need data</li>
<li><strong>Use select</strong> when need model methods</li>
<li><strong>Performance</strong> improves significantly</li>
<li><strong>Memory</strong> usage reduced</li>
<li><strong>Can use SQL</strong> expressions in select</li>
<li><strong>Profile</strong> to measure impact</li>
</ol>
<hr>
<h2>Question 69: How do you write complex SQL queries using ActiveRecord?</h2>
<h3>Answer</h3>
<p>ActiveRecord provides methods like <strong><code>joins</code></strong>, <strong><code>includes</code></strong>, <strong><code>where</code></strong>, <strong><code>select</code></strong>, <strong><code>group</code></strong>, <strong><code>having</code></strong>, and <strong><code>from</code></strong> to build complex queries. For extremely complex cases, use <strong><code>find_by_sql</code></strong> or <strong>Arel</strong>.</p>
<hr>
<h3>Building Blocks for Complex Queries</h3>
<p><strong>1. Multiple conditions:</strong></p>
<pre><code class="language-ruby"># AND conditions
User.where(active: true)
    .where(role: &#39;admin&#39;)
    .where(&#39;age &gt; ?&#39;, 18)

# SQL: WHERE active = true AND role = &#39;admin&#39; AND age &gt; 18

# OR conditions
User.where(role: &#39;admin&#39;)
    .or(User.where(role: &#39;moderator&#39;))

# SQL: WHERE role = &#39;admin&#39; OR role = &#39;moderator&#39;

# Complex OR
User.where(active: true)
    .where(
      User.where(role: &#39;admin&#39;)
          .or(User.where(&#39;created_at &gt; ?&#39;, 1.week.ago))
    )
</code></pre>
<p><strong>2. Joins:</strong></p>
<pre><code class="language-ruby"># INNER JOIN
User.joins(:posts)

# Multiple joins
User.joins(:posts, :comments)

# Nested joins
User.joins(posts: :comments)

# LEFT JOIN
User.left_joins(:posts)

# Custom JOIN
User.joins(&quot;LEFT JOIN posts ON posts.user_id = users.id AND posts.published = true&quot;)
</code></pre>
<p><strong>3. Subqueries:</strong></p>
<pre><code class="language-ruby"># WHERE with subquery
User.where(
  id: Post.select(:user_id)
          .where(published: true)
          .distinct
)

# FROM subquery
subquery = User.where(active: true).select(:id, :name)
User.from(subquery, :users)
    .where(&#39;users.name LIKE ?&#39;, &#39;A%&#39;)
</code></pre>
<hr>
<h3>Complex Query Examples</h3>
<p><strong>Example 1: Users with post count</strong></p>
<pre><code class="language-ruby"># Method 1: left_joins + group + select
users = User.left_joins(:posts)
            .group(&#39;users.id&#39;)
            .select(
              &#39;users.*&#39;,
              &#39;COUNT(posts.id) as posts_count&#39;
            )

users.first.posts_count  # From SQL

# Method 2: Counter cache (best performance)
class Post &lt; ApplicationRecord
  belongs_to :user, counter_cache: true
end

# Add migration:
add_column :users, :posts_count, :integer, default: 0

# Then just:
user.posts_count  # No query!
</code></pre>
<p><strong>Example 2: Users with no posts</strong></p>
<pre><code class="language-ruby"># Method 1: left_joins
User.left_joins(:posts)
    .where(posts: { id: nil })

# Method 2: NOT IN subquery
User.where.not(
  id: Post.select(:user_id).distinct
)

# Method 3: NOT EXISTS
User.where(
  &#39;NOT EXISTS (SELECT 1 FROM posts WHERE posts.user_id = users.id)&#39;
)
</code></pre>
<p><strong>Example 3: Top authors by post count</strong></p>
<pre><code class="language-ruby">User.joins(:posts)
    .select(
      &#39;users.*&#39;,
      &#39;COUNT(posts.id) as posts_count&#39;
    )
    .group(&#39;users.id&#39;)
    .order(&#39;posts_count DESC&#39;)
    .limit(10)

# SQL:
# SELECT users.*, COUNT(posts.id) as posts_count
# FROM users
# INNER JOIN posts ON posts.user_id = users.id
# GROUP BY users.id
# ORDER BY posts_count DESC
# LIMIT 10
</code></pre>
<p><strong>Example 4: Posts with comment count and likes</strong></p>
<pre><code class="language-ruby">Post.left_joins(:comments, :likes)
    .select(
      &#39;posts.*&#39;,
      &#39;COUNT(DISTINCT comments.id) as comments_count&#39;,
      &#39;COUNT(DISTINCT likes.id) as likes_count&#39;
    )
    .group(&#39;posts.id&#39;)
    .order(&#39;likes_count DESC, comments_count DESC&#39;)

# Access calculated values
posts.first.comments_count
posts.first.likes_count
</code></pre>
<p><strong>Example 5: Search across associations</strong></p>
<pre><code class="language-ruby"># Search posts by title, body, or user name
Post.joins(:user)
    .where(
      &#39;posts.title LIKE :q OR posts.body LIKE :q OR users.name LIKE :q&#39;,
      q: &quot;%#{params[:search]}%&quot;
    )
    .distinct
</code></pre>
<hr>
<h3>Advanced Techniques</h3>
<p><strong>Window functions:</strong></p>
<pre><code class="language-ruby"># Rank users by posts within each role
query = &lt;&lt;-SQL
  SELECT users.*,
         COUNT(posts.id) as posts_count,
         RANK() OVER (
           PARTITION BY users.role
           ORDER BY COUNT(posts.id) DESC
         ) as rank_in_role
  FROM users
  LEFT JOIN posts ON posts.user_id = users.id
  GROUP BY users.id, users.role
SQL

users = User.find_by_sql(query)
users.first.rank_in_role
</code></pre>
<p><strong>Common Table Expressions (CTE):</strong></p>
<pre><code class="language-ruby"># Using WITH clause
query = &lt;&lt;-SQL
  WITH active_users AS (
    SELECT * FROM users WHERE active = true
  ),
  user_stats AS (
    SELECT
      user_id,
      COUNT(*) as post_count
    FROM posts
    GROUP BY user_id
  )
  SELECT
    au.*,
    COALESCE(us.post_count, 0) as posts_count
  FROM active_users au
  LEFT JOIN user_stats us ON us.user_id = au.id
  ORDER BY posts_count DESC
SQL

users = User.find_by_sql(query)
</code></pre>
<p><strong>Recursive queries:</strong></p>
<pre><code class="language-ruby"># Get category tree
query = &lt;&lt;-SQL
  WITH RECURSIVE category_tree AS (
    SELECT id, name, parent_id, 0 as depth
    FROM categories
    WHERE parent_id IS NULL
    
    UNION ALL
    
    SELECT c.id, c.name, c.parent_id, ct.depth + 1
    FROM categories c
    INNER JOIN category_tree ct ON c.parent_id = ct.id
  )
  SELECT * FROM category_tree
  ORDER BY depth, name
SQL

Category.find_by_sql(query)
</code></pre>
<hr>
<h3>Using Arel for Complex Queries</h3>
<p><strong>Arel provides programmatic query building:</strong></p>
<pre><code class="language-ruby"># Basic Arel
users = User.arel_table
posts = Post.arel_table

# Complex condition
User.where(
  users[:active].eq(true).and(
    users[:role].eq(&#39;admin&#39;).or(users[:created_at].gt(1.week.ago))
  )
)

# Subquery
subquery = posts.project(posts[:user_id])
                .where(posts[:published].eq(true))
                .distinct

User.where(users[:id].in(subquery))

# JOIN
User.joins(
  users.join(posts)
       .on(posts[:user_id].eq(users[:id]))
       .join_sources
)
</code></pre>
<p><strong>Complex Arel example:</strong></p>
<pre><code class="language-ruby">users = User.arel_table
posts = Post.arel_table

# Users with &gt; 5 published posts
User.joins(
  users.join(posts, Arel::Nodes::OuterJoin)
       .on(posts[:user_id].eq(users[:id])
          .and(posts[:published].eq(true)))
       .join_sources
)
.group(users[:id])
.having(posts[:id].count.gt(5))
.select(
  users[Arel.star],
  posts[:id].count.as(&#39;posts_count&#39;)
)
</code></pre>
<hr>
<h3>Scopes for Complex Queries</h3>
<p><strong>Reusable complex queries:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  scope :active, -&gt; { where(active: true) }
  scope :admins, -&gt; { where(role: &#39;admin&#39;) }
  
  scope :with_posts_count, -&gt; {
    left_joins(:posts)
      .group(&#39;users.id&#39;)
      .select(&#39;users.*, COUNT(posts.id) as posts_count&#39;)
  }
  
  scope :prolific_authors, -&gt; {
    with_posts_count.having(&#39;COUNT(posts.id) &gt; 10&#39;)
  }
  
  scope :search, -&gt;(query) {
    where(&#39;name LIKE ? OR email LIKE ?&#39;, &quot;%#{query}%&quot;, &quot;%#{query}%&quot;)
  }
  
  scope :recent, -&gt; { where(&#39;created_at &gt; ?&#39;, 30.days.ago) }
end

# Usage - chain scopes
User.active
    .admins
    .prolific_authors
    .search(&#39;john&#39;)
    .recent
</code></pre>
<p><strong>Scope with arguments:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  scope :published_between, -&gt;(start_date, end_date) {
    where(published: true)
      .where(created_at: start_date..end_date)
  }
  
  scope :by_category, -&gt;(category_id) {
    joins(:categories)
      .where(categories: { id: category_id })
  }
  
  scope :popular, -&gt;(threshold = 100) {
    where(&#39;views_count &gt; ?&#39;, threshold)
  }
end

# Usage
Post.published_between(1.month.ago, Date.today)
    .by_category(params[:category_id])
    .popular(500)
</code></pre>
<hr>
<h3>Performance Optimization</h3>
<p><strong>1. Use indexes:</strong></p>
<pre><code class="language-ruby"># Migration
class AddIndexes &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :active
    add_index :posts, [:user_id, :published]
    add_index :posts, :created_at
  end
end
</code></pre>
<p><strong>2. Select only needed columns:</strong></p>
<pre><code class="language-ruby"># BAD
User.joins(:posts).where(posts: { published: true })

# GOOD
User.joins(:posts)
    .where(posts: { published: true })
    .select(&#39;users.id, users.name&#39;)
    .distinct
</code></pre>
<p><strong>3. Use exists for checking:</strong></p>
<pre><code class="language-ruby"># BAD
User.joins(:posts).where(posts: { published: true }).any?
# Loads all records

# GOOD
User.joins(:posts).where(posts: { published: true }).exists?
# Just checks existence
</code></pre>
<p><strong>4. Batch processing:</strong></p>
<pre><code class="language-ruby"># For large datasets
User.where(active: true).find_each(batch_size: 1000) do |user|
  process_user(user)
end
</code></pre>
<hr>
<h3>Complete Real-World Example</h3>
<p><strong>Blog analytics query:</strong></p>
<pre><code class="language-ruby">class PostAnalytics
  def self.top_posts(limit = 10)
    Post.joins(:user)
        .left_joins(:comments, :likes)
        .select(
          &#39;posts.*&#39;,
          &#39;users.name as author_name&#39;,
          &#39;COUNT(DISTINCT comments.id) as comments_count&#39;,
          &#39;COUNT(DISTINCT likes.id) as likes_count&#39;,
          &#39;(COUNT(DISTINCT likes.id) * 2 + COUNT(DISTINCT comments.id)) as engagement_score&#39;
        )
        .where(&#39;posts.published_at &gt; ?&#39;, 30.days.ago)
        .group(&#39;posts.id, users.name&#39;)
        .order(&#39;engagement_score DESC&#39;)
        .limit(limit)
  end
  
  def self.author_stats
    User.joins(:posts)
        .select(
          &#39;users.id&#39;,
          &#39;users.name&#39;,
          &#39;COUNT(posts.id) as total_posts&#39;,
          &#39;SUM(CASE WHEN posts.published THEN 1 ELSE 0 END) as published_posts&#39;,
          &#39;AVG(posts.views_count) as avg_views&#39;,
          &#39;MAX(posts.created_at) as last_post_at&#39;
        )
        .group(&#39;users.id, users.name&#39;)
        .having(&#39;COUNT(posts.id) &gt; 0&#39;)
        .order(&#39;total_posts DESC&#39;)
  end
  
  def self.trending_tags
    Tag.joins(:posts)
       .select(
         &#39;tags.*&#39;,
         &#39;COUNT(posts.id) as posts_count&#39;
       )
       .where(&#39;posts.created_at &gt; ?&#39;, 7.days.ago)
       .where(posts: { published: true })
       .group(&#39;tags.id&#39;)
       .order(&#39;posts_count DESC&#39;)
       .limit(20)
  end
end

# Usage
top_posts = PostAnalytics.top_posts(10)
top_posts.each do |post|
  puts &quot;#{post.title} by #{post.author_name}&quot;
  puts &quot;Likes: #{post.likes_count}, Comments: #{post.comments_count}&quot;
  puts &quot;Score: #{post.engagement_score}&quot;
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Chain methods</strong> for complex queries</li>
<li><strong>Use joins</strong> for filtering by associations</li>
<li><strong>Use select</strong> with GROUP BY for aggregations</li>
<li><strong>Subqueries</strong> with WHERE or FROM</li>
<li><strong>Scopes</strong> for reusable queries</li>
<li><strong>Arel</strong> for programmatic queries</li>
<li><strong>find_by_sql</strong> for raw SQL when needed</li>
<li><strong>Index</strong> columns used in WHERE/JOIN</li>
<li><strong>Test performance</strong> with EXPLAIN</li>
<li><strong>Profile queries</strong> in production</li>
</ol>
<h1>ActiveRecord CRUD Operations Interview Questions</h1>
<h2>Question 70: What is the difference between <code>delete</code> and <code>destroy</code> in ActiveRecord?</h2>
<h3>Answer</h3>
<p><strong><code>delete</code></strong> removes records directly from the database without loading them or running callbacks, while <strong><code>destroy</code></strong> loads records, runs callbacks, and validates dependencies.</p>
<hr>
<h3>Quick Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>delete</code></th>
<th><code>destroy</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Callbacks</strong></td>
<td>❌ Skipped</td>
<td>✅ Executed</td>
</tr>
<tr>
<td><strong>Validations</strong></td>
<td>❌ Skipped</td>
<td>❌ Skipped (on destroy)</td>
</tr>
<tr>
<td><strong>SQL</strong></td>
<td>Direct DELETE</td>
<td>Loads then DELETE</td>
</tr>
<tr>
<td><strong>Speed</strong></td>
<td>Fast</td>
<td>Slower</td>
</tr>
<tr>
<td><strong>Dependencies</strong></td>
<td>❌ Not checked</td>
<td>✅ Checked</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td>Number of rows</td>
<td>Object(s)</td>
</tr>
<tr>
<td><strong>Loads objects</strong></td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<hr>
<h3><code>delete</code> - Direct Database Deletion</h3>
<p><strong>Skips callbacks and validations:</strong></p>
<pre><code class="language-ruby"># Instance method
user = User.find(1)
user.delete
# SQL: DELETE FROM users WHERE id = 1
# Returns: User object (frozen)
# Callbacks: NONE executed

# Class method - delete by ID
User.delete(1)
# SQL: DELETE FROM users WHERE id = 1
# Returns: 1 (number of rows deleted)

# Delete multiple by IDs
User.delete([1, 2, 3])
# SQL: DELETE FROM users WHERE id IN (1, 2, 3)
# Returns: 3

# Delete all (dangerous!)
User.delete_all
# SQL: DELETE FROM users
# Returns: number of rows deleted

# Delete with conditions
User.delete_all(&quot;created_at &lt; ?&quot;, 1.year.ago)
# SQL: DELETE FROM users WHERE created_at &lt; &#39;2023-12-29&#39;
</code></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li><strong>Fast</strong> - single SQL DELETE</li>
<li><strong>No callbacks</strong> - before_destroy, after_destroy skipped</li>
<li><strong>No dependency checks</strong> - dependent: :destroy ignored</li>
<li><strong>No object loading</strong> - goes straight to database</li>
<li><strong>Returns count</strong> (class method) or frozen object (instance method)</li>
</ul>
<hr>
<h3><code>destroy</code> - Safe Deletion with Callbacks</h3>
<p><strong>Runs callbacks and checks dependencies:</strong></p>
<pre><code class="language-ruby"># Instance method
user = User.find(1)
user.destroy
# Steps:
# 1. Runs before_destroy callbacks
# 2. Destroys dependent records
# 3. SQL: DELETE FROM users WHERE id = 1
# 4. Runs after_destroy callbacks
# Returns: User object (frozen)

# Class method - destroy by ID
User.destroy(1)
# Loads object first, then destroys

# Destroy multiple
User.destroy([1, 2, 3])
# Loads each, destroys each with callbacks

# Destroy all
User.destroy_all
# Loads ALL records, destroys each
# SLOW for large datasets!

# Destroy with conditions
User.where(&quot;created_at &lt; ?&quot;, 1.year.ago).destroy_all
# Loads matching records, destroys each
</code></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li><strong>Slower</strong> - loads objects, runs callbacks</li>
<li><strong>Safe</strong> - respects callbacks and dependencies</li>
<li><strong>Complete</strong> - handles associations properly</li>
<li><strong>Returns objects</strong> (frozen)</li>
</ul>
<hr>
<h3>Detailed Examples</h3>
<p><strong>Example 1: Model with Callbacks</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :posts, dependent: :destroy
  has_many :comments
  
  before_destroy :check_admin
  after_destroy :log_deletion
  after_destroy :cleanup_files
  
  private
  
  def check_admin
    if admin?
      errors.add(:base, &quot;Cannot delete admin&quot;)
      throw :abort  # Prevents deletion
    end
  end
  
  def log_deletion
    Rails.logger.info &quot;User #{id} deleted&quot;
  end
  
  def cleanup_files
    # Remove uploaded files
    FileUtils.rm_rf(&quot;uploads/users/#{id}&quot;)
  end
end

# Using destroy - callbacks execute
user = User.find(1)
user.destroy
# 1. check_admin runs
# 2. posts destroyed (dependent: :destroy)
# 3. User deleted
# 4. log_deletion runs
# 5. cleanup_files runs

# Using delete - callbacks SKIPPED
user = User.find(1)
user.delete
# 1. User deleted immediately
# 2. Posts NOT destroyed (orphaned!)
# 3. No logging
# 4. Files not cleaned up
</code></pre>
<p><strong>Example 2: Associations</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  belongs_to :user
  has_many :comments, dependent: :destroy
  has_many :likes, dependent: :delete_all
end

post = Post.create(title: &quot;Hello&quot;)
post.comments.create(body: &quot;Nice!&quot;)
post.likes.create(user: user)

# destroy - respects dependent options
post.destroy
# 1. Comments destroyed (dependent: :destroy) - callbacks run
# 2. Likes deleted (dependent: :delete_all) - no callbacks
# 3. Post deleted

# delete - IGNORES dependent options
post.delete
# 1. Post deleted
# 2. Comments orphaned (comment.post_id still set!)
# 3. Likes orphaned
</code></pre>
<p><strong>Example 3: Performance Impact</strong></p>
<pre><code class="language-ruby"># Scenario: Delete 1000 users

# delete_all - FAST (1 query)
User.where(&quot;inactive = true&quot;).delete_all
# SQL: DELETE FROM users WHERE inactive = true
# Time: ~50ms

# destroy_all - SLOW (1001 queries)
User.where(&quot;inactive = true&quot;).destroy_all
# SQL:
#   SELECT * FROM users WHERE inactive = true (1000 records)
#   DELETE FROM users WHERE id = 1
#   DELETE FROM users WHERE id = 2
#   ... (1000 individual DELETEs)
# Time: ~5000ms (100x slower!)
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use <code>delete</code> when:</strong></p>
<p>✅ <strong>Performance critical:</strong></p>
<pre><code class="language-ruby"># Bulk cleanup - no callbacks needed
LogEntry.delete_all(&quot;created_at &lt; ?&quot;, 30.days.ago)
</code></pre>
<p>✅ <strong>No callbacks needed:</strong></p>
<pre><code class="language-ruby"># Simple join table
Like.delete_all(user_id: user.id)
</code></pre>
<p>✅ <strong>No dependencies:</strong></p>
<pre><code class="language-ruby"># Standalone records
TempFile.delete_all
</code></pre>
<p><strong>Use <code>destroy</code> when:</strong></p>
<p>✅ <strong>Callbacks required:</strong></p>
<pre><code class="language-ruby"># Need to cleanup files, send emails, etc.
user.destroy
</code></pre>
<p>✅ <strong>Has dependencies:</strong></p>
<pre><code class="language-ruby"># Must destroy associated records
post.destroy  # Also destroys comments
</code></pre>
<p>✅ <strong>Business logic in callbacks:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  after_destroy :refund_payment
  after_destroy :notify_customer
end

order.destroy  # Callbacks execute
</code></pre>
<p>✅ <strong>Audit logging:</strong></p>
<pre><code class="language-ruby">class Document &lt; ApplicationRecord
  after_destroy :create_audit_log
end
</code></pre>
<hr>
<h3>Advanced Patterns</h3>
<p><strong>Pattern 1: Conditional deletion</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_destroy :prevent_if_has_orders
  
  private
  
  def prevent_if_has_orders
    if orders.exists?
      errors.add(:base, &quot;Cannot delete user with orders&quot;)
      throw :abort
    end
  end
end

user.destroy
# Returns false if has orders, true if deleted
</code></pre>
<p><strong>Pattern 2: Soft delete (mark as deleted)</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  def destroy
    update(deleted_at: Time.current)
  end
  
  def self.active
    where(deleted_at: nil)
  end
end

# &quot;Delete&quot; user (soft)
user.destroy  # Sets deleted_at

# Actually delete
user.delete   # Removes from database
</code></pre>
<p><strong>Pattern 3: Cascading deletes</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :posts, dependent: :destroy
  has_many :comments, dependent: :destroy
  has_one :profile, dependent: :destroy
end

# destroy - cascades properly
user.destroy
# Destroys posts → destroys post comments
# Destroys user comments
# Destroys profile

# delete - orphans everything
user.delete
# Posts remain with user_id
# Comments remain with user_id
# Profile remains with user_id
</code></pre>
<hr>
<h3>Rollback Behavior</h3>
<p><strong>With transactions:</strong></p>
<pre><code class="language-ruby"># destroy - participates in transactions
ActiveRecord::Base.transaction do
  user.destroy
  raise &quot;Rollback!&quot;  # User NOT deleted
end

# delete - also participates
ActiveRecord::Base.transaction do
  user.delete
  raise &quot;Rollback!&quot;  # User NOT deleted
end

# Both work with transactions, but destroy is safer
</code></pre>
<hr>
<h3>Alternative Methods</h3>
<p><strong><code>delete_by</code> (Rails 6+):</strong></p>
<pre><code class="language-ruby"># Convenient delete with conditions
User.delete_by(inactive: true)
# Equivalent to:
User.where(inactive: true).delete_all
</code></pre>
<p><strong><code>destroy_by</code> (Rails 6+):</strong></p>
<pre><code class="language-ruby"># Convenient destroy with conditions
User.destroy_by(inactive: true)
# Equivalent to:
User.where(inactive: true).destroy_all
</code></pre>
<p><strong>Comparison:</strong></p>
<pre><code class="language-ruby"># All equivalent for deletion
User.where(id: 1).delete_all
User.delete_all(id: 1)
User.delete_by(id: 1)      # Rails 6+
User.delete(1)

# All equivalent for destruction
User.where(id: 1).destroy_all
User.destroy_by(id: 1)     # Rails 6+
User.destroy(1)
</code></pre>
<hr>
<h3>Testing Deletion</h3>
<pre><code class="language-ruby"># RSpec examples
RSpec.describe User do
  describe &#39;#destroy&#39; do
    it &#39;runs callbacks&#39; do
      user = create(:user)
      expect(user).to receive(:cleanup_files)
      user.destroy
    end
    
    it &#39;destroys dependent posts&#39; do
      user = create(:user)
      post = create(:post, user: user)
      
      expect { user.destroy }
        .to change { Post.count }.by(-1)
    end
  end
  
  describe &#39;#delete&#39; do
    it &#39;does not run callbacks&#39; do
      user = create(:user)
      expect(user).not_to receive(:cleanup_files)
      user.delete
    end
    
    it &#39;orphans dependent posts&#39; do
      user = create(:user)
      post = create(:post, user: user)
      
      expect { user.delete }
        .not_to change { Post.count }
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>delete</code></strong> - fast, no callbacks, dangerous</li>
<li><strong><code>destroy</code></strong> - slow, safe, complete</li>
<li><strong>Use <code>destroy</code></strong> by default</li>
<li><strong>Use <code>delete</code></strong> only when performance critical</li>
<li><strong><code>destroy</code></strong> respects dependencies</li>
<li><strong><code>delete</code></strong> can orphan records</li>
<li><strong>Both</strong> work in transactions</li>
<li><strong><code>destroy</code></strong> can be prevented (callbacks)</li>
<li><strong><code>delete</code></strong> cannot be prevented</li>
<li><strong>Test both</strong> behaviors in specs</li>
</ol>
<hr>
<h2>Question 71: How do you perform bulk inserts and updates efficiently?</h2>
<h3>Answer</h3>
<p>Use <strong><code>insert_all</code>/<code>upsert_all</code></strong> (Rails 6+), <strong><code>activerecord-import</code> gem</strong>, or raw SQL for bulk operations. Avoid loops with individual <code>create</code>/<code>update</code> calls.</p>
<hr>
<h3>Inefficient Approach (Don&#39;t Do This)</h3>
<pre><code class="language-ruby"># BAD - N queries for N records
users = []
1000.times do |i|
  User.create(name: &quot;User #{i}&quot;, email: &quot;user#{i}@example.com&quot;)
end
# 1000 INSERT queries!
# Time: ~5000ms

# BAD - update in loop
User.where(active: false).each do |user|
  user.update(status: &#39;inactive&#39;)
end
# N queries for N records
</code></pre>
<hr>
<h3>Efficient Bulk Inserts</h3>
<p><strong>Method 1: <code>insert_all</code> (Rails 6+)</strong></p>
<pre><code class="language-ruby"># Single query for multiple records
users_data = []
1000.times do |i|
  users_data &lt;&lt; {
    name: &quot;User #{i}&quot;,
    email: &quot;user#{i}@example.com&quot;,
    created_at: Time.current,
    updated_at: Time.current
  }
end

User.insert_all(users_data)
# SQL: INSERT INTO users (name, email, created_at, updated_at)
#      VALUES (...), (...), ... (1000 rows)
# Time: ~50ms

# Characteristics:
# - Single SQL INSERT
# - Skips validations
# - Skips callbacks
# - Returns ActiveRecord::Result
# - Requires all records have same columns
</code></pre>
<p><strong>Options for <code>insert_all</code>:</strong></p>
<pre><code class="language-ruby"># With options
User.insert_all(
  users_data,
  unique_by: :email,           # Conflict target
  returning: [:id, :email],    # Return specific columns
  record_timestamps: true      # Auto-add timestamps
)

# Skip duplicates
User.insert_all(users_data, unique_by: :email)
# ON CONFLICT (email) DO NOTHING

# Raises on duplicate (default)
User.insert_all!(users_data)
# Raises ActiveRecord::RecordNotUnique on conflict
</code></pre>
<hr>
<p><strong>Method 2: <code>upsert_all</code> (Rails 6+)</strong></p>
<pre><code class="language-ruby"># Insert or update on conflict
users_data = [
  { id: 1, name: &quot;Alice&quot;, email: &quot;alice@example.com&quot; },
  { id: 2, name: &quot;Bob&quot;, email: &quot;bob@example.com&quot; }
]

User.upsert_all(
  users_data,
  unique_by: :email  # Conflict detection column
)

# SQL: INSERT INTO users (id, name, email)
#      VALUES (1, &#39;Alice&#39;, &#39;alice@example.com&#39;),
#             (2, &#39;Bob&#39;, &#39;bob@example.com&#39;)
#      ON CONFLICT (email)
#      DO UPDATE SET name = EXCLUDED.name

# If email exists → UPDATE
# If email new → INSERT
</code></pre>
<p><strong>Advanced upsert:</strong></p>
<pre><code class="language-ruby">User.upsert_all(
  users_data,
  unique_by: [:email, :provider],  # Composite unique key
  update_only: [:name, :updated_at], # Only update these columns
  on_duplicate: :update            # Postgres/MySQL
)
</code></pre>
<hr>
<p><strong>Method 3: <code>activerecord-import</code> gem</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;activerecord-import&#39;

# Bulk insert with validations
users = []
1000.times do |i|
  users &lt;&lt; User.new(
    name: &quot;User #{i}&quot;,
    email: &quot;user#{i}@example.com&quot;
  )
end

User.import(users)
# Validates all records
# Single INSERT query
# Returns import result

# With options
User.import(
  users,
  validate: true,              # Run validations (default: true)
  on_duplicate_key_update: {   # Update on duplicate
    conflict_target: [:email],
    columns: [:name, :updated_at]
  },
  batch_size: 500,             # Split into batches
  returning: [:id]             # Return IDs (Postgres)
)

# Check results
result = User.import(users)
result.failed_instances  # Records that failed validation
result.num_inserts      # Number of inserts
result.ids              # IDs of inserted records
</code></pre>
<hr>
<p><strong>Method 4: Raw SQL (Maximum Performance)</strong></p>
<pre><code class="language-ruby"># Direct SQL for extreme performance
sql = &quot;INSERT INTO users (name, email, created_at, updated_at) VALUES &quot;

values = 1000.times.map do |i|
  &quot;(#{ActiveRecord::Base.connection.quote(&quot;User #{i}&quot;)}, 
    #{ActiveRecord::Base.connection.quote(&quot;user#{i}@example.com&quot;)},
    #{ActiveRecord::Base.connection.quote(Time.current)},
    #{ActiveRecord::Base.connection.quote(Time.current)})&quot;
end

sql += values.join(&quot;, &quot;)
ActiveRecord::Base.connection.execute(sql)
</code></pre>
<hr>
<h3>Efficient Bulk Updates</h3>
<p><strong>Method 1: <code>update_all</code> (Most Common)</strong></p>
<pre><code class="language-ruby"># Single UPDATE query
User.where(active: false).update_all(status: &#39;inactive&#39;)
# SQL: UPDATE users SET status = &#39;inactive&#39; WHERE active = false
# Time: ~50ms for 1000 records

# Multiple columns
User.where(role: &#39;guest&#39;).update_all(
  role: &#39;user&#39;,
  updated_at: Time.current
)

# With SQL expressions
User.where(trial: true).update_all(
  &quot;credits = credits + 100&quot;
)

# Calculated values
User.update_all(
  &quot;age = EXTRACT(YEAR FROM AGE(CURRENT_DATE, birth_date))&quot;
)
</code></pre>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Single SQL UPDATE</li>
<li>Skips validations</li>
<li>Skips callbacks</li>
<li>Very fast</li>
<li>Returns number of updated rows</li>
</ul>
<hr>
<p><strong>Method 2: <code>upsert_all</code> for Updates</strong></p>
<pre><code class="language-ruby"># Update existing records
updates = User.where(active: false).pluck(:id).map do |id|
  { id: id, status: &#39;inactive&#39;, updated_at: Time.current }
end

User.upsert_all(updates, unique_by: :id)
# Updates by matching ID
</code></pre>
<hr>
<p><strong>Method 3: Case-When for Different Updates</strong></p>
<pre><code class="language-ruby"># Different updates for different records
sql = &lt;&lt;-SQL
  UPDATE users
  SET status = CASE
    WHEN role = &#39;admin&#39; THEN &#39;active&#39;
    WHEN role = &#39;user&#39; THEN &#39;pending&#39;
    ELSE &#39;inactive&#39;
  END
  WHERE active = false
SQL

ActiveRecord::Base.connection.execute(sql)
</code></pre>
<hr>
<p><strong>Method 4: <code>activerecord-import</code> for Updates</strong></p>
<pre><code class="language-ruby">users = User.where(active: false)

users.each do |user|
  user.status = &#39;inactive&#39;
  user.updated_at = Time.current
end

# Bulk update
User.import(
  users,
  on_duplicate_key_update: {
    conflict_target: [:id],
    columns: [:status, :updated_at]
  },
  validate: false  # Skip validations for updates
)
</code></pre>
<hr>
<h3>Batch Processing</h3>
<p><strong>For very large datasets:</strong></p>
<pre><code class="language-ruby"># Process in batches
User.where(active: false).in_batches(of: 1000) do |batch|
  batch.update_all(status: &#39;inactive&#39;)
end

# Or with find_each
User.where(active: false).find_each(batch_size: 1000) do |user|
  # Process individual records if needed
  user.update_column(:status, &#39;inactive&#39;)  # Skips callbacks
end
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

data_size = 10000

Benchmark.bm(20) do |x|
  # Individual creates (SLOW)
  x.report(&quot;create (loop):&quot;) do
    data_size.times do |i|
      User.create(name: &quot;User #{i}&quot;, email: &quot;user#{i}@example.com&quot;)
    end
  end
  # Time: ~15000ms

  # insert_all (FAST)
  x.report(&quot;insert_all:&quot;) do
    data = data_size.times.map do |i|
      { name: &quot;User #{i}&quot;, email: &quot;user#{i}@example.com&quot; }
    end
    User.insert_all(data)
  end
  # Time: ~200ms

  # activerecord-import
  x.report(&quot;import:&quot;) do
    users = data_size.times.map do |i|
      User.new(name: &quot;User #{i}&quot;, email: &quot;user#{i}@example.com&quot;)
    end
    User.import(users, validate: false)
  end
  # Time: ~300ms
end

# Result: insert_all is ~75x faster than loop!
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: CSV Import</strong></p>
<pre><code class="language-ruby">require &#39;csv&#39;

class UserImporter
  def self.import_csv(file_path)
    users = []
    
    CSV.foreach(file_path, headers: true) do |row|
      users &lt;&lt; {
        name: row[&#39;name&#39;],
        email: row[&#39;email&#39;],
        created_at: Time.current,
        updated_at: Time.current
      }
      
      # Batch insert every 1000 records
      if users.size &gt;= 1000
        User.insert_all(users)
        users = []
      end
    end
    
    # Insert remaining
    User.insert_all(users) if users.any?
  end
end

# Usage
UserImporter.import_csv(&#39;users.csv&#39;)
</code></pre>
<p><strong>Example 2: Sync External Data</strong></p>
<pre><code class="language-ruby">class ExternalDataSync
  def sync_users(external_users)
    # Prepare data for upsert
    user_data = external_users.map do |ext_user|
      {
        external_id: ext_user[&#39;id&#39;],
        name: ext_user[&#39;name&#39;],
        email: ext_user[&#39;email&#39;],
        updated_at: Time.current
      }
    end
    
    # Insert new, update existing
    User.upsert_all(
      user_data,
      unique_by: :external_id,
      update_only: [:name, :email, :updated_at]
    )
  end
end
</code></pre>
<p><strong>Example 3: Bulk Status Update</strong></p>
<pre><code class="language-ruby">class OrderBulkUpdater
  def mark_as_shipped(order_ids, tracking_number)
    updates = order_ids.map do |id|
      {
        id: id,
        status: &#39;shipped&#39;,
        tracking_number: tracking_number,
        shipped_at: Time.current,
        updated_at: Time.current
      }
    end
    
    Order.upsert_all(updates, unique_by: :id)
  end
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Always use timestamps:</strong></p>
<pre><code class="language-ruby"># Include created_at and updated_at
User.insert_all(users_data, record_timestamps: true)
</code></pre>
<p><strong>2. Validate before bulk insert:</strong></p>
<pre><code class="language-ruby"># Validate individually first
valid_users = users.select(&amp;:valid?)
invalid_users = users.reject(&amp;:valid?)

# Then bulk insert
User.import(valid_users, validate: false)

# Handle invalid
invalid_users.each do |user|
  Rails.logger.error(&quot;Invalid user: #{user.errors.full_messages}&quot;)
end
</code></pre>
<p><strong>3. Use transactions for safety:</strong></p>
<pre><code class="language-ruby">ActiveRecord::Base.transaction do
  User.insert_all(users_data)
  Profile.insert_all(profiles_data)
  # Both or neither
end
</code></pre>
<p><strong>4. Batch large datasets:</strong></p>
<pre><code class="language-ruby"># Don&#39;t insert 1 million at once
data.each_slice(1000) do |batch|
  User.insert_all(batch)
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>insert_all</code></strong> for bulk inserts (Rails 6+)</li>
<li><strong><code>upsert_all</code></strong> for insert or update (Rails 6+)</li>
<li><strong><code>update_all</code></strong> for bulk updates</li>
<li><strong><code>activerecord-import</code></strong> for validations</li>
<li><strong>Avoid loops</strong> with individual creates/updates</li>
<li><strong>Batch large</strong> datasets (1000-5000 per batch)</li>
<li><strong>Skip validations</strong> when safe</li>
<li><strong>Use transactions</strong> for atomicity</li>
<li><strong>75-100x faster</strong> than loops</li>
<li><strong>Profile</strong> your specific use case</li>
</ol>
<hr>
<h2>Question 72: What is the best way to delete large amounts of data from a table?</h2>
<h3>Answer</h3>
<p>For large deletions, use <strong>batched <code>delete_all</code></strong>, <strong><code>find_in_batches</code></strong>, or <strong>database-level partitioning</strong>. Direct <code>DELETE</code> or <code>TRUNCATE</code> for entire tables.</p>
<hr>
<h3>Approaches for Large Deletions</h3>
<p><strong>1. Direct <code>delete_all</code> (Fast but Risky)</strong></p>
<pre><code class="language-ruby"># Fastest - single query
User.where(&quot;created_at &lt; ?&quot;, 1.year.ago).delete_all
# SQL: DELETE FROM users WHERE created_at &lt; &#39;2023-12-29&#39;
# Time: Fast for moderate sizes
# Problem: Can lock table, timeouts on very large datasets

# Characteristics:
# - Single SQL DELETE
# - No callbacks
# - Can cause table locks
# - Can timeout on millions of rows
</code></pre>
<hr>
<p><strong>2. Batched Deletion (Recommended)</strong></p>
<pre><code class="language-ruby"># Delete in batches to avoid locks
batch_size = 1000
loop do
  deleted_count = User.where(&quot;created_at &lt; ?&quot;, 1.year.ago)
                      .limit(batch_size)
                      .delete_all
  
  break if deleted_count == 0
  
  # Small delay to release locks
  sleep 0.1 if deleted_count &gt; 0
end

# Characteristics:
# - Multiple small DELETEs
# - Releases locks between batches
# - Slower but safer
# - Works for millions of rows
</code></pre>
<p><strong>Improved batched deletion:</strong></p>
<pre><code class="language-ruby">def delete_in_batches(relation, batch_size: 1000)
  total_deleted = 0
  
  loop do
    # Get IDs in batch
    ids = relation.limit(batch_size).pluck(:id)
    break if ids.empty?
    
    # Delete batch
    deleted = relation.where(id: ids).delete_all
    total_deleted += deleted
    
    Rails.logger.info &quot;Deleted #{deleted} records (#{total_deleted} total)&quot;
    
    # Prevent table lock buildup
    sleep 0.01
  end
  
  total_deleted
end

# Usage
old_users = User.where(&quot;created_at &lt; ?&quot;, 1.year.ago)
delete_in_batches(old_users, batch_size: 5000)
</code></pre>
<hr>
<p><strong>3. Using <code>find_in_batches</code> with <code>destroy</code></strong></p>
<pre><code class="language-ruby"># When you need callbacks (slower)
User.where(&quot;created_at &lt; ?&quot;, 1.year.ago)
    .find_in_batches(batch_size: 500) do |batch|
  batch.each(&amp;:destroy)  # Runs callbacks
  sleep 0.1
end

# Or with IDs
User.where(&quot;inactive = true&quot;)
    .in_batches(of: 1000)
    .delete_all
</code></pre>
<hr>
<p><strong>4. Background Jobs (Best for Large Deletions)</strong></p>
<pre><code class="language-ruby"># Job to delete in background
class BulkDeleteJob &lt; ApplicationJob
  queue_as :low_priority
  
  def perform(model_class, conditions, batch_size: 1000)
    relation = model_class.constantize.where(conditions)
    
    loop do
      ids = relation.limit(batch_size).pluck(:id)
      break if ids.empty?
      
      model_class.constantize.where(id: ids).delete_all
      
      # Re-enqueue if more to delete
      if relation.limit(1).exists?
        BulkDeleteJob.set(wait: 10.seconds).perform_later(
          model_class,
          conditions,
          batch_size: batch_size
        )
        break
      end
    end
  end
end

# Usage
BulkDeleteJob.perform_later(
  &#39;User&#39;,
  [&quot;created_at &lt; ?&quot;, 1.year.ago],
  batch_size: 5000
)
</code></pre>
<hr>
<p><strong>5. Database Partitioning (Most Efficient)</strong></p>
<pre><code class="language-ruby"># Migration - create partitioned table
class CreatePartitionedLogs &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE TABLE logs (
        id BIGSERIAL,
        message TEXT,
        created_at TIMESTAMP
      ) PARTITION BY RANGE (created_at);
      
      -- Create partitions for each month
      CREATE TABLE logs_2024_01 PARTITION OF logs
        FOR VALUES FROM (&#39;2024-01-01&#39;) TO (&#39;2024-02-01&#39;);
      
      CREATE TABLE logs_2024_02 PARTITION OF logs
        FOR VALUES FROM (&#39;2024-02-01&#39;) TO (&#39;2024-03-01&#39;);
    SQL
  end
end

# Drop entire partition (instant deletion!)
execute &quot;DROP TABLE logs_2023_01&quot;
# Instantly deletes all January 2023 logs
# No scanning, no locking
</code></pre>
<hr>
<p><strong>6. TRUNCATE (Entire Table)</strong></p>
<pre><code class="language-ruby"># Fastest way to delete ALL data
ActiveRecord::Base.connection.execute(&quot;TRUNCATE TABLE logs&quot;)

# Or with cascade
ActiveRecord::Base.connection.execute(&quot;TRUNCATE TABLE users CASCADE&quot;)

# Characteristics:
# - Instant for any size
# - Resets auto-increment
# - Can&#39;t use WHERE clause
# - Bypasses all triggers/callbacks
# - Use only for complete table wipe
</code></pre>
<hr>
<h3>Handling Foreign Keys</h3>
<p><strong>Problem: Foreign key constraints</strong></p>
<pre><code class="language-ruby"># This fails if posts reference users
User.delete_all
# ERROR: Foreign key violation

# Solution 1: Delete in correct order
Post.delete_all    # Children first
User.delete_all    # Parents second

# Solution 2: Use CASCADE
class AddForeignKeys &lt; ActiveRecord::Migration[7.0]
  def change
    add_foreign_key :posts, :users, on_delete: :cascade
  end
end

# Now deleting user cascades to posts
User.delete_all  # Also deletes all posts

# Solution 3: Temporarily disable constraints (dangerous!)
ActiveRecord::Base.connection.execute(
  &quot;SET CONSTRAINTS ALL DEFERRED&quot;
)
User.delete_all
ActiveRecord::Base.connection.execute(
  &quot;SET CONSTRAINTS ALL IMMEDIATE&quot;
)
</code></pre>
<hr>
<h3>Index Management for Large Deletions</h3>
<p><strong>Drop indexes before large delete:</strong></p>
<pre><code class="language-ruby"># Migration for large data cleanup
class CleanupOldData &lt; ActiveRecord::Migration[7.0]
  def up
    # Drop indexes
    remove_index :users, :email
    remove_index :users, :created_at
    
    # Delete data
    User.where(&quot;created_at &lt; ?&quot;, 2.years.ago).delete_all
    
    # Recreate indexes
    add_index :users, :email
    add_index :users, :created_at
  end
end
</code></pre>
<hr>
<h3>Archiving Before Deletion</h3>
<pre><code class="language-ruby">class UserArchiver
  def archive_and_delete(cutoff_date)
    # 1. Copy to archive table
    ActiveRecord::Base.connection.execute(&lt;&lt;-SQL)
      INSERT INTO archived_users
      SELECT * FROM users
      WHERE created_at &lt; &#39;#{cutoff_date}&#39;
    SQL
    
    # 2. Verify archive
    archived_count = ArchivedUser.where(&quot;created_at &lt; ?&quot;, cutoff_date).count
    original_count = User.where(&quot;created_at &lt; ?&quot;, cutoff_date).count
    
    raise &quot;Archive count mismatch&quot; unless archived_count == original_count
    
    # 3. Delete from main table
    delete_in_batches(
      User.where(&quot;created_at &lt; ?&quot;, cutoff_date),
      batch_size: 5000
    )
  end
end
</code></pre>
<hr>
<h3>Performance Strategies</h3>
<p><strong>Strategy 1: Delete during off-peak hours</strong></p>
<pre><code class="language-ruby"># Schedule deletion
class NightlyCleanupJob &lt; ApplicationJob
  queue_as :maintenance
  
  def perform
    return unless Time.current.hour.between?(2, 4)  # 2-4 AM
    
    delete_in_batches(
      LogEntry.where(&quot;created_at &lt; ?&quot;, 30.days.ago),
      batch_size: 10000
    )
  end
end

# Schedule daily at 3 AM
NightlyCleanupJob.set(wait_until: Date.tomorrow + 3.hours).perform_later
</code></pre>
<hr>
<p><strong>Strategy 2: Soft delete first, hard delete later</strong></p>
<pre><code class="language-ruby"># Step 1: Soft delete (fast)
User.where(&quot;created_at &lt; ?&quot;, 1.year.ago)
    .update_all(deleted_at: Time.current)

# Step 2: Hard delete later in batches
User.where.not(deleted_at: nil)
    .where(&quot;deleted_at &lt; ?&quot;, 30.days.ago)
    .find_in_batches(batch_size: 1000) do |batch|
  User.where(id: batch.map(&amp;:id)).delete_all
  sleep 1
end
</code></pre>
<hr>
<p><strong>Strategy 3: Use database-specific optimizations</strong></p>
<pre><code class="language-ruby"># PostgreSQL - VACUUM after large delete
ActiveRecord::Base.connection.execute(&quot;VACUUM ANALYZE users&quot;)

# MySQL - OPTIMIZE TABLE
ActiveRecord::Base.connection.execute(&quot;OPTIMIZE TABLE users&quot;)

# Defragment and reclaim space
</code></pre>
<hr>
<h3>Monitoring Large Deletions</h3>
<pre><code class="language-ruby">class MonitoredDeletion
  def delete_with_monitoring(relation, batch_size: 1000)
    start_time = Time.current
    total_deleted = 0
    
    loop do
      batch_start = Time.current
      
      ids = relation.limit(batch_size).pluck(:id)
      break if ids.empty?
      
      deleted = relation.where(id: ids).delete_all
      total_deleted += deleted
      
      batch_time = Time.current - batch_start
      
      Rails.logger.info(
        &quot;Deleted #{deleted} records in #{batch_time}s &quot; \
        &quot;(#{total_deleted} total, #{Time.current - start_time}s elapsed)&quot;
      )
      
      # Alert if batch takes too long
      if batch_time &gt; 5.seconds
        Rails.logger.warn &quot;Slow delete batch: #{batch_time}s&quot;
      end
      
      sleep 0.1
    end
    
    Rails.logger.info(
      &quot;Deletion complete: #{total_deleted} records &quot; \
      &quot;in #{Time.current - start_time}s&quot;
    )
  end
end
</code></pre>
<hr>
<h3>Production-Ready Example</h3>
<pre><code class="language-ruby">class LargeDataCleanup
  def self.cleanup_old_logs
    cutoff_date = 90.days.ago
    relation = LogEntry.where(&quot;created_at &lt; ?&quot;, cutoff_date)
    
    # Check count first
    total_count = relation.count
    Rails.logger.info &quot;Will delete #{total_count} log entries&quot;
    
    return if total_count == 0
    
    # Delete in batches
    deleted = 0
    batch_size = 5000
    
    loop do
      ActiveRecord::Base.transaction do
        ids = relation.limit(batch_size).pluck(:id)
        break if ids.empty?
        
        count = LogEntry.where(id: ids).delete_all
        deleted += count
        
        Rails.logger.info(
          &quot;Progress: #{deleted}/#{total_count} &quot; \
          &quot;(#{(deleted.to_f / total_count * 100).round(2)}%)&quot;
        )
      end
      
      # Prevent lock escalation
      sleep 0.5
    end
    
    # Cleanup
    ActiveRecord::Base.connection.execute(&quot;VACUUM ANALYZE log_entries&quot;)
    
    Rails.logger.info &quot;Cleanup complete: #{deleted} records deleted&quot;
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Batch deletions</strong> for large datasets</li>
<li><strong>Use <code>delete_all</code></strong> not <code>destroy_all</code></li>
<li><strong>Delete 1000-10000</strong> per batch</li>
<li><strong>Add sleep</strong> between batches</li>
<li><strong>Background jobs</strong> for millions of rows</li>
<li><strong>Partitioning</strong> for time-series data</li>
<li><strong>Archive first</strong>, delete later</li>
<li><strong>Monitor progress</strong> and timing</li>
<li><strong>VACUUM/OPTIMIZE</strong> after deletion</li>
<li><strong>Test on production copy</strong> first</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 73: How do you implement soft deletes in Rails (e.g., using Paranoia gem)?</h2>
<h3>Answer</h3>
<p><strong>Soft deletes</strong> mark records as deleted without removing them from the database. Implement using a <code>deleted_at</code> timestamp column, manually or with gems like <strong>Paranoia</strong> or <strong>Discard</strong>.</p>
<hr>
<h3>Why Soft Deletes?</h3>
<p><strong>Benefits:</strong>
✅ Data recovery - restore accidentally deleted records
✅ Audit trail - know when records were deleted
✅ Compliance - regulatory requirements to retain data
✅ Analytics - analyze deleted records
✅ Undo functionality - user can restore</p>
<p><strong>Drawbacks:</strong>
❌ Database bloat - deleted records take space
❌ Query complexity - must filter deleted records
❌ Index overhead - indexes include deleted records
❌ Unique constraints - harder to enforce</p>
<hr>
<h3>Method 1: Manual Implementation</h3>
<p><strong>Basic soft delete:</strong></p>
<pre><code class="language-ruby"># Migration
class AddDeletedAtToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :deleted_at, :datetime
    add_index :users, :deleted_at
  end
end

# Model
class User &lt; ApplicationRecord
  # Default scope to exclude deleted
  default_scope { where(deleted_at: nil) }
  
  # Scope for deleted records
  scope :deleted, -&gt; { unscope(where: :deleted_at).where.not(deleted_at: nil) }
  scope :with_deleted, -&gt; { unscope(where: :deleted_at) }
  
  def destroy
    update(deleted_at: Time.current)
  end
  
  def restore
    update(deleted_at: nil)
  end
  
  def deleted?
    deleted_at.present?
  end
end

# Usage
user = User.create(name: &quot;Alice&quot;)

# Soft delete
user.destroy
user.deleted?  # =&gt; true

# Still in database
User.unscoped.find(user.id)  # Found

# Not in default scope
User.find(user.id)  # Raises ActiveRecord::RecordNotFound

# Restore
user.restore
user.deleted?  # =&gt; false
</code></pre>
<hr>
<h3>Method 2: Paranoia Gem (Popular)</h3>
<p><strong>Installation:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;paranoia&#39;, &#39;~&gt; 2.6&#39;

# Migration
class AddDeletedAtToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :deleted_at, :datetime
    add_index :users, :deleted_at
  end
end
</code></pre>
<p><strong>Model setup:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  acts_as_paranoid
  
  # Paranoia provides:
  # - destroyed? method
  # - restore method
  # - really_destroy! method
  # - default scope excluding deleted
end

# Basic usage
user = User.create(name: &quot;Alice&quot;)

# Soft delete
user.destroy
# Sets deleted_at = Time.current
# Returns user object

user.destroyed?  # =&gt; true (Paranoia method)
user.deleted?    # =&gt; true
user.deleted_at  # =&gt; 2024-12-29 10:30:00

# Query scopes
User.all           # Excludes soft-deleted
User.with_deleted  # Includes soft-deleted
User.only_deleted  # Only soft-deleted

# Restore
user.restore
user.destroyed?  # =&gt; false

# Hard delete (permanent)
user.really_destroy!
# Actually removes from database
</code></pre>
<hr>
<p><strong>Advanced Paranoia features:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  acts_as_paranoid
  
  # Custom deleted column
  acts_as_paranoid column: :removed_at
  
  # Callbacks
  before_restore :check_can_restore
  after_restore :send_welcome_back_email
  
  # Associations
  has_many :posts, dependent: :destroy
  # Posts also soft-deleted when user deleted
end

# Restore with associations
user.restore(recursive: true)
# Restores user and all soft-deleted posts

# Force destroy with associations
user.really_destroy!
# Permanently deletes user and posts
</code></pre>
<hr>
<h3>Method 3: Discard Gem (Modern Alternative)</h3>
<p><strong>Installation:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;discard&#39;, &#39;~&gt; 1.3&#39;

# Migration
class AddDiscardedAtToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :discarded_at, :datetime
    add_index :users, :discarded_at
  end
end
</code></pre>
<p><strong>Model setup:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  include Discard::Model
  
  # Discard provides:
  # - discard/discard! methods
  # - undiscard/undiscard! methods
  # - discarded? method
  # - kept/discarded scopes
  # - NO default scope (you choose)
end

# Usage
user = User.create(name: &quot;Alice&quot;)

# Soft delete
user.discard
user.discarded?  # =&gt; true

# Scopes
User.kept       # Not discarded
User.discarded  # Only discarded

# Restore
user.undiscard
user.discarded?  # =&gt; false

# You control default scope
class User &lt; ApplicationRecord
  include Discard::Model
  default_scope -&gt; { kept }  # Only if you want
end
</code></pre>
<p><strong>Why Discard over Paranoia:</strong></p>
<ul>
<li>More explicit (no default scope by default)</li>
<li>Better naming (discard vs destroy)</li>
<li>Lighter weight</li>
<li>More control</li>
</ul>
<hr>
<h3>Complete Implementation Example</h3>
<pre><code class="language-ruby"># Migration
class AddSoftDeleteToModels &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :deleted_at, :datetime
    add_column :users, :deleted_by_id, :bigint
    
    add_column :posts, :deleted_at, :datetime
    add_column :posts, :deleted_by_id, :bigint
    
    add_index :users, :deleted_at
    add_index :posts, :deleted_at
    
    add_foreign_key :users, :users, column: :deleted_by_id
    add_foreign_key :posts, :users, column: :deleted_by_id
  end
end

# Concern for reusability
module SoftDeletable
  extend ActiveSupport::Concern
  
  included do
    belongs_to :deleted_by, class_name: &#39;User&#39;, optional: true
    
    default_scope { where(deleted_at: nil) }
    
    scope :deleted, -&gt; { unscope(where: :deleted_at).where.not(deleted_at: nil) }
    scope :with_deleted, -&gt; { unscope(where: :deleted_at) }
  end
  
  def destroy
    run_callbacks :destroy do
      update_columns(
        deleted_at: Time.current,
        deleted_by_id: Current.user&amp;.id
      )
    end
  end
  
  def restore
    update_columns(deleted_at: nil, deleted_by_id: nil)
  end
  
  def really_destroy!
    # Actually delete
    self.class.unscoped.find(id).delete
  end
  
  def deleted?
    deleted_at.present?
  end
end

# Models
class User &lt; ApplicationRecord
  include SoftDeletable
  
  has_many :posts
end

class Post &lt; ApplicationRecord
  include SoftDeletable
  
  belongs_to :user
end

# Usage
Current.user = User.find(1)  # Set current user

user = User.find(2)
user.destroy

user.deleted?        # =&gt; true
user.deleted_at      # =&gt; 2024-12-29 10:30:00
user.deleted_by      # =&gt; User object (who deleted)
</code></pre>
<hr>
<h3>Handling Associations</h3>
<p><strong>Cascade soft deletes:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  acts_as_paranoid
  
  has_many :posts, dependent: :destroy
  # When user deleted, posts also soft-deleted
end

class Post &lt; ApplicationRecord
  acts_as_paranoid
  
  belongs_to :user
end

user = User.create(name: &quot;Alice&quot;)
post = user.posts.create(title: &quot;Hello&quot;)

user.destroy

# Both soft-deleted
user.destroyed?   # =&gt; true
post.destroyed?   # =&gt; true

# Restore both
user.restore(recursive: true)
</code></pre>
<p><strong>Prevent cascade:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  acts_as_paranoid
  
  has_many :posts
  # Posts not deleted when user deleted
  
  before_destroy :check_posts
  
  private
  
  def check_posts
    if posts.exists?
      errors.add(:base, &quot;Cannot delete user with posts&quot;)
      throw :abort
    end
  end
end
</code></pre>
<hr>
<h3>Unique Constraints with Soft Deletes</h3>
<p><strong>Problem: Unique constraints include deleted records</strong></p>
<pre><code class="language-ruby"># Bad - can&#39;t reuse email after soft delete
class User &lt; ApplicationRecord
  acts_as_paranoid
  validates :email, uniqueness: true
end

user = User.create(email: &quot;alice@example.com&quot;)
user.destroy

# Fails! Email still &quot;taken&quot; by deleted record
User.create(email: &quot;alice@example.com&quot;)
</code></pre>
<p><strong>Solution 1: Scope uniqueness to non-deleted</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  acts_as_paranoid
  
  validates :email, uniqueness: { 
    conditions: -&gt; { where(deleted_at: nil) }
  }
end

# Now works
user = User.create(email: &quot;alice@example.com&quot;)
user.destroy
User.create(email: &quot;alice@example.com&quot;)  # Works!
</code></pre>
<p><strong>Solution 2: Partial index in database</strong></p>
<pre><code class="language-ruby"># Migration
class AddUniqueEmailIndex &lt; ActiveRecord::Migration[7.0]
  def change
    # Only enforce uniqueness for non-deleted
    add_index :users, :email, 
              unique: true,
              where: &quot;deleted_at IS NULL&quot;,
              name: &quot;index_users_on_email_where_not_deleted&quot;
  end
end
</code></pre>
<p><strong>Solution 3: Change email on delete</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  acts_as_paranoid
  
  before_destroy :anonymize_email
  
  private
  
  def anonymize_email
    update_column(:email, &quot;deleted_#{id}_#{email}&quot;)
  end
end

# Email changed to: deleted_123_alice@example.com
</code></pre>
<hr>
<h3>Querying Soft-Deleted Records</h3>
<p><strong>Paranoia scopes:</strong></p>
<pre><code class="language-ruby"># All active
User.all

# Include deleted
User.with_deleted

# Only deleted
User.only_deleted

# Deleted in date range
User.only_deleted.where(
  deleted_at: 1.week.ago..Date.today
)

# Recently deleted
User.only_deleted.where(
  &quot;deleted_at &gt; ?&quot;, 24.hours.ago
)

# Count deleted
User.only_deleted.count
</code></pre>
<p><strong>Custom scopes:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  acts_as_paranoid
  
  scope :deleted_by, -&gt;(user) {
    only_deleted.where(deleted_by: user)
  }
  
  scope :recently_deleted, -&gt; {
    only_deleted.where(&quot;deleted_at &gt; ?&quot;, 7.days.ago)
  }
  
  scope :old_deleted, -&gt; {
    only_deleted.where(&quot;deleted_at &lt; ?&quot;, 1.year.ago)
  }
end
</code></pre>
<hr>
<h3>Admin Interface for Soft Deletes</h3>
<p><strong>Controller:</strong></p>
<pre><code class="language-ruby">class Admin::UsersController &lt; AdminController
  def index
    @users = User.with_deleted.page(params[:page])
  end
  
  def restore
    @user = User.only_deleted.find(params[:id])
    
    if @user.restore
      redirect_to admin_users_path, notice: &quot;User restored&quot;
    else
      redirect_to admin_users_path, alert: &quot;Could not restore user&quot;
    end
  end
  
  def destroy
    @user = User.with_deleted.find(params[:id])
    
    if @user.destroyed?
      # Already soft-deleted, hard delete
      @user.really_destroy!
      redirect_to admin_users_path, notice: &quot;User permanently deleted&quot;
    else
      # Soft delete
      @user.destroy
      redirect_to admin_users_path, notice: &quot;User deleted&quot;
    end
  end
end

# Routes
namespace :admin do
  resources :users do
    member do
      post :restore
    end
  end
end
</code></pre>
<p><strong>View:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/admin/users/index.html.erb --&gt;
&lt;table&gt;
  &lt;% @users.each do |user| %&gt;
    &lt;tr class=&quot;&lt;%= &#39;deleted&#39; if user.destroyed? %&gt;&quot;&gt;
      &lt;td&gt;&lt;%= user.name %&gt;&lt;/td&gt;
      &lt;td&gt;&lt;%= user.email %&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;% if user.destroyed? %&gt;
          &lt;span class=&quot;badge&quot;&gt;Deleted &lt;%= time_ago_in_words(user.deleted_at) %&gt; ago&lt;/span&gt;
          &lt;%= link_to &quot;Restore&quot;, restore_admin_user_path(user), method: :post %&gt;
          &lt;%= link_to &quot;Permanently Delete&quot;, admin_user_path(user), 
                      method: :delete, 
                      data: { confirm: &quot;Permanently delete?&quot; } %&gt;
        &lt;% else %&gt;
          &lt;%= link_to &quot;Delete&quot;, admin_user_path(user), method: :delete %&gt;
        &lt;% end %&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;% end %&gt;
&lt;/table&gt;
</code></pre>
<hr>
<h3>Cleanup Old Soft-Deleted Records</h3>
<p><strong>Rake task:</strong></p>
<pre><code class="language-ruby"># lib/tasks/cleanup.rake
namespace :db do
  desc &quot;Permanently delete old soft-deleted records&quot;
  task cleanup_deleted: :environment do
    cutoff = 90.days.ago
    
    [User, Post, Comment].each do |model|
      if model.respond_to?(:only_deleted)
        old_records = model.only_deleted.where(&quot;deleted_at &lt; ?&quot;, cutoff)
        count = old_records.count
        
        old_records.find_each do |record|
          record.really_destroy!
        end
        
        puts &quot;Permanently deleted #{count} #{model.name.pluralize}&quot;
      end
    end
  end
end

# Run: rake db:cleanup_deleted
</code></pre>
<p><strong>Automated cleanup job:</strong></p>
<pre><code class="language-ruby">class CleanupDeletedRecordsJob &lt; ApplicationJob
  queue_as :low_priority
  
  def perform
    cutoff = 90.days.ago
    
    User.only_deleted
        .where(&quot;deleted_at &lt; ?&quot;, cutoff)
        .find_each do |user|
      user.really_destroy!
    end
  end
end

# Schedule daily
# config/schedule.rb (with whenever gem)
every 1.day, at: &#39;3:00 am&#39; do
  runner &quot;CleanupDeletedRecordsJob.perform_later&quot;
end
</code></pre>
<hr>
<h3>Testing Soft Deletes</h3>
<pre><code class="language-ruby"># spec/models/user_spec.rb
RSpec.describe User do
  describe &#39;soft delete&#39; do
    let(:user) { create(:user) }
    
    it &#39;sets deleted_at on destroy&#39; do
      expect { user.destroy }
        .to change { user.deleted_at }.from(nil)
    end
    
    it &#39;excludes from default scope&#39; do
      user.destroy
      expect(User.all).not_to include(user)
    end
    
    it &#39;can be restored&#39; do
      user.destroy
      user.restore
      
      expect(user.deleted_at).to be_nil
      expect(User.all).to include(user)
    end
    
    it &#39;cascades to associations&#39; do
      post = user.posts.create(title: &quot;Test&quot;)
      user.destroy
      
      expect(post.reload.deleted_at).to be_present
    end
  end
  
  describe &#39;really_destroy!&#39; do
    it &#39;permanently deletes record&#39; do
      user.destroy
      
      expect { user.really_destroy! }
        .to change { User.unscoped.count }.by(-1)
    end
  end
end
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<p><strong>Index deleted_at:</strong></p>
<pre><code class="language-ruby"># Always index deleted_at column
add_index :users, :deleted_at
add_index :posts, :deleted_at

# Composite indexes
add_index :users, [:deleted_at, :created_at]
add_index :posts, [:deleted_at, :user_id]
</code></pre>
<p><strong>Avoid default_scope in large tables:</strong></p>
<pre><code class="language-ruby"># Bad for performance
class User &lt; ApplicationRecord
  default_scope { where(deleted_at: nil) }
end

# Better - explicit scopes
class User &lt; ApplicationRecord
  scope :active, -&gt; { where(deleted_at: nil) }
  scope :deleted, -&gt; { where.not(deleted_at: nil) }
  
  # Use explicitly
  User.active.where(...)
end
</code></pre>
<p><strong>Cleanup strategy:</strong></p>
<pre><code class="language-ruby"># Archive then delete
class User &lt; ApplicationRecord
  def archive_and_destroy
    # 1. Copy to archive table
    ArchivedUser.create(attributes)
    
    # 2. Hard delete
    really_destroy!
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Soft deletes</strong> set <code>deleted_at</code> timestamp</li>
<li><strong>Paranoia gem</strong> for automatic soft deletes</li>
<li><strong>Discard gem</strong> for explicit control</li>
<li><strong>Default scope</strong> excludes deleted records</li>
<li><strong>Scopes</strong> for accessing deleted records</li>
<li><strong>Cascade</strong> to associations carefully</li>
<li><strong>Unique constraints</strong> need special handling</li>
<li><strong>Index</strong> <code>deleted_at</code> column</li>
<li><strong>Cleanup</strong> old deleted records</li>
<li><strong>Test</strong> soft delete behavior</li>
</ol>
<h1>Performance and Optimization Interview Questions</h1>
<h2>Question 74: What is counter cache, and how does it help database performance?</h2>
<h3>Answer</h3>
<p><strong>Counter cache</strong> stores the count of associated records directly on the parent model, eliminating expensive COUNT queries. This dramatically improves performance for displaying counts.</p>
<hr>
<h3>The Problem Without Counter Cache</h3>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :posts
end

class Post &lt; ApplicationRecord
  belongs_to :user
end

# View displaying post counts
&lt;% @users.each do |user| %&gt;
  &lt;%= user.name %&gt;: &lt;%= user.posts.count %&gt; posts
&lt;% end %&gt;

# Generates N+1 queries:
# SELECT * FROM users
# SELECT COUNT(*) FROM posts WHERE user_id = 1
# SELECT COUNT(*) FROM posts WHERE user_id = 2
# SELECT COUNT(*) FROM posts WHERE user_id = 3
# ...

# For 100 users: 101 queries!
</code></pre>
<hr>
<h3>Solution: Counter Cache</h3>
<p><strong>Setup:</strong></p>
<pre><code class="language-ruby"># Step 1: Migration - add counter column
class AddPostsCountToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :posts_count, :integer, default: 0, null: false
  end
end

# Step 2: Model - enable counter cache
class Post &lt; ApplicationRecord
  belongs_to :user, counter_cache: true
end

class User &lt; ApplicationRecord
  has_many :posts
end

# Step 3: Backfill existing counts
User.find_each do |user|
  User.reset_counters(user.id, :posts)
end
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-ruby"># Now this is fast!
&lt;% @users.each do |user| %&gt;
  &lt;%= user.name %&gt;: &lt;%= user.posts_count %&gt; posts
&lt;% end %&gt;

# Only 1 query:
# SELECT * FROM users

# No COUNT queries!
user.posts_count  # Direct column read, no query
</code></pre>
<hr>
<h3>How It Works</h3>
<p><strong>Automatic updates:</strong></p>
<pre><code class="language-ruby">user = User.create(name: &quot;Alice&quot;)
user.posts_count  # =&gt; 0

# Create post - counter increments
post = user.posts.create(title: &quot;Hello&quot;)
user.reload.posts_count  # =&gt; 1

# Create another - counter increments
user.posts.create(title: &quot;World&quot;)
user.reload.posts_count  # =&gt; 2

# Delete post - counter decrements
post.destroy
user.reload.posts_count  # =&gt; 1

# SQL generated:
# UPDATE users SET posts_count = posts_count + 1 WHERE id = 1
# UPDATE users SET posts_count = posts_count - 1 WHERE id = 1
</code></pre>
<hr>
<h3>Advanced Counter Cache</h3>
<p><strong>Custom column name:</strong></p>
<pre><code class="language-ruby">class Comment &lt; ApplicationRecord
  belongs_to :post, counter_cache: :comments_count
  # Looks for posts.comments_count instead of posts.comments_count
end

# Migration
add_column :posts, :comments_count, :integer, default: 0
</code></pre>
<p><strong>Multiple counters:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  has_many :comments
  has_many :approved_comments, -&gt; { where(approved: true) }, 
           class_name: &#39;Comment&#39;
end

class Comment &lt; ApplicationRecord
  belongs_to :post, counter_cache: true
  
  # Custom counter for approved comments
  after_create :increment_approved_count, if: :approved?
  after_destroy :decrement_approved_count, if: :approved?
  after_update :update_approved_count, if: :saved_change_to_approved?
  
  private
  
  def increment_approved_count
    post.increment!(:approved_comments_count)
  end
  
  def decrement_approved_count
    post.decrement!(:approved_comments_count)
  end
  
  def update_approved_count
    if approved?
      post.increment!(:approved_comments_count)
    else
      post.decrement!(:approved_comments_count)
    end
  end
end

# Migration
add_column :posts, :comments_count, :integer, default: 0
add_column :posts, :approved_comments_count, :integer, default: 0
</code></pre>
<hr>
<h3>Conditional Counter Cache</h3>
<pre><code class="language-ruby">class Article &lt; ApplicationRecord
  has_many :comments
  has_many :published_comments, -&gt; { where(published: true) },
           class_name: &#39;Comment&#39;
end

class Comment &lt; ApplicationRecord
  belongs_to :article, counter_cache: true
  
  after_commit :update_published_count, if: :saved_change_to_published?
  
  private
  
  def update_published_count
    if published?
      article.increment!(:published_comments_count)
    else
      article.decrement!(:published_comments_count)
    end
  end
end
</code></pre>
<hr>
<h3>Polymorphic Counter Cache</h3>
<pre><code class="language-ruby">class Like &lt; ApplicationRecord
  belongs_to :likeable, polymorphic: true, counter_cache: true
end

class Post &lt; ApplicationRecord
  has_many :likes, as: :likeable
end

class Comment &lt; ApplicationRecord
  has_many :likes, as: :likeable
end

# Migrations
add_column :posts, :likes_count, :integer, default: 0
add_column :comments, :likes_count, :integer, default: 0

# Usage
post.likes.create(user: user)
post.reload.likes_count  # =&gt; 1
</code></pre>
<hr>
<h3>Resetting Counter Caches</h3>
<p><strong>Manual reset:</strong></p>
<pre><code class="language-ruby"># Reset single counter
User.reset_counters(user_id, :posts)

# Reset all counters for a user
User.reset_counters(user_id, :posts, :comments, :likes)

# Reset for all users
User.find_each do |user|
  User.reset_counters(user.id, :posts)
end
</code></pre>
<p><strong>Rake task for maintenance:</strong></p>
<pre><code class="language-ruby"># lib/tasks/counter_cache.rake
namespace :db do
  desc &quot;Reset all counter caches&quot;
  task reset_counters: :environment do
    puts &quot;Resetting user post counts...&quot;
    User.find_each do |user|
      User.reset_counters(user.id, :posts)
    end
    
    puts &quot;Resetting post comment counts...&quot;
    Post.find_each do |post|
      Post.reset_counters(post.id, :comments)
    end
    
    puts &quot;Done!&quot;
  end
end
</code></pre>
<hr>
<h3>Performance Impact</h3>
<p><strong>Benchmark:</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

# Setup
user = User.create(name: &quot;Alice&quot;)
100.times { user.posts.create(title: &quot;Post&quot;) }

Benchmark.bm do |x|
  # Without counter cache
  x.report(&quot;COUNT query:&quot;) do
    1000.times { user.posts.count }
  end
  # Time: ~500ms (1000 queries)
  
  # With counter cache
  x.report(&quot;Counter cache:&quot;) do
    1000.times { user.posts_count }
  end
  # Time: ~1ms (no queries)
end

# Result: 500x faster!
</code></pre>
<hr>
<h3>Counter Cache with Gems</h3>
<p><strong>counter_culture gem (advanced):</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;counter_culture&#39;

# Model - more features than built-in
class Comment &lt; ApplicationRecord
  belongs_to :post
  
  counter_culture :post,
    column_name: proc { |model| 
      model.approved? ? &#39;approved_comments_count&#39; : nil 
    },
    delta_column: &#39;votes&#39;  # Use custom delta
end

# Features:
# - Conditional counters
# - Multi-level counters (post -&gt; user)
# - Custom column names
# - Delta columns
# - Touch support
</code></pre>
<hr>
<h3>Common Pitfalls</h3>
<p><strong>Pitfall 1: Using count instead of size</strong></p>
<pre><code class="language-ruby"># BAD - always queries database
user.posts.count  # SELECT COUNT(*) FROM posts WHERE user_id = 1

# GOOD - uses counter cache if available
user.posts.size   # Uses posts_count (no query)

# GOOD - direct access
user.posts_count  # Direct column read (no query)
</code></pre>
<p><strong>Pitfall 2: Stale counters</strong></p>
<pre><code class="language-ruby"># Problem: Direct SQL bypasses counter cache
Post.where(user_id: user.id).delete_all
# Counter NOT decremented!

# Solution 1: Use destroy
user.posts.destroy_all

# Solution 2: Reset after direct SQL
Post.where(user_id: user.id).delete_all
User.reset_counters(user.id, :posts)
</code></pre>
<p><strong>Pitfall 3: Forgetting to backfill</strong></p>
<pre><code class="language-ruby"># After adding counter cache to existing app
# Must backfill existing counts!

# Migration
class AddPostsCountToUsers &lt; ActiveRecord::Migration[7.0]
  def up
    add_column :users, :posts_count, :integer, default: 0
    
    # Backfill
    User.find_each do |user|
      User.reset_counters(user.id, :posts)
    end
  end
  
  def down
    remove_column :users, :posts_count
  end
end
</code></pre>
<hr>
<h3>Testing Counter Caches</h3>
<pre><code class="language-ruby"># spec/models/post_spec.rb
RSpec.describe Post do
  describe &#39;counter cache&#39; do
    let(:user) { create(:user) }
    
    it &#39;increments on create&#39; do
      expect { create(:post, user: user) }
        .to change { user.reload.posts_count }.by(1)
    end
    
    it &#39;decrements on destroy&#39; do
      post = create(:post, user: user)
      
      expect { post.destroy }
        .to change { user.reload.posts_count }.by(-1)
    end
    
    it &#39;updates on association change&#39; do
      post = create(:post, user: user)
      other_user = create(:user)
      
      expect {
        post.update(user: other_user)
      }.to change { user.reload.posts_count }.by(-1)
        .and change { other_user.reload.posts_count }.by(1)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Counter cache</strong> eliminates COUNT queries</li>
<li><strong>Use <code>size</code></strong> not <code>count</code> to leverage cache</li>
<li><strong>Add <code>default: 0</code></strong> to counter columns</li>
<li><strong>Backfill</strong> existing counts after migration</li>
<li><strong>Reset counters</strong> if they drift</li>
<li><strong>Avoid direct SQL</strong> that bypasses counters</li>
<li><strong>500x faster</strong> than COUNT queries</li>
<li><strong>Test</strong> counter behavior</li>
<li><strong>Custom counters</strong> for complex cases</li>
<li><strong>Polymorphic</strong> counters supported</li>
</ol>
<hr>
<h2>Question 75: What is Russian Doll Caching?</h2>
<h3>Answer</h3>
<p><strong>Russian Doll Caching</strong> is a nested fragment caching strategy where cached fragments contain other cached fragments, like Russian nesting dolls. Updates to inner fragments automatically invalidate outer fragments through cache keys.</p>
<hr>
<h3>Basic Concept</h3>
<pre><code>[User Profile]                    ← Outer cache
  [User Info]                     ← Inner cache
  [Posts List]                    ← Inner cache
    [Post 1]                      ← Inner cache
    [Post 2]                      ← Inner cache
    [Post 3]                      ← Inner cache
</code></pre>
<p>When Post 1 updates:</p>
<ul>
<li>Post 1 cache invalidates</li>
<li>Posts List cache invalidates (contains Post 1)</li>
<li>User Profile cache invalidates (contains Posts List)</li>
<li>User Info cache stays valid (not affected)</li>
</ul>
<hr>
<h3>How It Works</h3>
<p><strong>Cache keys with updated_at:</strong></p>
<pre><code class="language-ruby"># View: app/views/users/show.html.erb
&lt;% cache @user do %&gt;
  &lt;h1&gt;&lt;%= @user.name %&gt;&lt;/h1&gt;
  
  &lt;% cache [&#39;v1&#39;, @user, &#39;posts&#39;] do %&gt;
    &lt;% @user.posts.each do |post| %&gt;
      &lt;% cache post do %&gt;
        &lt;%= render post %&gt;
      &lt;% end %&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

# Generated cache keys:
# views/users/123-20241229103000/v1/users/123-20241229103000/posts
# views/posts/1-20241229100000
# views/posts/2-20241229101000
# views/posts/3-20241229102000

# When post 1 updates:
# - posts/1-20241229105000 (new timestamp)
# - Parent key changes automatically
# - Old caches expire naturally
</code></pre>
<hr>
<h3>Touch Associations</h3>
<p><strong>Automatic cache invalidation:</strong></p>
<pre><code class="language-ruby"># Models
class User &lt; ApplicationRecord
  has_many :posts
end

class Post &lt; ApplicationRecord
  belongs_to :user, touch: true  # Updates user.updated_at
  has_many :comments
end

class Comment &lt; ApplicationRecord
  belongs_to :post, touch: true  # Updates post.updated_at
end

# Chain reaction:
# Comment created
# → Post.updated_at updated (touch: true)
# → User.updated_at updated (touch: true)
# → All cache keys change
# → Stale caches ignored
</code></pre>
<hr>
<h3>Complete Example</h3>
<p><strong>Models with touch:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  belongs_to :user, touch: true
  has_many :comments
  has_many :tags
  
  # Custom touch
  after_save :touch_tags
  
  private
  
  def touch_tags
    tags.update_all(updated_at: Time.current)
  end
end

class Comment &lt; ApplicationRecord
  belongs_to :post, touch: true
  belongs_to :user
end

class Tag &lt; ApplicationRecord
  has_and_belongs_to_many :posts
end
</code></pre>
<p><strong>Views:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/show.html.erb --&gt;
&lt;% cache @post do %&gt;
  &lt;article&gt;
    &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
    
    &lt;!-- Nested: Author info --&gt;
    &lt;% cache [@post, &#39;author&#39;] do %&gt;
      &lt;%= render &#39;author&#39;, user: @post.user %&gt;
    &lt;% end %&gt;
    
    &lt;!-- Nested: Post content --&gt;
    &lt;% cache [@post, &#39;content&#39;] do %&gt;
      &lt;div class=&quot;content&quot;&gt;
        &lt;%= @post.body %&gt;
      &lt;/div&gt;
    &lt;% end %&gt;
    
    &lt;!-- Nested: Tags --&gt;
    &lt;% cache [@post, &#39;tags&#39;] do %&gt;
      &lt;div class=&quot;tags&quot;&gt;
        &lt;% @post.tags.each do |tag| %&gt;
          &lt;% cache tag do %&gt;
            &lt;%= link_to tag.name, tag_path(tag) %&gt;
          &lt;% end %&gt;
        &lt;% end %&gt;
      &lt;/div&gt;
    &lt;% end %&gt;
    
    &lt;!-- Nested: Comments --&gt;
    &lt;% cache [@post, &#39;comments&#39;] do %&gt;
      &lt;%= render &#39;comments&#39;, comments: @post.comments %&gt;
    &lt;% end %&gt;
  &lt;/article&gt;
&lt;% end %&gt;

&lt;!-- app/views/posts/_comments.html.erb --&gt;
&lt;% cache [&#39;v1&#39;, comments.maximum(:updated_at), comments.count] do %&gt;
  &lt;div class=&quot;comments&quot;&gt;
    &lt;h2&gt;&lt;%= comments.count %&gt; Comments&lt;/h2&gt;
    
    &lt;% comments.each do |comment| %&gt;
      &lt;% cache comment do %&gt;
        &lt;%= render comment %&gt;
      &lt;% end %&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
&lt;% end %&gt;

&lt;!-- app/views/comments/_comment.html.erb --&gt;
&lt;% cache comment do %&gt;
  &lt;div class=&quot;comment&quot;&gt;
    &lt;p&gt;&lt;%= comment.body %&gt;&lt;/p&gt;
    &lt;small&gt;by &lt;%= comment.user.name %&gt;&lt;/small&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Cache Key Strategies</h3>
<p><strong>Version numbers:</strong></p>
<pre><code class="language-ruby"># Include version in cache key
&lt;% cache [&#39;v2&#39;, @post] do %&gt;
  &lt;%= render @post %&gt;
&lt;% end %&gt;

# When layout changes, bump version to &#39;v3&#39;
# All caches invalidate automatically
</code></pre>
<p><strong>Collection caching:</strong></p>
<pre><code class="language-ruby"># Efficient collection caching
&lt;% cache [&#39;posts-list&#39;, @posts.maximum(:updated_at), @posts.count] do %&gt;
  &lt;% @posts.each do |post| %&gt;
    &lt;% cache post do %&gt;
      &lt;%= render post %&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

# Cache key includes:
# - Maximum updated_at (changes when any post updates)
# - Count (changes when posts added/removed)
</code></pre>
<p><strong>Custom cache keys:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  # Custom cache key
  def cache_key_with_version
    &quot;#{cache_key}-#{cache_version}&quot;
  end
  
  def cache_version
    # Include related data in version
    [
      updated_at.to_i,
      comments.maximum(:updated_at)&amp;.to_i,
      tags.maximum(:updated_at)&amp;.to_i
    ].compact.join(&#39;-&#39;)
  end
end
</code></pre>
<hr>
<h3>Performance Impact</h3>
<p><strong>Before Russian Doll Caching:</strong></p>
<pre><code class="language-ruby"># Every page load:
# 1. Query user
# 2. Query all posts
# 3. Query all comments
# 4. Query all tags
# 5. Render everything

# Time: ~500ms per page
# Database: 50+ queries
</code></pre>
<p><strong>After Russian Doll Caching:</strong></p>
<pre><code class="language-ruby"># First load:
# - Same as before (cache miss)
# - Stores cached fragments

# Subsequent loads:
# - Check cache keys
# - Return cached HTML
# - No queries (except cache check)

# Time: ~50ms per page (10x faster)
# Database: 1-2 queries

# Partial update (1 comment added):
# - Comment cache miss (new)
# - Comments collection cache miss
# - Post cache miss (updated_at changed)
# - Other caches hit

# Time: ~100ms (still 5x faster)
</code></pre>
<hr>
<h3>Advanced Patterns</h3>
<p><strong>Conditional caching:</strong></p>
<pre><code class="language-ruby">&lt;% cache_if user_signed_in?, @post do %&gt;
  &lt;%= render @post %&gt;
&lt;% end %&gt;

# Cache for logged-in users only
# Anonymous users always get fresh content
</code></pre>
<p><strong>Cache with expiry:</strong></p>
<pre><code class="language-ruby">&lt;% cache @post, expires_in: 12.hours do %&gt;
  &lt;%= render @post %&gt;
&lt;% end %&gt;

# Expires after 12 hours regardless of updates
</code></pre>
<p><strong>Multi-key caching:</strong></p>
<pre><code class="language-ruby">&lt;% cache [current_user, @post, &#39;personalized&#39;] do %&gt;
  &lt;h1&gt;Hello, &lt;%= current_user.name %&gt;!&lt;/h1&gt;
  &lt;%= render @post %&gt;
&lt;% end %&gt;

# Different cache per user
# Key includes: user ID, post ID, updated_at
</code></pre>
<hr>
<h3>Cache Store Configuration</h3>
<pre><code class="language-ruby"># config/environments/production.rb
config.cache_store = :redis_cache_store, {
  url: ENV[&#39;REDIS_URL&#39;],
  expires_in: 1.week,
  namespace: &#39;myapp&#39;,
  pool_size: 5,
  pool_timeout: 5
}

# Best practices:
# - Use Redis for fragment caching
# - Set reasonable expiry
# - Use namespace for multiple apps
# - Configure pool for concurrency
</code></pre>
<hr>
<h3>Monitoring Cache Performance</h3>
<pre><code class="language-ruby"># Log cache hits/misses
ActiveSupport::Notifications.subscribe(&#39;cache_read.active_support&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  
  hit = event.payload[:hit]
  key = event.payload[:key]
  
  Rails.logger.info &quot;Cache #{hit ? &#39;HIT&#39; : &#39;MISS&#39;}: #{key}&quot;
end

# Track metrics
class CacheMetrics
  def self.record_hit(key)
    # Send to monitoring (DataDog, New Relic, etc.)
    StatsD.increment(&#39;cache.hit&#39;, tags: [&quot;key:#{key}&quot;])
  end
  
  def self.record_miss(key)
    StatsD.increment(&#39;cache.miss&#39;, tags: [&quot;key:#{key}&quot;])
  end
end
</code></pre>
<hr>
<h3>Testing</h3>
<pre><code class="language-ruby"># spec/views/posts/show.html.erb_spec.rb
RSpec.describe &#39;posts/show&#39; do
  it &#39;caches post content&#39; do
    post = create(:post)
    
    # First render - cache miss
    expect(Rails.cache).to receive(:write)
    render
    
    # Second render - cache hit
    expect(Rails.cache).to receive(:read).and_return(rendered)
    render
  end
  
  it &#39;invalidates cache when post updates&#39; do
    post = create(:post)
    
    render
    cached_content = rendered
    
    post.update(title: &quot;New Title&quot;)
    render
    
    expect(rendered).not_to eq(cached_content)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Nested caches</strong> like Russian dolls</li>
<li><strong>Touch associations</strong> for auto-invalidation</li>
<li><strong>Cache keys</strong> include updated_at</li>
<li><strong>Inner updates</strong> invalidate outer caches</li>
<li><strong>Collection caching</strong> with max updated_at</li>
<li><strong>Version numbers</strong> for layout changes</li>
<li><strong>Redis</strong> recommended for production</li>
<li><strong>10x faster</strong> page loads</li>
<li><strong>Monitor</strong> hit/miss rates</li>
<li><strong>Test</strong> cache behavior</li>
</ol>
<hr>
<h2>Question 76: Explain Rails caching techniques (fragment caching, page caching, action caching)</h2>
<h3>Answer</h3>
<p>Rails provides multiple caching layers: <strong>Fragment caching</strong> (cache view partials), <strong>Page caching</strong> (static HTML files), <strong>Action caching</strong> (like page caching with filters), and <strong>Low-level caching</strong> (manual caching). Modern Rails focuses on fragment caching.</p>
<hr>
<h3>1. Fragment Caching (Most Common)</h3>
<p><strong>Cache parts of views:</strong></p>
<pre><code class="language-ruby"># app/views/posts/show.html.erb
&lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;

&lt;% cache @post do %&gt;
  &lt;div class=&quot;content&quot;&gt;
    &lt;%= markdown(@post.body) %&gt;  # Expensive rendering
  &lt;/div&gt;
&lt;% end %&gt;

&lt;% cache [@post, &#39;sidebar&#39;] do %&gt;
  &lt;%= render &#39;sidebar&#39; %&gt;
&lt;% end %&gt;

# Cache keys:
# views/posts/123-20241229103000
# views/posts/123-20241229103000/sidebar
</code></pre>
<p><strong>With collections:</strong></p>
<pre><code class="language-ruby">&lt;% cache [&#39;posts&#39;, @posts.maximum(:updated_at), @posts.count] do %&gt;
  &lt;% @posts.each do |post| %&gt;
    &lt;% cache post do %&gt;
      &lt;%= render post %&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>Configuration:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.action_controller.perform_caching = true
config.cache_store = :redis_cache_store, {
  url: ENV[&#39;REDIS_URL&#39;],
  expires_in: 90.minutes
}
</code></pre>
<hr>
<h3>2. Page Caching (Deprecated in Rails 4)</h3>
<p><strong>Static HTML files served directly by web server:</strong></p>
<pre><code class="language-ruby"># Gemfile (Rails 4+)
gem &#39;actionpack-page_caching&#39;

# Controller
class PostsController &lt; ApplicationController
  caches_page :index, :show
  
  def index
    @posts = Post.all
  end
  
  def show
    @post = Post.find(params[:id])
  end
end

# Generated files:
# public/posts.html
# public/posts/123.html

# Web server (Nginx) serves these directly
# Rails never hit!

# Expire cache:
expire_page action: :show, id: @post.id
</code></pre>
<p><strong>Nginx configuration:</strong></p>
<pre><code class="language-nginx">location / {
  # Try cached file first
  try_files /cache/$uri.html $uri @app;
}

location @app {
  proxy_pass http://rails_app;
}
</code></pre>
<p><strong>Limitations:</strong></p>
<ul>
<li>❌ No dynamic content (user-specific)</li>
<li>❌ No authentication</li>
<li>❌ Manual expiration needed</li>
<li>✅ Fastest possible (no Rails)</li>
<li>✅ Great for static pages</li>
</ul>
<hr>
<h3>3. Action Caching (Deprecated in Rails 4)</h3>
<p><strong>Like page caching but runs filters:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;actionpack-action_caching&#39;

# Controller
class PostsController &lt; ApplicationController
  before_action :authenticate_user!
  caches_action :show, :index
  
  cache_sweeper :post_sweeper
  
  def show
    @post = Post.find(params[:id])
  end
end

# Runs filters (authentication) THEN checks cache
# Better than page caching for protected pages
# But still no user-specific content
</code></pre>
<p><strong>Cache sweeper:</strong></p>
<pre><code class="language-ruby">class PostSweeper &lt; ActionController::Caching::Sweeper
  observe Post
  
  def after_update(post)
    expire_action controller: &#39;posts&#39;, action: &#39;show&#39;, id: post.id
  end
end
</code></pre>
<hr>
<h3>4. Low-Level Caching</h3>
<p><strong>Manual caching with Rails.cache:</strong></p>
<pre><code class="language-ruby"># Simple read/write
Rails.cache.write(&#39;key&#39;, &#39;value&#39;, expires_in: 1.hour)
value = Rails.cache.read(&#39;key&#39;)

# Fetch (read or write)
posts = Rails.cache.fetch(&#39;recent_posts&#39;, expires_in: 1.hour) do
  Post.recent.limit(10).to_a
end

# Delete
Rails.cache.delete(&#39;key&#39;)

# Clear all
Rails.cache.clear
</code></pre>
<p><strong>In models:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  def self.trending
    Rails.cache.fetch(&#39;trending_posts&#39;, expires_in: 1.hour) do
      where(&#39;created_at &gt; ?&#39;, 24.hours.ago)
        .order(views: :desc)
        .limit(10)
        .to_a
    end
  end
  
  after_save :clear_trending_cache
  
  private
  
  def clear_trending_cache
    Rails.cache.delete(&#39;trending_posts&#39;)
  end
end
</code></pre>
<hr>
<h3>5. HTTP Caching</h3>
<p><strong>Browser and proxy caching:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    
    # Conditional GET (ETag)
    if stale?(etag: @post, last_modified: @post.updated_at)
      respond_to do |format|
        format.html
        format.json { render json: @post }
      end
    end
    
    # Returns 304 Not Modified if unchanged
  end
  
  def index
    @posts = Post.all
    
    # Cache-Control header
    expires_in 5.minutes, public: true
  end
end

# HTTP headers sent:
# ETag: &quot;...&quot;
# Last-Modified: Mon, 29 Dec 2024 10:00:00 GMT
# Cache-Control: public, max-age=300
</code></pre>
<hr>
<h3>6. SQL Query Caching</h3>
<p><strong>Automatic within single request:</strong></p>
<pre><code class="language-ruby"># Automatic - same query within request
def show
  @user = User.find(1)      # Query 1
  @user2 = User.find(1)     # Cached!
  
  @posts = Post.where(published: true)  # Query 2
  @posts2 = Post.where(published: true) # Cached!
end

# Only 2 queries total
# Cleared after request completes
</code></pre>
<hr>
<h3>Cache Store Options</h3>
<p><strong>1. Memory Store (Development):</strong></p>
<pre><code class="language-ruby">config.cache_store = :memory_store, { size: 64.megabytes }

# Fast, simple
# Lost on restart
# Not shared across processes
</code></pre>
<p><strong>2. File Store:</strong></p>
<pre><code class="language-ruby">config.cache_store = :file_store, Rails.root.join(&#39;tmp&#39;, &#39;cache&#39;)

# Persistent
# Slow
# Good for small apps
</code></pre>
<p><strong>3. Redis (Production - Recommended):</strong></p>
<pre><code class="language-ruby">config.cache_store = :redis_cache_store, {
  url: ENV[&#39;REDIS_URL&#39;],
  namespace: &#39;myapp&#39;,
  expires_in: 90.minutes,
  pool_size: 5
}

# Fast
# Shared across processes
# Production-ready
</code></pre>
<p><strong>4. Memcached:</strong></p>
<pre><code class="language-ruby">config.cache_store = :mem_cache_store, 
  &#39;cache1.example.com&#39;,
  &#39;cache2.example.com&#39;,
  {
    namespace: &#39;myapp&#39;,
    expires_in: 90.minutes
  }

# Very fast
# Distributed
# No persistence
</code></pre>
<hr>
<h3>Complete Caching Strategy</h3>
<p><strong>Multi-layer approach:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  # 1. HTTP Caching (Browser/CDN)
  def show
    @post = Post.find(params[:id])
    
    expires_in 5.minutes, public: true
    
    if stale?(@post)
      # 2. Fragment caching (Redis)
      # Views use fragment caching
      render
    end
  end
  
  def index
    # 3. Low-level caching (Redis)
    @posts = Rails.cache.fetch(&#39;posts_index&#39;, expires_in: 1.hour) do
      Post.published.includes(:user).recent.to_a
    end
    
    expires_in 5.minutes, public: true
  end
end

# View uses fragment caching
&lt;% cache @post do %&gt;
  &lt;%= render @post %&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Cache Invalidation Strategies</h3>
<p><strong>1. Time-based expiration:</strong></p>
<pre><code class="language-ruby">Rails.cache.fetch(&#39;key&#39;, expires_in: 1.hour) do
  expensive_operation
end
</code></pre>
<p><strong>2. Touch-based (Russian Doll):</strong></p>
<pre><code class="language-ruby">class Comment &lt; ApplicationRecord
  belongs_to :post, touch: true
end

# Comment updated → Post updated_at changes → Cache key changes
</code></pre>
<p><strong>3. Manual expiration:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  after_save :clear_cache
  
  private
  
  def clear_cache
    Rails.cache.delete(&#39;trending_posts&#39;)
    Rails.cache.delete([&#39;posts_index&#39;])
  end
end
</code></pre>
<p><strong>4. Cache sweepers (observers):</strong></p>
<pre><code class="language-ruby">class PostCacheSweeper
  def self.sweep(post)
    Rails.cache.delete([&#39;posts&#39;, &#39;list&#39;])
    Rails.cache.delete([&#39;posts&#39;, post.id])
    Rails.cache.delete([&#39;posts&#39;, &#39;trending&#39;])
  end
end

class Post &lt; ApplicationRecord
  after_commit :sweep_cache
  
  def sweep_cache
    PostCacheSweeper.sweep(self)
  end
end
</code></pre>
<hr>
<h3>Testing Caching</h3>
<pre><code class="language-ruby"># spec/requests/posts_spec.rb
RSpec.describe &#39;Posts&#39; do
  describe &#39;GET /posts/:id&#39; do
    it &#39;returns 304 when not modified&#39; do
      post = create(:post)
      
      # First request
      get post_path(post)
      expect(response).to have_http_status(:ok)
      etag = response.headers[&#39;ETag&#39;]
      
      # Second request with ETag
      get post_path(post), headers: { &#39;If-None-Match&#39; =&gt; etag }
      expect(response).to have_http_status(:not_modified)
    end
  end
end

# spec/models/post_spec.rb
RSpec.describe Post do
  it &#39;caches trending posts&#39; do
    expect(Post).to receive(:expensive_query).once.and_call_original
    
    2.times { Post.trending }
  end
  
  it &#39;clears cache on update&#39; do
    post = create(:post)
    Post.trending  # Prime cache
    
    expect { post.update(title: &#39;New&#39;) }
      .to change { Post.trending }
  end
end
</code></pre>
<hr>
<h3>Performance Monitoring</h3>
<pre><code class="language-ruby"># Cache hit rate
ActiveSupport::Notifications.subscribe(&#39;cache_read.active_support&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  
  if event.payload[:hit]
    StatsD.increment(&#39;cache.hit&#39;)
  else
    StatsD.increment(&#39;cache.miss&#39;)
  end
end

# Slow cache operations
ActiveSupport::Notifications.subscribe(&#39;cache_read.active_support&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  
  if event.duration &gt; 100  # 100ms
    Rails.logger.warn &quot;Slow cache read: #{event.payload[:key]} (#{event.duration}ms)&quot;
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Fragment caching</strong> - most common, cache view parts</li>
<li><strong>Page caching</strong> - fastest, static HTML files</li>
<li><strong>Action caching</strong> - page caching with filters</li>
<li><strong>Low-level caching</strong> - manual with Rails.cache</li>
<li><strong>HTTP caching</strong> - browser/CDN caching</li>
<li><strong>Use Redis</strong> in production</li>
<li><strong>Russian Doll</strong> for nested caching</li>
<li><strong>Touch associations</strong> for auto-invalidation</li>
<li><strong>Monitor</strong> hit rates</li>
<li><strong>Test</strong> cache behavior</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 77: What is query caching in Rails?</h2>
<h3>Answer</h3>
<p><strong>Query caching</strong> is an automatic Rails feature that caches identical SQL queries within a single request. It&#39;s enabled by default and cleared after each request completes.</p>
<hr>
<h3>How Query Caching Works</h3>
<p><strong>Automatic caching within request:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    # Query 1: SELECT * FROM posts WHERE id = 1
    @post = Post.find(1)
    
    # Cached! (same query)
    @post2 = Post.find(1)
    
    # Query 2: SELECT * FROM users WHERE id = 5
    @user = User.find(5)
    
    # Cached! (same query)
    @user2 = User.find(5)
    
    # Total: 2 queries (not 4)
  end
end

# In logs:
# Post Load (0.5ms)  SELECT * FROM posts WHERE id = 1
# Post Load (0.0ms)  SELECT * FROM posts WHERE id = 1  [CACHE]
# User Load (0.3ms)  SELECT * FROM users WHERE id = 5
# User Load (0.0ms)  SELECT * FROM users WHERE id = 5  [CACHE]
</code></pre>
<hr>
<h3>Scope and Lifecycle</h3>
<p><strong>Per-request caching:</strong></p>
<pre><code class="language-ruby"># Request 1
def show
  Post.find(1)  # Query
  Post.find(1)  # Cached
end
# Cache cleared after response

# Request 2
def index
  Post.find(1)  # Query again (new request)
  Post.find(1)  # Cached within this request
end
# Cache cleared after response
</code></pre>
<p><strong>Middleware that enables it:</strong></p>
<pre><code class="language-ruby"># Automatic in Rails
ActiveRecord::QueryCache.install_executor_hooks

# Wraps each request:
# 1. Enable query cache
# 2. Execute request
# 3. Clear query cache
</code></pre>
<hr>
<h3>When Query Cache Helps</h3>
<p><strong>Scenario 1: Helper methods</strong></p>
<pre><code class="language-ruby"># View
&lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
&lt;%= render &#39;sidebar&#39; %&gt;

# app/views/posts/_sidebar.html.erb
&lt;div class=&quot;author&quot;&gt;
  &lt;%= @post.user.name %&gt;  # Query 1: SELECT * FROM users
&lt;/div&gt;

# app/helpers/posts_helper.rb
def post_author
  @post.user.name  # Cached! (same query)
end

# Only 1 query for user, not 2
</code></pre>
<p><strong>Scenario 2: Partials</strong></p>
<pre><code class="language-ruby"># Render same partial multiple times
&lt;% @posts.each do |post| %&gt;
  &lt;%= render &#39;post&#39;, post: post %&gt;
&lt;% end %&gt;

# In partial:
&lt;div&gt;
  &lt;%= post.user.name %&gt;  # First: Query, Rest: Cached
&lt;/div&gt;

# With 10 posts by same user:
# Without cache: 10 queries
# With cache: 1 query
</code></pre>
<p><strong>Scenario 3: Callbacks</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  after_create :send_notification
  after_create :update_inventory
  
  def send_notification
    product = Product.find(product_id)  # Query
    # Send email
  end
  
  def update_inventory
    product = Product.find(product_id)  # Cached!
    product.decrement!(:stock)
  end
end

# Only 1 query for product
</code></pre>
<hr>
<h3>When Query Cache Doesn&#39;t Help</h3>
<p><strong>Different queries:</strong></p>
<pre><code class="language-ruby">Post.find(1)  # Query 1
Post.find(2)  # Query 2 (different ID)

Post.where(published: true)   # Query 3
Post.where(published: false)  # Query 4 (different WHERE)

# Each is a different query = no caching
</code></pre>
<p><strong>Across requests:</strong></p>
<pre><code class="language-ruby"># Request 1
Post.find(1)  # Query

# Request 2 (different request)
Post.find(1)  # Query again (cache cleared between requests)
</code></pre>
<p><strong>Write operations:</strong></p>
<pre><code class="language-ruby">Post.find(1)  # Query 1
Post.find(1)  # Cached

Post.create(title: &quot;New&quot;)  # Cache cleared!

Post.find(1)  # Query 2 (cache was cleared)
</code></pre>
<hr>
<h3>Manual Query Cache Control</h3>
<p><strong>Enable/disable manually:</strong></p>
<pre><code class="language-ruby"># Disable query cache
ActiveRecord::Base.connection.uncached do
  Post.find(1)  # Always queries
  Post.find(1)  # Always queries (no cache)
end

# Enable query cache explicitly
ActiveRecord::Base.connection.cache do
  Post.find(1)  # Query
  Post.find(1)  # Cached
end
</code></pre>
<p><strong>Clear cache manually:</strong></p>
<pre><code class="language-ruby">Post.find(1)  # Query
Post.find(1)  # Cached

# Clear cache
ActiveRecord::Base.connection.clear_query_cache

Post.find(1)  # Query again
</code></pre>
<hr>
<h3>Query Cache in Background Jobs</h3>
<p><strong>Not automatic in jobs:</strong></p>
<pre><code class="language-ruby">class ReportJob &lt; ApplicationJob
  def perform
    # Query cache NOT enabled by default in jobs
    
    # Enable manually
    ActiveRecord::Base.connection.cache do
      user = User.find(1)
      user2 = User.find(1)  # Cached
      
      generate_report(user)
    end
    # Cache cleared after block
  end
end
</code></pre>
<hr>
<h3>Monitoring Query Cache</h3>
<p><strong>Log cache hits:</strong></p>
<pre><code class="language-ruby"># config/initializers/query_cache_logging.rb
ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  
  if event.payload[:cached]
    Rails.logger.debug &quot;Query Cache HIT: #{event.payload[:sql]}&quot;
  end
end
</code></pre>
<p><strong>Track cache effectiveness:</strong></p>
<pre><code class="language-ruby">class QueryCacheStats
  def self.track
    hits = 0
    misses = 0
    
    ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do |*args|
      event = ActiveSupport::Notifications::Event.new(*args)
      
      if event.payload[:cached]
        hits += 1
      else
        misses += 1
      end
    end
    
    at_exit do
      total = hits + misses
      rate = (hits.to_f / total * 100).round(2)
      puts &quot;Query Cache Hit Rate: #{rate}% (#{hits}/#{total})&quot;
    end
  end
end
</code></pre>
<hr>
<h3>Common Pitfalls</h3>
<p><strong>Pitfall 1: Assuming cache persists</strong></p>
<pre><code class="language-ruby"># WRONG assumption
def show
  @post = Post.find(1)  # Cached from previous request?
  # NO! Each request starts fresh
end
</code></pre>
<p><strong>Pitfall 2: Relying on query cache for performance</strong></p>
<pre><code class="language-ruby"># BAD - N+1 still a problem
users.each do |user|
  user.posts  # Even if cached, still N+1
end

# GOOD - eager load
users.includes(:posts).each do |user|
  user.posts  # No N+1
end
</code></pre>
<p><strong>Pitfall 3: Not understanding scope</strong></p>
<pre><code class="language-ruby"># Query cache is per-connection
# If using multiple database connections:
ActiveRecord::Base.connection.cache do
  Post.find(1)  # Cached on this connection
end

# Different connection
SecondaryDatabase.connection.cache do
  Post.find(1)  # NOT cached (different connection)
end
</code></pre>
<hr>
<h3>Testing Query Cache</h3>
<pre><code class="language-ruby">RSpec.describe &#39;Query caching&#39; do
  it &#39;caches identical queries&#39; do
    # Count queries
    queries = []
    
    ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do |*args|
      event = ActiveSupport::Notifications::Event.new(*args)
      queries &lt;&lt; event.payload[:sql] unless event.payload[:cached]
    end
    
    ActiveRecord::Base.connection.cache do
      Post.find(1)
      Post.find(1)
      Post.find(1)
    end
    
    # Only 1 actual query
    expect(queries.count { |q| q.include?(&#39;SELECT&#39;) }).to eq(1)
  end
  
  it &#39;clears cache on write&#39; do
    ActiveRecord::Base.connection.cache do
      Post.find(1)  # Query
      
      Post.create(title: &#39;New&#39;)  # Clears cache
      
      # Should query again
      expect(ActiveRecord::Base.connection).to receive(:select_all)
      Post.find(1)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Automatic</strong> within each request</li>
<li><strong>Same SQL</strong> = cached</li>
<li><strong>Cleared</strong> after request completes</li>
<li><strong>Cleared</strong> on write operations</li>
<li><strong>Per connection</strong> not global</li>
<li><strong>Helps</strong> with repeated queries</li>
<li><strong>Not a substitute</strong> for eager loading</li>
<li><strong>Not persistent</strong> across requests</li>
<li><strong>Manual control</strong> available</li>
<li><strong>Monitor</strong> for effectiveness</li>
</ol>
<hr>
<h2>Question 78: How do you optimize database queries in Rails?</h2>
<h3>Answer</h3>
<p>Optimize queries using <strong>eager loading</strong>, <strong>indexes</strong>, <strong>select specific columns</strong>, <strong>counter caches</strong>, <strong>database-level operations</strong>, and <strong>query monitoring tools</strong>.</p>
<hr>
<h3>1. Eager Loading (Fix N+1)</h3>
<p><strong>Problem:</strong></p>
<pre><code class="language-ruby"># N+1 query problem
posts = Post.all

posts.each do |post|
  puts post.user.name  # N queries
end

# SQL:
# SELECT * FROM posts
# SELECT * FROM users WHERE id = 1
# SELECT * FROM users WHERE id = 2
# ... (N more queries)
</code></pre>
<p><strong>Solution:</strong></p>
<pre><code class="language-ruby"># Eager load associations
posts = Post.includes(:user)

posts.each do |post|
  puts post.user.name  # No extra queries
end

# SQL:
# SELECT * FROM posts
# SELECT * FROM users WHERE id IN (1, 2, 3, ...)
# Only 2 queries total!

# Multiple associations
posts = Post.includes(:user, :comments, :tags)

# Nested associations
posts = Post.includes(:user, comments: [:user, :likes])
</code></pre>
<hr>
<h3>2. Database Indexes</h3>
<p><strong>Add indexes on:</strong></p>
<pre><code class="language-ruby"># Foreign keys
add_index :posts, :user_id

# Columns in WHERE clauses
add_index :posts, :published
add_index :posts, :created_at

# Columns in ORDER BY
add_index :posts, [:created_at, :id]

# Unique constraints
add_index :users, :email, unique: true

# Composite indexes
add_index :posts, [:user_id, :published]
add_index :posts, [:category_id, :created_at]

# Partial indexes (PostgreSQL)
add_index :posts, :user_id, where: &quot;published = true&quot;

# Expression indexes
add_index :users, &quot;lower(email)&quot;, name: &quot;index_users_on_lower_email&quot;
</code></pre>
<p><strong>When to use indexes:</strong></p>
<pre><code class="language-ruby"># Good candidates for indexes:
# - Foreign keys
# - Columns frequently in WHERE
# - Columns frequently in ORDER BY
# - Columns in JOIN conditions
# - Columns with high cardinality (many unique values)

# Don&#39;t index:
# - Small tables (&lt; 1000 rows)
# - Columns rarely queried
# - Columns with low cardinality (e.g., boolean)
# - Columns frequently updated
</code></pre>
<hr>
<h3>3. Select Specific Columns</h3>
<p><strong>Only load needed data:</strong></p>
<pre><code class="language-ruby"># BAD - loads all columns
users = User.all
emails = users.map(&amp;:email)

# GOOD - load only needed columns
emails = User.pluck(:email)

# BETTER - select for objects
users = User.select(:id, :name, :email)

# With calculations
User.select(:id, :name, &#39;COUNT(posts.id) as posts_count&#39;)
    .left_joins(:posts)
    .group(&#39;users.id&#39;)
</code></pre>
<hr>
<h3>4. Counter Caches</h3>
<p><strong>Avoid COUNT queries:</strong></p>
<pre><code class="language-ruby"># BAD - COUNT query for each user
users.each do |user|
  puts &quot;#{user.name}: #{user.posts.count} posts&quot;
end

# GOOD - counter cache
class Post &lt; ApplicationRecord
  belongs_to :user, counter_cache: true
end

add_column :users, :posts_count, :integer, default: 0

users.each do |user|
  puts &quot;#{user.name}: #{user.posts_count} posts&quot;  # No query!
end
</code></pre>
<hr>
<h3>5. Database-Level Operations</h3>
<p><strong>Use SQL instead of Ruby:</strong></p>
<pre><code class="language-ruby"># BAD - loads all records into memory
posts = Post.where(published: false)
posts.each { |p| p.update(published: true) }

# GOOD - single UPDATE query
Post.where(published: false).update_all(published: true)

# BAD - Ruby aggregation
posts.map(&amp;:views).sum

# GOOD - database aggregation
Post.sum(:views)

# Other database operations
Post.average(:score)
Post.minimum(:created_at)
Post.maximum(:updated_at)
</code></pre>
<hr>
<h3>6. Batch Processing</h3>
<p><strong>For large datasets:</strong></p>
<pre><code class="language-ruby"># BAD - loads everything into memory
User.all.each do |user|
  process_user(user)
end

# GOOD - batch loading
User.find_each(batch_size: 1000) do |user|
  process_user(user)
end

# Or with in_batches
User.in_batches(of: 1000) do |batch|
  batch.update_all(processed: true)
end
</code></pre>
<hr>
<h3>7. Avoid Unnecessary Queries</h3>
<p><strong>exists? vs any?:</strong></p>
<pre><code class="language-ruby"># BAD - loads all records
if user.posts.any?
  puts &quot;Has posts&quot;
end

# GOOD - just checks existence
if user.posts.exists?
  puts &quot;Has posts&quot;
end

# BAD - COUNT query
if user.posts.count &gt; 0
  puts &quot;Has posts&quot;
end
</code></pre>
<p><strong>size vs count vs length:</strong></p>
<pre><code class="language-ruby">posts = user.posts.load

# size - smart (uses cached or count)
posts.size

# count - always queries database
posts.count  # SELECT COUNT(*)

# length - loads all, counts in Ruby
posts.length  # Loads all posts
</code></pre>
<hr>
<h3>8. Scopes and Composability</h3>
<p><strong>Reusable optimized queries:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  scope :published, -&gt; { where(published: true) }
  scope :recent, -&gt; { where(&#39;created_at &gt; ?&#39;, 1.week.ago) }
  scope :popular, -&gt; { where(&#39;views &gt; ?&#39;, 1000) }
  scope :with_author, -&gt; { includes(:user) }
  
  # Composable
  def self.trending
    published.recent.popular.with_author.order(views: :desc)
  end
end

# Usage
Post.trending  # Optimized, composable query
</code></pre>
<hr>
<h3>9. Identify Slow Queries</h3>
<p><strong>Using query logs:</strong></p>
<pre><code class="language-ruby"># config/environments/development.rb
config.active_record.verbose_query_logs = true

# Shows file and line number in logs:
# User Load (0.5ms)  SELECT * FROM users
#   ↳ app/controllers/users_controller.rb:5
</code></pre>
<p><strong>Bullet gem (N+1 detection):</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;bullet&#39;, group: :development

# config/environments/development.rb
config.after_initialize do
  Bullet.enable = true
  Bullet.alert = true
  Bullet.bullet_logger = true
  Bullet.console = true
end

# Alerts on:
# - N+1 queries
# - Unused eager loading
# - Missing counter caches
</code></pre>
<p><strong>EXPLAIN queries:</strong></p>
<pre><code class="language-ruby"># Analyze query plan
User.where(email: &#39;test@example.com&#39;).explain

# Output:
# EXPLAIN for: SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;email&quot; = &#39;test@example.com&#39;
#                              QUERY PLAN
# ---------------------------------------------------------------------
#  Seq Scan on users  (cost=0.00..10.88 rows=1 width=1000)
#    Filter: ((email)::text = &#39;test@example.com&#39;::text)
# (2 rows)

# Look for:
# - Seq Scan → might need index
# - Index Scan → good
# - High cost → slow query
</code></pre>
<hr>
<h3>10. Connection Pooling</h3>
<p><strong>Configure pool size:</strong></p>
<pre><code class="language-ruby"># config/database.yml
production:
  adapter: postgresql
  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;
  timeout: 5000

# Match pool size to:
# - Web server threads (Puma: threads)
# - Background job concurrency
</code></pre>
<hr>
<h3>Complete Optimization Example</h3>
<p><strong>Before optimization:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def index
    @posts = Post.all  # N+1 on user
    
    @posts.each do |post|
      post.user.name           # Query per post
      post.comments.count      # COUNT per post
      post.tags.map(&amp;:name)    # Query per post
    end
  end
end

# Queries: 1 + (3 * N) for N posts
# Time for 100 posts: ~2000ms
</code></pre>
<p><strong>After optimization:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def index
    @posts = Post.published
                 .includes(:user, :tags)  # Eager load
                 .select(
                   &#39;posts.*&#39;,
                   &#39;COUNT(comments.id) as comments_count&#39;  # Calculate count
                 )
                 .left_joins(:comments)
                 .group(&#39;posts.id&#39;)
                 .order(created_at: :desc)
                 .page(params[:page])
                 .per(20)
  end
end

# Queries: 3 (posts, users, tags)
# Time for 100 posts: ~50ms (40x faster!)
</code></pre>
<hr>
<h3>Monitoring and Profiling</h3>
<p><strong>Scout APM / New Relic:</strong></p>
<pre><code class="language-ruby"># Automatic query monitoring
# Shows:
# - Slowest endpoints
# - Most frequent queries
# - N+1 queries
# - Memory usage
</code></pre>
<p><strong>Custom instrumentation:</strong></p>
<pre><code class="language-ruby">ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  
  if event.duration &gt; 100  # 100ms
    Rails.logger.warn &quot;Slow query (#{event.duration}ms): #{event.payload[:sql]}&quot;
  end
end
</code></pre>
<hr>
<h3>Database-Specific Optimizations</h3>
<p><strong>PostgreSQL:</strong></p>
<pre><code class="language-ruby"># Full-text search
add_index :posts, :title, using: :gin, opclass: :gin_trgm_ops

Post.where(&quot;title % ?&quot;, search_term)

# JSONB indexing
add_index :posts, :metadata, using: :gin

Post.where(&quot;metadata @&gt; ?&quot;, {category: &#39;tech&#39;}.to_json)

# Materialized views
execute &quot;CREATE MATERIALIZED VIEW popular_posts AS ...&quot;
execute &quot;REFRESH MATERIALIZED VIEW popular_posts&quot;
</code></pre>
<p><strong>MySQL:</strong></p>
<pre><code class="language-ruby"># Force index usage
Post.from(&#39;posts FORCE INDEX (index_posts_on_created_at)&#39;)
    .where(&#39;created_at &gt; ?&#39;, 1.week.ago)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Eager load</strong> associations (includes)</li>
<li><strong>Add indexes</strong> on frequently queried columns</li>
<li><strong>Select</strong> only needed columns</li>
<li><strong>Counter caches</strong> for counts</li>
<li><strong>Database operations</strong> over Ruby</li>
<li><strong>Batch process</strong> large datasets</li>
<li><strong>Use exists?</strong> not any?</li>
<li><strong>Monitor</strong> with Bullet gem</li>
<li><strong>EXPLAIN</strong> slow queries</li>
<li><strong>Profile</strong> in production</li>
</ol>
<hr>
<h2>Question 79: How do you optimize queries with large datasets?</h2>
<h3>Answer</h3>
<p>For large datasets, use <strong>batch processing</strong>, <strong>pagination</strong>, <strong>database-level operations</strong>, <strong>background jobs</strong>, <strong>archiving</strong>, and <strong>database partitioning</strong>.</p>
<hr>
<h3>1. Batch Processing</h3>
<p><strong>find_each (Recommended):</strong></p>
<pre><code class="language-ruby"># BAD - loads all 1M users into memory
User.all.each do |user|
  process_user(user)
end
# Memory: ~10GB
# Time: Slow, might timeout

# GOOD - process in batches
User.find_each(batch_size: 1000) do |user|
  process_user(user)
end

# How it works:
# SELECT * FROM users ORDER BY id LIMIT 1000
# SELECT * FROM users WHERE id &gt; 1000 ORDER BY id LIMIT 1000
# SELECT * FROM users WHERE id &gt; 2000 ORDER BY id LIMIT 1000
# ...

# Memory: ~10MB (constant)
# Time: Stable
</code></pre>
<p><strong>in_batches:</strong></p>
<pre><code class="language-ruby"># Process batches, not individual records
User.in_batches(of: 1000) do |batch|
  # batch is ActiveRecord::Relation
  batch.update_all(processed: true)
  
  # Or process as array
  batch.to_a.each do |user|
    process_user(user)
  end
end

# Efficient for bulk operations
User.in_batches(of: 5000) do |batch|
  batch.where(active: false).delete_all
end
</code></pre>
<p><strong>Custom batching:</strong></p>
<pre><code class="language-ruby">def process_in_batches(relation, batch_size: 1000)
  offset = 0
  
  loop do
    batch = relation.limit(batch_size).offset(offset)
    break if batch.empty?
    
    yield batch
    
    offset += batch_size
  end
end

# Usage
process_in_batches(User.where(active: true)) do |batch|
  batch.each { |user| process_user(user) }
end
</code></pre>
<hr>
<h3>2. Pagination</h3>
<p><strong>Kaminari / Pagy:</strong></p>
<pre><code class="language-ruby"># Controller
class PostsController &lt; ApplicationController
  def index
    @posts = Post.page(params[:page]).per(20)
    # Only loads 20 records
  end
end

# View
&lt;%= paginate @posts %&gt;

# SQL:
# SELECT * FROM posts LIMIT 20 OFFSET 0   (page 1)
# SELECT * FROM posts LIMIT 20 OFFSET 20  (page 2)
</code></pre>
<p><strong>Cursor-based pagination (better for large datasets):</strong></p>
<pre><code class="language-ruby"># Better than OFFSET for millions of rows
class PostsController &lt; ApplicationController
  def index
    @posts = Post.where(&#39;id &gt; ?&#39;, params[:after] || 0)
                 .order(:id)
                 .limit(20)
    
    @next_cursor = @posts.last&amp;.id
  end
end

# SQL:
# SELECT * FROM posts WHERE id &gt; 0 ORDER BY id LIMIT 20
# SELECT * FROM posts WHERE id &gt; 20 ORDER BY id LIMIT 20
# SELECT * FROM posts WHERE id &gt; 40 ORDER BY id LIMIT 20

# Much faster than OFFSET for large datasets
</code></pre>
<hr>
<h3>3. Database-Level Operations</h3>
<p><strong>Avoid loading into Ruby:</strong></p>
<pre><code class="language-ruby"># BAD - loads 1M records, processes in Ruby
posts = Post.where(published: false)
posts.each { |p| p.update(published: true) }
# Memory: ~5GB
# Time: ~30 minutes

# GOOD - single UPDATE query
Post.where(published: false).update_all(published: true)
# Memory: ~1MB
# Time: ~5 seconds

# BAD - Ruby calculation
total_views = Post.all.sum { |p| p.views }

# GOOD - database SUM
total_views = Post.sum(:views)
</code></pre>
<hr>
<h3>4. Select Only Needed Data</h3>
<p><strong>Reduce data transfer:</strong></p>
<pre><code class="language-ruby"># BAD - loads all columns (1GB data)
emails = User.all.map(&amp;:email)

# GOOD - pluck (10MB data)
emails = User.pluck(:email)

# GOOD - select for objects (100MB data)
users = User.select(:id, :email, :name)

# For exports
CSV.open(&#39;users.csv&#39;, &#39;w&#39;) do |csv|
  User.select(:id, :name, :email)
      .find_each(batch_size: 1000) do |user|
    csv &lt;&lt; [user.id, user.name, user.email]
  end
end
</code></pre>
<hr>
<h3>5. Background Jobs</h3>
<p><strong>Async processing:</strong></p>
<pre><code class="language-ruby"># BAD - processes 1M records in web request (timeout!)
class ReportController &lt; ApplicationController
  def generate
    @users = User.all
    @users.each { |u| generate_report(u) }
    # Request timeout after 30s!
  end
end

# GOOD - background job
class GenerateReportsJob &lt; ApplicationJob
  queue_as :low_priority
  
  def perform
    User.find_each(batch_size: 100) do |user|
      generate_report(user)
    end
  end
end

# Controller
class ReportController &lt; ApplicationController
  def generate
    GenerateReportsJob.perform_later
    flash[:notice] = &quot;Report generation started&quot;
    redirect_to root_path
  end
end
</code></pre>
<hr>
<h3>6. Streaming Responses</h3>
<p><strong>For large exports:</strong></p>
<pre><code class="language-ruby">class ExportsController &lt; ApplicationController
  def users_csv
    # Stream CSV (no memory buildup)
    headers[&#39;Content-Type&#39;] = &#39;text/csv&#39;
    headers[&#39;Content-Disposition&#39;] = &#39;attachment; filename=&quot;users.csv&quot;&#39;
    headers[&#39;X-Accel-Buffering&#39;] = &#39;no&#39;  # Disable Nginx buffering
    
    self.response_body = csv_enumerator
  end
  
  private
  
  def csv_enumerator
    Enumerator.new do |y|
      # Header
      y &lt;&lt; CSV.generate_line([&#39;ID&#39;, &#39;Name&#39;, &#39;Email&#39;])
      
      # Stream rows
      User.find_each(batch_size: 1000) do |user|
        y &lt;&lt; CSV.generate_line([user.id, user.name, user.email])
      end
    end
  end
end

# Memory: Constant (~10MB)
# Can export millions of rows
</code></pre>
<hr>
<h3>7. Database Indexes</h3>
<p><strong>Essential for large tables:</strong></p>
<pre><code class="language-ruby"># Composite index for common queries
add_index :posts, [:user_id, :created_at]
add_index :posts, [:category_id, :published, :created_at]

# Partial index (PostgreSQL)
add_index :posts, :user_id, where: &quot;published = true&quot;

# Covering index (include extra columns)
add_index :posts, [:user_id, :created_at], include: [:title, :views]

# Index on expressions
add_index :users, &quot;lower(email)&quot;
</code></pre>
<p><strong>Verify index usage:</strong></p>
<pre><code class="language-ruby"># Check if index used
Post.where(user_id: 1).explain

# Look for &quot;Index Scan&quot; not &quot;Seq Scan&quot;
</code></pre>
<hr>
<h3>8. Partitioning</h3>
<p><strong>Table partitioning (PostgreSQL):</strong></p>
<pre><code class="language-ruby"># Migration - create partitioned table
class CreatePartitionedLogs &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE TABLE logs (
        id BIGSERIAL,
        message TEXT,
        created_at TIMESTAMP NOT NULL
      ) PARTITION BY RANGE (created_at);
      
      -- Create partitions for each month
      CREATE TABLE logs_2024_01 PARTITION OF logs
        FOR VALUES FROM (&#39;2024-01-01&#39;) TO (&#39;2024-02-01&#39;);
      
      CREATE TABLE logs_2024_02 PARTITION OF logs
        FOR VALUES FROM (&#39;2024-02-01&#39;) TO (&#39;2024-03-01&#39;);
    SQL
  end
end

# Benefits:
# - Queries only scan relevant partitions
# - Drop old partitions instantly (no DELETE)
# - Better index performance per partition
</code></pre>
<hr>
<h3>9. Archiving Old Data</h3>
<p><strong>Move to archive tables:</strong></p>
<pre><code class="language-ruby">class ArchiveOldOrders
  def self.archive(cutoff_date)
    # 1. Copy to archive
    execute &lt;&lt;-SQL
      INSERT INTO archived_orders
      SELECT * FROM orders
      WHERE created_at &lt; &#39;#{cutoff_date}&#39;
    SQL
    
    # 2. Verify
    archived_count = ArchivedOrder.where(&quot;created_at &lt; ?&quot;, cutoff_date).count
    original_count = Order.where(&quot;created_at &lt; ?&quot;, cutoff_date).count
    raise &quot;Count mismatch&quot; unless archived_count == original_count
    
    # 3. Delete from main table (in batches)
    Order.where(&quot;created_at &lt; ?&quot;, cutoff_date)
         .in_batches(of: 10000)
         .delete_all
  end
end
</code></pre>
<hr>
<h3>10. Read Replicas</h3>
<p><strong>Distribute load:</strong></p>
<pre><code class="language-ruby"># config/database.yml
production:
  primary:
    adapter: postgresql
    host: primary.db.example.com
  
  replica:
    adapter: postgresql
    host: replica.db.example.com
    replica: true

# Model
class Report &lt; ApplicationRecord
  connects_to database: { writing: :primary, reading: :replica }
end

# Usage
Report.all  # Reads from replica

ActiveRecord::Base.connected_to(role: :reading) do
  # All reads from replica
  User.all
  Post.all
end
</code></pre>
<hr>
<h3>11. Materialized Views</h3>
<p><strong>Pre-compute expensive queries:</strong></p>
<pre><code class="language-ruby"># Migration
class CreateDashboardStats &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE MATERIALIZED VIEW dashboard_stats AS
      SELECT
        DATE(created_at) as date,
        COUNT(*) as order_count,
        SUM(amount) as total_amount
      FROM orders
      GROUP BY DATE(created_at)
    SQL
    
    add_index :dashboard_stats, :date, unique: true
  end
end

# Model
class DashboardStat &lt; ApplicationRecord
  self.primary_key = :date
  
  def self.refresh
    ActiveRecord::Base.connection.execute(
      &quot;REFRESH MATERIALIZED VIEW CONCURRENTLY dashboard_stats&quot;
    )
  end
end

# Refresh nightly
class RefreshStatsJob &lt; ApplicationJob
  def perform
    DashboardStat.refresh
  end
end

# Usage (instant)
stats = DashboardStat.all
</code></pre>
<hr>
<h3>12. Connection Pooling</h3>
<p><strong>Configure for high concurrency:</strong></p>
<pre><code class="language-ruby"># config/database.yml
production:
  adapter: postgresql
  pool: &lt;%= ENV.fetch(&quot;DB_POOL_SIZE&quot;, 25) %&gt;
  checkout_timeout: 5
  reaping_frequency: 10  # Check for dead connections

# Monitor pool usage
ActiveRecord::Base.connection_pool.stat
# =&gt; {size: 25, connections: 10, busy: 5, dead: 0, idle: 5, waiting: 0}
</code></pre>
<hr>
<h3>Complete Example</h3>
<p><strong>Processing 10M users:</strong></p>
<pre><code class="language-ruby">class UserProcessor
  def self.process_all
    total = User.count
    processed = 0
    start_time = Time.current
    
    User.find_each(batch_size: 5000) do |user|
      process_user(user)
      
      processed += 1
      
      # Log progress every 10k
      if processed % 10_000 == 0
        elapsed = Time.current - start_time
        rate = processed / elapsed
        remaining = (total - processed) / rate
        
        Rails.logger.info(
          &quot;Processed #{processed}/#{total} users &quot; \
          &quot;(#{(processed.to_f / total * 100).round(2)}%) &quot; \
          &quot;Rate: #{rate.round}/s &quot; \
          &quot;ETA: #{remaining.round}s&quot;
        )
      end
    end
  end
  
  def self.process_user(user)
    # Update user
    user.update_column(:last_processed_at, Time.current)
    
    # Send email
    UserMailer.notification(user).deliver_later
  end
end

# Run in background
class ProcessUsersJob &lt; ApplicationJob
  queue_as :low_priority
  
  def perform
    UserProcessor.process_all
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>find_each</strong> for batch processing</li>
<li><strong>Pagination</strong> for UI display</li>
<li><strong>Database operations</strong> over Ruby</li>
<li><strong>Background jobs</strong> for long tasks</li>
<li><strong>Stream responses</strong> for exports</li>
<li><strong>Index</strong> frequently queried columns</li>
<li><strong>Partition tables</strong> by date</li>
<li><strong>Archive</strong> old data</li>
<li><strong>Read replicas</strong> for scaling</li>
<li><strong>Monitor</strong> and profile continuously</li>
</ol>
<h1>Database Design Interview Questions</h1>
<h2>Question 80: What is indexing in Rails/databases?</h2>
<h3>Answer</h3>
<p><strong>Indexing</strong> creates a data structure (usually B-tree) that allows the database to find rows quickly without scanning the entire table. Indexes dramatically speed up queries but slow down writes and consume storage.</p>
<hr>
<h3>How Indexes Work</h3>
<p><strong>Without index (Table Scan):</strong></p>
<pre><code>Table: users (1,000,000 rows)
Query: SELECT * FROM users WHERE email = &#39;alice@example.com&#39;

Database scans ALL rows:
Row 1: bob@example.com     ❌
Row 2: charlie@example.com ❌
Row 3: alice@example.com   ✅ Found! But keeps scanning...
Row 4: dave@example.com    ❌
...
Row 1,000,000             ❌

Time: ~5000ms (scanned all rows)
</code></pre>
<p><strong>With index (Index Lookup):</strong></p>
<pre><code>Index on email (B-tree):
alice@example.com → Row 3
bob@example.com   → Row 1
charlie@example.com → Row 2
dave@example.com  → Row 4

Query: SELECT * FROM users WHERE email = &#39;alice@example.com&#39;

1. Look up in index: O(log n) - finds Row 3
2. Read Row 3 directly

Time: ~5ms (1000x faster!)
</code></pre>
<hr>
<h3>Creating Indexes in Rails</h3>
<p><strong>Migration:</strong></p>
<pre><code class="language-ruby"># Single column index
class AddIndexToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :email
  end
end

# SQL generated:
# CREATE INDEX index_users_on_email ON users (email)

# Unique index
add_index :users, :email, unique: true

# Multiple columns (composite index)
add_index :posts, [:user_id, :created_at]

# Named index
add_index :users, :email, name: &#39;idx_user_email&#39;

# Conditional index (PostgreSQL)
add_index :posts, :user_id, where: &quot;published = true&quot;

# Expression index (PostgreSQL)
add_index :users, &quot;lower(email)&quot;, name: &#39;idx_users_lower_email&#39;

# GIN index for arrays/JSONB (PostgreSQL)
add_index :posts, :tags, using: :gin

# Full-text search (PostgreSQL)
add_index :posts, :title, using: :gist, opclass: :gist_trgm_ops
</code></pre>
<hr>
<h3>When to Add Indexes</h3>
<p><strong>Always index:</strong></p>
<p>✅ <strong>Primary keys</strong> (automatic)</p>
<pre><code class="language-ruby"># Rails adds automatically
create_table :users do |t|
  # id column automatically indexed
end
</code></pre>
<p>✅ <strong>Foreign keys</strong></p>
<pre><code class="language-ruby"># Always index foreign keys!
add_reference :posts, :user, foreign_key: true, index: true
# Creates user_id column + index
</code></pre>
<p>✅ <strong>Columns in WHERE clauses</strong></p>
<pre><code class="language-ruby"># Frequently queried:
Post.where(published: true)
# Index it:
add_index :posts, :published

# Date range queries:
Order.where(&#39;created_at &gt; ?&#39;, 1.week.ago)
# Index it:
add_index :orders, :created_at
</code></pre>
<p>✅ <strong>Columns in ORDER BY</strong></p>
<pre><code class="language-ruby"># Frequently sorted:
Post.order(created_at: :desc)
# Index it:
add_index :posts, :created_at

# Or composite for better performance:
add_index :posts, [:created_at, :id]
</code></pre>
<p>✅ <strong>Columns in JOIN conditions</strong></p>
<pre><code class="language-ruby"># Joining tables:
Post.joins(:user)
# Index foreign key:
add_index :posts, :user_id
</code></pre>
<p><strong>Consider indexing:</strong></p>
<p>⚠️ <strong>Unique constraints</strong></p>
<pre><code class="language-ruby">validates :email, uniqueness: true
# Add unique index to enforce at DB level:
add_index :users, :email, unique: true
</code></pre>
<p>⚠️ <strong>Columns with high cardinality</strong> (many unique values)</p>
<pre><code class="language-ruby"># Email: mostly unique → good for index
add_index :users, :email

# Boolean: only 2 values → might not need index
# published: true/false
</code></pre>
<p><strong>Don&#39;t index:</strong></p>
<p>❌ <strong>Small tables</strong> (&lt; 1000 rows)</p>
<pre><code class="language-ruby"># Table with 100 rows
# Full scan is faster than index lookup
</code></pre>
<p>❌ <strong>Columns rarely queried</strong></p>
<pre><code class="language-ruby"># Description field rarely in WHERE clause
# Don&#39;t index it
</code></pre>
<p>❌ <strong>Low cardinality columns</strong></p>
<pre><code class="language-ruby"># Boolean columns (true/false)
# Gender (M/F/Other)
# Unless using partial index
</code></pre>
<p>❌ <strong>Frequently updated columns</strong></p>
<pre><code class="language-ruby"># last_accessed_at updated on every request
# Index update overhead &gt; query benefit
</code></pre>
<hr>
<h3>Index Types</h3>
<p><strong>1. B-tree (Default):</strong></p>
<pre><code class="language-ruby">add_index :users, :email  # B-tree by default

# Good for:
# - Equality (email = &#39;alice@example.com&#39;)
# - Range (age &gt; 18)
# - Sorting (ORDER BY created_at)
# - Prefix matching (name LIKE &#39;John%&#39;)
</code></pre>
<p><strong>2. Hash:</strong></p>
<pre><code class="language-ruby">add_index :users, :email, using: :hash

# Good for:
# - Only equality (email = &#39;alice@example.com&#39;)
# - Faster than B-tree for exact matches
# - Can&#39;t do range queries
</code></pre>
<p><strong>3. GiST (Generalized Search Tree - PostgreSQL):</strong></p>
<pre><code class="language-ruby">add_index :posts, :location, using: :gist

# Good for:
# - Geometric data
# - Full-text search
# - Custom data types
</code></pre>
<p><strong>4. GIN (Generalized Inverted Index - PostgreSQL):</strong></p>
<pre><code class="language-ruby">add_index :posts, :tags, using: :gin
add_index :posts, :metadata, using: :gin

# Good for:
# - Arrays
# - JSONB
# - Full-text search
# - When value contains multiple elements
</code></pre>
<hr>
<h3>Composite Indexes</h3>
<p><strong>Multiple columns in one index:</strong></p>
<pre><code class="language-ruby"># Composite index
add_index :posts, [:user_id, :published, :created_at]

# Efficient queries (LEFT to RIGHT):
Post.where(user_id: 1)                                    # ✅ Uses index
Post.where(user_id: 1, published: true)                   # ✅ Uses index
Post.where(user_id: 1, published: true, created_at: ...)  # ✅ Uses index

# Won&#39;t use index efficiently:
Post.where(published: true)                               # ❌ Doesn&#39;t use index
Post.where(created_at: ...)                               # ❌ Doesn&#39;t use index

# Order matters! Index works LEFT to RIGHT
</code></pre>
<p><strong>Column order importance:</strong></p>
<pre><code class="language-ruby"># Query: WHERE user_id = 1 ORDER BY created_at DESC
# Good index:
add_index :posts, [:user_id, :created_at]

# Query: WHERE published = true AND user_id = 1
# Put most selective column first:
add_index :posts, [:user_id, :published]  # If user_id more selective
# or
add_index :posts, [:published, :user_id]  # If published more selective
</code></pre>
<hr>
<h3>Checking Index Usage</h3>
<p><strong>EXPLAIN query:</strong></p>
<pre><code class="language-ruby"># Rails console
User.where(email: &#39;alice@example.com&#39;).explain

# Output:
# EXPLAIN for: SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;email&quot; = &#39;alice@example.com&#39;
#                                 QUERY PLAN
# ---------------------------------------------------------------------------
#  Index Scan using index_users_on_email on users  (cost=0.42..8.44 rows=1)
#    Index Cond: ((email)::text = &#39;alice@example.com&#39;::text)
# (2 rows)

# Look for:
# - &quot;Index Scan&quot; ✅ Good - using index
# - &quot;Seq Scan&quot; ❌ Bad - full table scan
# - &quot;Bitmap Index Scan&quot; ✅ Good - using index
</code></pre>
<p><strong>PostgreSQL - Check unused indexes:</strong></p>
<pre><code class="language-sql">SELECT
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND indexname NOT LIKE &#39;%pkey&#39;
ORDER BY tablename, indexname;

-- Shows indexes never used
</code></pre>
<p><strong>Check index size:</strong></p>
<pre><code class="language-sql">SELECT
  tablename,
  indexname,
  pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes
ORDER BY pg_relation_size(indexrelid) DESC;
</code></pre>
<hr>
<h3>Performance Impact</h3>
<p><strong>Benchmark:</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

# Setup: 1,000,000 users without index
User.connection.execute(&quot;DROP INDEX IF EXISTS index_users_on_email&quot;)

Benchmark.bm do |x|
  x.report(&quot;Without index:&quot;) do
    User.where(email: &#39;user500000@example.com&#39;).first
  end
  # Time: ~2500ms (full table scan)
end

# Add index
User.connection.add_index(:users, :email)

Benchmark.bm do |x|
  x.report(&quot;With index:&quot;) do
    User.where(email: &#39;user500000@example.com&#39;).first
  end
  # Time: ~2ms (index lookup)
end

# Result: 1000x faster with index!
</code></pre>
<hr>
<h3>Index Maintenance</h3>
<p><strong>Reindex (PostgreSQL):</strong></p>
<pre><code class="language-ruby"># Rebuild all indexes on table
ActiveRecord::Base.connection.execute(&quot;REINDEX TABLE users&quot;)

# Rebuild specific index
ActiveRecord::Base.connection.execute(&quot;REINDEX INDEX index_users_on_email&quot;)

# Concurrent reindex (doesn&#39;t lock table)
ActiveRecord::Base.connection.execute(&quot;REINDEX INDEX CONCURRENTLY index_users_on_email&quot;)
</code></pre>
<p><strong>Remove unused indexes:</strong></p>
<pre><code class="language-ruby">class RemoveUnusedIndexes &lt; ActiveRecord::Migration[7.0]
  def change
    remove_index :users, :rarely_queried_column
  end
end
</code></pre>
<hr>
<h3>Common Pitfalls</h3>
<p><strong>Pitfall 1: Missing index on foreign keys</strong></p>
<pre><code class="language-ruby"># BAD - no index on foreign key
class CreatePosts &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :posts do |t|
      t.bigint :user_id  # No index!
    end
  end
end

# GOOD - index foreign key
class CreatePosts &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :posts do |t|
      t.references :user, foreign_key: true, index: true
    end
  end
end
</code></pre>
<p><strong>Pitfall 2: Using function in WHERE without function index</strong></p>
<pre><code class="language-ruby"># Query
User.where(&quot;LOWER(email) = ?&quot;, &#39;alice@example.com&#39;)

# Index not used (function applied):
add_index :users, :email  # ❌ Won&#39;t help

# Solution - function index:
add_index :users, &quot;LOWER(email)&quot;  # ✅ Will be used
</code></pre>
<p><strong>Pitfall 3: Wrong column order in composite index</strong></p>
<pre><code class="language-ruby"># Frequent query:
Post.where(user_id: 1).order(created_at: :desc)

# Wrong order:
add_index :posts, [:created_at, :user_id]  # ❌ Won&#39;t use efficiently

# Correct order:
add_index :posts, [:user_id, :created_at]  # ✅ Efficient
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Indexes</strong> speed up reads, slow down writes</li>
<li><strong>Always index</strong> foreign keys</li>
<li><strong>Index</strong> WHERE, ORDER BY, JOIN columns</li>
<li><strong>B-tree</strong> is default and most common</li>
<li><strong>Composite indexes</strong> use left-to-right</li>
<li><strong>Check usage</strong> with EXPLAIN</li>
<li><strong>Remove</strong> unused indexes</li>
<li><strong>1000x faster</strong> with proper indexes</li>
<li><strong>High cardinality</strong> columns benefit most</li>
<li><strong>Don&#39;t over-index</strong> (impacts writes)</li>
</ol>
<hr>
<h2>Question 81: What are partial indexes, and how do they improve performance?</h2>
<h3>Answer</h3>
<p><strong>Partial indexes</strong> (also called filtered indexes) index only rows that meet a specific condition. They&#39;re smaller, faster to query, and reduce storage compared to full indexes.</p>
<hr>
<h3>How Partial Indexes Work</h3>
<p><strong>Full index:</strong></p>
<pre><code>Index on published column:
true  → 100,000 rows
false → 900,000 rows

Size: 50MB
Maintenance: Updates all 1,000,000 rows
</code></pre>
<p><strong>Partial index:</strong></p>
<pre><code>Partial index WHERE published = true:
true → 100,000 rows (only these indexed)

Size: 5MB (10x smaller!)
Maintenance: Updates only 100,000 rows (10x faster!)
</code></pre>
<hr>
<h3>Creating Partial Indexes</h3>
<p><strong>PostgreSQL syntax:</strong></p>
<pre><code class="language-ruby"># Migration
class AddPartialIndexToPosts &lt; ActiveRecord::Migration[7.0]
  def change
    # Index only published posts
    add_index :posts, :user_id, where: &quot;published = true&quot;
    
    # Index only recent posts
    add_index :posts, :created_at, where: &quot;created_at &gt; &#39;2024-01-01&#39;&quot;
    
    # Index only active users
    add_index :users, :email, where: &quot;deleted_at IS NULL&quot;
    
    # Complex condition
    add_index :orders, :user_id, 
              where: &quot;status = &#39;pending&#39; AND created_at &gt; &#39;2024-01-01&#39;&quot;
  end
end

# SQL generated:
# CREATE INDEX index_posts_on_user_id 
# ON posts (user_id) 
# WHERE published = true
</code></pre>
<p><strong>MySQL equivalent (different syntax):</strong></p>
<pre><code class="language-ruby"># MySQL doesn&#39;t support WHERE clause directly
# Use functional/expression indexes instead
add_index :posts, [:published, :user_id]

# Or in raw SQL:
execute &lt;&lt;-SQL
  CREATE INDEX idx_published_posts 
  ON posts (user_id) 
  WHERE published = 1
SQL
</code></pre>
<hr>
<h3>Use Cases</h3>
<p><strong>1. Soft Deletes</strong></p>
<pre><code class="language-ruby"># Only index active (non-deleted) records
class AddPartialIndexToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    # Full index (includes deleted rows)
    # add_index :users, :email
    # Size: 100MB
    
    # Partial index (only active rows)
    add_index :users, :email, where: &quot;deleted_at IS NULL&quot;
    # Size: 80MB (if 20% deleted)
  end
end

# Queries that benefit:
User.where(deleted_at: nil).where(email: &#39;alice@example.com&#39;)
# Uses partial index ✅

# Queries that don&#39;t benefit:
User.unscoped.where(email: &#39;alice@example.com&#39;)
# Can&#39;t use partial index (includes deleted) ❌
</code></pre>
<p><strong>2. Status-based Indexing</strong></p>
<pre><code class="language-ruby"># Most queries only care about pending/processing orders
class AddPartialIndexToOrders &lt; ActiveRecord::Migration[7.0]
  def change
    # Only index active orders (90% of queries)
    add_index :orders, [:user_id, :created_at], 
              where: &quot;status IN (&#39;pending&#39;, &#39;processing&#39;)&quot;
    
    # Completed orders rarely queried (separate index if needed)
    # add_index :orders, :completed_at, where: &quot;status = &#39;completed&#39;&quot;
  end
end

# Efficient query:
Order.where(status: &#39;pending&#39;).where(user_id: 1).order(created_at: :desc)
# Uses partial index ✅
</code></pre>
<p><strong>3. Recent Data Indexing</strong></p>
<pre><code class="language-ruby"># Most queries only access recent data
class AddPartialIndexToLogs &lt; ActiveRecord::Migration[7.0]
  def change
    # Only index last 30 days
    add_index :logs, [:user_id, :created_at],
              where: &quot;created_at &gt; CURRENT_DATE - INTERVAL &#39;30 days&#39;&quot;
  end
end

# Benefit: Index stays small as old data excluded
</code></pre>
<p><strong>4. Boolean Columns</strong></p>
<pre><code class="language-ruby"># Boolean column: 95% false, 5% true
# Only index the rare case
class AddPartialIndexToPosts &lt; ActiveRecord::Migration[7.0]
  def change
    # Don&#39;t index: add_index :posts, :featured
    # Only 5% true → most queries won&#39;t use index anyway
    
    # Instead, partial index on true only:
    add_index :posts, [:featured, :created_at], 
              where: &quot;featured = true&quot;
  end
end

# Efficient for:
Post.where(featured: true).order(created_at: :desc)
# Uses small partial index ✅

# Less efficient for (but rare query):
Post.where(featured: false)
# Full scan, but acceptable since rare ❌
</code></pre>
<p><strong>5. Unique Constraints with Soft Deletes</strong></p>
<pre><code class="language-ruby"># Problem: Can&#39;t reuse email after soft delete with regular unique index
class User &lt; ApplicationRecord
  validates :email, uniqueness: true
  # Issue: Deleted user&#39;s email still in index!
end

# Solution: Partial unique index
class AddPartialUniqueIndexToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    # Only enforce uniqueness on active users
    add_index :users, :email, 
              unique: true,
              where: &quot;deleted_at IS NULL&quot;
  end
end

# Now can reuse email:
user = User.create(email: &#39;alice@example.com&#39;)
user.update(deleted_at: Time.current)  # Soft delete
User.create(email: &#39;alice@example.com&#39;)  # ✅ Works!
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<p><strong>Benchmark:</strong></p>
<pre><code class="language-ruby"># Setup: 1,000,000 posts (100,000 published)

# Full index on published + user_id
add_index :posts, [:published, :user_id]
# Size: 50MB
# Maintenance: Updates affect all 1M rows

# Partial index
add_index :posts, :user_id, where: &quot;published = true&quot;
# Size: 5MB (10x smaller)
# Maintenance: Updates affect only 100k rows

# Query performance:
Post.where(published: true).where(user_id: 1)

# Full index:    5ms
# Partial index: 3ms (40% faster due to smaller index)

# Write performance (updating unpublished post):
post.update(title: &quot;New&quot;)

# Full index:    2ms (must update index)
# Partial index: 0ms (not in index, no update needed)
</code></pre>
<hr>
<h3>Advanced Partial Index Patterns</h3>
<p><strong>1. Multi-column conditions:</strong></p>
<pre><code class="language-ruby">add_index :orders, :user_id,
          where: &quot;status = &#39;pending&#39; AND payment_status = &#39;unpaid&#39;&quot;

# Very specific, very efficient for common queries
</code></pre>
<p><strong>2. Date ranges:</strong></p>
<pre><code class="language-ruby"># Only index current year
add_index :events, :user_id,
          where: &quot;EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM CURRENT_DATE)&quot;

# Requires periodic recreation (use regular index for this case)
</code></pre>
<p><strong>3. Null values:</strong></p>
<pre><code class="language-ruby"># Only index rows with value (exclude nulls)
add_index :products, :discount_code,
          where: &quot;discount_code IS NOT NULL&quot;

# Smaller index, faster for discount queries
</code></pre>
<p><strong>4. Combination with expression indexes:</strong></p>
<pre><code class="language-ruby">add_index :users, &quot;LOWER(email)&quot;,
          where: &quot;deleted_at IS NULL&quot;,
          name: &quot;idx_users_active_email_lower&quot;

# Case-insensitive search on active users only
</code></pre>
<hr>
<h3>Monitoring Partial Indexes</h3>
<p><strong>Check if query uses partial index:</strong></p>
<pre><code class="language-ruby">Post.where(published: true, user_id: 1).explain

# Look for index name in EXPLAIN output:
# Index Scan using index_posts_on_user_id on posts
# Index Cond: (user_id = 1)
# Filter: published = true
</code></pre>
<p><strong>Check index size:</strong></p>
<pre><code class="language-sql">SELECT
  indexname,
  pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes
WHERE indexname = &#39;index_posts_on_user_id&#39;;

-- Compare partial vs full index sizes
</code></pre>
<hr>
<h3>When to Use Partial Indexes</h3>
<p><strong>Use partial indexes when:</strong></p>
<p>✅ <strong>Queries filter by specific condition</strong> frequently</p>
<pre><code class="language-ruby"># 90% of queries: where(published: true)
add_index :posts, :user_id, where: &quot;published = true&quot;
</code></pre>
<p>✅ <strong>Subset of data is much smaller</strong> than full table</p>
<pre><code class="language-ruby"># 5% of users are admins, 95% regular
add_index :users, :last_login, where: &quot;role = &#39;admin&#39;&quot;
</code></pre>
<p>✅ <strong>Soft deletes</strong> with active queries dominant</p>
<pre><code class="language-ruby">add_index :records, :field, where: &quot;deleted_at IS NULL&quot;
</code></pre>
<p>✅ <strong>Unique constraints</strong> on active records only</p>
<pre><code class="language-ruby">add_index :users, :email, unique: true, where: &quot;deleted_at IS NULL&quot;
</code></pre>
<p><strong>Don&#39;t use when:</strong></p>
<p>❌ <strong>Filter condition varies</strong> frequently</p>
<pre><code class="language-ruby"># Sometimes status = &#39;pending&#39;, sometimes &#39;completed&#39;
# Full index better
</code></pre>
<p>❌ <strong>Subset is large</strong> (&gt; 50% of table)</p>
<pre><code class="language-ruby"># If 60% published, partial index not much smaller
# Full index better
</code></pre>
<hr>
<h3>Migration Example</h3>
<p><strong>Complete implementation:</strong></p>
<pre><code class="language-ruby">class OptimizePostsIndexes &lt; ActiveRecord::Migration[7.0]
  def up
    # Remove full index
    remove_index :posts, :user_id if index_exists?(:posts, :user_id)
    
    # Add partial index for published posts (80% of queries)
    add_index :posts, [:user_id, :created_at],
              where: &quot;published = true&quot;,
              name: &quot;idx_posts_published&quot;
    
    # Add partial index for drafts (20% of queries)
    add_index :posts, [:user_id, :updated_at],
              where: &quot;published = false&quot;,
              name: &quot;idx_posts_drafts&quot;
  end
  
  def down
    remove_index :posts, name: &quot;idx_posts_published&quot;
    remove_index :posts, name: &quot;idx_posts_drafts&quot;
    add_index :posts, :user_id
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Partial indexes</strong> index subset of rows</li>
<li><strong>Much smaller</strong> than full indexes</li>
<li><strong>Faster</strong> for filtered queries</li>
<li><strong>PostgreSQL native</strong> feature</li>
<li><strong>Perfect for</strong> soft deletes</li>
<li><strong>Great for</strong> skewed data (5/95 split)</li>
<li><strong>Unique constraints</strong> on active rows</li>
<li><strong>Less maintenance</strong> overhead</li>
<li><strong>Query must match</strong> WHERE condition</li>
<li><strong>10x smaller</strong> possible for right use case</li>
</ol>
<hr>
<h2>Question 82: What is the difference between a clustered index and non-clustered index?</h2>
<h3>Answer</h3>
<p><strong>Clustered index</strong> determines physical row storage order (table sorted by index). <strong>Non-clustered index</strong> is a separate structure pointing to row locations. Tables can have only ONE clustered index but multiple non-clustered indexes.</p>
<hr>
<h3>Clustered Index</h3>
<p><strong>Physical row order:</strong></p>
<pre><code>Table: users (clustered on id)

Physical storage on disk:
[Row: id=1, name=&quot;Alice&quot;]
[Row: id=2, name=&quot;Bob&quot;]
[Row: id=3, name=&quot;Charlie&quot;]
[Row: id=4, name=&quot;Dave&quot;]

Data IS the index
Index and table are ONE thing
</code></pre>
<p><strong>Characteristics:</strong></p>
<p>✅ <strong>Fast range queries</strong> on clustered column</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id BETWEEN 100 AND 200
-- Reads contiguous disk blocks (very fast)
</code></pre>
<p>✅ <strong>No pointer lookup</strong> needed</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id = 50
-- Finds row directly (data is there)
</code></pre>
<p>❌ <strong>Only ONE per table</strong></p>
<pre><code class="language-sql">-- Can&#39;t cluster by both id AND email
</code></pre>
<p>❌ <strong>Expensive inserts</strong> if not sequential</p>
<pre><code class="language-sql">INSERT INTO users (id, name) VALUES (50, &#39;New&#39;)
-- Might require row reordering on disk
</code></pre>
<hr>
<h3>Non-Clustered Index</h3>
<p><strong>Separate structure with pointers:</strong></p>
<pre><code>Table: users (heap storage)
Physical storage (random order):
[Row: id=3, name=&quot;Charlie&quot;]
[Row: id=1, name=&quot;Alice&quot;]
[Row: id=4, name=&quot;Dave&quot;]
[Row: id=2, name=&quot;Bob&quot;]

Index on email:
alice@ex.com   → pointer to row location
bob@ex.com     → pointer to row location
charlie@ex.com → pointer to row location
dave@ex.com    → pointer to row location
</code></pre>
<p><strong>Characteristics:</strong></p>
<p>✅ <strong>Multiple per table</strong></p>
<pre><code class="language-sql">CREATE INDEX idx_email ON users(email)
CREATE INDEX idx_name ON users(name)
CREATE INDEX idx_created ON users(created_at)
-- Can have many!
</code></pre>
<p>✅ <strong>Flexible</strong> index choices</p>
<pre><code class="language-sql">-- Index whatever makes sense
</code></pre>
<p>❌ <strong>Requires pointer lookup</strong></p>
<pre><code class="language-sql">SELECT * FROM users WHERE email = &#39;alice@example.com&#39;
-- 1. Find in index
-- 2. Follow pointer to row
-- (Two lookups)
</code></pre>
<p>❌ <strong>Slower range queries</strong></p>
<pre><code class="language-sql">SELECT * FROM users WHERE email BETWEEN &#39;a&#39; AND &#39;c&#39;
-- Must follow each pointer (random disk reads)
</code></pre>
<hr>
<h3>Database Implementation</h3>
<p><strong>MySQL (InnoDB):</strong></p>
<pre><code class="language-ruby"># Primary key is ALWAYS clustered index
create_table :users do |t|
  t.bigint :id, primary_key: true  # Clustered index
  t.string :email
  t.string :name
end

# Secondary indexes are non-clustered
add_index :users, :email  # Non-clustered (points to PK)

# InnoDB structure:
# Clustered index (PK):
#   1 → [id=1, email=&quot;alice@ex.com&quot;, name=&quot;Alice&quot;]
#   2 → [id=2, email=&quot;bob@ex.com&quot;, name=&quot;Bob&quot;]
#
# Secondary index (email):
#   alice@ex.com → 1 (points to PK)
#   bob@ex.com   → 2 (points to PK)
#
# Lookup by email:
# 1. Find email in secondary index → get PK=1
# 2. Find PK=1 in clustered index → get full row
</code></pre>
<p><strong>PostgreSQL:</strong></p>
<pre><code class="language-ruby"># No clustered indexes by default!
# All indexes are non-clustered (heap storage)

create_table :users do |t|
  t.bigint :id  # Just a unique index, not clustered
  t.string :email
end

# Can manually cluster (one-time sort):
execute &quot;CLUSTER users USING users_pkey&quot;
# Sorts table by index
# But doesn&#39;t maintain order on future inserts

# All indexes point to row location:
# Index on id:
#   1 → row location A
#   2 → row location B
#
# Index on email:
#   alice@ex.com → row location A
#   bob@ex.com   → row location B
</code></pre>
<hr>
<h3>Performance Implications</h3>
<p><strong>Clustered Index:</strong></p>
<pre><code class="language-ruby"># FAST - range query on clustered index
User.where(id: 1..1000).to_a
# SQL: SELECT * FROM users WHERE id BETWEEN 1 AND 1000
# Reads: Sequential disk reads (fast)
# Time: ~10ms for 1000 rows

# SLOW - range query on non-clustered
User.where(email: &#39;a@ex.com&#39;..&#39;m@ex.com&#39;).to_a
# Reads: Random disk seeks (slow)
# Time: ~100ms for 1000 rows

# INSERT performance:
# Fast if sequential:
User.create(id: 10001)  # Append to end
# Slow if random:
User.create(id: 5000)   # Might need to reorganize
</code></pre>
<p><strong>Non-Clustered Index:</strong></p>
<pre><code class="language-ruby"># Extra lookup required
User.where(email: &#39;alice@example.com&#39;).first
# 1. Find &#39;alice@example.com&#39; in email index → get id=1
# 2. Find id=1 in clustered index → get full row
# Time: ~5ms (two lookups)

# But flexible:
add_index :users, :email
add_index :users, :name
add_index :users, :created_at
# Can have many!
</code></pre>
<hr>
<h3>Choosing Clustered Index Column</h3>
<p><strong>Good clustered index candidates:</strong></p>
<p>✅ <strong>Sequential</strong> (auto-increment ID)</p>
<pre><code class="language-ruby"># Perfect for clustered index
create_table :users do |t|
  t.bigint :id  # Sequential, always increasing
end
</code></pre>
<p>✅ <strong>Frequently used in range queries</strong></p>
<pre><code class="language-ruby"># If you often query:
Post.where(created_at: 1.week.ago..Date.today)
# Consider clustering by created_at
</code></pre>
<p>✅ <strong>Never/rarely updated</strong></p>
<pre><code class="language-ruby"># ID never changes → good
# last_updated_at changes constantly → bad
</code></pre>
<p><strong>Bad clustered index candidates:</strong></p>
<p>❌ <strong>Random</strong> (UUIDs)</p>
<pre><code class="language-ruby"># UUID as clustered index
create_table :users, id: :uuid do |t|
  # Random UUIDs cause random inserts
  # Lots of page splits and fragmentation
end
</code></pre>
<p>❌ <strong>Frequently updated</strong></p>
<pre><code class="language-ruby"># Clustering by updated_at
# Every update changes cluster position (expensive!)
</code></pre>
<p>❌ <strong>Wide</strong> columns</p>
<pre><code class="language-ruby"># Clustering by VARCHAR(500)
# Secondary indexes store this value (bloat)
</code></pre>
<hr>
<h3>Rails/PostgreSQL Simulation</h3>
<p><strong>PostgreSQL doesn&#39;t maintain clustering:</strong></p>
<pre><code class="language-ruby"># One-time cluster
class ClusterUsers &lt; ActiveRecord::Migration[7.0]
  def up
    # Sort table by index
    execute &quot;CLUSTER users USING index_users_on_created_at&quot;
  end
end

# Now sorted by created_at on disk
# But future inserts won&#39;t maintain order

# To maintain, must re-cluster periodically:
# CLUSTER users  (re-sorts entire table)
</code></pre>
<hr>
<h3>MySQL Clustered Index Strategy</h3>
<p><strong>Always cluster by primary key:</strong></p>
<pre><code class="language-ruby"># Default: id (good for most cases)
create_table :posts do |t|
  t.bigint :id  # Clustered
  t.timestamps
end

# UUID primary key (be careful)
create_table :posts, id: :uuid do |t|
  # Clustered by UUID (random!)
  # Consider using uuid_v7 (time-ordered)
end

# Secondary indexes reference PK:
add_index :posts, :user_id
# Internally stores: user_id → id (not row location)
# This is why narrow PKs are important
</code></pre>
<hr>
<h3>Covering Index (Related Concept)</h3>
<p><strong>Include extra columns in non-clustered index:</strong></p>
<pre><code class="language-ruby"># PostgreSQL: INCLUDE clause
execute &lt;&lt;-SQL
  CREATE INDEX idx_user_email 
  ON users (email) 
  INCLUDE (name, created_at)
SQL

# Now this query doesn&#39;t need table lookup:
User.select(:email, :name, :created_at).where(email: &#39;alice@example.com&#39;)
# All columns in index (covering index)
# No pointer follow needed!
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Clustered</strong> = physical row order</li>
<li><strong>Non-clustered</strong> = separate index structure</li>
<li><strong>ONE clustered</strong> per table</li>
<li><strong>Many non-clustered</strong> possible</li>
<li><strong>MySQL PK</strong> is always clustered</li>
<li><strong>PostgreSQL</strong> has no true clustered indexes</li>
<li><strong>Clustered</strong> fast for ranges</li>
<li><strong>Non-clustered</strong> requires pointer lookup</li>
<li><strong>Sequential clustered</strong> keys best</li>
<li><strong>Choose wisely</strong> - expensive to change</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 83: What is a covering index?</h2>
<h3>Answer</h3>
<p>A <strong>covering index</strong> includes all columns needed for a query, allowing the database to satisfy the query entirely from the index without accessing the table. This eliminates expensive table lookups.</p>
<hr>
<h3>How Covering Indexes Work</h3>
<p><strong>Without covering index:</strong></p>
<pre><code>Query: SELECT name, email FROM users WHERE email = &#39;alice@example.com&#39;

Index on email:
alice@example.com → Row pointer

Steps:
1. Find &#39;alice@example.com&#39; in index
2. Get row pointer
3. Read row from table to get &#39;name&#39;
4. Return result

Disk reads: 2 (index + table)
Time: ~5ms
</code></pre>
<p><strong>With covering index:</strong></p>
<pre><code>Covering index on (email, name):
alice@example.com, Alice → (all data here)

Steps:
1. Find &#39;alice@example.com&#39; in index
2. Read name directly from index
3. Return result (no table access!)

Disk reads: 1 (index only)
Time: ~1ms (5x faster)
</code></pre>
<hr>
<h3>Creating Covering Indexes</h3>
<p><strong>PostgreSQL (INCLUDE clause):</strong></p>
<pre><code class="language-ruby"># Migration
class AddCoveringIndexToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    # Regular index
    # add_index :users, :email
    
    # Covering index (includes extra columns)
    execute &lt;&lt;-SQL
      CREATE INDEX idx_users_email_covering 
      ON users (email) 
      INCLUDE (name, created_at)
    SQL
  end
end

# This query covered (no table access):
User.select(:email, :name, :created_at)
    .where(email: &#39;alice@example.com&#39;)

# Index contains all needed columns!
</code></pre>
<p><strong>MySQL/Other DBs (add columns to index):</strong></p>
<pre><code class="language-ruby"># MySQL doesn&#39;t have INCLUDE
# Add columns to index directly:
add_index :users, [:email, :name, :created_at]

# This makes it a covering index for:
User.select(:email, :name, :created_at)
    .where(email: &#39;alice@example.com&#39;)
</code></pre>
<hr>
<h3>When Queries Are Covered</h3>
<p><strong>Covered query:</strong></p>
<pre><code class="language-ruby"># Index: (email, name, created_at)

# ✅ Covered - all columns in index
User.select(:email, :name, :created_at)
    .where(email: &#39;alice@example.com&#39;)

# ✅ Covered - subset of indexed columns
User.select(:email, :name)
    .where(email: &#39;alice@example.com&#39;)

# ✅ Covered - WHERE + SELECT both in index
User.select(:name)
    .where(email: &#39;alice@example.com&#39;)
</code></pre>
<p><strong>Not covered queries:</strong></p>
<pre><code class="language-ruby"># Index: (email, name, created_at)

# ❌ Not covered - bio not in index
User.select(:email, :name, :bio)
    .where(email: &#39;alice@example.com&#39;)
# Must access table for &#39;bio&#39;

# ❌ Not covered - SELECT * includes all columns
User.where(email: &#39;alice@example.com&#39;)
# Must access table for all columns
</code></pre>
<hr>
<h3>Covering Index Patterns</h3>
<p><strong>Pattern 1: SELECT specific columns</strong></p>
<pre><code class="language-ruby"># Frequent query:
Post.select(:id, :title, :user_id)
    .where(published: true)
    .order(created_at: :desc)
    .limit(10)

# Covering index:
add_index :posts, [:published, :created_at, :id, :title, :user_id],
          name: &#39;idx_posts_published_covering&#39;

# All columns in index - no table access!
</code></pre>
<p><strong>Pattern 2: API endpoints</strong></p>
<pre><code class="language-ruby"># API returns limited fields:
class Api::UsersController &lt; ApplicationController
  def index
    users = User.select(:id, :name, :email, :created_at)
                .where(active: true)
                .order(created_at: :desc)
    
    render json: users
  end
end

# Covering index for this endpoint:
execute &lt;&lt;-SQL
  CREATE INDEX idx_users_api_index
  ON users (active, created_at DESC)
  INCLUDE (id, name, email)
SQL
</code></pre>
<p><strong>Pattern 3: Frequent aggregations</strong></p>
<pre><code class="language-ruby"># Count posts per user
Post.select(:user_id, &#39;COUNT(*) as count&#39;)
    .group(:user_id)

# Covering index:
add_index :posts, :user_id
# Only needs user_id - covered!
</code></pre>
<hr>
<h3>PostgreSQL INCLUDE vs Regular Index</h3>
<p><strong>INCLUDE clause (PostgreSQL 11+):</strong></p>
<pre><code class="language-ruby"># Advantage: Cleaner separation
execute &lt;&lt;-SQL
  CREATE INDEX idx_users_email
  ON users (email)
  INCLUDE (name, avatar_url, bio)
SQL

# Index structure:
# email (sortable, searchable)
# + name, avatar_url, bio (just stored, not sortable)

# Queries:
# WHERE email = &#39;...&#39;  → Uses email for search
# Can also return name, avatar_url, bio without table access
</code></pre>
<p><strong>Regular composite index:</strong></p>
<pre><code class="language-ruby"># Alternative for MySQL:
add_index :users, [:email, :name, :avatar_url, :bio]

# Index structure:
# All columns sortable/searchable
# Larger index (all columns indexed)
# Can use for: WHERE name = &#39;...&#39; (less useful)
</code></pre>
<hr>
<h3>Performance Impact</h3>
<p><strong>Benchmark:</strong></p>
<pre><code class="language-ruby"># Setup: 1,000,000 users

# Regular index on email
add_index :users, :email

query = User.select(:email, :name, :created_at)
            .where(email: &#39;user500000@example.com&#39;)

Benchmark.bm do |x|
  x.report(&quot;Regular index:&quot;) do
    1000.times { query.to_a }
  end
  # Time: ~5000ms (2 reads per query: index + table)
end

# Covering index
execute &lt;&lt;-SQL
  CREATE INDEX idx_users_email_covering
  ON users (email)
  INCLUDE (name, created_at)
SQL

Benchmark.bm do |x|
  x.report(&quot;Covering index:&quot;) do
    1000.times { query.to_a }
  end
  # Time: ~1000ms (1 read per query: index only)
  # 5x faster!
end
</code></pre>
<hr>
<h3>Verifying Index Coverage</h3>
<p><strong>EXPLAIN query:</strong></p>
<pre><code class="language-ruby">User.select(:email, :name)
    .where(email: &#39;alice@example.com&#39;)
    .explain

# With covering index:
# Index Only Scan using idx_users_email_covering
#   Index Cond: (email = &#39;alice@example.com&#39;)
# ↑ &quot;Index Only Scan&quot; means covered!

# Without covering index:
# Index Scan using index_users_on_email
#   Index Cond: (email = &#39;alice@example.com&#39;)
# ↑ &quot;Index Scan&quot; (not &quot;Index Only&quot;) means table access needed
</code></pre>
<p><strong>Check heap fetches:</strong></p>
<pre><code class="language-ruby"># PostgreSQL - see if table accessed
EXPLAIN (ANALYZE, BUFFERS) 
SELECT email, name 
FROM users 
WHERE email = &#39;alice@example.com&#39;;

# Look for &quot;Heap Fetches: 0&quot;
# 0 = fully covered
# &gt; 0 = some table access needed
</code></pre>
<hr>
<h3>Trade-offs</h3>
<p><strong>Benefits:</strong></p>
<p>✅ <strong>Faster queries</strong> - no table access
✅ <strong>Less I/O</strong> - only read index
✅ <strong>Better caching</strong> - index stays in memory</p>
<p><strong>Costs:</strong></p>
<p>❌ <strong>Larger indexes</strong> - store extra columns
❌ <strong>Slower writes</strong> - must update extra columns
❌ <strong>More storage</strong> - indexes take space</p>
<hr>
<h3>When to Use Covering Indexes</h3>
<p><strong>Use when:</strong></p>
<p>✅ <strong>Frequent queries</strong> select same columns</p>
<pre><code class="language-ruby"># Dashboard query run 1000x/sec:
User.select(:id, :name, :email, :role)
    .where(active: true)
    .order(created_at: :desc)

# Worth the index overhead
</code></pre>
<p>✅ <strong>API endpoints</strong> with fixed fields</p>
<pre><code class="language-ruby"># API always returns same fields:
def index
  render json: User.select(:id, :name, :email, :avatar_url)
end
</code></pre>
<p>✅ <strong>Report queries</strong> with specific columns</p>
<pre><code class="language-ruby"># Monthly report:
Order.select(:id, :total, :created_at, :status)
     .where(created_at: 1.month.ago..Date.today)
</code></pre>
<p><strong>Don&#39;t use when:</strong></p>
<p>❌ <strong>SELECT * queries</strong> dominate</p>
<pre><code class="language-ruby"># Most queries do:
User.where(email: &#39;alice@example.com&#39;)
# Returns all columns anyway
</code></pre>
<p>❌ <strong>Covered columns rarely queried</strong></p>
<pre><code class="language-ruby"># Covering index includes 10 columns
# But only 2 used in most queries
# Waste of space
</code></pre>
<p>❌ <strong>High write volume</strong> on covered columns</p>
<pre><code class="language-ruby"># last_seen_at updated every request
# Don&#39;t include in covering index
</code></pre>
<hr>
<h3>Real-World Example</h3>
<p><strong>Dashboard endpoint:</strong></p>
<pre><code class="language-ruby">class DashboardController &lt; ApplicationController
  def index
    # Query run 10,000x/day
    @users = User.select(
      :id,
      :name,
      :email,
      :role,
      :last_sign_in_at,
      :created_at
    )
    .where(active: true)
    .order(last_sign_in_at: :desc)
    .limit(100)
  end
end

# Migration - covering index
class AddDashboardCoveringIndex &lt; ActiveRecord::Migration[7.0]
  def change
    execute &lt;&lt;-SQL
      CREATE INDEX idx_users_dashboard
      ON users (active, last_sign_in_at DESC)
      INCLUDE (id, name, email, role, created_at)
    SQL
  end
end

# Result:
# Before: ~50ms (index scan + table fetch)
# After:  ~10ms (index only scan)
# 5x faster!
</code></pre>
<hr>
<h3>Monitoring Covering Indexes</h3>
<p><strong>Check index usage:</strong></p>
<pre><code class="language-sql">-- PostgreSQL
SELECT
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes
WHERE indexname = &#39;idx_users_email_covering&#39;;

-- idx_tup_fetch should be 0 for fully covered queries
</code></pre>
<p><strong>Check size:</strong></p>
<pre><code class="language-sql">SELECT
  pg_size_pretty(pg_relation_size(&#39;idx_users_email_covering&#39;)) as size;

-- Monitor if covering index grows too large
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Covering index</strong> contains all query columns</li>
<li><strong>No table access</strong> needed</li>
<li><strong>&quot;Index Only Scan&quot;</strong> in EXPLAIN</li>
<li><strong>5-10x faster</strong> for covered queries</li>
<li><strong>PostgreSQL INCLUDE</strong> clause recommended</li>
<li><strong>Larger indexes</strong> trade-off</li>
<li><strong>Perfect for</strong> frequent queries</li>
<li><strong>Perfect for</strong> API endpoints</li>
<li><strong>Monitor</strong> index size</li>
<li><strong>Verify</strong> with EXPLAIN</li>
</ol>
<hr>
<h2>Question 84: What is the impact of too many indexes on a table?</h2>
<h3>Answer</h3>
<p>Too many indexes <strong>slow down writes</strong> (INSERT/UPDATE/DELETE), <strong>consume storage</strong>, <strong>waste memory</strong>, and can confuse the query optimizer. Balance is key - index for reads, but don&#39;t over-index.</p>
<hr>
<h3>Negative Impacts</h3>
<p><strong>1. Write Performance Degradation</strong></p>
<pre><code class="language-ruby"># Table with no indexes
User.create(name: &quot;Alice&quot;, email: &quot;alice@example.com&quot;)
# Time: ~1ms
# Actions: INSERT one row

# Table with 10 indexes
User.create(name: &quot;Alice&quot;, email: &quot;alice@example.com&quot;)
# Time: ~10ms (10x slower)
# Actions:
# - INSERT one row
# - UPDATE index on name
# - UPDATE index on email
# - UPDATE index on created_at
# - UPDATE index on updated_at
# - UPDATE index on role
# - UPDATE index on active
# - UPDATE composite index (name, email)
# - UPDATE composite index (email, created_at)
# - UPDATE full-text search index
# - UPDATE partial index on active users

# Each index must be updated!
</code></pre>
<p><strong>Benchmark:</strong></p>
<pre><code class="language-ruby">require &#39;benchmark&#39;

# Setup: Table with 1 index vs 10 indexes
# Test: Insert 10,000 rows

Benchmark.bm do |x|
  x.report(&quot;1 index:&quot;) do
    10000.times { |i| User.create(email: &quot;user#{i}@example.com&quot;) }
  end
  # Time: ~2000ms
  
  x.report(&quot;10 indexes:&quot;) do
    10000.times { |i| User.create(email: &quot;user#{i}@example.com&quot;) }
  end
  # Time: ~15000ms (7.5x slower!)
end
</code></pre>
<hr>
<p><strong>2. Storage Overhead</strong></p>
<pre><code class="language-ruby"># Table: users (1,000,000 rows)
# Table size: 500MB

# Add 10 indexes:
add_index :users, :email              # +50MB
add_index :users, :name               # +60MB
add_index :users, [:email, :name]     # +80MB
add_index :users, :created_at         # +45MB
add_index :users, [:role, :active]    # +40MB
# ... 5 more indexes ...              # +200MB

# Total storage:
# Table: 500MB
# Indexes: 475MB (almost as much as table!)
# Total: 975MB

# Storage costs doubled!
</code></pre>
<hr>
<p><strong>3. Memory Pressure</strong></p>
<pre><code class="language-ruby"># Database tries to cache indexes in RAM
# With many indexes, less cache hits

# Good scenario (few indexes):
# RAM: 8GB
# Table: 2GB (cached)
# Indexes: 1GB (all cached)
# Cache hit rate: 95%

# Bad scenario (many indexes):
# RAM: 8GB
# Table: 2GB (partially cached)
# Indexes: 6GB (can&#39;t fit all in RAM)
# Cache hit rate: 60% (more disk I/O)

# Result: Queries slower despite indexes!
</code></pre>
<hr>
<p><strong>4. Query Optimizer Confusion</strong></p>
<pre><code class="language-ruby"># 10 possible indexes for query:
User.where(email: &#39;alice@example.com&#39;)
    .where(active: true)
    .order(created_at: :desc)

# Available indexes:
# 1. email
# 2. active
# 3. created_at
# 4. (email, active)
# 5. (email, created_at)
# 6. (active, created_at)
# 7. (email, active, created_at)
# ... more ...

# Optimizer must choose:
# - Takes time to evaluate options
# - Might choose suboptimal index
# - Planning time increases
</code></pre>
<p><strong>EXPLAIN shows planning time:</strong></p>
<pre><code class="language-sql">EXPLAIN ANALYZE SELECT * FROM users WHERE email = &#39;...&#39;;

# Planning Time: 2.5 ms    (with 2 indexes)
# Planning Time: 15.3 ms   (with 20 indexes)
# 
# Planning overhead increases with more indexes!
</code></pre>
<hr>
<p><strong>5. Index Maintenance Overhead</strong></p>
<pre><code class="language-ruby"># VACUUM (PostgreSQL) must process all indexes
execute &quot;VACUUM ANALYZE users&quot;

# With 2 indexes:  ~5 seconds
# With 20 indexes: ~50 seconds

# REINDEX must rebuild all
execute &quot;REINDEX TABLE users&quot;

# With 2 indexes:  ~10 seconds
# With 20 indexes: ~100 seconds

# Database maintenance windows increase!
</code></pre>
<hr>
<p><strong>6. Backup/Restore Time</strong></p>
<pre><code class="language-ruby"># Backup size includes indexes
# pg_dump users table:

# With 2 indexes:  500MB, 2 minutes
# With 20 indexes: 2.5GB, 10 minutes

# Restore time also increases
</code></pre>
<hr>
<h3>Finding Unused Indexes</h3>
<p><strong>PostgreSQL query:</strong></p>
<pre><code class="language-sql">-- Find indexes never used
SELECT
  schemaname,
  tablename,
  indexname,
  idx_scan,
  pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
  AND indexname NOT LIKE &#39;%pkey&#39;
ORDER BY pg_relation_size(indexrelid) DESC;

-- idx_scan = 0 means never used!
</code></pre>
<p><strong>Find rarely used indexes:</strong></p>
<pre><code class="language-sql">-- Indexes used &lt; 10 times
SELECT
  schemaname,
  tablename,
  indexname,
  idx_scan,
  pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes
WHERE idx_scan &lt; 10
  AND indexname NOT LIKE &#39;%pkey&#39;
ORDER BY pg_relation_size(indexrelid) DESC;
</code></pre>
<hr>
<h3>Index Overlap/Redundancy</h3>
<p><strong>Redundant indexes:</strong></p>
<pre><code class="language-ruby"># Redundant: Both indexes exist
add_index :users, :email
add_index :users, [:email, :name]

# First index redundant!
# Composite (email, name) covers (email) queries

# Remove redundant:
remove_index :users, :email
# Keep only composite
</code></pre>
<p><strong>Check for duplicates:</strong></p>
<pre><code class="language-sql">-- PostgreSQL: Find duplicate indexes
SELECT
  array_agg(indexname) as indexes,
  tablename,
  array_agg(pg_size_pretty(pg_relation_size(indexrelid))) as sizes
FROM pg_stat_user_indexes
WHERE schemaname = &#39;public&#39;
GROUP BY tablename, array_to_string(array_agg(indkey::text), &#39;,&#39;)
HAVING COUNT(*) &gt; 1;
</code></pre>
<hr>
<h3>Optimal Number of Indexes</h3>
<p><strong>General guidelines:</strong></p>
<pre><code class="language-ruby"># Small table (&lt; 10,000 rows): 1-3 indexes
# PK + 1-2 frequently queried columns

# Medium table (10k-1M rows): 3-7 indexes
# PK + foreign keys + 2-4 query columns

# Large table (1M+ rows): 5-15 indexes
# PK + all foreign keys + 5-10 query patterns

# Very large table (10M+ rows): Carefully analyze
# Each index must justify its cost
</code></pre>
<p><strong>Signs of too many indexes:</strong></p>
<p>❌ Write performance degraded
❌ Index size &gt; table size
❌ Many indexes with idx_scan = 0
❌ Planning time &gt; execution time
❌ Maintenance takes too long</p>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Create indexes purposefully:</strong></p>
<pre><code class="language-ruby"># BAD - &quot;just in case&quot; indexes
add_index :users, :middle_name  # Never queried
add_index :users, :favorite_color  # Rarely queried

# GOOD - proven need
# Add index AFTER seeing slow query
# Monitor with EXPLAIN ANALYZE
</code></pre>
<p><strong>2. Use composite indexes:</strong></p>
<pre><code class="language-ruby"># BAD - separate indexes
add_index :posts, :user_id
add_index :posts, :created_at

# GOOD - composite covers both
add_index :posts, [:user_id, :created_at]
# Can handle:
# WHERE user_id = 1
# WHERE user_id = 1 ORDER BY created_at
</code></pre>
<p><strong>3. Monitor and remove unused:</strong></p>
<pre><code class="language-ruby"># Regular audit task
class AuditIndexesJob &lt; ApplicationJob
  def perform
    unused = find_unused_indexes
    
    if unused.any?
      Rails.logger.warn &quot;Unused indexes: #{unused}&quot;
      # Email team to review
    end
  end
  
  private
  
  def find_unused_indexes
    sql = &lt;&lt;-SQL
      SELECT indexname FROM pg_stat_user_indexes
      WHERE idx_scan = 0 AND indexname NOT LIKE &#39;%pkey&#39;
    SQL
    
    ActiveRecord::Base.connection.execute(sql).values.flatten
  end
end
</code></pre>
<p><strong>4. Partial indexes for subsets:</strong></p>
<pre><code class="language-ruby"># BAD - full index on boolean
add_index :users, :admin

# GOOD - partial index on rare value
add_index :users, :id, where: &quot;admin = true&quot;
# Only 1% of users are admin
# Index 100x smaller!
</code></pre>
<p><strong>5. Document index purpose:</strong></p>
<pre><code class="language-ruby"># Migration with documentation
class AddUserEmailIndex &lt; ActiveRecord::Migration[7.0]
  def change
    # Index for: User lookup by email (login)
    # Query: User.find_by(email: params[:email])
    # Frequency: 10,000/day
    add_index :users, :email, unique: true
  end
end
</code></pre>
<hr>
<h3>Real-World Example</h3>
<p><strong>Before optimization:</strong></p>
<pre><code class="language-ruby"># users table: 15 indexes
# Indexes:
# 1. id (PK)
# 2. email
# 3. name
# 4. created_at
# 5. updated_at
# 6. role
# 7. active
# 8. (email, name)
# 9. (name, email)  # Duplicate!
# 10. (role, active)
# 11. (active, role)  # Duplicate!
# 12. last_sign_in_at
# 13. confirmation_token  # Never queried
# 14. reset_password_token  # Rarely queried
# 15. middle_name  # Never queried

# Write performance: 10ms per insert
# Index size: 800MB
# Planning time: 12ms
</code></pre>
<p><strong>After optimization:</strong></p>
<pre><code class="language-ruby"># Removed:
# - middle_name (never queried)
# - confirmation_token (never queried)
# - reset_password_token (only 10 uses/month)
# - (name, email) (redundant with (email, name))
# - (active, role) (redundant with (role, active))
# - updated_at (never in WHERE clause)

# Kept: 9 indexes
# 1. id (PK)
# 2. email (login)
# 3. created_at (reports)
# 4. role (admin queries)
# 5. active (user queries)
# 6. (email, name) (API endpoint)
# 7. (role, active) (dashboard)
# 8. last_sign_in_at (analytics)
# 9. (active, created_at) (user list)

# Write performance: 5ms per insert (2x faster)
# Index size: 400MB (50% reduction)
# Planning time: 3ms (4x faster)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>More indexes</strong> = slower writes</li>
<li><strong>Index maintenance</strong> has cost</li>
<li><strong>Storage</strong> doubles or triples</li>
<li><strong>Memory pressure</strong> from large indexes</li>
<li><strong>Planning overhead</strong> increases</li>
<li><strong>Monitor</strong> index usage regularly</li>
<li><strong>Remove</strong> unused indexes</li>
<li><strong>Composite</strong> instead of multiple</li>
<li><strong>Partial</strong> for subsets</li>
<li><strong>5-15 indexes</strong> typical for most tables</li>
</ol>
<hr>
<h2>Question 85: What is the difference between UniqueKey and PrimaryKey?</h2>
<h3>Answer</h3>
<p><strong>Primary Key</strong> uniquely identifies rows, cannot be NULL, and only ONE per table. <strong>Unique Key</strong> enforces uniqueness but allows NULLs (in most databases), and multiple unique keys per table are allowed.</p>
<hr>
<h3>Quick Comparison</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Primary Key</th>
<th>Unique Key</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Purpose</strong></td>
<td>Row identifier</td>
<td>Enforce uniqueness</td>
</tr>
<tr>
<td><strong>NULL values</strong></td>
<td>❌ Not allowed</td>
<td>✅ Allowed (usually)</td>
</tr>
<tr>
<td><strong>Count per table</strong></td>
<td>ONE only</td>
<td>Multiple allowed</td>
</tr>
<tr>
<td><strong>Clustered index</strong></td>
<td>Yes (MySQL)</td>
<td>No</td>
</tr>
<tr>
<td><strong>Foreign key reference</strong></td>
<td>✅ Common</td>
<td>✅ Possible</td>
</tr>
<tr>
<td><strong>Auto-indexed</strong></td>
<td>✅ Always</td>
<td>✅ Always</td>
</tr>
</tbody></table>
<hr>
<h3>Primary Key</h3>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby"># Migration
create_table :users do |t|
  t.bigint :id  # Primary key (automatic)
  t.string :email
  t.string :name
end

# SQL:
# CREATE TABLE users (
#   id BIGSERIAL PRIMARY KEY,  ← Primary key
#   email VARCHAR,
#   name VARCHAR
# )

# Properties:
# - NOT NULL (automatic)
# - UNIQUE (automatic)
# - Indexed (automatic)
# - Only ONE per table
</code></pre>
<p><strong>Cannot be NULL:</strong></p>
<pre><code class="language-ruby">User.create(id: nil, email: &#39;alice@example.com&#39;)
# ERROR: null value in column &quot;id&quot; violates not-null constraint

# Can&#39;t have duplicate:
User.create(id: 1, email: &#39;alice@example.com&#39;)
User.create(id: 1, email: &#39;bob@example.com&#39;)
# ERROR: duplicate key value violates unique constraint &quot;users_pkey&quot;
</code></pre>
<p><strong>Used as foreign key reference:</strong></p>
<pre><code class="language-ruby">create_table :posts do |t|
  t.references :user, foreign_key: true
  # References users.id (primary key)
end

# posts.user_id → users.id
</code></pre>
<hr>
<h3>Unique Key</h3>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby"># Migration
create_table :users do |t|
  t.bigint :id  # Primary key
  t.string :email
  t.string :username
end

# Add unique constraints
add_index :users, :email, unique: true
add_index :users, :username, unique: true

# SQL:
# CREATE UNIQUE INDEX index_users_on_email ON users (email)
# CREATE UNIQUE INDEX index_users_on_username ON users (username)

# Properties:
# - UNIQUE enforced
# - NULLs allowed (in most DBs)
# - Indexed automatically
# - Multiple per table
</code></pre>
<p><strong>Allows NULL (usually):</strong></p>
<pre><code class="language-ruby"># PostgreSQL, MySQL behavior:
User.create(email: nil, username: &#39;alice&#39;)  # ✅ OK
User.create(email: nil, username: &#39;bob&#39;)    # ✅ OK
# Multiple NULLs allowed in unique column!

User.create(email: &#39;alice@example.com&#39;, username: &#39;charlie&#39;)
User.create(email: &#39;alice@example.com&#39;, username: &#39;dave&#39;)
# ERROR: duplicate key value violates unique constraint
</code></pre>
<p><strong>Multiple unique keys:</strong></p>
<pre><code class="language-ruby">create_table :users do |t|
  t.string :email
  t.string :username
  t.string :phone
end

# Multiple unique constraints:
add_index :users, :email, unique: true
add_index :users, :username, unique: true
add_index :users, :phone, unique: true

# All enforce uniqueness independently
</code></pre>
<hr>
<h3>Composite Primary Key</h3>
<p><strong>Multiple columns as PK:</strong></p>
<pre><code class="language-ruby"># Not common in Rails, but possible
create_table :user_roles, id: false do |t|
  t.references :user, null: false
  t.references :role, null: false
end

add_index :user_roles, [:user_id, :role_id], unique: true

# Or explicitly:
execute &lt;&lt;-SQL
  ALTER TABLE user_roles
  ADD CONSTRAINT user_roles_pkey
  PRIMARY KEY (user_id, role_id)
SQL

# Now (user_id, role_id) together is primary key
# Each alone can have duplicates
# Together must be unique
</code></pre>
<hr>
<h3>Composite Unique Key</h3>
<p><strong>Multiple columns must be unique together:</strong></p>
<pre><code class="language-ruby">create_table :enrollments do |t|
  t.references :student
  t.references :course
  t.timestamps
end

# Composite unique constraint
add_index :enrollments, [:student_id, :course_id], unique: true

# Allows:
Enrollment.create(student_id: 1, course_id: 1)  # ✅
Enrollment.create(student_id: 1, course_id: 2)  # ✅
Enrollment.create(student_id: 2, course_id: 1)  # ✅

# Prevents:
Enrollment.create(student_id: 1, course_id: 1)  # ❌ Duplicate
</code></pre>
<hr>
<h3>NULL Handling Differences</h3>
<p><strong>PostgreSQL/MySQL:</strong></p>
<pre><code class="language-ruby"># Unique key allows multiple NULLs
add_index :users, :middle_name, unique: true

User.create(middle_name: nil)  # ✅
User.create(middle_name: nil)  # ✅
User.create(middle_name: nil)  # ✅
# All allowed! NULL != NULL

User.create(middle_name: &#39;James&#39;)  # ✅
User.create(middle_name: &#39;James&#39;)  # ❌ ERROR
</code></pre>
<p><strong>SQL Server (different):</strong></p>
<pre><code class="language-sql">-- SQL Server: Only ONE NULL allowed in unique column
CREATE UNIQUE INDEX idx_middle_name ON users (middle_name)

-- First NULL: OK
-- Second NULL: ERROR (unique violation)
</code></pre>
<hr>
<h3>Using Unique Keys as Foreign Keys</h3>
<p><strong>Possible but uncommon:</strong></p>
<pre><code class="language-ruby">create_table :users do |t|
  t.string :email
end
add_index :users, :email, unique: true

create_table :profiles do |t|
  t.string :user_email
end

# Foreign key to unique column (not primary key)
add_foreign_key :profiles, :users, 
                column: :user_email,
                primary_key: :email

# Works, but unusual
# Normally reference primary key
</code></pre>
<hr>
<h3>Performance Differences</h3>
<p><strong>Both create indexes:</strong></p>
<pre><code class="language-ruby"># Primary key
create_table :users do |t|
  t.bigint :id  # Indexed automatically
end

# Unique key
add_index :users, :email, unique: true  # Also indexed

# Both equally fast for lookups:
User.find(1)                    # Fast (uses PK index)
User.find_by(email: &#39;alice@..&#39;) # Fast (uses unique index)
</code></pre>
<p><strong>Clustered index (MySQL InnoDB):</strong></p>
<pre><code class="language-ruby"># Primary key = clustered index (data sorted by PK)
# Unique key = non-clustered index (separate structure)

# This affects:
# - Range queries (PK faster)
# - Insert performance (PK sequential better)
</code></pre>
<hr>
<h3>Rails Conventions</h3>
<p><strong>Primary key always id:</strong></p>
<pre><code class="language-ruby"># Rails default
create_table :users do |t|
  # id column automatic
end

# Custom primary key name
create_table :products, primary_key: &#39;product_id&#39; do |t|
  # ...
end

# Composite primary key (gem needed)
gem &#39;composite_primary_keys&#39;

class Enrollment &lt; ApplicationRecord
  self.primary_keys = :student_id, :course_id
end
</code></pre>
<p><strong>Unique validations:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Application-level uniqueness
  validates :email, uniqueness: true
  
  # But should also add database constraint:
end

# Migration
add_index :users, :email, unique: true
# Both validation AND database constraint
</code></pre>
<hr>
<h3>Real-World Example</h3>
<pre><code class="language-ruby">class CreateUsers &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      # Primary key (automatic)
      # t.bigint :id
      
      # Unique constraints
      t.string :email, null: false
      t.string :username, null: false
      t.string :phone  # Can be NULL
      
      t.timestamps
    end
    
    # Unique indexes
    add_index :users, :email, unique: true
    add_index :users, :username, unique: true
    add_index :users, :phone, unique: true  # Allows multiple NULLs
  end
end

# Result:
# - id: Primary key (NOT NULL, UNIQUE, one per table)
# - email: Unique key (NOT NULL via migration, UNIQUE, enforced)
# - username: Unique key (NOT NULL via migration, UNIQUE, enforced)
# - phone: Unique key (NULLable, UNIQUE values only, multiple NULLs OK)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Primary key</strong> identifies rows uniquely</li>
<li><strong>Unique key</strong> enforces uniqueness only</li>
<li><strong>One primary key</strong> per table</li>
<li><strong>Multiple unique keys</strong> allowed</li>
<li><strong>Primary key</strong> cannot be NULL</li>
<li><strong>Unique key</strong> usually allows NULL</li>
<li><strong>Both</strong> create indexes automatically</li>
<li><strong>Primary key</strong> used for foreign keys</li>
<li><strong>Unique keys</strong> can be foreign keys (rare)</li>
<li><strong>Use both</strong> for data integrity</li>
</ol>
<hr>
<h2>Question 86: What is the difference between UUIDs and integer primary keys?</h2>
<h3>Answer</h3>
<p><strong>Integer IDs</strong> are sequential, compact, and fast. <strong>UUIDs</strong> are globally unique, distributed-friendly, but larger and slower. Choice depends on requirements: scale, security, distributed systems.</p>
<hr>
<h3>Quick Comparison</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Integer ID</th>
<th>UUID</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Size</strong></td>
<td>4-8 bytes</td>
<td>16 bytes</td>
</tr>
<tr>
<td><strong>Sequential</strong></td>
<td>✅ Yes</td>
<td>❌ No (v4), ✅ Yes (v7)</td>
</tr>
<tr>
<td><strong>Predictable</strong></td>
<td>✅ Yes</td>
<td>❌ No</td>
</tr>
<tr>
<td><strong>Globally unique</strong></td>
<td>❌ No</td>
<td>✅ Yes</td>
</tr>
<tr>
<td><strong>Index performance</strong></td>
<td>✅ Excellent</td>
<td>⚠️ Good (v4), ✅ Excellent (v7)</td>
</tr>
<tr>
<td><strong>Insert performance</strong></td>
<td>✅ Excellent</td>
<td>⚠️ Poor (v4), ✅ Good (v7)</td>
</tr>
<tr>
<td><strong>URL friendly</strong></td>
<td>✅ Short</td>
<td>❌ Long</td>
</tr>
<tr>
<td><strong>Merge databases</strong></td>
<td>❌ Conflicts</td>
<td>✅ No conflicts</td>
</tr>
</tbody></table>
<hr>
<h3>Integer Primary Keys (Default)</h3>
<p><strong>Rails default:</strong></p>
<pre><code class="language-ruby"># Migration
create_table :users do |t|
  # id: bigint (8 bytes)
  # Auto-increment: 1, 2, 3, 4, ...
  t.string :email
end

# Model
user1 = User.create(email: &#39;alice@example.com&#39;)
user1.id  # =&gt; 1

user2 = User.create(email: &#39;bob@example.com&#39;)
user2.id  # =&gt; 2

# Sequential, predictable
</code></pre>
<p><strong>Characteristics:</strong></p>
<p>✅ <strong>Compact:</strong> 8 bytes vs 16 bytes (UUID)
✅ <strong>Fast inserts:</strong> Sequential, no page splits
✅ <strong>Excellent index performance:</strong> B-tree optimal
✅ <strong>Short URLs:</strong> <code>/users/123</code> vs <code>/users/550e8400-e29b-41d4-a716-446655440000</code>
✅ <strong>Human-friendly:</strong> Easy to reference</p>
<p>❌ <strong>Predictable:</strong> Users can guess IDs
❌ <strong>Sequential reveals info:</strong> Competitors know record count
❌ <strong>Distributed systems:</strong> Conflicts when merging databases
❌ <strong>Not globally unique:</strong> Need coordination across services</p>
<hr>
<h3>UUIDs</h3>
<p><strong>Types of UUIDs:</strong></p>
<pre><code class="language-ruby"># UUID v4 (Random)
SecureRandom.uuid
# =&gt; &quot;550e8400-e29b-41d4-a716-446655440000&quot;
# Completely random (except version/variant bits)

# UUID v7 (Time-ordered, recommended)
# Not in Ruby stdlib, use gem
gem &#39;ruby_uuid&#39;

UUID.uuid_v7
# =&gt; &quot;01234567-89ab-cdef-0123-456789abcdef&quot;
# First 48 bits: timestamp (millisecond precision)
# Remaining: random
# Sortable by creation time!
</code></pre>
<p><strong>Rails with UUID:</strong></p>
<pre><code class="language-ruby"># Migration
class EnableUuidExtension &lt; ActiveRecord::Migration[7.0]
  def change
    enable_extension &#39;pgcrypto&#39;  # PostgreSQL
  end
end

create_table :users, id: :uuid do |t|
  t.string :email
end

# Model
user = User.create(email: &#39;alice@example.com&#39;)
user.id
# =&gt; &quot;550e8400-e29b-41d4-a716-446655440000&quot;

# Routes
users_path(user)
# =&gt; &quot;/users/550e8400-e29b-41d4-a716-446655440000&quot;
</code></pre>
<p><strong>Characteristics:</strong></p>
<p>✅ <strong>Globally unique:</strong> Can merge databases without conflicts
✅ <strong>Not predictable:</strong> Can&#39;t guess other users&#39; IDs
✅ <strong>Distributed-friendly:</strong> Generate without central coordination
✅ <strong>Security:</strong> Harder to enumerate resources</p>
<p>❌ <strong>Larger:</strong> 16 bytes vs 8 bytes (2x storage)
❌ <strong>Slower inserts (v4):</strong> Random writes cause page splits
❌ <strong>Larger indexes:</strong> 2x size
❌ <strong>Long URLs:</strong> Ugly and error-prone
❌ <strong>Not human-friendly:</strong> Hard to reference verbally</p>
<hr>
<h3>Storage Impact</h3>
<p><strong>Database size comparison:</strong></p>
<pre><code class="language-ruby"># 10,000,000 rows

# Integer ID:
# PK index: ~200MB
# Foreign keys: ~80MB each
# Total overhead: ~360MB

# UUID v4:
# PK index: ~400MB (2x)
# Foreign keys: ~160MB each (2x)
# Total overhead: ~720MB (2x)

# For large tables, this matters!
</code></pre>
<hr>
<h3>Index Performance</h3>
<p><strong>UUID v4 (Random - Poor):</strong></p>
<pre><code>B-tree index insertions (random):

Before insert:
[Page 1: uuid1, uuid2, uuid3]
[Page 2: uuid4, uuid5, uuid6]
[Page 3: uuid7, uuid8, uuid9]

Insert uuid_new (random, belongs in Page 2):
→ Page 2 is full!
→ Page split required
→ Expensive reorganization

Result:
- Random inserts cause page splits
- Index fragmentation
- 2-3x slower inserts than sequential
</code></pre>
<p><strong>UUID v7 (Time-ordered - Good):</strong></p>
<pre><code>B-tree index insertions (time-ordered):

Before insert:
[Page 1: uuid1, uuid2, uuid3]
[Page 2: uuid4, uuid5, uuid6]
[Page 3: uuid7, uuid8, uuid9]

Insert uuid_new (timestamp-based, newest):
→ Append to Page 3 (or new page)
→ No page splits!
→ Similar to sequential integers

Result:
- Sequential inserts
- No fragmentation
- Similar performance to integer IDs
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use Integer IDs when:</strong></p>
<p>✅ <strong>Single database</strong> (no distributed systems)
✅ <strong>Performance critical</strong> (high write volume)
✅ <strong>Storage costs matter</strong> (billions of rows)
✅ <strong>Short URLs</strong> important
✅ <strong>Internal tools</strong> (security less critical)</p>
<p><strong>Use UUIDs when:</strong></p>
<p>✅ <strong>Distributed systems</strong> (multiple databases)
✅ <strong>Merging databases</strong> (acquisitions, replication)
✅ <strong>Security</strong> (hide record counts, prevent enumeration)
✅ <strong>Client-side ID generation</strong> (offline-first apps)
✅ <strong>Microservices</strong> (independent ID generation)
✅ <strong>Global uniqueness</strong> required</p>
<hr>
<h3>Hybrid Approach</h3>
<p><strong>UUID + Integer:</strong></p>
<pre><code class="language-ruby"># Best of both worlds
create_table :users do |t|
  t.bigint :id  # Primary key (fast, compact)
  t.uuid :uuid, null: false  # Public ID (secure)
  t.string :email
end

add_index :users, :uuid, unique: true

# Model
class User &lt; ApplicationRecord
  before_create :generate_uuid
  
  def to_param
    uuid  # Use UUID in URLs
  end
  
  private
  
  def generate_uuid
    self.uuid = SecureRandom.uuid
  end
end

# Controller
def show
  @user = User.find_by!(uuid: params[:id])
end

# URLs:
# /users/550e8400-e29b-41d4-a716-446655440000

# Database:
# - Integer PK for joins (fast)
# - UUID for public API (secure)
</code></pre>
<hr>
<h3>UUID v7 (Modern Recommendation)</h3>
<p><strong>Time-ordered UUIDs:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;uuid7&#39;

# Migration
create_table :users, id: :uuid do |t|
  t.string :email
end

# Model
class User &lt; ApplicationRecord
  before_create :set_uuid_v7
  
  private
  
  def set_uuid_v7
    self.id = UUID7.generate
  end
end

# Benefits:
# ✅ Globally unique
# ✅ Sequential (time-ordered)
# ✅ Good index performance
# ✅ Sortable by creation time
# ✅ No page splits

# Drawbacks:
# ❌ Still 16 bytes (larger than integer)
# ❌ Long URLs
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Social Network</strong></p>
<pre><code class="language-ruby"># Requirements:
# - Billions of users
# - Distributed globally
# - Merge acquisitions

# Solution: UUID v7
create_table :users, id: :uuid do |t|
  t.string :username
  t.timestamps
end

# Benefits:
# - Globally unique (no conflicts across regions)
# - Time-ordered (good performance)
# - Can merge databases from acquisitions
</code></pre>
<p><strong>Example 2: Internal Business App</strong></p>
<pre><code class="language-ruby"># Requirements:
# - 10,000 users max
# - Single database
# - Staff references IDs verbally

# Solution: Integer ID
create_table :users do |t|
  t.string :email
  t.timestamps
end

# Benefits:
# - Fast
# - Compact
# - Human-friendly (&quot;User 42&quot;)
# - Short URLs
</code></pre>
<p><strong>Example 3: SaaS with API</strong></p>
<pre><code class="language-ruby"># Requirements:
# - Multi-tenant
# - Public API
# - Security important

# Solution: Integer ID + UUID
create_table :users do |t|
  t.uuid :uuid, null: false
  t.string :email
  t.timestamps
end

add_index :users, :uuid, unique: true

# API uses UUID:
# GET /api/users/550e8400-e29b-41d4-a716-446655440000

# Internal uses integer ID:
# Fast joins: SELECT * FROM posts WHERE user_id = 42
</code></pre>
<hr>
<h3>Performance Benchmark</h3>
<pre><code class="language-ruby">require &#39;benchmark&#39;

# Setup: Empty table
# Test: Insert 100,000 rows

Benchmark.bm(20) do |x|
  # Integer ID
  x.report(&quot;Integer ID:&quot;) do
    100000.times { |i| User.create(email: &quot;user#{i}@example.com&quot;) }
  end
  # Time: ~15 seconds
  
  # UUID v4
  x.report(&quot;UUID v4:&quot;) do
    100000.times { |i| User.create(email: &quot;user#{i}@example.com&quot;) }
  end
  # Time: ~45 seconds (3x slower due to page splits)
  
  # UUID v7
  x.report(&quot;UUID v7:&quot;) do
    100000.times { |i| User.create(email: &quot;user#{i}@example.com&quot;) }
  end
  # Time: ~18 seconds (similar to integer!)
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Integer IDs</strong> - default, fast, compact</li>
<li><strong>UUIDs</strong> - globally unique, secure</li>
<li><strong>UUID v4</strong> - random, slow inserts</li>
<li><strong>UUID v7</strong> - time-ordered, fast inserts</li>
<li><strong>Storage</strong> - UUIDs 2x larger</li>
<li><strong>Performance</strong> - integers faster (except v7)</li>
<li><strong>URLs</strong> - integers shorter</li>
<li><strong>Distributed</strong> - UUIDs better</li>
<li><strong>Hybrid</strong> - integer PK + UUID public ID</li>
<li><strong>Choose</strong> based on requirements</li>
</ol>
<h1>Migrations, Locking, and Transactions Interview Questions</h1>
<h2>Question 87: What are migrations in Rails?</h2>
<h3>Answer</h3>
<p><strong>Migrations</strong> are Ruby classes that define database schema changes in a version-controlled, reversible way. They allow you to evolve your database schema over time while maintaining a history of all changes.</p>
<hr>
<h3>How Migrations Work</h3>
<p><strong>Basic structure:</strong></p>
<pre><code class="language-ruby"># db/migrate/20241229103000_create_users.rb
class CreateUsers &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      t.string :email, null: false
      t.string :name
      t.timestamps
    end
    
    add_index :users, :email, unique: true
  end
end

# Generates SQL:
# CREATE TABLE users (
#   id BIGSERIAL PRIMARY KEY,
#   email VARCHAR NOT NULL,
#   name VARCHAR,
#   created_at TIMESTAMP,
#   updated_at TIMESTAMP
# );
# CREATE UNIQUE INDEX index_users_on_email ON users (email);
</code></pre>
<p><strong>Version tracking:</strong></p>
<pre><code class="language-ruby"># db/schema.rb (generated from migrations)
ActiveRecord::Schema[7.0].define(version: 2024_12_29_103000) do
  create_table &quot;users&quot;, force: :cascade do |t|
    t.string &quot;email&quot;, null: false
    t.string &quot;name&quot;
    t.datetime &quot;created_at&quot;, null: false
    t.datetime &quot;updated_at&quot;, null: false
    t.index [&quot;email&quot;], name: &quot;index_users_on_email&quot;, unique: true
  end
end

# schema_migrations table tracks which migrations have run
# | version          |
# |------------------|
# | 20241229103000  |
# | 20241229104500  |
# | 20241229110000  |
</code></pre>
<hr>
<h3>Migration Commands</h3>
<p><strong>Generate migration:</strong></p>
<pre><code class="language-bash"># Create table
rails generate migration CreateUsers

# Add column
rails generate migration AddAgeToUsers age:integer

# Remove column
rails generate migration RemoveAgeFromUsers age:integer

# Add index
rails generate migration AddIndexToUsersEmail

# Custom migration
rails generate migration CustomChanges
</code></pre>
<p><strong>Run migrations:</strong></p>
<pre><code class="language-bash"># Run all pending migrations
rails db:migrate

# Run up to specific version
rails db:migrate VERSION=20241229103000

# Rollback last migration
rails db:rollback

# Rollback last 3 migrations
rails db:rollback STEP=3

# Redo last migration (down then up)
rails db:migrate:redo

# Check migration status
rails db:migrate:status

# Database       Status   Migration ID    Migration Name
# --------------------------------------------------
#   up           20241229103000  Create users
#   up           20241229104500  Add age to users
#  down          20241229110000  Add index to users
</code></pre>
<hr>
<h3>Common Migration Operations</h3>
<p><strong>1. Create table:</strong></p>
<pre><code class="language-ruby">class CreatePosts &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :posts do |t|
      t.string :title, null: false
      t.text :body
      t.references :user, foreign_key: true, index: true
      t.boolean :published, default: false
      t.integer :views_count, default: 0
      t.timestamps
    end
    
    add_index :posts, [:user_id, :created_at]
  end
end
</code></pre>
<p><strong>2. Add/remove columns:</strong></p>
<pre><code class="language-ruby">class AddColumnsToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :age, :integer
    add_column :users, :bio, :text
    add_column :users, :avatar_url, :string
    
    remove_column :users, :old_field, :string
  end
end
</code></pre>
<p><strong>3. Change column:</strong></p>
<pre><code class="language-ruby">class ChangeUserEmailType &lt; ActiveRecord::Migration[7.0]
  def change
    # Change column type
    change_column :users, :email, :text
    
    # Change default
    change_column_default :users, :active, from: false, to: true
    
    # Change null constraint
    change_column_null :users, :email, false
  end
end
</code></pre>
<p><strong>4. Rename:</strong></p>
<pre><code class="language-ruby">class RenameColumns &lt; ActiveRecord::Migration[7.0]
  def change
    rename_column :users, :name, :full_name
    rename_table :old_table, :new_table
  end
end
</code></pre>
<p><strong>5. Add/remove indexes:</strong></p>
<pre><code class="language-ruby">class ManageIndexes &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :posts, :title
    add_index :posts, [:user_id, :published]
    add_index :users, :email, unique: true
    
    remove_index :posts, :old_column
  end
end
</code></pre>
<p><strong>6. Foreign keys:</strong></p>
<pre><code class="language-ruby">class AddForeignKeys &lt; ActiveRecord::Migration[7.0]
  def change
    add_foreign_key :posts, :users
    add_foreign_key :comments, :posts, on_delete: :cascade
    
    remove_foreign_key :posts, :categories
  end
end
</code></pre>
<hr>
<h3>Reversible Migrations</h3>
<p><strong>Automatic reversal:</strong></p>
<pre><code class="language-ruby"># change method is automatically reversible
class CreateUsers &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      t.string :email
    end
  end
end

# rails db:rollback automatically runs:
# DROP TABLE users
</code></pre>
<p><strong>Manual up/down:</strong></p>
<pre><code class="language-ruby">class CustomMigration &lt; ActiveRecord::Migration[7.0]
  def up
    # Forward migration
    execute &quot;UPDATE users SET role = &#39;member&#39; WHERE role IS NULL&quot;
  end
  
  def down
    # Reverse migration
    execute &quot;UPDATE users SET role = NULL WHERE role = &#39;member&#39;&quot;
  end
end
</code></pre>
<p><strong>Reversible blocks:</strong></p>
<pre><code class="language-ruby">class ComplexMigration &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      t.string :email
    end
    
    reversible do |dir|
      dir.up do
        execute &quot;UPDATE users SET status = &#39;active&#39;&quot;
      end
      
      dir.down do
        execute &quot;UPDATE users SET status = NULL&quot;
      end
    end
  end
end
</code></pre>
<p><strong>Irreversible migrations:</strong></p>
<pre><code class="language-ruby">class IrreversibleMigration &lt; ActiveRecord::Migration[7.0]
  def change
    # Can&#39;t auto-reverse data deletion
    remove_column :users, :old_data
    
    # Mark as irreversible
    raise ActiveRecord::IrreversibleMigration
  end
end

# Or be explicit:
class IrreversibleMigration &lt; ActiveRecord::Migration[7.0]
  def up
    remove_column :users, :old_data
  end
  
  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
</code></pre>
<hr>
<h3>Data Migrations</h3>
<p><strong>Mixing schema and data (be careful):</strong></p>
<pre><code class="language-ruby">class AddDefaultRole &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :role, :string
    
    # Set default for existing records
    reversible do |dir|
      dir.up do
        User.update_all(role: &#39;member&#39;)
      end
    end
  end
end

# WARNING: Can be slow for large tables!
# Better: Use separate rake task or background job
</code></pre>
<p><strong>Separate data migration (recommended):</strong></p>
<pre><code class="language-ruby"># lib/tasks/data_migrations.rake
namespace :data do
  desc &quot;Set default role for users&quot;
  task set_default_role: :environment do
    User.where(role: nil).find_each do |user|
      user.update(role: &#39;member&#39;)
    end
  end
end

# Run separately:
# rails db:migrate
# rails data:set_default_role
</code></pre>
<hr>
<h3>Migration Best Practices</h3>
<p><strong>1. Never edit committed migrations:</strong></p>
<pre><code class="language-ruby"># BAD - editing old migration
class CreateUsers &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      t.string :email
      t.string :name  # Added later - BAD!
    end
  end
end

# GOOD - create new migration
class AddNameToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :name, :string
  end
end
</code></pre>
<p><strong>2. Use reversible migrations:</strong></p>
<pre><code class="language-ruby"># GOOD - automatically reversible
def change
  add_column :users, :age, :integer
end

# BAD - manual reversal needed
def up
  execute &quot;ALTER TABLE users ADD COLUMN age INTEGER&quot;
end
</code></pre>
<p><strong>3. Add indexes for foreign keys:</strong></p>
<pre><code class="language-ruby"># GOOD
add_reference :posts, :user, foreign_key: true, index: true

# BAD - missing index
add_column :posts, :user_id, :bigint
add_foreign_key :posts, :users
# Missing: add_index :posts, :user_id
</code></pre>
<p><strong>4. Set default values in migrations:</strong></p>
<pre><code class="language-ruby"># GOOD - default in database
add_column :users, :active, :boolean, default: true

# BAD - default only in model
# Model: attribute :active, :boolean, default: true
</code></pre>
<p><strong>5. Use null constraints:</strong></p>
<pre><code class="language-ruby"># GOOD - enforce at database level
add_column :users, :email, :string, null: false

# BAD - only model validation
# Model: validates :email, presence: true
</code></pre>
<hr>
<h3>Testing Migrations</h3>
<pre><code class="language-ruby"># spec/migrations/create_users_spec.rb
require &#39;rails_helper&#39;
require Rails.root.join(&#39;db/migrate/20241229103000_create_users.rb&#39;)

RSpec.describe CreateUsers do
  let(:migration) { described_class.new }
  
  it &#39;creates users table&#39; do
    expect { migration.migrate(:up) }
      .to change { ActiveRecord::Base.connection.table_exists?(:users) }
      .from(false).to(true)
  end
  
  it &#39;is reversible&#39; do
    migration.migrate(:up)
    
    expect { migration.migrate(:down) }
      .to change { ActiveRecord::Base.connection.table_exists?(:users) }
      .from(true).to(false)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Migrations</strong> version control database schema</li>
<li><strong>Tracked</strong> in schema_migrations table</li>
<li><strong>Reversible</strong> by default (change method)</li>
<li><strong>Never edit</strong> committed migrations</li>
<li><strong>Generate</strong> with rails g migration</li>
<li><strong>Run</strong> with rails db:migrate</li>
<li><strong>Rollback</strong> with rails db:rollback</li>
<li><strong>Test</strong> migrations before production</li>
<li><strong>Add indexes</strong> on foreign keys</li>
<li><strong>Separate</strong> data migrations</li>
</ol>
<hr>
<h2>Question 88: What is the difference between migration (noun) and migrate (verb)?</h2>
<h3>Answer</h3>
<p><strong>Migration (noun)</strong> is the Ruby file/class that defines schema changes. <strong>Migrate (verb)</strong> is the action of running migrations to apply changes to the database.</p>
<hr>
<h3>Migration (Noun) - The File</h3>
<p><strong>The migration file:</strong></p>
<pre><code class="language-ruby"># db/migrate/20241229103000_create_users.rb ← This is the MIGRATION (noun)

class CreateUsers &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      t.string :email
      t.timestamps
    end
  end
end

# The migration:
# - Is a Ruby class
# - Defines what changes to make
# - Lives in db/migrate/
# - Has a timestamp prefix
# - Is version controlled in git
</code></pre>
<p><strong>Properties of a migration:</strong></p>
<pre><code class="language-ruby"># 1. Filename: timestamp + description
20241229103000_create_users.rb

# 2. Class name: CamelCase version of filename
CreateUsers

# 3. Inherits from ActiveRecord::Migration
class CreateUsers &lt; ActiveRecord::Migration[7.0]

# 4. Defines change/up/down methods
def change
  # Schema changes here
end
</code></pre>
<hr>
<h3>Migrate (Verb) - The Action</h3>
<p><strong>The migrate command:</strong></p>
<pre><code class="language-bash"># rails db:migrate ← This is MIGRATE (verb)
# The action of applying migrations

# What happens:
# 1. Rails checks schema_migrations table
# 2. Finds pending migrations (not yet applied)
# 3. Runs each pending migration in order
# 4. Executes SQL to change database
# 5. Records version in schema_migrations
# 6. Updates db/schema.rb
</code></pre>
<p><strong>Other migrate actions:</strong></p>
<pre><code class="language-bash"># Migrate forward
rails db:migrate           # Run pending migrations
rails db:migrate:up VERSION=20241229103000  # Run specific migration

# Migrate backward
rails db:rollback          # Undo last migration
rails db:migrate:down VERSION=20241229103000  # Undo specific migration

# Re-migrate
rails db:migrate:redo      # Rollback and re-run last migration
rails db:migrate:reset     # Drop, create, migrate entire database

# Check status
rails db:migrate:status    # Show which migrations have run
</code></pre>
<hr>
<h3>Detailed Comparison</h3>
<p><strong>Migration (noun):</strong></p>
<pre><code class="language-ruby"># 1. Creating a migration
rails generate migration AddAgeToUsers age:integer

# Creates FILE (the migration):
# db/migrate/20241229103000_add_age_to_users.rb

class AddAgeToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :age, :integer
  end
end

# This is the MIGRATION - a definition, not an action
# It doesn&#39;t DO anything until you run rails db:migrate
</code></pre>
<p><strong>Migrate (verb):</strong></p>
<pre><code class="language-bash"># 2. Running the migration (migrating)
rails db:migrate

# Output:
# == 20241229103000 AddAgeToUsers: migrating ===================================
# -- add_column(:users, :age, :integer)
#    -&gt; 0.0015s
# == 20241229103000 AddAgeToUsers: migrated (0.0016s) ==========================

# This is MIGRATING - the actual execution
# SQL is run: ALTER TABLE users ADD COLUMN age INTEGER
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Example 1: Creating a feature</strong></p>
<pre><code class="language-ruby"># Step 1: Create migration (noun)
rails generate migration CreatePosts

# Step 2: Edit the migration (noun)
# db/migrate/20241229103000_create_posts.rb
class CreatePosts &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :posts do |t|
      t.string :title
      t.text :body
      t.references :user, foreign_key: true
      t.timestamps
    end
  end
end

# Step 3: Migrate (verb) - apply it
rails db:migrate

# The migration (noun) defines WHAT to do
# The migrate (verb) actually DOES it
</code></pre>
<p><strong>Example 2: Rolling back</strong></p>
<pre><code class="language-ruby"># The migration (noun) still exists as a file
# db/migrate/20241229103000_create_posts.rb

# But you can migrate backward (verb)
rails db:rollback

# This runs the DOWN direction of the migration
# DROP TABLE posts;

# The migration (noun) is still there
# You could migrate forward again
rails db:migrate
</code></pre>
<hr>
<h3>Migration States</h3>
<p><strong>A migration can be in different states:</strong></p>
<pre><code class="language-bash">rails db:migrate:status

# Database: myapp_development
#
#  Status   Migration ID    Migration Name
# --------------------------------------------------
#   up      20241229103000  Create users
#   up      20241229104500  Add age to users
#  down     20241229110000  Create posts
#  down     20241229111500  Add index to posts

# &quot;up&quot; = migrated (verb past tense) - changes applied
# &quot;down&quot; = not migrated - changes not applied
</code></pre>
<hr>
<h3>In Code Comments</h3>
<p><strong>Using the terms correctly:</strong></p>
<pre><code class="language-ruby"># NOUN usage:
# &quot;I created a migration to add the email column&quot;
# &quot;This migration adds an index&quot;
# &quot;The migration file is in db/migrate/&quot;

# VERB usage:
# &quot;We need to migrate the database&quot;
# &quot;Don&#39;t forget to migrate before deploying&quot;
# &quot;The migration migrated successfully&quot;
# &quot;Migrate forward to apply changes&quot;
</code></pre>
<hr>
<h3>Schema.rb vs Migrations</h3>
<p><strong>Migrations (noun) - Individual changes:</strong></p>
<pre><code class="language-ruby"># db/migrate/20241229103000_create_users.rb
class CreateUsers &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :users do |t|
      t.string :email
    end
  end
end

# db/migrate/20241229104500_add_name_to_users.rb
class AddNameToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :name, :string
  end
end

# Each migration (noun) is a step in history
</code></pre>
<p><strong>Schema.rb - Current state after migrating:</strong></p>
<pre><code class="language-ruby"># db/schema.rb (generated after running rails db:migrate)
ActiveRecord::Schema[7.0].define(version: 2024_12_29_104500) do
  create_table &quot;users&quot;, force: :cascade do |t|
    t.string &quot;email&quot;
    t.string &quot;name&quot;      # Result of applying both migrations
  end
end

# Schema is the result of migrating all migrations
</code></pre>
<hr>
<h3>Common Confusion</h3>
<p><strong>Incorrect usage:</strong></p>
<pre><code class="language-ruby"># ❌ &quot;I need to migration the database&quot;
# (migration is a noun, can&#39;t be used as verb)

# ✅ &quot;I need to migrate the database&quot;
# ✅ &quot;I need to run the migrations&quot;

# ❌ &quot;The migrate created a new table&quot;
# (migrate is a verb, it&#39;s an action not a thing)

# ✅ &quot;The migration created a new table&quot;
# ✅ &quot;Migrating the database created a new table&quot;
</code></pre>
<hr>
<h3>Grammar Guide</h3>
<p><strong>Migration (noun):</strong></p>
<ul>
<li>&quot;The migration&quot;</li>
<li>&quot;A new migration&quot;</li>
<li>&quot;Create a migration&quot;</li>
<li>&quot;Edit the migration&quot;</li>
<li>&quot;This migration adds...&quot;</li>
</ul>
<p><strong>Migrate (verb):</strong></p>
<ul>
<li>&quot;To migrate&quot;</li>
<li>&quot;Migrating the database&quot;</li>
<li>&quot;The database migrated&quot;</li>
<li>&quot;Run migrations&quot;</li>
<li>&quot;Migrate forward/backward&quot;</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Migration (noun)</strong> = file that defines changes</li>
<li><strong>Migrate (verb)</strong> = action of applying changes</li>
<li><strong>Migration</strong> = what to do</li>
<li><strong>Migrate</strong> = actually doing it</li>
<li><strong>Migration</strong> = stored in db/migrate/</li>
<li><strong>Migrate</strong> = executed with rails db:migrate</li>
<li><strong>Migration</strong> = version controlled</li>
<li><strong>Migrate</strong> = tracked in schema_migrations</li>
<li><strong>You create</strong> a migration</li>
<li><strong>You run</strong> (migrate) migrations</li>
</ol>
<hr>
<h2>Question 89: How do you handle database migrations in production environments?</h2>
<h3>Answer</h3>
<p>Production migrations require <strong>planning, testing, backup, zero-downtime strategies, monitoring, and rollback plans</strong>. Critical to minimize downtime and prevent data loss.</p>
<hr>
<h3>Pre-Deployment Checklist</h3>
<p><strong>1. Test thoroughly:</strong></p>
<pre><code class="language-ruby"># Run on development
rails db:migrate

# Run on staging (production-like environment)
# With production data dump
heroku pg:pull DATABASE_URL myapp_staging --app myapp-production
rails db:migrate RAILS_ENV=staging

# Test rollback
rails db:rollback RAILS_ENV=staging
rails db:migrate RAILS_ENV=staging
</code></pre>
<p><strong>2. Review migration:</strong></p>
<pre><code class="language-ruby"># Check SQL that will be executed
rails db:migrate RAILS_ENV=production --dry-run

# Or manually review
rails runner &quot;puts CreatePosts.new.migrate(:up)&quot;
</code></pre>
<p><strong>3. Estimate duration:</strong></p>
<pre><code class="language-ruby"># Time migration on staging with production data
time rails db:migrate RAILS_ENV=staging

# For large tables, calculate:
# - Row count
# - Index creation time
# - Lock duration
</code></pre>
<p><strong>4. Backup database:</strong></p>
<pre><code class="language-bash"># PostgreSQL
pg_dump myapp_production &gt; backup_$(date +%Y%m%d_%H%M%S).sql

# MySQL
mysqldump -u user -p myapp_production &gt; backup_$(date +%Y%m%d_%H%M%S).sql

# Heroku
heroku pg:backups:capture --app myapp-production
</code></pre>
<hr>
<h3>Deployment Strategies</h3>
<p><strong>Strategy 1: Maintenance Window (Traditional)</strong></p>
<pre><code class="language-ruby"># 1. Enable maintenance mode
# config/routes.rb
if File.exist?(Rails.root.join(&#39;tmp&#39;, &#39;maintenance.txt&#39;))
  match &#39;*path&#39;, to: &#39;maintenance#index&#39;, via: :all
end

# 2. Stop background jobs
# Sidekiq/Delayed Job: pause queues

# 3. Wait for active requests to complete
sleep 30

# 4. Run migrations
rails db:migrate RAILS_ENV=production

# 5. Restart app servers
cap production deploy:restart

# 6. Disable maintenance mode
rm tmp/maintenance.txt

# 7. Resume background jobs

# Downtime: 2-10 minutes
</code></pre>
<p><strong>Strategy 2: Blue-Green Deployment</strong></p>
<pre><code class="language-ruby"># 1. Deploy new version (Blue) alongside old (Green)
# Blue and Green both connect to same database

# 2. Run migrations on database
rails db:migrate RAILS_ENV=production

# 3. Switch traffic from Green to Blue
# Load balancer switches instantly

# 4. Keep Green running briefly for rollback
# Monitor Blue for 30 minutes

# 5. Shutdown Green if all good

# Downtime: None (if migration compatible)
</code></pre>
<p><strong>Strategy 3: Rolling Deployment</strong></p>
<pre><code class="language-ruby"># For multi-server deployments
# 1. Take server 1 out of load balancer
# 2. Deploy new code to server 1
# 3. Run migrations (once, from server 1)
# 4. Add server 1 back to load balancer
# 5. Repeat for servers 2, 3, 4...

# Downtime: None
# Requirement: New code works with old AND new schema
</code></pre>
<hr>
<h3>Zero-Downtime Migrations</h3>
<p><strong>Compatible migrations (safe):</strong></p>
<pre><code class="language-ruby"># Adding columns (with defaults in code, not DB)
class AddAgeToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    # SAFE - doesn&#39;t lock table
    add_column :users, :age, :integer
    
    # Set default in code, not migration:
    # Model: attribute :age, default: 0
  end
end

# Adding indexes concurrently (PostgreSQL)
class AddIndexToUsers &lt; ActiveRecord::Migration[7.0]
  disable_ddl_transaction!
  
  def change
    add_index :users, :email, algorithm: :concurrently
    # Doesn&#39;t lock table for writes
  end
end

# Creating new tables
class CreatePosts &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :posts do |t|
      t.string :title
      t.timestamps
    end
  end
  # Safe - doesn&#39;t affect existing tables
end
</code></pre>
<p><strong>Incompatible migrations (dangerous):</strong></p>
<pre><code class="language-ruby"># Removing columns (breaks old code)
class RemoveAgeFromUsers &lt; ActiveRecord::Migration[7.0]
  def change
    # DANGEROUS - old code expects this column
    remove_column :users, :age, :integer
  end
end

# Renaming columns (breaks old code)
class RenameEmailColumn &lt; ActiveRecord::Migration[7.0]
  def change
    # DANGEROUS - old code uses old name
    rename_column :users, :email, :email_address
  end
end

# Adding NOT NULL constraint without default
class AddEmailNotNull &lt; ActiveRecord::Migration[7.0]
  def change
    # DANGEROUS - existing NULLs will cause error
    change_column_null :users, :email, false
  end
end
</code></pre>
<hr>
<h3>Multi-Step Deployment Pattern</h3>
<p><strong>Step 1: Add new column (compatible):</strong></p>
<pre><code class="language-ruby"># Deploy 1: Add column
class AddEmailAddressToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :email_address, :string
  end
end

# Deploy code that writes to BOTH columns:
class User &lt; ApplicationRecord
  before_save :sync_email
  
  def sync_email
    self.email_address = email if email_changed?
    self.email = email_address if email_address_changed?
  end
end
</code></pre>
<p><strong>Step 2: Backfill data:</strong></p>
<pre><code class="language-ruby"># Rake task (run separately, not in migration)
namespace :data do
  task backfill_email_address: :environment do
    User.where(email_address: nil)
        .where.not(email: nil)
        .find_each(batch_size: 1000) do |user|
      user.update_column(:email_address, user.email)
    end
  end
end

# Run: rails data:backfill_email_address
</code></pre>
<p><strong>Step 3: Switch to new column:</strong></p>
<pre><code class="language-ruby"># Deploy 2: Use new column
class User &lt; ApplicationRecord
  # Remove sync_email
  # Start using email_address as primary
  
  def email
    email_address
  end
  
  def email=(value)
    self.email_address = value
  end
end
</code></pre>
<p><strong>Step 4: Remove old column:</strong></p>
<pre><code class="language-ruby"># Deploy 3 (days/weeks later): Remove old column
class RemoveEmailFromUsers &lt; ActiveRecord::Migration[7.0]
  def change
    remove_column :users, :email, :string
  end
end
</code></pre>
<hr>
<h3>Long-Running Migrations</h3>
<p><strong>For large tables:</strong></p>
<pre><code class="language-ruby"># BAD - locks table for hours
class AddIndexToLargeTable &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :email  # Blocks writes!
  end
end

# GOOD - create concurrently (PostgreSQL)
class AddIndexToLargeTable &lt; ActiveRecord::Migration[7.0]
  disable_ddl_transaction!  # Required for concurrent
  
  def change
    add_index :users, :email, algorithm: :concurrently
    # Doesn&#39;t block writes, but takes longer
  end
end
</code></pre>
<p><strong>Backfill data in background:</strong></p>
<pre><code class="language-ruby"># Don&#39;t backfill in migration
class AddRoleToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :role, :string
    
    # BAD - blocks migration for hours
    # User.update_all(role: &#39;member&#39;)
  end
end

# GOOD - background job
class BackfillUserRolesJob &lt; ApplicationJob
  def perform
    User.where(role: nil).find_each(batch_size: 1000) do |user|
      user.update(role: &#39;member&#39;)
      sleep 0.01  # Be gentle on database
    end
  end
end

# Deploy migration, then:
BackfillUserRolesJob.perform_later
</code></pre>
<hr>
<h3>Monitoring Migrations</h3>
<p><strong>Log migration progress:</strong></p>
<pre><code class="language-ruby">class LargeMigration &lt; ActiveRecord::Migration[7.0]
  def change
    say_with_time &quot;Adding index to users&quot; do
      add_index :users, :email, algorithm: :concurrently
    end
  end
end

# Output:
# -- Adding index to users
#    -&gt; 45.3214s
</code></pre>
<p><strong>Check for blocking queries:</strong></p>
<pre><code class="language-sql">-- PostgreSQL: Check for locks
SELECT
  pid,
  usename,
  pg_blocking_pids(pid) as blocked_by,
  query
FROM pg_stat_activity
WHERE cardinality(pg_blocking_pids(pid)) &gt; 0;
</code></pre>
<p><strong>Monitor migration in progress:</strong></p>
<pre><code class="language-bash"># Watch migration status
watch -n 5 &#39;rails db:migrate:status | grep down | wc -l&#39;

# Monitor database load
# DataDog, New Relic, CloudWatch, etc.
</code></pre>
<hr>
<h3>Rollback Plan</h3>
<p><strong>Always have a rollback plan:</strong></p>
<pre><code class="language-ruby"># 1. Can you rollback the migration?
rails db:rollback RAILS_ENV=production

# 2. Can you rollback the code?
git revert HEAD
cap production deploy

# 3. Can you restore from backup?
psql myapp_production &lt; backup.sql

# Test rollback on staging BEFORE production!
</code></pre>
<p><strong>Make migrations rollback-safe:</strong></p>
<pre><code class="language-ruby"># GOOD - automatically reversible
class AddColumnToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :age, :integer
  end
end

# Rollback: remove_column :users, :age

# BAD - not reversible
class UpdateUserData &lt; ActiveRecord::Migration[7.0]
  def change
    User.update_all(status: &#39;active&#39;)
    # Can&#39;t undo data change!
  end
end
</code></pre>
<hr>
<h3>Production Migration Checklist</h3>
<p><strong>Pre-deployment:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Test on staging with production data</li>
<li><input disabled="" type="checkbox"> Time migration duration</li>
<li><input disabled="" type="checkbox"> Review generated SQL</li>
<li><input disabled="" type="checkbox"> Backup database</li>
<li><input disabled="" type="checkbox"> Plan rollback strategy</li>
<li><input disabled="" type="checkbox"> Schedule maintenance window (if needed)</li>
<li><input disabled="" type="checkbox"> Notify team/stakeholders</li>
</ul>
<p><strong>During deployment:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Enable maintenance mode (if needed)</li>
<li><input disabled="" type="checkbox"> Stop background jobs (if needed)</li>
<li><input disabled="" type="checkbox"> Run migrations</li>
<li><input disabled="" type="checkbox"> Verify migration success</li>
<li><input disabled="" type="checkbox"> Check application health</li>
<li><input disabled="" type="checkbox"> Monitor error rates</li>
<li><input disabled="" type="checkbox"> Test critical features</li>
</ul>
<p><strong>Post-deployment:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Disable maintenance mode</li>
<li><input disabled="" type="checkbox"> Resume background jobs</li>
<li><input disabled="" type="checkbox"> Monitor performance</li>
<li><input disabled="" type="checkbox"> Check for errors</li>
<li><input disabled="" type="checkbox"> Verify data integrity</li>
<li><input disabled="" type="checkbox"> Keep backup for 24-48 hours</li>
<li><input disabled="" type="checkbox"> Document any issues</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Always backup</strong> before migrations</li>
<li><strong>Test on staging</strong> with production data</li>
<li><strong>Zero-downtime</strong> possible with planning</li>
<li><strong>Multi-step</strong> deployments for breaking changes</li>
<li><strong>Concurrent indexes</strong> for large tables</li>
<li><strong>Background jobs</strong> for data backfills</li>
<li><strong>Monitor</strong> during migration</li>
<li><strong>Rollback plan</strong> essential</li>
<li><strong>Maintenance window</strong> for risky changes</li>
<li><strong>Documentation</strong> of process</li>
</ol>
<hr>
<h2>Question 90: How do you handle database schema changes with minimal downtime?</h2>
<h3>Answer</h3>
<p>Use <strong>backward-compatible migrations</strong>, <strong>multi-step deployments</strong>, <strong>concurrent operations</strong>, <strong>feature flags</strong>, and <strong>gradual rollouts</strong> to change schema without downtime.</p>
<hr>
<h3>Key Principles</h3>
<p><strong>1. Make changes backward compatible</strong>
<strong>2. Deploy in multiple steps</strong>
<strong>3. Use concurrent operations</strong>
<strong>4. Validate before enforcing</strong></p>
<hr>
<h3>Common Scenarios</h3>
<h3>Scenario 1: Adding a Column</h3>
<p><strong>Single-step (causes brief downtime):</strong></p>
<pre><code class="language-ruby"># Migration
class AddAgeToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :age, :integer, default: 0
    # Setting default locks table briefly
  end
end

# Problem: Table locked during default value write
</code></pre>
<p><strong>Zero-downtime approach:</strong></p>
<pre><code class="language-ruby"># Step 1: Add column without default
class AddAgeToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :age, :integer
    # No table lock!
  end
end

# Step 2: Set default in application
class User &lt; ApplicationRecord
  attribute :age, :integer, default: 0
end

# Step 3: Backfill existing records (background job)
User.where(age: nil).find_each do |user|
  user.update_column(:age, 0)
end

# Step 4: Add database default (optional)
class AddDefaultToUserAge &lt; ActiveRecord::Migration[7.0]
  def change
    change_column_default :users, :age, from: nil, to: 0
    # Only affects new rows, no lock
  end
end
</code></pre>
<hr>
<h3>Scenario 2: Removing a Column</h3>
<p><strong>Single-step (BREAKS old code):</strong></p>
<pre><code class="language-ruby"># Migration
class RemoveAgeFromUsers &lt; ActiveRecord::Migration[7.0]
  def change
    remove_column :users, :age, :integer
  end
end

# Problem: Old app servers crash when accessing .age
</code></pre>
<p><strong>Zero-downtime approach:</strong></p>
<pre><code class="language-ruby"># Step 1: Ignore column in code
class User &lt; ApplicationRecord
  self.ignored_columns = [:age]
end

# Deploy code
# Old servers: still use age (works)
# New servers: ignore age (works)

# Step 2: Remove from views/controllers
# Ensure no code references user.age

# Step 3: Wait for all servers updated
sleep 3600  # Wait 1 hour

# Step 4: Remove column
class RemoveAgeFromUsers &lt; ActiveRecord::Migration[7.0]
  def change
    remove_column :users, :age, :integer
  end
end
</code></pre>
<hr>
<h3>Scenario 3: Renaming a Column</h3>
<p><strong>Single-step (BREAKS):</strong></p>
<pre><code class="language-ruby">class RenameEmailToEmailAddress &lt; ActiveRecord::Migration[7.0]
  def change
    rename_column :users, :email, :email_address
  end
end

# Problem: Old code expects :email
</code></pre>
<p><strong>Zero-downtime approach:</strong></p>
<pre><code class="language-ruby"># Step 1: Add new column
class AddEmailAddressToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :email_address, :string
  end
end

# Step 2: Dual-write to both columns
class User &lt; ApplicationRecord
  before_save :sync_email_fields
  
  def sync_email_fields
    self.email_address = email if email_changed?
    self.email = email_address if email_address_changed?
  end
end

# Step 3: Backfill existing data
User.where(email_address: nil)
    .where.not(email: nil)
    .update_all(&#39;email_address = email&#39;)

# Step 4: Switch reads to new column
class User &lt; ApplicationRecord
  alias_attribute :email, :email_address
  
  # Or gradually with feature flag:
  def email
    if FeatureFlag.enabled?(:new_email_column)
      email_address
    else
      self[:email]
    end
  end
end

# Step 5: Remove old column (days/weeks later)
class RemoveEmailFromUsers &lt; ActiveRecord::Migration[7.0]
  def change
    remove_column :users, :email, :string
  end
end
</code></pre>
<hr>
<h3>Scenario 4: Adding NOT NULL Constraint</h3>
<p><strong>Single-step (FAILS if NULLs exist):</strong></p>
<pre><code class="language-ruby">class AddNotNullToEmail &lt; ActiveRecord::Migration[7.0]
  def change
    change_column_null :users, :email, false
  end
end

# ERROR: column &quot;email&quot; contains null values
</code></pre>
<p><strong>Zero-downtime approach:</strong></p>
<pre><code class="language-ruby"># Step 1: Add validation in app
class User &lt; ApplicationRecord
  validates :email, presence: true
end

# Deploy and monitor
# Ensure no new NULLs being created

# Step 2: Backfill NULLs
User.where(email: nil).find_each do |user|
  user.update(email: &quot;missing_#{user.id}@example.com&quot;)
end

# Step 3: Add constraint with validation (PostgreSQL)
class AddNotNullToEmail &lt; ActiveRecord::Migration[7.0]
  def change
    # Validate existing data first (doesn&#39;t lock)
    execute &lt;&lt;-SQL
      ALTER TABLE users
      ADD CONSTRAINT users_email_null_check
      CHECK (email IS NOT NULL)
      NOT VALID
    SQL
    
    # Validate constraint (can take time but doesn&#39;t block writes)
    execute &lt;&lt;-SQL
      ALTER TABLE users
      VALIDATE CONSTRAINT users_email_null_check
    SQL
    
    # Make column NOT NULL (fast now, already validated)
    change_column_null :users, :email, false
    
    # Drop check constraint (not needed anymore)
    execute &lt;&lt;-SQL
      ALTER TABLE users
      DROP CONSTRAINT users_email_null_check
    SQL
  end
end
</code></pre>
<hr>
<h3>Scenario 5: Adding an Index</h3>
<p><strong>Single-step (locks table):</strong></p>
<pre><code class="language-ruby">class AddIndexToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :email
    # Blocks writes until complete!
  end
end
</code></pre>
<p><strong>Zero-downtime approach (PostgreSQL):</strong></p>
<pre><code class="language-ruby">class AddIndexToUsers &lt; ActiveRecord::Migration[7.0]
  disable_ddl_transaction!
  
  def change
    add_index :users, :email, algorithm: :concurrently
    # Doesn&#39;t block writes
    # Takes longer but safe
  end
end
</code></pre>
<hr>
<h3>Scenario 6: Changing Column Type</h3>
<p><strong>Single-step (locks table):</strong></p>
<pre><code class="language-ruby">class ChangeEmailType &lt; ActiveRecord::Migration[7.0]
  def change
    change_column :users, :email, :text
    # Table locked!
  end
end
</code></pre>
<p><strong>Zero-downtime approach:</strong></p>
<pre><code class="language-ruby"># Step 1: Add new column with new type
class AddNewEmailColumn &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :email_new, :text
  end
end

# Step 2: Dual-write
class User &lt; ApplicationRecord
  before_save do
    self.email_new = email if email_changed?
  end
end

# Step 3: Backfill
User.where(email_new: nil)
    .find_each { |u| u.update_column(:email_new, u.email) }

# Step 4: Switch reads
class User &lt; ApplicationRecord
  alias_attribute :email, :email_new
end

# Step 5: Remove old column
class RemoveOldEmail &lt; ActiveRecord::Migration[7.0]
  def change
    remove_column :users, :email, :string
    rename_column :users, :email_new, :email
  end
end
</code></pre>
<hr>
<h3>Using Strong Migrations Gem</h3>
<p><strong>Catch dangerous migrations:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;strong_migrations&#39;

# Prevents:
# - remove_column
# - add_column with default
# - change_column
# - rename_column
# - rename_table
# - add_index (without concurrent)
# - execute (arbitrary SQL)

# Example error:
add_column :users, :name, :string, default: &quot;...&quot;
# StrongMigrations::UnsafeMigration:
# Adding a column with a default value blocks
# reads and writes while the entire table is rewritten.
#
# Instead, add the column without a default value:
# add_column :users, :name, :string
# Then change the default:
# change_column_default :users, :name, &quot;...&quot;
</code></pre>
<hr>
<h3>Feature Flags for Schema Changes</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;flipper&#39;

# Gradually enable new column
class User &lt; ApplicationRecord
  def email
    if Flipper.enabled?(:use_new_email_column, self)
      email_address
    else
      self[:email]
    end
  end
end

# Enable for 1%
Flipper.enable_percentage_of_actors(:use_new_email_column, 1)

# Monitor errors/performance

# Enable for 10%
Flipper.enable_percentage_of_actors(:use_new_email_column, 10)

# Eventually 100%
Flipper.enable(:use_new_email_column)
</code></pre>
<hr>
<h3>Testing Zero-Downtime Migrations</h3>
<pre><code class="language-ruby"># spec/migrations/zero_downtime_spec.rb
RSpec.describe &#39;Zero Downtime Migrations&#39; do
  it &#39;allows old code to run with new schema&#39; do
    # Run migration
    migrate_to_version(20241229103000)
    
    # Simulate old code (before deploy)
    user = User.create(email: &#39;test@example.com&#39;)
    expect(user.email).to eq(&#39;test@example.com&#39;)
  end
  
  it &#39;allows new code to run with old schema&#39; do
    # Don&#39;t run migration yet
    
    # New code should handle missing column
    user = User.create(email: &#39;test@example.com&#39;)
    expect { user.email_address }.not_to raise_error
  end
end
</code></pre>
<hr>
<h3>Deployment Checklist</h3>
<p><strong>Before deployment:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Migration is backward compatible</li>
<li><input disabled="" type="checkbox"> Old code works with new schema</li>
<li><input disabled="" type="checkbox"> New code works with old schema</li>
<li><input disabled="" type="checkbox"> Data backfill plan ready</li>
<li><input disabled="" type="checkbox"> Monitoring set up</li>
<li><input disabled="" type="checkbox"> Rollback plan documented</li>
</ul>
<p><strong>During deployment:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Deploy new code (no migration yet)</li>
<li><input disabled="" type="checkbox"> Verify new code works</li>
<li><input disabled="" type="checkbox"> Run migration</li>
<li><input disabled="" type="checkbox"> Monitor errors</li>
<li><input disabled="" type="checkbox"> Check performance</li>
<li><input disabled="" type="checkbox"> Run data backfill (if needed)</li>
</ul>
<p><strong>After deployment:</strong></p>
<ul>
<li><input disabled="" type="checkbox"> Monitor for 24-48 hours</li>
<li><input disabled="" type="checkbox"> Complete data backfill</li>
<li><input disabled="" type="checkbox"> Plan next step (if multi-step)</li>
<li><input disabled="" type="checkbox"> Document lessons learned</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Backward compatible</strong> migrations essential</li>
<li><strong>Multi-step</strong> deployments for big changes</li>
<li><strong>Add before remove</strong> columns</li>
<li><strong>Dual-write</strong> during transition</li>
<li><strong>Backfill</strong> data separately</li>
<li><strong>Concurrent indexes</strong> in PostgreSQL</li>
<li><strong>Validate before enforce</strong> constraints</li>
<li><strong>Feature flags</strong> for gradual rollout</li>
<li><strong>Strong migrations</strong> gem helps</li>
<li><strong>Test</strong> compatibility thoroughly</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 91: What is database locking?</h2>
<h3>Answer</h3>
<p><strong>Database locking</strong> prevents concurrent transactions from interfering with each other by controlling access to data. Locks ensure data consistency but can cause performance issues if not managed properly.</p>
<hr>
<h3>Why Locking is Needed</h3>
<p><strong>Without locking (race condition):</strong></p>
<pre><code class="language-ruby"># User has $100 balance
# Two concurrent transactions:

# Transaction 1:          # Transaction 2:
balance = account.balance # balance = account.balance
# =&gt; $100                 # =&gt; $100

balance += 50             # balance -= 30
# =&gt; $150                 # =&gt; $70

account.update(           # account.update(
  balance: balance        #   balance: balance
)                         # )

# Final balance: $70 (WRONG! Should be $120)
# Lost update: Transaction 1&#39;s change lost
</code></pre>
<p><strong>With locking (correct):</strong></p>
<pre><code class="language-ruby"># Transaction 1 locks row first
Account.transaction do
  account = Account.lock.find(id)  # LOCK acquired
  account.balance += 50
  account.save!
end  # LOCK released

# Transaction 2 waits for lock
Account.transaction do
  account = Account.lock.find(id)  # Waits for Transaction 1
  account.balance -= 30
  account.save!
end

# Final balance: $120 (CORRECT)
</code></pre>
<hr>
<h3>Types of Locks</h3>
<p><strong>1. Shared Lock (Read Lock):</strong></p>
<pre><code class="language-ruby"># Multiple transactions can read
# But no one can write

# SQL:
SELECT * FROM accounts WHERE id = 1 FOR SHARE

# Multiple readers allowed:
# Transaction 1: SELECT ... FOR SHARE  ✅
# Transaction 2: SELECT ... FOR SHARE  ✅
# Transaction 3: UPDATE ...            ❌ Waits
</code></pre>
<p><strong>2. Exclusive Lock (Write Lock):</strong></p>
<pre><code class="language-ruby"># Only one transaction can access
# No reads or writes by others

# SQL:
SELECT * FROM accounts WHERE id = 1 FOR UPDATE

# Only one accessor:
# Transaction 1: SELECT ... FOR UPDATE  ✅ Acquired
# Transaction 2: SELECT ... FOR SHARE   ❌ Waits
# Transaction 3: UPDATE ...             ❌ Waits
</code></pre>
<hr>
<h3>Lock Granularity</h3>
<p><strong>Row-level locks (most common):</strong></p>
<pre><code class="language-ruby"># Lock single row
Account.transaction do
  account = Account.lock.find(1)  # Row 1 locked
  # Other rows still accessible
  Account.find(2).update(...)  # Works fine
end
</code></pre>
<p><strong>Table-level locks:</strong></p>
<pre><code class="language-ruby"># Lock entire table (rare, usually DDL)
ActiveRecord::Base.connection.execute(
  &quot;LOCK TABLE accounts IN EXCLUSIVE MODE&quot;
)
# Entire table locked
# All rows inaccessible to other transactions
</code></pre>
<p><strong>Page-level locks:</strong></p>
<pre><code># Database may lock &quot;pages&quot; (groups of rows)
# Automatically managed by database
# Usually invisible to application
</code></pre>
<hr>
<h3>Lock Modes in PostgreSQL</h3>
<pre><code class="language-ruby"># ACCESS SHARE - SELECT (doesn&#39;t block others)
User.where(active: true).to_a

# ROW SHARE - SELECT FOR UPDATE
User.lock.find(1)

# ROW EXCLUSIVE - UPDATE, DELETE, INSERT
User.find(1).update(name: &quot;New&quot;)

# SHARE - CREATE INDEX (blocks writes)
add_index :users, :email

# ACCESS EXCLUSIVE - ALTER TABLE, DROP TABLE (blocks everything)
drop_table :old_users
</code></pre>
<hr>
<h3>Lock Duration</h3>
<p><strong>Transaction-scoped:</strong></p>
<pre><code class="language-ruby"># Locks held for entire transaction
Account.transaction do
  account = Account.lock.find(1)  # Lock acquired
  
  # ... slow operations ...
  sleep(10)
  
  account.update(balance: 100)
end  # Lock released here

# Keep transactions short!
</code></pre>
<p><strong>Auto-released on commit/rollback:</strong></p>
<pre><code class="language-ruby">Account.transaction do
  account = Account.lock.find(1)
  raise &quot;Error!&quot;  # Rollback
end  # Lock automatically released

# No manual lock management needed
</code></pre>
<hr>
<h3>Lock Wait Timeouts</h3>
<p><strong>PostgreSQL:</strong></p>
<pre><code class="language-ruby"># Set lock timeout
ActiveRecord::Base.connection.execute(
  &quot;SET lock_timeout = &#39;5s&#39;&quot;
)

# Query waits max 5 seconds for lock
begin
  Account.transaction do
    account = Account.lock.find(1)
  end
rescue ActiveRecord::LockWaitTimeout
  # Handle timeout
  Rails.logger.error &quot;Could not acquire lock&quot;
end
</code></pre>
<p><strong>MySQL:</strong></p>
<pre><code class="language-ruby"># InnoDB lock wait timeout (default 50s)
# Set in my.cnf:
# innodb_lock_wait_timeout = 50
</code></pre>
<hr>
<h3>Detecting Locks</h3>
<p><strong>PostgreSQL - show blocking locks:</strong></p>
<pre><code class="language-sql">SELECT
  blocked_locks.pid AS blocked_pid,
  blocked_activity.usename AS blocked_user,
  blocking_locks.pid AS blocking_pid,
  blocking_activity.usename AS blocking_user,
  blocked_activity.query AS blocked_statement,
  blocking_activity.query AS blocking_statement
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity 
  ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
  ON blocking_locks.locktype = blocked_locks.locktype
  AND blocking_locks.relation = blocked_locks.relation
  AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity 
  ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
</code></pre>
<p><strong>Monitor lock waits:</strong></p>
<pre><code class="language-ruby"># New Relic, DataDog, etc.
# Track:
# - Lock wait time
# - Lock wait count
# - Long-running transactions
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Keep transactions short:</strong></p>
<pre><code class="language-ruby"># BAD - long transaction
Account.transaction do
  account = Account.lock.find(1)
  
  # External API call (slow!)
  PaymentGateway.charge(account, 100)
  
  account.update(balance: account.balance - 100)
end  # Lock held during API call

# GOOD - short transaction
payment_result = PaymentGateway.charge(account, 100)

if payment_result.success?
  Account.transaction do
    account = Account.lock.find(1)
    account.update(balance: account.balance - 100)
  end  # Lock held briefly
end
</code></pre>
<p><strong>2. Lock in consistent order:</strong></p>
<pre><code class="language-ruby"># BAD - can cause deadlock
# Transaction 1:
Account.transaction do
  account1 = Account.lock.find(1)
  account2 = Account.lock.find(2)
end

# Transaction 2:
Account.transaction do
  account2 = Account.lock.find(2)  # Waits for Transaction 1
  account1 = Account.lock.find(1)  # Transaction 1 waits for Transaction 2
end  # DEADLOCK!

# GOOD - always same order
[account1, account2].sort_by(&amp;:id).each do |account|
  account.lock!
end
</code></pre>
<p><strong>3. Use optimistic locking when possible:</strong></p>
<pre><code class="language-ruby"># Instead of always locking (pessimistic)
# Try without lock first (optimistic)
# Only retry if conflict
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Locks</strong> prevent race conditions</li>
<li><strong>Shared lock</strong> allows reads</li>
<li><strong>Exclusive lock</strong> blocks all</li>
<li><strong>Row-level</strong> most common</li>
<li><strong>Transaction-scoped</strong> duration</li>
<li><strong>Keep short</strong> to avoid blocking</li>
<li><strong>Timeouts</strong> prevent infinite waits</li>
<li><strong>Lock order</strong> prevents deadlocks</li>
<li><strong>Monitor</strong> lock waits</li>
<li><strong>Optimistic</strong> often better</li>
</ol>
<hr>
<h2>Question 92: What is the difference between optimistic locking and pessimistic locking?</h2>
<h3>Answer</h3>
<p><strong>Pessimistic locking</strong> assumes conflicts will happen and locks resources proactively. <strong>Optimistic locking</strong> assumes conflicts are rare and checks for conflicts only at save time.</p>
<hr>
<h3>Quick Comparison</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Pessimistic Locking</th>
<th>Optimistic Locking</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Assumes</strong></td>
<td>Conflicts likely</td>
<td>Conflicts rare</td>
</tr>
<tr>
<td><strong>Locks</strong></td>
<td>Immediately</td>
<td>Never</td>
</tr>
<tr>
<td><strong>Database</strong></td>
<td>Explicit locks</td>
<td>Version column</td>
</tr>
<tr>
<td><strong>Concurrency</strong></td>
<td>Lower (blocked)</td>
<td>Higher (parallel)</td>
</tr>
<tr>
<td><strong>Best for</strong></td>
<td>High contention</td>
<td>Low contention</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Lower</td>
<td>Higher</td>
</tr>
<tr>
<td><strong>Complexity</strong></td>
<td>Simple</td>
<td>Handle conflicts</td>
</tr>
</tbody></table>
<hr>
<h3>Pessimistic Locking</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby"># Acquire lock BEFORE reading
Account.transaction do
  account = Account.lock.find(1)  # SELECT ... FOR UPDATE
  # Row locked - other transactions wait
  
  account.balance += 100
  account.save!
end  # Lock released

# SQL generated:
# BEGIN
# SELECT * FROM accounts WHERE id = 1 FOR UPDATE
# UPDATE accounts SET balance = 200 WHERE id = 1
# COMMIT
</code></pre>
<p><strong>Types of pessimistic locks:</strong></p>
<pre><code class="language-ruby"># Exclusive lock (default)
account = Account.lock.find(1)
# SELECT * FROM accounts WHERE id = 1 FOR UPDATE

# Shared lock (allow concurrent reads)
account = Account.lock(&#39;FOR SHARE&#39;).find(1)
# SELECT * FROM accounts WHERE id = 1 FOR SHARE

# No wait (fail immediately if locked)
account = Account.lock(&#39;FOR UPDATE NOWAIT&#39;).find(1)
# SELECT * FROM accounts WHERE id = 1 FOR UPDATE NOWAIT
# Raises exception if already locked

# Skip locked (skip rows that are locked)
accounts = Account.lock(&#39;FOR UPDATE SKIP LOCKED&#39;).limit(10)
# SELECT * FROM accounts LIMIT 10 FOR UPDATE SKIP LOCKED
# Good for job queues
</code></pre>
<p><strong>When to use:</strong></p>
<p>✅ <strong>High contention</strong> (many conflicts expected)</p>
<pre><code class="language-ruby"># Bank account transfers
# Inventory management
# Ticket sales
</code></pre>
<p>✅ <strong>Critical operations</strong> (must prevent conflicts)</p>
<pre><code class="language-ruby"># Payment processing
# Stock trading
# Seat reservations
</code></pre>
<p>✅ <strong>Long transactions</strong> (rare, but sometimes needed)</p>
<pre><code class="language-ruby"># Complex calculations
# Multi-step operations
</code></pre>
<hr>
<h3>Optimistic Locking</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby"># Migration: Add lock_version column
class AddLockVersionToAccounts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :accounts, :lock_version, :integer, default: 0, null: false
  end
end

# Model automatically uses optimistic locking
class Account &lt; ApplicationRecord
  # lock_version handled automatically
end

# Usage:
account = Account.find(1)  # lock_version = 5
account.balance += 100

# Save checks version
account.save!
# UPDATE accounts 
# SET balance = 200, lock_version = 6
# WHERE id = 1 AND lock_version = 5

# If version changed (another update happened):
# ActiveRecord::StaleObjectError raised
</code></pre>
<p><strong>Handling conflicts:</strong></p>
<pre><code class="language-ruby"># Retry on conflict
def transfer_money(from_id, to_id, amount)
  retry_count = 0
  
  begin
    Account.transaction do
      from_account = Account.find(from_id)
      to_account = Account.find(to_id)
      
      from_account.balance -= amount
      to_account.balance += amount
      
      from_account.save!
      to_account.save!
    end
  rescue ActiveRecord::StaleObjectError
    retry_count += 1
    
    if retry_count &lt; 3
      sleep(0.1 * retry_count)  # Exponential backoff
      retry
    else
      raise &quot;Transfer failed after 3 attempts&quot;
    end
  end
end
</code></pre>
<p><strong>When to use:</strong></p>
<p>✅ <strong>Low contention</strong> (conflicts rare)</p>
<pre><code class="language-ruby"># User profile updates
# Blog post edits
# Settings changes
</code></pre>
<p>✅ <strong>Read-heavy workloads</strong></p>
<pre><code class="language-ruby"># Most reads, few writes
# No waiting for locks
</code></pre>
<p>✅ <strong>Long-running edits</strong> (user forms)</p>
<pre><code class="language-ruby"># User fills form for 30 minutes
# No lock held during form fill
# Check conflict only on save
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<p><strong>Scenario: 100 concurrent requests updating same record</strong></p>
<p><strong>Pessimistic locking:</strong></p>
<pre><code class="language-ruby">100.times.map do
  Thread.new do
    Account.transaction do
      account = Account.lock.find(1)
      account.balance += 1
      account.save!
    end
  end
end.each(&amp;:join)

# Result:
# - Serial execution (one at a time)
# - Time: ~1000ms
# - Success: 100/100
# - Database: High lock wait time
</code></pre>
<p><strong>Optimistic locking:</strong></p>
<pre><code class="language-ruby">100.times.map do
  Thread.new do
    begin
      account = Account.find(1)
      account.balance += 1
      account.save!
    rescue ActiveRecord::StaleObjectError
      retry
    end
  end
end.each(&amp;:join)

# Result:
# - Parallel execution
# - Time: ~100ms
# - Success: 100/100 (with retries)
# - Database: Low lock wait time
</code></pre>
<hr>
<h3>Pessimistic Locking Examples</h3>
<p><strong>Example 1: Bank transfer</strong></p>
<pre><code class="language-ruby">class BankTransferService
  def transfer(from_account_id, to_account_id, amount)
    Account.transaction do
      # Lock both accounts
      from = Account.lock.find(from_account_id)
      to = Account.lock.find(to_account_id)
      
      raise &quot;Insufficient funds&quot; if from.balance &lt; amount
      
      from.balance -= amount
      to.balance += amount
      
      from.save!
      to.save!
    end
  end
end

# Ensures consistency
# No race conditions possible
</code></pre>
<p><strong>Example 2: Inventory management</strong></p>
<pre><code class="language-ruby">class PurchaseService
  def purchase(product_id, quantity)
    Product.transaction do
      product = Product.lock.find(product_id)
      
      if product.stock &gt;= quantity
        product.stock -= quantity
        product.save!
        true
      else
        false
      end
    end
  end
end

# Prevents overselling
# Stock always accurate
</code></pre>
<p><strong>Example 3: Job queue</strong></p>
<pre><code class="language-ruby">class Job &lt; ApplicationRecord
  def self.claim_next
    transaction do
      job = Job.where(status: &#39;pending&#39;)
               .order(created_at: :asc)
               .lock(&#39;FOR UPDATE SKIP LOCKED&#39;)
               .first
      
      if job
        job.update(status: &#39;processing&#39;)
        job
      end
    end
  end
end

# Multiple workers can claim jobs simultaneously
# SKIP LOCKED avoids waiting
</code></pre>
<hr>
<h3>Optimistic Locking Examples</h3>
<p><strong>Example 1: Blog post editing</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def update
    @post = Post.find(params[:id])
    
    if @post.update(post_params)
      redirect_to @post, notice: &#39;Post updated&#39;
    else
      render :edit
    end
  rescue ActiveRecord::StaleObjectError
    flash.now[:alert] = &#39;Post was modified by someone else. Please review changes.&#39;
    @post.reload
    render :edit
  end
end

# User can edit for hours
# No locks held
# Check conflict only on save
</code></pre>
<p><strong>Example 2: User settings</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  def update_settings(new_settings)
    self.settings = new_settings
    save!
  rescue ActiveRecord::StaleObjectError
    # Reload and retry
    reload
    retry
  end
end

# Conflicts rare (users rarely edit simultaneously)
# Optimistic locking perfect
</code></pre>
<hr>
<h3>Choosing Between Locking Strategies</h3>
<p><strong>Use Pessimistic when:</strong></p>
<p>✅ <strong>Conflicts are COMMON</strong></p>
<pre><code class="language-ruby"># Same row updated frequently
# Example: Real-time auction bids
</code></pre>
<p>✅ <strong>Conflicts are EXPENSIVE</strong></p>
<pre><code class="language-ruby"># Retry is costly (complex calculation)
# Example: Financial aggregations
</code></pre>
<p>✅ <strong>Absolute consistency required</strong></p>
<pre><code class="language-ruby"># Cannot tolerate conflicts
# Example: Money transfers
</code></pre>
<p><strong>Use Optimistic when:</strong></p>
<p>✅ <strong>Conflicts are RARE</strong></p>
<pre><code class="language-ruby"># Row rarely updated
# Example: User profiles
</code></pre>
<p>✅ <strong>Read-heavy workload</strong></p>
<pre><code class="language-ruby"># Mostly reads, few writes
# Example: Blog posts
</code></pre>
<p>✅ <strong>Long-running edits</strong></p>
<pre><code class="language-ruby"># User holds form open
# Example: CMS article editing
</code></pre>
<hr>
<h3>Hybrid Approach</h3>
<p><strong>Combine both strategies:</strong></p>
<pre><code class="language-ruby">class Account &lt; ApplicationRecord
  def safe_transfer_to(other_account, amount)
    # Use pessimistic for critical operation
    Account.transaction do
      self.lock!  # Pessimistic lock
      other_account.lock!
      
      self.balance -= amount
      other_account.balance += amount
      
      self.save!  # Also checks lock_version (optimistic)
      other_account.save!
    end
  end
end

# Pessimistic: Prevents concurrent transfers
# Optimistic: Detects external updates
# Best of both worlds
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Pessimistic</strong> locks immediately</li>
<li><strong>Optimistic</strong> checks at save</li>
<li><strong>Pessimistic</strong> for high contention</li>
<li><strong>Optimistic</strong> for low contention</li>
<li><strong>Pessimistic</strong> blocks others</li>
<li><strong>Optimistic</strong> allows concurrency</li>
<li><strong>Pessimistic</strong> lower throughput</li>
<li><strong>Optimistic</strong> higher throughput</li>
<li><strong>Handle</strong> StaleObjectError</li>
<li><strong>Choose</strong> based on workload</li>
</ol>
<h1>Migrations, Locking, and Transactions (Part 2) - Questions 93-96</h1>
<h2>Question 93: How do you implement row-level locking in SQL?</h2>
<h3>Answer</h3>
<p><strong>Row-level locking</strong> locks specific rows using <code>SELECT ... FOR UPDATE</code> (exclusive) or <code>SELECT ... FOR SHARE</code> (shared) within a transaction. Rails provides <code>.lock</code> method for this.</p>
<hr>
<h3>SQL Syntax</h3>
<p><strong>Exclusive lock (FOR UPDATE):</strong></p>
<pre><code class="language-sql">BEGIN;

SELECT * FROM accounts 
WHERE id = 1 
FOR UPDATE;

-- Row is locked
-- Other transactions wait

UPDATE accounts 
SET balance = balance + 100 
WHERE id = 1;

COMMIT;
-- Lock released
</code></pre>
<p><strong>Shared lock (FOR SHARE):</strong></p>
<pre><code class="language-sql">BEGIN;

SELECT * FROM accounts 
WHERE id = 1 
FOR SHARE;

-- Row locked for writes
-- Other reads allowed

COMMIT;
</code></pre>
<hr>
<h3>Rails Implementation</h3>
<p><strong>Basic locking:</strong></p>
<pre><code class="language-ruby"># Exclusive lock
Account.transaction do
  account = Account.lock.find(1)
  # SELECT * FROM accounts WHERE id = 1 FOR UPDATE
  
  account.balance += 100
  account.save!
end

# Lock with condition
Account.transaction do
  account = Account.where(id: 1, active: true).lock.first
  # SELECT * FROM accounts WHERE id = 1 AND active = true FOR UPDATE
end
</code></pre>
<p><strong>Lock types:</strong></p>
<pre><code class="language-ruby"># 1. Exclusive lock (default)
account = Account.lock.find(1)
# FOR UPDATE

# 2. Shared lock
account = Account.lock(&#39;FOR SHARE&#39;).find(1)
# FOR SHARE

# 3. No wait
account = Account.lock(&#39;FOR UPDATE NOWAIT&#39;).find(1)
# Raises error if locked

# 4. Skip locked
accounts = Account.lock(&#39;FOR UPDATE SKIP LOCKED&#39;).limit(10)
# Skips locked rows

# 5. Custom lock mode
account = Account.lock(&#39;FOR UPDATE OF accounts NOWAIT&#39;).find(1)
</code></pre>
<hr>
<h3>Locking Multiple Rows</h3>
<p><strong>Lock in order to avoid deadlocks:</strong></p>
<pre><code class="language-ruby">def transfer(from_id, to_id, amount)
  Account.transaction do
    # Always lock in ID order
    ids = [from_id, to_id].sort
    
    accounts = Account.where(id: ids).lock.order(:id).to_a
    from = accounts.find { |a| a.id == from_id }
    to = accounts.find { |a| a.id == to_id }
    
    from.balance -= amount
    to.balance += amount
    
    from.save!
    to.save!
  end
end
</code></pre>
<hr>
<h3>Advanced Patterns</h3>
<p><strong>Lock only specific columns (PostgreSQL):</strong></p>
<pre><code class="language-sql">SELECT * FROM accounts 
WHERE id = 1 
FOR UPDATE OF accounts;

-- Locks only accounts table
-- Allows locking in complex joins
</code></pre>
<p><strong>Lock with inheritance:</strong></p>
<pre><code class="language-sql">SELECT * FROM accounts 
WHERE id = 1 
FOR UPDATE SKIP LOCKED;

-- Skip rows already locked
-- Perfect for job queues
</code></pre>
<hr>
<h3>Job Queue Pattern</h3>
<pre><code class="language-ruby">class Job &lt; ApplicationRecord
  def self.claim_next(worker_id)
    transaction do
      job = Job.where(status: &#39;pending&#39;)
               .order(priority: :desc, created_at: :asc)
               .lock(&#39;FOR UPDATE SKIP LOCKED&#39;)
               .first
      
      if job
        job.update!(
          status: &#39;processing&#39;,
          worker_id: worker_id,
          started_at: Time.current
        )
        job
      end
    end
  end
end

# Multiple workers can claim different jobs
# SKIP LOCKED prevents waiting
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>FOR UPDATE</strong> - exclusive lock</li>
<li><strong>FOR SHARE</strong> - shared lock</li>
<li><strong>NOWAIT</strong> - fail immediately</li>
<li><strong>SKIP LOCKED</strong> - skip locked rows</li>
<li><strong>Lock in order</strong> to avoid deadlocks</li>
<li><strong>Keep transactions short</strong></li>
<li><strong>Use with transactions</strong></li>
<li><strong>Lock released on commit</strong></li>
<li><strong>Perfect for queues</strong></li>
<li><strong>Rails <code>.lock</code> method</strong></li>
</ol>
<hr>
<h2>Question 94: What are database transactions, and when would you use them?</h2>
<h3>Answer</h3>
<p><strong>Transactions</strong> group multiple database operations into an atomic unit - either all succeed or all fail. They ensure data consistency through ACID properties.</p>
<hr>
<h3>ACID Properties</h3>
<p><strong>Atomicity:</strong></p>
<pre><code class="language-ruby"># All or nothing
Account.transaction do
  from_account.update!(balance: from_account.balance - 100)
  to_account.update!(balance: to_account.balance + 100)
  
  # If either fails, BOTH rollback
end
</code></pre>
<p><strong>Consistency:</strong></p>
<pre><code class="language-ruby"># Database stays in valid state
# Constraints enforced
Account.transaction do
  account.balance = -100  # Violates constraint
  account.save!  # Raises error, transaction rolls back
end
# Database unchanged
</code></pre>
<p><strong>Isolation:</strong></p>
<pre><code class="language-ruby"># Transactions don&#39;t interfere
# Each sees consistent snapshot
</code></pre>
<p><strong>Durability:</strong></p>
<pre><code class="language-ruby"># Once committed, changes permanent
# Survives crashes
</code></pre>
<hr>
<h3>When to Use Transactions</h3>
<p><strong>1. Multiple related updates:</strong></p>
<pre><code class="language-ruby"># BAD - no transaction
order = Order.create!(total: 100)
order_items.each { |item| item.save! }
# If item.save! fails, order exists but incomplete

# GOOD - transaction
Order.transaction do
  order = Order.create!(total: 100)
  order_items.each { |item| item.save! }
end
# All or nothing
</code></pre>
<p><strong>2. Financial operations:</strong></p>
<pre><code class="language-ruby">def transfer(from_id, to_id, amount)
  Account.transaction do
    from = Account.find(from_id)
    to = Account.find(to_id)
    
    from.balance -= amount
    to.balance += amount
    
    from.save!
    to.save!
  end
end
# Money never lost or created
</code></pre>
<p><strong>3. Maintaining referential integrity:</strong></p>
<pre><code class="language-ruby">def delete_user_and_data(user_id)
  User.transaction do
    user = User.find(user_id)
    user.posts.destroy_all
    user.comments.destroy_all
    user.destroy!
  end
end
# All data deleted or none
</code></pre>
<hr>
<h3>Transaction Isolation Levels</h3>
<p><strong>Read Uncommitted (lowest):</strong></p>
<pre><code class="language-ruby">Account.transaction(isolation: :read_uncommitted) do
  # Can see uncommitted changes from other transactions
  # Dirty reads possible
  # Rarely used
end
</code></pre>
<p><strong>Read Committed (default for PostgreSQL):</strong></p>
<pre><code class="language-ruby">Account.transaction(isolation: :read_committed) do
  # Only see committed changes
  # Non-repeatable reads possible
  # Default in most databases
end
</code></pre>
<p><strong>Repeatable Read:</strong></p>
<pre><code class="language-ruby">Account.transaction(isolation: :repeatable_read) do
  # Same query returns same results
  # Phantom reads possible
  # Good for reports
end
</code></pre>
<p><strong>Serializable (highest):</strong></p>
<pre><code class="language-ruby">Account.transaction(isolation: :serializable) do
  # Complete isolation
  # As if transactions ran serially
  # Safest but slowest
end
</code></pre>
<hr>
<h3>Savepoints (Nested Transactions)</h3>
<pre><code class="language-ruby">Account.transaction do
  account = Account.create!(balance: 100)
  
  begin
    Account.transaction(requires_new: true) do
      # Savepoint created
      account.update!(balance: -100)  # Invalid
    end
  rescue ActiveRecord::RecordInvalid
    # Inner transaction rolled back
    # Outer transaction continues
  end
  
  account.reload.balance  # =&gt; 100 (outer transaction)
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Keep transactions short:</strong></p>
<pre><code class="language-ruby"># BAD
Account.transaction do
  account = Account.find(1)
  
  # External API call (slow!)
  result = PaymentGateway.charge(100)
  
  account.update!(balance: account.balance - 100)
end

# GOOD
result = PaymentGateway.charge(100)

if result.success?
  Account.transaction do
    account = Account.find(1)
    account.update!(balance: account.balance - 100)
  end
end
</code></pre>
<p><strong>2. Handle exceptions:</strong></p>
<pre><code class="language-ruby">begin
  Account.transaction do
    # operations
  end
rescue ActiveRecord::RecordInvalid =&gt; e
  Rails.logger.error &quot;Transaction failed: #{e.message}&quot;
  # Handle error
end
</code></pre>
<p><strong>3. Use <code>!</code> methods:</strong></p>
<pre><code class="language-ruby"># BAD - silent failure
Account.transaction do
  account.save  # Returns false, but transaction commits
end

# GOOD - raises exception
Account.transaction do
  account.save!  # Raises exception, transaction rolls back
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>ACID</strong> properties guaranteed</li>
<li><strong>All or nothing</strong> execution</li>
<li><strong>Use for related</strong> operations</li>
<li><strong>Keep short</strong> to avoid locks</li>
<li><strong>Handle exceptions</strong> properly</li>
<li><strong>Use <code>!</code> methods</strong> in transactions</li>
<li><strong>Isolation levels</strong> control visibility</li>
<li><strong>Savepoints</strong> for nested transactions</li>
<li><strong>Financial operations</strong> always use</li>
<li><strong>Test rollback</strong> behavior</li>
</ol>
<hr>
<h2>Question 95: How do you handle database transactions in Rails using ActiveRecord?</h2>
<h3>Answer</h3>
<p>Rails provides <code>ActiveRecord::Base.transaction</code> to wrap operations in database transactions. Supports manual control, callbacks, and automatic rollback on exceptions.</p>
<hr>
<h3>Basic Transaction Usage</h3>
<pre><code class="language-ruby"># Simple transaction
Account.transaction do
  account1.update!(balance: account1.balance - 100)
  account2.update!(balance: account2.balance + 100)
end

# Equivalent to:
ActiveRecord::Base.transaction do
  # operations
end
</code></pre>
<hr>
<h3>Automatic Rollback</h3>
<p><strong>On exception:</strong></p>
<pre><code class="language-ruby">Account.transaction do
  account.update!(balance: -100)  # Raises exception
  # Never reached
  other_account.update!(balance: 200)
end
# Transaction automatically rolled back

# Database unchanged
account.reload.balance  # =&gt; original value
</code></pre>
<p><strong>With rescue:</strong></p>
<pre><code class="language-ruby">begin
  Account.transaction do
    account.save!
    raise &quot;Custom error&quot;
  end
rescue =&gt; e
  Rails.logger.error &quot;Transaction failed: #{e.message}&quot;
  # Transaction already rolled back
end
</code></pre>
<hr>
<h3>Manual Rollback</h3>
<pre><code class="language-ruby">Account.transaction do
  account.update!(balance: 100)
  
  if some_condition
    raise ActiveRecord::Rollback
    # Rolls back but doesn&#39;t propagate exception
  end
  
  other_account.update!(balance: 200)
end

# ActiveRecord::Rollback is special:
# - Rolls back transaction
# - Doesn&#39;t raise outside transaction
# - Useful for conditional rollback
</code></pre>
<hr>
<h3>Transaction Callbacks</h3>
<p><strong>after_commit:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  after_commit :send_confirmation_email, on: :create
  
  def send_confirmation_email
    OrderMailer.confirmation(self).deliver_later
  end
end

# Email sent AFTER transaction commits
# If transaction rolls back, email not sent
</code></pre>
<p><strong>after_rollback:</strong></p>
<pre><code class="language-ruby">class Payment &lt; ApplicationRecord
  after_rollback :log_failure
  
  def log_failure
    Rails.logger.error &quot;Payment #{id} failed&quot;
  end
end
</code></pre>
<p><strong>Callback timing:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  after_save :log_save
  after_commit :log_commit
  
  def log_save
    puts &quot;In transaction&quot;  # Runs during transaction
  end
  
  def log_commit
    puts &quot;After commit&quot;  # Runs after commit
  end
end

User.transaction do
  User.create!(name: &quot;Alice&quot;)
  # Output: &quot;In transaction&quot;
end
# Output: &quot;After commit&quot;
</code></pre>
<hr>
<h3>Nested Transactions</h3>
<p><strong>Subtransactions (savepoints):</strong></p>
<pre><code class="language-ruby">User.transaction do
  user = User.create!(name: &quot;Alice&quot;)
  
  # Nested transaction becomes savepoint
  User.transaction(requires_new: true) do
    post = user.posts.create!(title: &quot;Hello&quot;)
    raise ActiveRecord::Rollback  # Rolls back to savepoint
  end
  
  user.reload.posts.count  # =&gt; 0 (post rolled back)
  user.persisted?          # =&gt; true (user committed)
end
</code></pre>
<p><strong>Without requires_new:</strong></p>
<pre><code class="language-ruby">User.transaction do
  User.transaction do
    # Not really nested, same transaction
    # Rollback affects outer too
  end
end
</code></pre>
<hr>
<h3>Transaction Isolation</h3>
<pre><code class="language-ruby"># Set isolation level
Account.transaction(isolation: :serializable) do
  account = Account.find(1)
  account.balance += 100
  account.save!
end

# Available levels:
# :read_uncommitted
# :read_committed  (default)
# :repeatable_read
# :serializable
</code></pre>
<hr>
<h3>Testing Transactions</h3>
<p><strong>RSpec with database_cleaner:</strong></p>
<pre><code class="language-ruby">RSpec.configure do |config|
  config.use_transactional_fixtures = true
  
  # Each test runs in transaction
  # Rolled back after test
end

RSpec.describe Account do
  it &#39;transfers money atomically&#39; do
    from = Account.create!(balance: 100)
    to = Account.create!(balance: 0)
    
    Account.transaction do
      from.update!(balance: 0)
      to.update!(balance: 100)
    end
    
    expect(from.reload.balance).to eq(0)
    expect(to.reload.balance).to eq(100)
  end
  
  it &#39;rolls back on error&#39; do
    account = Account.create!(balance: 100)
    
    expect {
      Account.transaction do
        account.update!(balance: 200)
        raise &quot;Error&quot;
      end
    }.to raise_error
    
    expect(account.reload.balance).to eq(100)
  end
end
</code></pre>
<hr>
<h3>Advanced Patterns</h3>
<p><strong>Conditional transactions:</strong></p>
<pre><code class="language-ruby">def save_with_transaction(use_transaction: true)
  if use_transaction
    Account.transaction do
      save!
    end
  else
    save!
  end
end
</code></pre>
<p><strong>Transaction per request:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  around_action :wrap_in_transaction
  
  private
  
  def wrap_in_transaction
    ActiveRecord::Base.transaction do
      yield
    rescue =&gt; e
      raise ActiveRecord::Rollback
      raise e
    end
  end
end

# Every request in transaction
# Auto-rollback on error
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>.transaction</code></strong> wraps operations</li>
<li><strong>Auto-rollback</strong> on exception</li>
<li><strong>Use <code>!</code> methods</strong> for errors</li>
<li><strong><code>ActiveRecord::Rollback</code></strong> manual rollback</li>
<li><strong><code>after_commit</code></strong> for side effects</li>
<li><strong><code>requires_new: true</code></strong> for savepoints</li>
<li><strong>Isolation levels</strong> configurable</li>
<li><strong>Test rollback</strong> behavior</li>
<li><strong>Keep short</strong> for performance</li>
<li><strong>Callbacks</strong> run after commit</li>
</ol>
<hr>
<h2>Question 96: What are deadlocks, and how do you prevent them?</h2>
<h3>Answer</h3>
<p><strong>Deadlocks</strong> occur when two or more transactions wait for each other to release locks, creating a circular dependency. Prevention requires careful lock ordering and transaction design.</p>
<hr>
<h3>How Deadlocks Happen</h3>
<p><strong>Classic deadlock scenario:</strong></p>
<pre><code class="language-ruby"># Transaction 1:                # Transaction 2:
Account.transaction do          Account.transaction do
  account1 = Account.lock       account2 = Account.lock
    .find(1)                      .find(2)
  # Locked account 1            # Locked account 2
  
  account2 = Account.lock       account1 = Account.lock
    .find(2)                      .find(1)
  # Waits for account 2...      # Waits for account 1...
end                             end

# DEADLOCK!
# Transaction 1 waits for Transaction 2
# Transaction 2 waits for Transaction 1
# Neither can proceed
</code></pre>
<p><strong>Database response:</strong></p>
<pre><code class="language-ruby"># Database detects deadlock
# Kills one transaction
# ActiveRecord::Deadlocked raised

# One transaction succeeds
# Other must retry
</code></pre>
<hr>
<h3>Prevention Strategy 1: Lock in Order</h3>
<p><strong>Always lock in same order:</strong></p>
<pre><code class="language-ruby"># BAD - can deadlock
def transfer(from_id, to_id, amount)
  Account.transaction do
    from = Account.lock.find(from_id)
    to = Account.lock.find(to_id)
    # ...
  end
end

# GOOD - consistent order
def transfer(from_id, to_id, amount)
  Account.transaction do
    # Always lock in ID order
    ids = [from_id, to_id].sort
    accounts = Account.where(id: ids).lock.order(:id).to_a
    
    from = accounts.find { |a| a.id == from_id }
    to = accounts.find { |a| a.id == to_id }
    
    from.balance -= amount
    to.balance += amount
    
    from.save!
    to.save!
  end
end

# No deadlock possible - same lock order
</code></pre>
<hr>
<h3>Prevention Strategy 2: Keep Transactions Short</h3>
<pre><code class="language-ruby"># BAD - long transaction
Account.transaction do
  account = Account.lock.find(1)
  
  # External API call
  PaymentGateway.charge(100)  # 3 seconds
  
  # Complex calculation
  calculate_interest  # 2 seconds
  
  account.update!(balance: new_balance)
end
# Lock held for 5+ seconds
# High chance of deadlock

# GOOD - short transaction
result = PaymentGateway.charge(100)
new_balance = calculate_interest

Account.transaction do
  account = Account.lock.find(1)
  account.update!(balance: new_balance)
end
# Lock held &lt; 10ms
# Low chance of deadlock
</code></pre>
<hr>
<h3>Prevention Strategy 3: Use Timeouts</h3>
<pre><code class="language-ruby"># Set lock timeout
ActiveRecord::Base.connection.execute(
  &quot;SET lock_timeout = &#39;2s&#39;&quot;
)

begin
  Account.transaction do
    account = Account.lock.find(1)
    # ...
  end
rescue ActiveRecord::LockWaitTimeout
  # Timeout instead of deadlock
  Rails.logger.error &quot;Could not acquire lock&quot;
  retry_or_fail
end
</code></pre>
<hr>
<h3>Prevention Strategy 4: Retry Logic</h3>
<pre><code class="language-ruby">def transfer_with_retry(from_id, to_id, amount, retries: 3)
  attempts = 0
  
  begin
    attempts += 1
    transfer(from_id, to_id, amount)
  rescue ActiveRecord::Deadlocked
    if attempts &lt; retries
      sleep(0.1 * attempts)  # Exponential backoff
      retry
    else
      raise &quot;Transfer failed after #{retries} attempts&quot;
    end
  end
end
</code></pre>
<hr>
<h3>Prevention Strategy 5: Optimistic Locking</h3>
<pre><code class="language-ruby"># Use optimistic instead of pessimistic
# No locks = no deadlocks

def transfer(from_id, to_id, amount)
  Account.transaction do
    from = Account.find(from_id)  # No lock
    to = Account.find(to_id)      # No lock
    
    from.balance -= amount
    to.balance += amount
    
    from.save!  # Checks lock_version
    to.save!    # Checks lock_version
  end
rescue ActiveRecord::StaleObjectError
  retry  # Retry on conflict
end

# No deadlocks possible
# But need to handle StaleObjectError
</code></pre>
<hr>
<h3>Detecting Deadlocks</h3>
<p><strong>PostgreSQL query:</strong></p>
<pre><code class="language-sql">SELECT
  blocked_locks.pid AS blocked_pid,
  blocked_activity.query AS blocked_query,
  blocking_locks.pid AS blocking_pid,
  blocking_activity.query AS blocking_query
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity 
  ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
  ON blocking_locks.locktype = blocked_locks.locktype
  AND blocking_locks.relation = blocked_locks.relation
  AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity 
  ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
</code></pre>
<p><strong>Monitor deadlock rate:</strong></p>
<pre><code class="language-ruby"># New Relic, DataDog, etc.
# Track:
# - Deadlock count
# - Deadlock rate
# - Which queries involved
</code></pre>
<hr>
<h3>Real-World Example</h3>
<p><strong>Job processing system:</strong></p>
<pre><code class="language-ruby">class Job &lt; ApplicationRecord
  def self.process_next
    # BAD - can deadlock
    transaction do
      job = Job.where(status: &#39;pending&#39;)
               .order(created_at: :asc)
               .lock
               .first
      
      if job
        job.update!(status: &#39;processing&#39;)
        job.process
      end
    end
  end
  
  # GOOD - use SKIP LOCKED
  def self.process_next
    transaction do
      job = Job.where(status: &#39;pending&#39;)
               .order(created_at: :asc)
               .lock(&#39;FOR UPDATE SKIP LOCKED&#39;)
               .first
      
      if job
        job.update!(status: &#39;processing&#39;)
        job.process
      end
    end
  end
end

# SKIP LOCKED prevents deadlocks
# Workers skip locked jobs
# No circular waiting
</code></pre>
<hr>
<h3>Testing for Deadlocks</h3>
<pre><code class="language-ruby">RSpec.describe &#39;Deadlock prevention&#39; do
  it &#39;handles concurrent transfers without deadlock&#39; do
    account1 = Account.create!(balance: 100)
    account2 = Account.create!(balance: 100)
    
    # Simulate concurrent transfers
    threads = []
    
    threads &lt;&lt; Thread.new do
      transfer(account1.id, account2.id, 50)
    end
    
    threads &lt;&lt; Thread.new do
      transfer(account2.id, account1.id, 30)
    end
    
    # Should complete without deadlock
    expect { threads.each(&amp;:join) }.not_to raise_error
    
    # Balances correct
    expect(account1.reload.balance + account2.reload.balance).to eq(200)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Deadlock</strong> = circular lock wait</li>
<li><strong>Lock in order</strong> prevents deadlocks</li>
<li><strong>Keep transactions short</strong></li>
<li><strong>Use timeouts</strong> for safety</li>
<li><strong>Retry</strong> on deadlock</li>
<li><strong>SKIP LOCKED</strong> for queues</li>
<li><strong>Optimistic locking</strong> avoids locks</li>
<li><strong>Monitor</strong> deadlock rate</li>
<li><strong>Test</strong> concurrent scenarios</li>
<li><strong>Database</strong> detects and resolves</li>
</ol>
<hr>
<h2>Summary of All Questions (87-96)</h2>
<p><strong>Migrations (87-90):</strong></p>
<ul>
<li>Migrations version control schema</li>
<li>Migration (noun) vs migrate (verb)</li>
<li>Production deployment strategies</li>
<li>Zero-downtime migrations</li>
</ul>
<p><strong>Locking (91-93):</strong></p>
<ul>
<li>Database locking basics</li>
<li>Pessimistic vs optimistic locking</li>
<li>Row-level locking implementation</li>
</ul>
<p><strong>Transactions &amp; Deadlocks (94-96):</strong></p>
<ul>
<li>ACID properties and usage</li>
<li>ActiveRecord transaction handling</li>
<li>Deadlock prevention strategies</li>
</ul>
<h1>Advanced Database Concepts Interview Questions</h1>
<h2>Question 97: What is normalization? Explain 1st, 2nd, and 3rd normal forms</h2>
<h3>Answer</h3>
<p><strong>Normalization</strong> is the process of organizing database tables to reduce redundancy and improve data integrity by decomposing tables into smaller, related tables following specific rules (normal forms).</p>
<hr>
<h3>Why Normalize?</h3>
<p><strong>Problems with unnormalized data:</strong></p>
<pre><code class="language-ruby"># Unnormalized orders table
# | order_id | customer_name | customer_email | product_name | product_price | quantity |
# |----------|---------------|----------------|--------------|---------------|----------|
# | 1        | Alice         | alice@ex.com   | Laptop       | 1000          | 1        |
# | 2        | Alice         | alice@ex.com   | Mouse        | 20            | 2        |
# | 3        | Bob           | bob@ex.com     | Laptop       | 1000          | 1        |

# Problems:
# 1. Data redundancy (Alice&#39;s info repeated)
# 2. Update anomalies (change email in multiple places)
# 3. Insert anomalies (can&#39;t add customer without order)
# 4. Delete anomalies (delete order loses customer info)
</code></pre>
<hr>
<h3>First Normal Form (1NF)</h3>
<p><strong>Rule: Eliminate repeating groups, ensure atomic values</strong></p>
<p><strong>Before 1NF:</strong></p>
<pre><code class="language-ruby"># Violates 1NF - multiple values in single column
# | order_id | customer_name | products                    |
# |----------|---------------|-----------------------------|
# | 1        | Alice         | Laptop, Mouse, Keyboard     |
# | 2        | Bob           | Monitor, Cable              |

# Problems:
# - products column contains multiple values
# - Can&#39;t query for specific product
# - Can&#39;t enforce constraints
</code></pre>
<p><strong>After 1NF:</strong></p>
<pre><code class="language-ruby"># Each column contains atomic (single) value
# | order_id | customer_name | product_name |
# |----------|---------------|--------------|
# | 1        | Alice         | Laptop       |
# | 1        | Alice         | Mouse        |
# | 1        | Alice         | Keyboard     |
# | 2        | Bob           | Monitor      |
# | 2        | Bob           | Cable        |

# Rails migration:
class CreateOrderItems &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :orders do |t|
      t.string :customer_name
      t.timestamps
    end
    
    create_table :order_items do |t|
      t.references :order, foreign_key: true
      t.string :product_name
      t.integer :quantity
      t.timestamps
    end
  end
end

# Models:
class Order &lt; ApplicationRecord
  has_many :order_items
end

class OrderItem &lt; ApplicationRecord
  belongs_to :order
end
</code></pre>
<hr>
<h3>Second Normal Form (2NF)</h3>
<p><strong>Rule: 1NF + No partial dependencies (all non-key columns depend on entire primary key)</strong></p>
<p><strong>Before 2NF (violates 2NF):</strong></p>
<pre><code class="language-ruby"># Composite primary key: (order_id, product_id)
# | order_id | product_id | product_name | product_price | quantity |
# |----------|------------|--------------|---------------|----------|
# | 1        | 101        | Laptop       | 1000          | 1        |
# | 1        | 102        | Mouse        | 20            | 2        |
# | 2        | 101        | Laptop       | 1000          | 1        |

# Problem: product_name and product_price depend only on product_id
# Not on (order_id, product_id) together
# Partial dependency exists!
</code></pre>
<p><strong>After 2NF:</strong></p>
<pre><code class="language-ruby"># Split into separate tables
# orders table:
# | order_id | customer_id | order_date |
# |----------|-------------|------------|
# | 1        | 1           | 2024-01-01 |
# | 2        | 2           | 2024-01-02 |

# order_items table:
# | order_id | product_id | quantity |
# |----------|------------|----------|
# | 1        | 101        | 1        |
# | 1        | 102        | 2        |
# | 2        | 101        | 1        |

# products table:
# | product_id | product_name | product_price |
# |------------|--------------|---------------|
# | 101        | Laptop       | 1000          |
# | 102        | Mouse        | 20            |

# Rails implementation:
class CreateNormalizedTables &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :products do |t|
      t.string :name, null: false
      t.decimal :price, precision: 10, scale: 2, null: false
      t.timestamps
    end
    
    create_table :orders do |t|
      t.references :customer, foreign_key: true
      t.timestamps
    end
    
    create_table :order_items do |t|
      t.references :order, foreign_key: true
      t.references :product, foreign_key: true
      t.integer :quantity, null: false
      t.timestamps
    end
  end
end

class Product &lt; ApplicationRecord
  has_many :order_items
end

class Order &lt; ApplicationRecord
  belongs_to :customer
  has_many :order_items
  has_many :products, through: :order_items
end

class OrderItem &lt; ApplicationRecord
  belongs_to :order
  belongs_to :product
end
</code></pre>
<hr>
<h3>Third Normal Form (3NF)</h3>
<p><strong>Rule: 2NF + No transitive dependencies (non-key columns depend only on primary key, not on other non-key columns)</strong></p>
<p><strong>Before 3NF (violates 3NF):</strong></p>
<pre><code class="language-ruby"># orders table:
# | order_id | customer_id | customer_name | customer_email | customer_city | customer_zipcode |
# |----------|-------------|---------------|----------------|---------------|------------------|
# | 1        | 1           | Alice         | alice@ex.com   | New York      | 10001            |
# | 2        | 1           | Alice         | alice@ex.com   | New York      | 10001            |
# | 3        | 2           | Bob           | bob@ex.com     | Boston        | 02101            |

# Problem: customer_name, customer_email, customer_city depend on customer_id
# Not directly on order_id
# Transitive dependency: order_id → customer_id → customer_name
</code></pre>
<p><strong>After 3NF:</strong></p>
<pre><code class="language-ruby"># customers table:
# | customer_id | name  | email         | city     | zipcode |
# |-------------|-------|---------------|----------|---------|
# | 1           | Alice | alice@ex.com  | New York | 10001   |
# | 2           | Bob   | bob@ex.com    | Boston   | 02101   |

# orders table:
# | order_id | customer_id | order_date |
# |----------|-------------|------------|
# | 1        | 1           | 2024-01-01 |
# | 2        | 1           | 2024-01-02 |
# | 3        | 2           | 2024-01-03 |

# Rails implementation:
class CreateCustomersAndOrders &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :customers do |t|
      t.string :name, null: false
      t.string :email, null: false
      t.string :city
      t.string :zipcode
      t.timestamps
    end
    
    add_index :customers, :email, unique: true
    
    create_table :orders do |t|
      t.references :customer, foreign_key: true, null: false
      t.timestamps
    end
  end
end

class Customer &lt; ApplicationRecord
  has_many :orders
  validates :email, presence: true, uniqueness: true
end

class Order &lt; ApplicationRecord
  belongs_to :customer
  
  # Delegate customer attributes
  delegate :name, :email, :city, :zipcode, to: :customer, prefix: true
end

# Usage:
order = Order.first
order.customer_name  # =&gt; &quot;Alice&quot;
order.customer_email # =&gt; &quot;alice@ex.com&quot;
</code></pre>
<hr>
<h3>Higher Normal Forms (Brief Overview)</h3>
<p><strong>Boyce-Codd Normal Form (BCNF):</strong></p>
<ul>
<li>Stricter version of 3NF</li>
<li>Every determinant must be a candidate key</li>
<li>Handles rare edge cases</li>
</ul>
<p><strong>Fourth Normal Form (4NF):</strong></p>
<ul>
<li>No multi-valued dependencies</li>
<li>Example: Student has multiple hobbies AND multiple courses</li>
<li>Should be separate tables</li>
</ul>
<p><strong>Fifth Normal Form (5NF):</strong></p>
<ul>
<li>No join dependencies</li>
<li>Rarely needed in practice</li>
</ul>
<hr>
<h3>Complete E-commerce Example</h3>
<p><strong>Fully normalized (3NF) schema:</strong></p>
<pre><code class="language-ruby">class CreateEcommerceSchema &lt; ActiveRecord::Migration[7.0]
  def change
    # Customers (3NF: no transitive dependencies)
    create_table :customers do |t|
      t.string :name, null: false
      t.string :email, null: false
      t.string :phone
      t.timestamps
    end
    add_index :customers, :email, unique: true
    
    # Addresses (3NF: separated from customers)
    create_table :addresses do |t|
      t.references :customer, foreign_key: true
      t.string :street, null: false
      t.string :city, null: false
      t.string :state, null: false
      t.string :zipcode, null: false
      t.boolean :default_shipping, default: false
      t.boolean :default_billing, default: false
      t.timestamps
    end
    
    # Products (2NF: no partial dependencies)
    create_table :products do |t|
      t.string :name, null: false
      t.text :description
      t.decimal :price, precision: 10, scale: 2, null: false
      t.references :category, foreign_key: true
      t.timestamps
    end
    
    # Categories (3NF: separated from products)
    create_table :categories do |t|
      t.string :name, null: false
      t.timestamps
    end
    
    # Orders (3NF: only order-specific data)
    create_table :orders do |t|
      t.references :customer, foreign_key: true, null: false
      t.references :shipping_address, foreign_key: { to_table: :addresses }
      t.references :billing_address, foreign_key: { to_table: :addresses }
      t.string :status, default: &#39;pending&#39;
      t.decimal :total, precision: 10, scale: 2
      t.timestamps
    end
    
    # Order Items (2NF: junction table with quantity)
    create_table :order_items do |t|
      t.references :order, foreign_key: true, null: false
      t.references :product, foreign_key: true, null: false
      t.integer :quantity, null: false
      t.decimal :unit_price, precision: 10, scale: 2, null: false
      t.timestamps
    end
  end
end

# Models:
class Customer &lt; ApplicationRecord
  has_many :addresses, dependent: :destroy
  has_many :orders, dependent: :destroy
end

class Address &lt; ApplicationRecord
  belongs_to :customer
end

class Category &lt; ApplicationRecord
  has_many :products
end

class Product &lt; ApplicationRecord
  belongs_to :category
  has_many :order_items
  has_many :orders, through: :order_items
end

class Order &lt; ApplicationRecord
  belongs_to :customer
  belongs_to :shipping_address, class_name: &#39;Address&#39;
  belongs_to :billing_address, class_name: &#39;Address&#39;
  has_many :order_items, dependent: :destroy
  has_many :products, through: :order_items
end

class OrderItem &lt; ApplicationRecord
  belongs_to :order
  belongs_to :product
end
</code></pre>
<hr>
<h3>Benefits of Normalization</h3>
<p>✅ <strong>Eliminates redundancy</strong></p>
<pre><code class="language-ruby"># Before: Customer info repeated in every order
# After: Customer info stored once, referenced by ID
</code></pre>
<p>✅ <strong>Prevents update anomalies</strong></p>
<pre><code class="language-ruby"># Before: Updating customer email requires updating all orders
# After: Update customer table once
</code></pre>
<p>✅ <strong>Ensures data integrity</strong></p>
<pre><code class="language-ruby"># Foreign keys enforce referential integrity
# Can&#39;t create order for non-existent customer
</code></pre>
<p>✅ <strong>Saves storage</strong></p>
<pre><code class="language-ruby"># No duplicate data
# Smaller database size
</code></pre>
<hr>
<h3>Trade-offs</h3>
<p>❌ <strong>More JOINs required</strong></p>
<pre><code class="language-ruby"># Normalized: Need to join tables
Order.joins(:customer, :order_items, :products)

# More complex queries
# Potentially slower for reads
</code></pre>
<p>❌ <strong>More tables to manage</strong></p>
<pre><code class="language-ruby"># Normalized: 6+ tables
# vs Denormalized: 1-2 tables
</code></pre>
<p><strong>Solution: Denormalization for performance</strong> (see Question 98)</p>
<hr>
<h3>Quick Reference</h3>
<p><strong>1NF:</strong> Atomic values, no repeating groups</p>
<ul>
<li>Split multi-value columns</li>
<li>Example: &quot;products&quot; column → order_items table</li>
</ul>
<p><strong>2NF:</strong> 1NF + No partial dependencies</p>
<ul>
<li>All columns depend on entire primary key</li>
<li>Example: Extract products table from order_items</li>
</ul>
<p><strong>3NF:</strong> 2NF + No transitive dependencies</p>
<ul>
<li>Non-key columns depend only on primary key</li>
<li>Example: Extract customers table from orders</li>
</ul>
<p><strong>Rule of thumb:</strong> </p>
<ul>
<li>Most applications use 3NF</li>
<li>BCNF for edge cases</li>
<li>4NF/5NF rarely needed</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Normalization</strong> reduces redundancy</li>
<li><strong>1NF</strong> - atomic values only</li>
<li><strong>2NF</strong> - no partial dependencies</li>
<li><strong>3NF</strong> - no transitive dependencies</li>
<li><strong>Benefits</strong> - integrity, consistency</li>
<li><strong>Trade-off</strong> - more JOINs</li>
<li><strong>Rails</strong> - use associations</li>
<li><strong>Most apps</strong> use 3NF</li>
<li><strong>Denormalize</strong> for performance</li>
<li><strong>Balance</strong> normalization vs performance</li>
</ol>
<hr>
<h2>Question 98: What is denormalization, and when should you use it?</h2>
<h3>Answer</h3>
<p><strong>Denormalization</strong> intentionally adds redundancy to normalized databases to improve read performance by reducing JOINs. It&#39;s a trade-off: faster reads for slower writes and increased storage.</p>
<hr>
<h3>When to Denormalize</h3>
<p><strong>Use denormalization when:</strong></p>
<p>✅ <strong>Read-heavy workload</strong> (90% reads, 10% writes)</p>
<pre><code class="language-ruby"># Analytics dashboard
# Report generation
# Public-facing pages
</code></pre>
<p>✅ <strong>JOIN performance becomes bottleneck</strong></p>
<pre><code class="language-ruby"># Query with 5+ JOINs taking seconds
# Denormalize to reduce JOINs
</code></pre>
<p>✅ <strong>Aggregated data frequently accessed</strong></p>
<pre><code class="language-ruby"># post.comments.count
# user.posts.sum(:views)
# Expensive to calculate repeatedly
</code></pre>
<p>✅ <strong>Third-party data that rarely changes</strong></p>
<pre><code class="language-ruby"># Product details from external API
# Cache locally to avoid API calls
</code></pre>
<hr>
<h3>Denormalization Patterns</h3>
<p><strong>Pattern 1: Counter Caches</strong></p>
<pre><code class="language-ruby"># BEFORE (normalized):
class User &lt; ApplicationRecord
  has_many :posts
end

# Every time:
user.posts.count
# SELECT COUNT(*) FROM posts WHERE user_id = 1

# AFTER (denormalized):
class AddPostsCountToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :posts_count, :integer, default: 0, null: false
  end
end

class Post &lt; ApplicationRecord
  belongs_to :user, counter_cache: true
end

# Now:
user.posts_count
# Direct column read - no query!

# Performance:
# Before: ~5ms per query
# After:  ~0ms (no query)
</code></pre>
<p><strong>Pattern 2: Calculated Columns</strong></p>
<pre><code class="language-ruby"># BEFORE (normalized):
class Order &lt; ApplicationRecord
  has_many :order_items
  
  def total
    order_items.sum { |item| item.quantity * item.unit_price }
  end
end

order.total  # Loads all items, calculates in Ruby

# AFTER (denormalized):
class AddTotalToOrders &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :orders, :total, :decimal, precision: 10, scale: 2, default: 0
  end
end

class Order &lt; ApplicationRecord
  has_many :order_items
  
  after_save :recalculate_total
  
  private
  
  def recalculate_total
    update_column(:total, order_items.sum(&#39;quantity * unit_price&#39;))
  end
end

# Usage:
order.total  # Direct column read - fast!

# Trade-off:
# - Faster reads
# - Slower writes (recalculation)
# - Data must be kept in sync
</code></pre>
<p><strong>Pattern 3: Store Aggregate Data</strong></p>
<pre><code class="language-ruby"># BEFORE (normalized):
class User &lt; ApplicationRecord
  has_many :posts
end

# Dashboard query:
User.joins(:posts)
    .select(&#39;users.*, COUNT(posts.id) as posts_count, 
             SUM(posts.views) as total_views&#39;)
    .group(&#39;users.id&#39;)
# Expensive JOIN + aggregation

# AFTER (denormalized):
class AddStatsToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :posts_count, :integer, default: 0
    add_column :users, :total_views, :integer, default: 0
    add_column :users, :last_post_at, :datetime
  end
end

class Post &lt; ApplicationRecord
  belongs_to :user
  
  after_create :update_user_stats
  after_destroy :update_user_stats
  after_update :update_user_stats, if: :saved_change_to_views?
  
  private
  
  def update_user_stats
    user.update_columns(
      posts_count: user.posts.count,
      total_views: user.posts.sum(:views),
      last_post_at: user.posts.maximum(:created_at)
    )
  end
end

# Usage:
User.where(&#39;total_views &gt; 1000&#39;)
    .order(last_post_at: :desc)
# No JOINs, no aggregation - fast!
</code></pre>
<p><strong>Pattern 4: Duplicate Foreign Entity Data</strong></p>
<pre><code class="language-ruby"># BEFORE (normalized):
class Order &lt; ApplicationRecord
  belongs_to :customer
end

# Every order display:
order.customer.name
order.customer.email
# SELECT * FROM customers WHERE id = ...

# AFTER (denormalized):
class AddCustomerInfoToOrders &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :orders, :customer_name, :string
    add_column :orders, :customer_email, :string
  end
end

class Order &lt; ApplicationRecord
  belongs_to :customer
  
  before_create :cache_customer_info
  
  private
  
  def cache_customer_info
    self.customer_name = customer.name
    self.customer_email = customer.email
  end
end

# Usage:
order.customer_name   # No query needed
order.customer_email  # No query needed

# Benefits:
# - Historical data preserved (even if customer changes)
# - No JOIN needed for order list
# - Faster queries

# Trade-offs:
# - Duplicated data
# - Must update if customer changes (rare)
</code></pre>
<hr>
<h3>Real-World Example: E-commerce Product Listing</h3>
<p><strong>Normalized (slow):</strong></p>
<pre><code class="language-ruby">class ProductsController &lt; ApplicationController
  def index
    @products = Product.includes(:category, :brand, :reviews)
                      .page(params[:page])
    
    # For each product:
    # - Load category
    # - Load brand
    # - Calculate average rating
    # - Count reviews
    # - Count inventory
    
    # 5 queries per product!
  end
end

# View:
&lt;% @products.each do |product| %&gt;
  &lt;div class=&quot;product&quot;&gt;
    &lt;h3&gt;&lt;%= product.name %&gt;&lt;/h3&gt;
    &lt;p&gt;&lt;%= product.category.name %&gt; - &lt;%= product.brand.name %&gt;&lt;/p&gt;
    &lt;p&gt;Rating: &lt;%= product.reviews.average(:rating) %&gt; 
       (&lt;%= product.reviews.count %&gt; reviews)&lt;/p&gt;
    &lt;p&gt;Stock: &lt;%= product.inventory_items.sum(:quantity) %&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;% end %&gt;

# 100 products = 500+ queries!
</code></pre>
<p><strong>Denormalized (fast):</strong></p>
<pre><code class="language-ruby"># Migration:
class DenormalizeProducts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :products, :category_name, :string
    add_column :products, :brand_name, :string
    add_column :products, :average_rating, :decimal, precision: 3, scale: 2
    add_column :products, :reviews_count, :integer, default: 0
    add_column :products, :stock_quantity, :integer, default: 0
    
    # Backfill
    Product.find_each do |product|
      product.update_columns(
        category_name: product.category.name,
        brand_name: product.brand.name,
        average_rating: product.reviews.average(:rating),
        reviews_count: product.reviews.count,
        stock_quantity: product.inventory_items.sum(:quantity)
      )
    end
  end
end

# Model:
class Product &lt; ApplicationRecord
  belongs_to :category
  belongs_to :brand
  has_many :reviews
  has_many :inventory_items
  
  # Keep denormalized data in sync
  after_save :update_category_name, if: :saved_change_to_category_id?
  after_save :update_brand_name, if: :saved_change_to_brand_id?
end

class Review &lt; ApplicationRecord
  belongs_to :product
  
  after_commit :update_product_stats
  
  private
  
  def update_product_stats
    product.update_columns(
      average_rating: product.reviews.average(:rating),
      reviews_count: product.reviews.count
    )
  end
end

# Controller:
class ProductsController &lt; ApplicationController
  def index
    @products = Product.select(
      :id, :name, :price,
      :category_name, :brand_name,
      :average_rating, :reviews_count, :stock_quantity
    ).page(params[:page])
    
    # Single query!
  end
end

# View:
&lt;% @products.each do |product| %&gt;
  &lt;div class=&quot;product&quot;&gt;
    &lt;h3&gt;&lt;%= product.name %&gt;&lt;/h3&gt;
    &lt;p&gt;&lt;%= product.category_name %&gt; - &lt;%= product.brand_name %&gt;&lt;/p&gt;
    &lt;p&gt;Rating: &lt;%= product.average_rating %&gt; 
       (&lt;%= product.reviews_count %&gt; reviews)&lt;/p&gt;
    &lt;p&gt;Stock: &lt;%= product.stock_quantity %&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;% end %&gt;

# 100 products = 1 query!
# 500x fewer queries
</code></pre>
<hr>
<h3>Managing Denormalized Data</h3>
<p><strong>Challenge: Keeping data in sync</strong></p>
<pre><code class="language-ruby"># Option 1: Callbacks (immediate)
class Review &lt; ApplicationRecord
  after_save :update_product_rating
  
  private
  
  def update_product_rating
    product.update_columns(
      average_rating: product.reviews.average(:rating)
    )
  end
end

# Option 2: Background job (eventual consistency)
class Review &lt; ApplicationRecord
  after_commit :schedule_product_update
  
  private
  
  def schedule_product_update
    UpdateProductStatsJob.perform_later(product_id)
  end
end

class UpdateProductStatsJob &lt; ApplicationJob
  def perform(product_id)
    product = Product.find(product_id)
    product.update_columns(
      average_rating: product.reviews.average(:rating),
      reviews_count: product.reviews.count
    )
  end
end

# Option 3: Periodic batch update
class UpdateProductStats
  def self.run
    Product.find_each do |product|
      product.update_columns(
        average_rating: product.reviews.average(:rating),
        reviews_count: product.reviews.count
      )
    end
  end
end

# Run nightly:
# rake products:update_stats
</code></pre>
<hr>
<h3>Denormalization Anti-Patterns</h3>
<p><strong>❌ Don&#39;t denormalize frequently changing data:</strong></p>
<pre><code class="language-ruby"># BAD - user status changes often
class AddUserStatusToPosts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :posts, :user_status, :string
  end
end

# Must update millions of posts when user status changes
# Not worth it!
</code></pre>
<p><strong>❌ Don&#39;t denormalize if JOINs are fast:</strong></p>
<pre><code class="language-ruby"># BAD - small table, indexed FK, fast JOIN
# No need to denormalize
User.joins(:role).where(roles: { name: &#39;admin&#39; })
# Fast query, don&#39;t denormalize
</code></pre>
<p><strong>❌ Don&#39;t denormalize critical financial data:</strong></p>
<pre><code class="language-ruby"># BAD - risk of data inconsistency
class AddTotalToInvoices &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :invoices, :total, :decimal
  end
end

# If denormalized total drifts from actual items
# Financial reports incorrect!
# Calculate on-the-fly for accuracy
</code></pre>
<hr>
<h3>Hybrid Approach</h3>
<p><strong>Best practice: Normalize for writes, denormalize for reads</strong></p>
<pre><code class="language-ruby"># Store normalized data (source of truth)
class Order &lt; ApplicationRecord
  has_many :order_items
end

class OrderItem &lt; ApplicationRecord
  belongs_to :order
  belongs_to :product
end

# Denormalize for common queries
add_column :orders, :items_count, :integer, default: 0
add_column :orders, :total, :decimal, precision: 10, scale: 2

# Keep in sync
class OrderItem &lt; ApplicationRecord
  after_commit :update_order_cache
  
  private
  
  def update_order_cache
    order.update_columns(
      items_count: order.order_items.count,
      total: order.order_items.sum(&#39;quantity * unit_price&#39;)
    )
  end
end

# Use denormalized for displays
def index
  @orders = Order.select(:id, :created_at, :items_count, :total)
                .order(created_at: :desc)
  # Fast - no JOINs
end

# Use normalized for calculations
def calculate_tax
  # Use actual items for accuracy
  order.order_items.sum(&#39;quantity * unit_price&#39;) * 0.1
end
</code></pre>
<hr>
<h3>Monitoring Denormalized Data</h3>
<pre><code class="language-ruby"># Check for inconsistencies
class DataIntegrityCheck
  def self.check_order_totals
    Order.find_each do |order|
      cached_total = order.total
      calculated_total = order.order_items.sum(&#39;quantity * unit_price&#39;)
      
      if (cached_total - calculated_total).abs &gt; 0.01
        Rails.logger.error &quot;Order #{order.id} total mismatch: &quot; \
                           &quot;#{cached_total} vs #{calculated_total}&quot;
      end
    end
  end
end

# Run periodically
# rake data:check_integrity
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Denormalization</strong> adds redundancy for speed</li>
<li><strong>Use for</strong> read-heavy workloads</li>
<li><strong>Counter caches</strong> simplest form</li>
<li><strong>Store aggregates</strong> for common queries</li>
<li><strong>Duplicate data</strong> to avoid JOINs</li>
<li><strong>Keep in sync</strong> with callbacks/jobs</li>
<li><strong>Monitor</strong> for inconsistencies</li>
<li><strong>Don&#39;t denormalize</strong> critical data</li>
<li><strong>Trade-off</strong> - faster reads, slower writes</li>
<li><strong>Balance</strong> normalization vs performance</li>
</ol>
<hr>
<h2>Question 99: How do you implement database partitioning in Rails?</h2>
<h3>Answer</h3>
<p><strong>Database partitioning</strong> splits large tables into smaller, more manageable pieces (partitions) while maintaining a single logical table. PostgreSQL native partitioning or manual sharding can be used.</p>
<hr>
<h3>Why Partition?</h3>
<p><strong>Problems with large tables:</strong></p>
<pre><code class="language-ruby"># Table: logs (100 million rows)

# Query slow:
Log.where(&#39;created_at &gt; ?&#39;, 30.days.ago)
# Scans entire 100M row table

# Index large:
# Index on created_at: 5GB
# Doesn&#39;t fit in memory

# Maintenance slow:
# VACUUM: 30 minutes
# Backup: 2 hours

# Solution: Partition by date
# Query only relevant partition
</code></pre>
<hr>
<h3>PostgreSQL Native Partitioning</h3>
<p><strong>Range Partitioning (by date):</strong></p>
<pre><code class="language-ruby"># Migration:
class CreatePartitionedLogs &lt; ActiveRecord::Migration[7.0]
  def up
    # Create parent table (partitioned)
    execute &lt;&lt;-SQL
      CREATE TABLE logs (
        id BIGSERIAL,
        message TEXT,
        level VARCHAR(10),
        created_at TIMESTAMP NOT NULL,
        PRIMARY KEY (id, created_at)
      ) PARTITION BY RANGE (created_at);
    SQL
    
    # Create partitions for each month
    execute &lt;&lt;-SQL
      CREATE TABLE logs_2024_01 PARTITION OF logs
      FOR VALUES FROM (&#39;2024-01-01&#39;) TO (&#39;2024-02-01&#39;);
      
      CREATE TABLE logs_2024_02 PARTITION OF logs
      FOR VALUES FROM (&#39;2024-02-01&#39;) TO (&#39;2024-03-01&#39;);
      
      CREATE TABLE logs_2024_03 PARTITION OF logs
      FOR VALUES FROM (&#39;2024-03-01&#39;) TO (&#39;2024-04-01&#39;);
    SQL
    
    # Create indexes on each partition
    execute &lt;&lt;-SQL
      CREATE INDEX idx_logs_2024_01_level ON logs_2024_01 (level);
      CREATE INDEX idx_logs_2024_02_level ON logs_2024_02 (level);
      CREATE INDEX idx_logs_2024_03_level ON logs_2024_03 (level);
    SQL
  end
  
  def down
    execute &quot;DROP TABLE logs CASCADE&quot;
  end
end

# Model:
class Log &lt; ApplicationRecord
  # Works transparently with partitioned table
end

# Usage (automatic partition selection):
Log.create(message: &quot;Test&quot;, created_at: &#39;2024-01-15&#39;)
# Inserted into logs_2024_01

Log.where(&#39;created_at &gt;= ?&#39;, &#39;2024-02-01&#39;).where(&#39;created_at &lt; ?&#39;, &#39;2024-03-01&#39;)
# Queries only logs_2024_02 partition (partition pruning)
</code></pre>
<hr>
<h3>Auto-Creating Partitions</h3>
<p><strong>Rake task to create future partitions:</strong></p>
<pre><code class="language-ruby"># lib/tasks/partitions.rake
namespace :partitions do
  desc &quot;Create log partitions for next 12 months&quot;
  task create_future: :environment do
    conn = ActiveRecord::Base.connection
    
    # Start from next month
    start_date = Date.today.beginning_of_month.next_month
    
    12.times do |i|
      partition_date = start_date + i.months
      partition_name = &quot;logs_#{partition_date.strftime(&#39;%Y_%m&#39;)}&quot;
      next_month = partition_date.next_month
      
      # Check if partition exists
      result = conn.execute(&lt;&lt;-SQL)
        SELECT COUNT(*) 
        FROM pg_tables 
        WHERE tablename = &#39;#{partition_name}&#39;
      SQL
      
      if result.first[&#39;count&#39;].to_i == 0
        puts &quot;Creating partition #{partition_name}...&quot;
        
        conn.execute(&lt;&lt;-SQL)
          CREATE TABLE #{partition_name} PARTITION OF logs
          FOR VALUES FROM (&#39;#{partition_date}&#39;) TO (&#39;#{next_month}&#39;);
          
          CREATE INDEX idx_#{partition_name}_level 
          ON #{partition_name} (level);
        SQL
        
        puts &quot;Created #{partition_name}&quot;
      else
        puts &quot;Partition #{partition_name} already exists&quot;
      end
    end
  end
end

# Run monthly via cron:
# 0 0 1 * * cd /app &amp;&amp; rake partitions:create_future
</code></pre>
<hr>
<h3>Dropping Old Partitions</h3>
<pre><code class="language-ruby"># lib/tasks/partitions.rake
namespace :partitions do
  desc &quot;Drop log partitions older than 90 days&quot;
  task drop_old: :environment do
    cutoff_date = 90.days.ago.beginning_of_month
    
    # Find old partitions
    old_partitions = ActiveRecord::Base.connection.execute(&lt;&lt;-SQL)
      SELECT tablename 
      FROM pg_tables 
      WHERE tablename LIKE &#39;logs_%&#39;
    SQL
    
    old_partitions.each do |row|
      table_name = row[&#39;tablename&#39;]
      
      # Extract date from partition name
      if table_name =~ /logs_(\d{4})_(\d{2})/
        year, month = $1.to_i, $2.to_i
        partition_date = Date.new(year, month, 1)
        
        if partition_date &lt; cutoff_date
          puts &quot;Dropping old partition: #{table_name}&quot;
          ActiveRecord::Base.connection.execute(
            &quot;DROP TABLE #{table_name}&quot;
          )
        end
      end
    end
  end
end

# Benefits:
# - Instant deletion (no DELETE scan)
# - Reclaims disk space immediately
# - No VACUUM needed
</code></pre>
<hr>
<h3>List Partitioning (by category)</h3>
<pre><code class="language-ruby"># Partition by region
class CreatePartitionedOrders &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE TABLE orders (
        id BIGSERIAL,
        customer_id BIGINT,
        region VARCHAR(10) NOT NULL,
        total DECIMAL(10, 2),
        created_at TIMESTAMP,
        PRIMARY KEY (id, region)
      ) PARTITION BY LIST (region);
    SQL
    
    # Create partitions for each region
    execute &lt;&lt;-SQL
      CREATE TABLE orders_us PARTITION OF orders
      FOR VALUES IN (&#39;US&#39;, &#39;USA&#39;);
      
      CREATE TABLE orders_eu PARTITION OF orders
      FOR VALUES IN (&#39;EU&#39;, &#39;UK&#39;, &#39;DE&#39;, &#39;FR&#39;);
      
      CREATE TABLE orders_asia PARTITION OF orders
      FOR VALUES IN (&#39;JP&#39;, &#39;CN&#39;, &#39;IN&#39;);
      
      CREATE TABLE orders_other PARTITION OF orders
      DEFAULT;
    SQL
  end
end

# Query automatically routes to partition:
Order.where(region: &#39;US&#39;)
# Only queries orders_us partition
</code></pre>
<hr>
<h3>Hash Partitioning (distribute evenly)</h3>
<pre><code class="language-ruby"># Partition by user_id hash
class CreatePartitionedSessions &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE TABLE sessions (
        id BIGSERIAL,
        user_id BIGINT NOT NULL,
        data JSONB,
        created_at TIMESTAMP,
        PRIMARY KEY (id, user_id)
      ) PARTITION BY HASH (user_id);
    SQL
    
    # Create 8 partitions (power of 2 recommended)
    8.times do |i|
      execute &lt;&lt;-SQL
        CREATE TABLE sessions_p#{i} PARTITION OF sessions
        FOR VALUES WITH (MODULUS 8, REMAINDER #{i});
      SQL
    end
  end
end

# Data distributed evenly across partitions
# Good for large, uniform datasets
</code></pre>
<hr>
<h3>Manual Partitioning (Pre-PostgreSQL 10)</h3>
<p><strong>Using inheritance:</strong></p>
<pre><code class="language-ruby"># Parent table
class CreateLogsTables &lt; ActiveRecord::Migration[7.0]
  def change
    # Parent
    create_table :logs do |t|
      t.text :message
      t.string :level
      t.datetime :created_at, null: false
    end
    
    # Child tables (partitions)
    create_table :logs_2024_01, inherits: :logs do |t|
    end
    
    create_table :logs_2024_02, inherits: :logs do |t|
    end
    
    # Check constraints
    execute &lt;&lt;-SQL
      ALTER TABLE logs_2024_01 
      ADD CONSTRAINT logs_2024_01_date_check 
      CHECK (created_at &gt;= &#39;2024-01-01&#39; AND created_at &lt; &#39;2024-02-01&#39;);
      
      ALTER TABLE logs_2024_02
      ADD CONSTRAINT logs_2024_02_date_check 
      CHECK (created_at &gt;= &#39;2024-02-01&#39; AND created_at &lt; &#39;2024-03-01&#39;);
    SQL
  end
end

# Trigger to route inserts
execute &lt;&lt;-SQL
  CREATE OR REPLACE FUNCTION logs_insert_trigger()
  RETURNS TRIGGER AS $$
  BEGIN
    IF NEW.created_at &gt;= &#39;2024-01-01&#39; AND NEW.created_at &lt; &#39;2024-02-01&#39; THEN
      INSERT INTO logs_2024_01 VALUES (NEW.*);
    ELSIF NEW.created_at &gt;= &#39;2024-02-01&#39; AND NEW.created_at &lt; &#39;2024-03-01&#39; THEN
      INSERT INTO logs_2024_02 VALUES (NEW.*);
    ELSE
      RAISE EXCEPTION &#39;Date out of range&#39;;
    END IF;
    RETURN NULL;
  END;
  $$ LANGUAGE plpgsql;
  
  CREATE TRIGGER logs_insert_trigger
  BEFORE INSERT ON logs
  FOR EACH ROW EXECUTE FUNCTION logs_insert_trigger();
SQL

# Enable constraint_exclusion
execute &quot;SET constraint_exclusion = partition&quot;
</code></pre>
<hr>
<h3>Querying Partitioned Tables</h3>
<pre><code class="language-ruby"># Works transparently
Log.where(&#39;created_at &gt;= ?&#39;, &#39;2024-02-01&#39;).count
# Automatically queries only logs_2024_02 and later

# Check which partitions queried:
Log.where(&#39;created_at &gt;= ?&#39;, &#39;2024-02-01&#39;).explain
# Seq Scan on logs_2024_02
# Seq Scan on logs_2024_03
# (logs_2024_01 pruned - not queried)

# Cross-partition query:
Log.where(level: &#39;ERROR&#39;).count
# Queries all partitions (can&#39;t prune)
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Choose partition key wisely:</strong></p>
<pre><code class="language-ruby"># GOOD - frequently filtered
PARTITION BY RANGE (created_at)
# Most queries: WHERE created_at &gt; ...

# BAD - rarely filtered
PARTITION BY RANGE (updated_at)
# Most queries don&#39;t filter by updated_at
</code></pre>
<p><strong>2. Include partition key in WHERE:</strong></p>
<pre><code class="language-ruby"># GOOD - partition pruning works
Log.where(&#39;created_at &gt; ? AND level = ?&#39;, 1.month.ago, &#39;ERROR&#39;)

# BAD - scans all partitions
Log.where(level: &#39;ERROR&#39;)
# No created_at filter, can&#39;t prune
</code></pre>
<p><strong>3. Keep partitions balanced:</strong></p>
<pre><code class="language-ruby"># Monthly partitions for time-series
# ~3M rows per partition (manageable)

# Not: Single partition with 50M rows
# Not: Daily partitions with 100k rows (too many partitions)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Partitioning</strong> splits large tables</li>
<li><strong>Range</strong> partitioning for time-series</li>
<li><strong>List</strong> partitioning for categories</li>
<li><strong>Hash</strong> partitioning for even distribution</li>
<li><strong>PostgreSQL 10+</strong> native partitioning</li>
<li><strong>Partition pruning</strong> improves queries</li>
<li><strong>Drop partitions</strong> instead of DELETE</li>
<li><strong>Auto-create</strong> future partitions</li>
<li><strong>Include partition key</strong> in queries</li>
<li><strong>Test performance</strong> before/after</li>
</ol>
<h1>Advanced Database Concepts (Part 2) - Questions 100-104</h1>
<h2>Question 100: What is sharding, and how do you handle it in Rails?</h2>
<h3>Answer</h3>
<p><strong>Sharding</strong> is horizontal partitioning across multiple database servers, splitting data by a shard key (e.g., user_id, region). Each shard is an independent database server.</p>
<hr>
<h3>Sharding vs Partitioning</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Partitioning</th>
<th>Sharding</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Scope</strong></td>
<td>Single database</td>
<td>Multiple databases/servers</td>
</tr>
<tr>
<td><strong>Purpose</strong></td>
<td>Manage large tables</td>
<td>Scale beyond single server</td>
</tr>
<tr>
<td><strong>Complexity</strong></td>
<td>Low</td>
<td>High</td>
</tr>
<tr>
<td><strong>Transparency</strong></td>
<td>Transparent to app</td>
<td>Requires app logic</td>
</tr>
<tr>
<td><strong>Cost</strong></td>
<td>Low</td>
<td>High (multiple servers)</td>
</tr>
</tbody></table>
<hr>
<h3>When to Shard</h3>
<p><strong>Shard when:</strong></p>
<p>✅ <strong>Single database maxed out</strong></p>
<pre><code class="language-ruby"># Database at capacity:
# - CPU: 95%
# - Memory: 90%
# - Disk I/O: saturated
# - Read replicas not enough
</code></pre>
<p>✅ <strong>Data too large for single server</strong></p>
<pre><code class="language-ruby"># Database size: 5TB
# Single server limit: 4TB
# Must split across servers
</code></pre>
<p>✅ <strong>Geographic distribution needed</strong></p>
<pre><code class="language-ruby"># US users → US database
# EU users → EU database
# Reduce latency
</code></pre>
<p><strong>Don&#39;t shard when:</strong></p>
<p>❌ <strong>Can scale vertically</strong> (bigger server)
❌ <strong>Read replicas</strong> solve problem
❌ <strong>Partitioning</strong> sufficient
❌ <strong>Premature optimization</strong></p>
<hr>
<h3>Sharding Strategies</h3>
<p><strong>1. Range-based Sharding:</strong></p>
<pre><code class="language-ruby"># Shard by user_id ranges
# Shard 1: user_id 1-1,000,000
# Shard 2: user_id 1,000,001-2,000,000
# Shard 3: user_id 2,000,001-3,000,000

class User &lt; ApplicationRecord
  def self.shard_for(user_id)
    case user_id
    when 1..1_000_000
      :shard1
    when 1_000_001..2_000_000
      :shard2
    else
      :shard3
    end
  end
  
  def self.using_shard(user_id)
    shard_name = shard_for(user_id)
    connected_to(shard: shard_name) { yield }
  end
end

# Usage:
User.using_shard(user_id) do
  User.find(user_id)
end

# Problem: Unbalanced shards (Shard 1 fills first)
</code></pre>
<p><strong>2. Hash-based Sharding (better):</strong></p>
<pre><code class="language-ruby"># Shard by user_id hash
class User &lt; ApplicationRecord
  def self.shard_for(user_id)
    shard_num = user_id % 4  # 4 shards
    &quot;shard#{shard_num}&quot;.to_sym
  end
  
  def self.using_shard(user_id)
    shard_name = shard_for(user_id)
    connected_to(shard: shard_name) { yield }
  end
end

# Distributes evenly
# User 1 → shard1 (1 % 4 = 1)
# User 2 → shard2 (2 % 4 = 2)
# User 3 → shard3 (3 % 4 = 3)
# User 4 → shard0 (4 % 4 = 0)
</code></pre>
<p><strong>3. Geographic Sharding:</strong></p>
<pre><code class="language-ruby"># Shard by region
class User &lt; ApplicationRecord
  def self.shard_for_region(region)
    case region
    when &#39;US&#39;, &#39;CA&#39;, &#39;MX&#39;
      :shard_americas
    when &#39;UK&#39;, &#39;DE&#39;, &#39;FR&#39;
      :shard_europe
    when &#39;JP&#39;, &#39;CN&#39;, &#39;IN&#39;
      :shard_asia
    else
      :shard_default
    end
  end
end
</code></pre>
<hr>
<h3>Rails Multi-Database Setup</h3>
<p><strong>config/database.yml:</strong></p>
<pre><code class="language-yaml">production:
  primary:
    adapter: postgresql
    database: myapp_primary
    host: primary.db.example.com
  
  shard1:
    adapter: postgresql
    database: myapp_shard1
    host: shard1.db.example.com
    migrations_paths: db/shards_migrate
  
  shard2:
    adapter: postgresql
    database: myapp_shard2
    host: shard2.db.example.com
    migrations_paths: db/shards_migrate
  
  shard3:
    adapter: postgresql
    database: myapp_shard3
    host: shard3.db.example.com
    migrations_paths: db/shards_migrate
</code></pre>
<p><strong>Model configuration:</strong></p>
<pre><code class="language-ruby">class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  # Define shard connections
  connects_to shards: {
    default: { writing: :primary },
    shard1: { writing: :shard1 },
    shard2: { writing: :shard2 },
    shard3: { writing: :shard3 }
  }
end

class User &lt; ApplicationRecord
  # User data sharded
end

class Setting &lt; ApplicationRecord
  # Global data (not sharded)
  connects_to database: { writing: :primary }
end
</code></pre>
<hr>
<h3>Using Shards</h3>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-ruby"># Switch to specific shard
ActiveRecord::Base.connected_to(shard: :shard1) do
  User.find(1)
end

# With role (writing/reading)
ActiveRecord::Base.connected_to(shard: :shard1, role: :writing) do
  User.create(name: &quot;Alice&quot;)
end
</code></pre>
<p><strong>Automatic shard selection:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Shard resolver
  def self.shard_for(user_id)
    shard_num = Digest::MD5.hexdigest(user_id.to_s).to_i(16) % 4
    &quot;shard#{shard_num}&quot;.to_sym
  end
  
  # Find with automatic shard selection
  def self.find_sharded(user_id)
    connected_to(shard: shard_for(user_id)) do
      find(user_id)
    end
  end
  
  # Create with automatic shard selection
  def self.create_sharded(user_id, attributes)
    connected_to(shard: shard_for(user_id)) do
      create!(attributes.merge(id: user_id))
    end
  end
end

# Usage:
user = User.find_sharded(12345)
User.create_sharded(12346, name: &quot;Bob&quot;, email: &quot;bob@example.com&quot;)
</code></pre>
<hr>
<h3>Shard-aware Associations</h3>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_many :posts
  
  # Posts must be on same shard as user
  def posts
    self.class.connected_to(shard: self.class.shard_for(id)) do
      super
    end
  end
end

class Post &lt; ApplicationRecord
  belongs_to :user
  
  # Always use user&#39;s shard
  def self.for_user(user_id)
    User.connected_to(shard: User.shard_for(user_id)) do
      where(user_id: user_id)
    end
  end
end

# Usage:
user = User.find_sharded(123)
posts = user.posts  # Queries correct shard
</code></pre>
<hr>
<h3>Cross-Shard Queries</h3>
<p><strong>Problem: Can&#39;t JOIN across shards</strong></p>
<pre><code class="language-ruby"># DOESN&#39;T WORK:
User.joins(:posts).where(posts: { published: true })
# Users and posts on different shards!

# Solution 1: Denormalize
class Post &lt; ApplicationRecord
  belongs_to :user
  
  # Store user data on same shard
  before_create :cache_user_data
  
  def cache_user_data
    self.user_name = user.name
    self.user_email = user.email
  end
end

# Now can query posts without joining users
Post.for_user(user_id).where(published: true)

# Solution 2: Application-level JOIN
users = User.where(status: &#39;active&#39;)
user_ids = users.pluck(:id)

posts_by_shard = {}
user_ids.each do |user_id|
  shard = User.shard_for(user_id)
  posts_by_shard[shard] ||= []
  posts_by_shard[shard] &lt;&lt; user_id
end

all_posts = []
posts_by_shard.each do |shard, user_ids_for_shard|
  ActiveRecord::Base.connected_to(shard: shard) do
    all_posts += Post.where(user_id: user_ids_for_shard).to_a
  end
end

# Expensive but works
</code></pre>
<hr>
<h3>Migrations on Shards</h3>
<pre><code class="language-ruby"># Run migration on all shards
namespace :db do
  task migrate_shards: :environment do
    shards = [:shard1, :shard2, :shard3]
    
    shards.each do |shard|
      puts &quot;Migrating #{shard}...&quot;
      
      ActiveRecord::Base.connected_to(shard: shard) do
        ActiveRecord::Migration.migrate(&#39;db/shards_migrate&#39;)
      end
      
      puts &quot;Completed #{shard}&quot;
    end
  end
end

# Run:
# rake db:migrate_shards
</code></pre>
<hr>
<h3>Resharding (Adding Shards)</h3>
<p><strong>Challenge: Redistributing data</strong></p>
<pre><code class="language-ruby"># Original: 2 shards
# New: 4 shards
# Must redistribute data

class ReshardUsers
  def self.perform
    # 1. Add new shards to config
    # 2. Create schema on new shards
    # 3. Redistribute data
    
    User.find_each(batch_size: 1000) do |user|
      old_shard = old_shard_for(user.id)  # Based on 2 shards
      new_shard = new_shard_for(user.id)  # Based on 4 shards
      
      if old_shard != new_shard
        # Copy to new shard
        ActiveRecord::Base.connected_to(shard: new_shard) do
          User.create!(user.attributes)
        end
        
        # Delete from old shard
        ActiveRecord::Base.connected_to(shard: old_shard) do
          user.destroy!
        end
      end
    end
  end
  
  def self.old_shard_for(user_id)
    &quot;shard#{user_id % 2}&quot;.to_sym
  end
  
  def self.new_shard_for(user_id)
    &quot;shard#{user_id % 4}&quot;.to_sym
  end
end

# Downtime required OR complex dual-write strategy
</code></pre>
<hr>
<h3>Sharding Gems</h3>
<p><strong>1. Octopus (deprecated):</strong></p>
<pre><code class="language-ruby"># gem &#39;ar-octopus&#39;
# Simple but unmaintained
</code></pre>
<p><strong>2. rails-sharding:</strong></p>
<pre><code class="language-ruby"># gem &#39;rails-sharding&#39;

class User &lt; ApplicationRecord
  sharded_by :id
end

User.shard_for(123).find(123)
</code></pre>
<p><strong>3. Vitess (production-grade):</strong></p>
<pre><code class="language-ruby"># MySQL sharding proxy
# Handles routing, resharding
# Used by: YouTube, Slack, Square
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Sharding</strong> = multiple database servers</li>
<li><strong>Use when</strong> single DB insufficient</li>
<li><strong>Hash-based</strong> for even distribution</li>
<li><strong>Rails multi-database</strong> support</li>
<li><strong>Cross-shard JOINs</strong> impossible</li>
<li><strong>Denormalize</strong> to avoid cross-shard</li>
<li><strong>Migrations</strong> run on all shards</li>
<li><strong>Resharding</strong> complex and expensive</li>
<li><strong>Last resort</strong> after other options</li>
<li><strong>Complexity</strong> vs <strong>scalability</strong></li>
</ol>
<hr>
<h2>Question 101: What are materialized views, and when would you use them?</h2>
<h3>Answer</h3>
<p><strong>Materialized views</strong> are pre-computed query results stored as physical tables. Unlike regular views (virtual), materialized views store actual data, making reads fast but requiring periodic refreshes.</p>
<hr>
<h3>Regular View vs Materialized View</h3>
<p><strong>Regular View (virtual):</strong></p>
<pre><code class="language-sql">CREATE VIEW active_users AS
SELECT users.*, COUNT(posts.id) as posts_count
FROM users
LEFT JOIN posts ON posts.user_id = users.id
WHERE users.active = true
GROUP BY users.id;

-- Query view:
SELECT * FROM active_users WHERE posts_count &gt; 10;

-- Executes underlying query every time:
-- JOIN + GROUP BY runs on every SELECT
-- Slow for complex queries
</code></pre>
<p><strong>Materialized View (physical):</strong></p>
<pre><code class="language-sql">CREATE MATERIALIZED VIEW active_users AS
SELECT users.*, COUNT(posts.id) as posts_count
FROM users
LEFT JOIN posts ON posts.user_id = users.id
WHERE users.active = true
GROUP BY users.id;

-- Query view:
SELECT * FROM active_users WHERE posts_count &gt; 10;

-- Reads from stored results:
-- No JOIN, no GROUP BY
-- Fast like regular table
</code></pre>
<hr>
<h3>When to Use Materialized Views</h3>
<p><strong>Use when:</strong></p>
<p>✅ <strong>Complex queries executed frequently</strong></p>
<pre><code class="language-ruby"># Dashboard query run 10,000x/day
# 5 JOINs + 3 aggregations
# Takes 2 seconds
# Perfect for materialized view
</code></pre>
<p>✅ <strong>Data changes infrequently</strong></p>
<pre><code class="language-ruby"># Monthly reports
# Daily analytics
# Historical data
# Refresh once per day acceptable
</code></pre>
<p>✅ <strong>Real-time accuracy not required</strong></p>
<pre><code class="language-ruby"># Dashboard can be 5 minutes stale
# Reports can be 1 hour stale
# Analytics can be 1 day stale
</code></pre>
<p><strong>Don&#39;t use when:</strong></p>
<p>❌ <strong>Data changes frequently</strong></p>
<pre><code class="language-ruby"># Real-time stock prices
# Live chat messages
# Current account balance
</code></pre>
<p>❌ <strong>Real-time accuracy required</strong></p>
<pre><code class="language-ruby"># Financial transactions
# Inventory management
# Payment processing
</code></pre>
<hr>
<h3>Creating Materialized Views in Rails</h3>
<p><strong>Migration:</strong></p>
<pre><code class="language-ruby">class CreateDashboardStats &lt; ActiveRecord::Migration[7.0]
  def up
    # Create materialized view
    execute &lt;&lt;-SQL
      CREATE MATERIALIZED VIEW dashboard_stats AS
      SELECT
        DATE(orders.created_at) as date,
        COUNT(DISTINCT orders.id) as orders_count,
        COUNT(DISTINCT orders.customer_id) as customers_count,
        SUM(orders.total) as revenue,
        AVG(orders.total) as average_order_value
      FROM orders
      WHERE orders.created_at &gt;= CURRENT_DATE - INTERVAL &#39;90 days&#39;
      GROUP BY DATE(orders.created_at)
      ORDER BY date DESC;
    SQL
    
    # Create index for fast lookups
    add_index :dashboard_stats, :date, unique: true
  end
  
  def down
    execute &quot;DROP MATERIALIZED VIEW IF EXISTS dashboard_stats&quot;
  end
end
</code></pre>
<p><strong>Model:</strong></p>
<pre><code class="language-ruby">class DashboardStat &lt; ApplicationRecord
  self.primary_key = :date
  
  # Refresh methods
  def self.refresh
    # Full refresh (recreates all data)
    connection.execute(
      &quot;REFRESH MATERIALIZED VIEW dashboard_stats&quot;
    )
  end
  
  def self.refresh_concurrent
    # Concurrent refresh (doesn&#39;t lock reads)
    # Requires unique index
    connection.execute(
      &quot;REFRESH MATERIALIZED VIEW CONCURRENTLY dashboard_stats&quot;
    )
  end
end

# Usage:
stats = DashboardStat.all  # Fast query
revenue = DashboardStat.where(&quot;date &gt;= ?&quot;, 7.days.ago).sum(:revenue)
</code></pre>
<hr>
<h3>Refresh Strategies</h3>
<p><strong>1. Manual Refresh:</strong></p>
<pre><code class="language-ruby"># Refresh in controller/job
class DashboardController &lt; ApplicationController
  def index
    # Refresh if stale
    if DashboardStat.maximum(:refreshed_at) &lt; 1.hour.ago
      DashboardStat.refresh_concurrent
    end
    
    @stats = DashboardStat.order(date: :desc).limit(30)
  end
end
</code></pre>
<p><strong>2. Scheduled Refresh (recommended):</strong></p>
<pre><code class="language-ruby"># app/jobs/refresh_dashboard_stats_job.rb
class RefreshDashboardStatsJob &lt; ApplicationJob
  queue_as :low_priority
  
  def perform
    DashboardStat.refresh_concurrent
    
    Rails.logger.info &quot;Refreshed dashboard_stats at #{Time.current}&quot;
  end
end

# config/initializers/scheduler.rb
if Rails.env.production?
  scheduler = Rufus::Scheduler.new
  
  # Refresh every hour
  scheduler.every &#39;1h&#39; do
    RefreshDashboardStatsJob.perform_later
  end
end

# Or use cron:
# 0 * * * * cd /app &amp;&amp; rake stats:refresh
</code></pre>
<p><strong>3. Trigger-based Refresh:</strong></p>
<pre><code class="language-ruby"># Refresh on data changes
class Order &lt; ApplicationRecord
  after_commit :schedule_stats_refresh
  
  private
  
  def schedule_stats_refresh
    RefreshDashboardStatsJob.perform_later
  end
end

# Problem: Too many refreshes if high volume
# Better: Debounce refreshes
</code></pre>
<hr>
<h3>Concurrent vs Non-Concurrent Refresh</h3>
<p><strong>Non-concurrent (locks view):</strong></p>
<pre><code class="language-sql">REFRESH MATERIALIZED VIEW dashboard_stats;

-- Behavior:
-- 1. Locks view (no reads during refresh)
-- 2. Drops old data
-- 3. Recomputes and inserts new data
-- 4. Releases lock

-- Downtime during refresh!
</code></pre>
<p><strong>Concurrent (no locks):</strong></p>
<pre><code class="language-sql">REFRESH MATERIALIZED VIEW CONCURRENTLY dashboard_stats;

-- Behavior:
-- 1. Recomputes in temp space
-- 2. Swaps data atomically
-- 3. No lock on reads

-- Requirements:
-- - Unique index required
-- - Slower than non-concurrent
-- - No downtime
</code></pre>
<p><strong>Recommendation: Use concurrent in production</strong></p>
<pre><code class="language-ruby">class DashboardStat &lt; ApplicationRecord
  def self.refresh
    # Always use concurrent in production
    if Rails.env.production?
      refresh_concurrent
    else
      # Faster for development
      connection.execute(
        &quot;REFRESH MATERIALIZED VIEW dashboard_stats&quot;
      )
    end
  end
end
</code></pre>
<hr>
<h3>Complex Materialized View Example</h3>
<p><strong>User analytics:</strong></p>
<pre><code class="language-ruby">class CreateUserAnalytics &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE MATERIALIZED VIEW user_analytics AS
      SELECT
        users.id,
        users.name,
        users.email,
        users.created_at as joined_at,
        COUNT(DISTINCT posts.id) as posts_count,
        COUNT(DISTINCT comments.id) as comments_count,
        COUNT(DISTINCT likes.id) as likes_received,
        SUM(posts.views) as total_views,
        MAX(posts.created_at) as last_post_at,
        MAX(comments.created_at) as last_comment_at,
        CASE
          WHEN COUNT(posts.id) = 0 THEN &#39;inactive&#39;
          WHEN COUNT(posts.id) &lt; 5 THEN &#39;beginner&#39;
          WHEN COUNT(posts.id) &lt; 50 THEN &#39;regular&#39;
          ELSE &#39;power_user&#39;
        END as user_tier
      FROM users
      LEFT JOIN posts ON posts.user_id = users.id
      LEFT JOIN comments ON comments.user_id = users.id
      LEFT JOIN likes ON likes.post_id = posts.id
      WHERE users.created_at &gt;= CURRENT_DATE - INTERVAL &#39;1 year&#39;
      GROUP BY users.id, users.name, users.email, users.created_at
      ORDER BY posts_count DESC;
    SQL
    
    add_index :user_analytics, :id, unique: true
    add_index :user_analytics, :user_tier
    add_index :user_analytics, :posts_count
  end
end

class UserAnalytic &lt; ApplicationRecord
  self.primary_key = :id
  
  scope :power_users, -&gt; { where(user_tier: &#39;power_user&#39;) }
  scope :inactive, -&gt; { where(user_tier: &#39;inactive&#39;) }
  scope :top_contributors, -&gt; { order(posts_count: :desc).limit(100) }
end

# Usage:
# Fast queries without complex JOINs
power_users = UserAnalytic.power_users
top_10 = UserAnalytic.top_contributors.limit(10)
</code></pre>
<hr>
<h3>Incremental Refresh (PostgreSQL 13+)</h3>
<pre><code class="language-sql">-- Create table to track changes
CREATE TABLE user_posts_changes (
  user_id BIGINT,
  changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Trigger to track changes
CREATE OR REPLACE FUNCTION track_post_changes()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO user_posts_changes (user_id)
  VALUES (COALESCE(NEW.user_id, OLD.user_id));
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER posts_change_trigger
AFTER INSERT OR UPDATE OR DELETE ON posts
FOR EACH ROW EXECUTE FUNCTION track_post_changes();

-- Incremental refresh
-- Only update changed users
UPDATE user_analytics ua
SET
  posts_count = (SELECT COUNT(*) FROM posts WHERE user_id = ua.id),
  last_post_at = (SELECT MAX(created_at) FROM posts WHERE user_id = ua.id)
WHERE ua.id IN (
  SELECT DISTINCT user_id 
  FROM user_posts_changes 
  WHERE changed_at &gt; NOW() - INTERVAL &#39;1 hour&#39;
);

-- Clear tracked changes
DELETE FROM user_posts_changes 
WHERE changed_at &lt; NOW() - INTERVAL &#39;1 hour&#39;;
</code></pre>
<hr>
<h3>Monitoring Materialized Views</h3>
<pre><code class="language-ruby"># Check view freshness
class DashboardStat &lt; ApplicationRecord
  def self.stale?
    last_refresh = connection.execute(&lt;&lt;-SQL).first
      SELECT
        pg_stat_get_last_analyze_time(c.oid) as last_refresh
      FROM pg_class c
      WHERE c.relname = &#39;dashboard_stats&#39;
    SQL
    
    last_refresh_time = last_refresh[&#39;last_refresh&#39;]
    last_refresh_time.nil? || last_refresh_time &lt; 1.hour.ago
  end
  
  def self.size
    connection.execute(&lt;&lt;-SQL).first[&#39;size&#39;]
      SELECT pg_size_pretty(pg_total_relation_size(&#39;dashboard_stats&#39;)) as size
    SQL
  end
end

# Monitor refresh duration
class RefreshDashboardStatsJob &lt; ApplicationJob
  def perform
    start_time = Time.current
    
    DashboardStat.refresh_concurrent
    
    duration = Time.current - start_time
    
    Rails.logger.info &quot;Dashboard stats refreshed in #{duration}s&quot;
    
    if duration &gt; 60
      Rails.logger.warn &quot;Slow refresh: #{duration}s&quot;
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Materialized views</strong> store query results</li>
<li><strong>Fast reads</strong> like regular tables</li>
<li><strong>Require refresh</strong> to update</li>
<li><strong>Perfect for</strong> dashboards/analytics</li>
<li><strong>Use when</strong> data changes slowly</li>
<li><strong>Concurrent refresh</strong> in production</li>
<li><strong>Schedule refreshes</strong> regularly</li>
<li><strong>Index</strong> for fast lookups</li>
<li><strong>Monitor</strong> freshness and size</li>
<li><strong>Trade-off</strong> - speed vs freshness</li>
</ol>
<hr>
<h2>Question 102: How do you use materialized views for performance optimization?</h2>
<h3>Answer</h3>
<p>Use materialized views to <strong>pre-compute expensive queries</strong>, <strong>eliminate JOINs</strong>, <strong>cache aggregations</strong>, and <strong>serve analytics dashboards</strong> with sub-second response times instead of multi-second query times.</p>
<hr>
<h3>Optimization Pattern 1: Dashboard Queries</h3>
<p><strong>Before (slow):</strong></p>
<pre><code class="language-ruby">class DashboardController &lt; ApplicationController
  def index
    # Complex query - 5 JOINs, 3 aggregations
    @stats = Order.joins(:customer, :order_items, :products)
                  .where(&#39;orders.created_at &gt;= ?&#39;, 30.days.ago)
                  .group(&#39;DATE(orders.created_at)&#39;)
                  .select(
                    &#39;DATE(orders.created_at) as date&#39;,
                    &#39;COUNT(DISTINCT orders.id) as orders&#39;,
                    &#39;COUNT(DISTINCT customers.id) as customers&#39;,
                    &#39;SUM(order_items.quantity * order_items.price) as revenue&#39;
                  )
    
    # Query time: 8 seconds for 10M orders
    # Timeout issues
  end
end
</code></pre>
<p><strong>After (fast with materialized view):</strong></p>
<pre><code class="language-ruby"># Migration:
class CreateDailyStats &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE MATERIALIZED VIEW daily_stats AS
      SELECT
        DATE(orders.created_at) as date,
        COUNT(DISTINCT orders.id) as orders_count,
        COUNT(DISTINCT orders.customer_id) as customers_count,
        SUM(order_items.quantity * order_items.price) as revenue,
        AVG(order_items.quantity * order_items.price) as avg_order_value
      FROM orders
      JOIN order_items ON order_items.order_id = orders.id
      WHERE orders.created_at &gt;= CURRENT_DATE - INTERVAL &#39;90 days&#39;
      GROUP BY DATE(orders.created_at);
    SQL
    
    add_index :daily_stats, :date, unique: true
  end
end

# Model:
class DailyStat &lt; ApplicationRecord
  self.primary_key = :date
end

# Controller:
class DashboardController &lt; ApplicationController
  def index
    @stats = DailyStat.where(&#39;date &gt;= ?&#39;, 30.days.ago)
                     .order(date: :desc)
    
    # Query time: 10ms
    # 800x faster!
  end
end

# Refresh job:
class RefreshDailyStatsJob &lt; ApplicationJob
  def perform
    DailyStat.refresh_concurrent
  end
end

# Schedule: Every hour
</code></pre>
<hr>
<h3>Optimization Pattern 2: Leaderboards</h3>
<p><strong>Before:</strong></p>
<pre><code class="language-ruby">class UsersController &lt; ApplicationController
  def leaderboard
    @top_users = User.joins(:posts, :comments)
                    .select(
                      &#39;users.*&#39;,
                      &#39;COUNT(DISTINCT posts.id) as posts_count&#39;,
                      &#39;COUNT(DISTINCT comments.id) as comments_count&#39;,
                      &#39;SUM(posts.views) as total_views&#39;
                    )
                    .group(&#39;users.id&#39;)
                    .order(&#39;total_views DESC&#39;)
                    .limit(100)
    
    # Query time: 12 seconds
  end
end
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-ruby"># Materialized view:
CREATE MATERIALIZED VIEW user_leaderboard AS
SELECT
  users.id,
  users.name,
  users.avatar_url,
  COUNT(DISTINCT posts.id) as posts_count,
  COUNT(DISTINCT comments.id) as comments_count,
  SUM(posts.views) as total_views,
  ROW_NUMBER() OVER (ORDER BY SUM(posts.views) DESC) as rank
FROM users
LEFT JOIN posts ON posts.user_id = users.id
LEFT JOIN comments ON comments.user_id = users.id
GROUP BY users.id, users.name, users.avatar_url;

-- Index:
CREATE UNIQUE INDEX idx_leaderboard_id ON user_leaderboard (id);
CREATE INDEX idx_leaderboard_rank ON user_leaderboard (rank);

# Controller:
class UsersController &lt; ApplicationController
  def leaderboard
    @top_users = UserLeaderboard.order(:rank).limit(100)
    # Query time: 5ms
    # 2400x faster!
  end
end
</code></pre>
<hr>
<h3>Optimization Pattern 3: Search Results</h3>
<p><strong>Before:</strong></p>
<pre><code class="language-ruby">class ProductsController &lt; ApplicationController
  def search
    @products = Product.joins(:category, :brand, :reviews)
                      .select(
                        &#39;products.*&#39;,
                        &#39;categories.name as category_name&#39;,
                        &#39;brands.name as brand_name&#39;,
                        &#39;AVG(reviews.rating) as avg_rating&#39;,
                        &#39;COUNT(reviews.id) as reviews_count&#39;
                      )
                      .where(&#39;products.name ILIKE ?&#39;, &quot;%#{params[:q]}%&quot;)
                      .group(&#39;products.id, categories.name, brands.name&#39;)
                      .page(params[:page])
    
    # Every search: JOINs + aggregations
    # Slow for large product catalogs
  end
end
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-ruby"># Materialized view with all searchable data:
CREATE MATERIALIZED VIEW product_search AS
SELECT
  products.id,
  products.name,
  products.description,
  products.price,
  products.image_url,
  categories.name as category_name,
  brands.name as brand_name,
  AVG(reviews.rating) as avg_rating,
  COUNT(reviews.id) as reviews_count,
  SUM(order_items.quantity) as total_sold,
  setweight(to_tsvector(&#39;english&#39;, products.name), &#39;A&#39;) ||
  setweight(to_tsvector(&#39;english&#39;, products.description), &#39;B&#39;) ||
  setweight(to_tsvector(&#39;english&#39;, brands.name), &#39;C&#39;) as search_vector
FROM products
LEFT JOIN categories ON categories.id = products.category_id
LEFT JOIN brands ON brands.id = products.brand_id
LEFT JOIN reviews ON reviews.product_id = products.id
LEFT JOIN order_items ON order_items.product_id = products.id
GROUP BY products.id, categories.name, brands.name;

-- Full-text search index:
CREATE INDEX idx_product_search_fts ON product_search USING gin(search_vector);

# Controller:
class ProductsController &lt; ApplicationController
  def search
    @products = ProductSearch
                  .where(&quot;search_vector @@ plainto_tsquery(&#39;english&#39;, ?)&quot;, params[:q])
                  .order(&#39;ts_rank(search_vector, plainto_tsquery(?)) DESC&#39;, params[:q])
                  .page(params[:page])
    
    # Fast full-text search with all data pre-joined
  end
end
</code></pre>
<hr>
<h3>Optimization Pattern 4: Reports</h3>
<p><strong>Before:</strong></p>
<pre><code class="language-ruby"># Monthly report - very slow
class MonthlyReport
  def generate(year, month)
    start_date = Date.new(year, month, 1)
    end_date = start_date.end_of_month
    
    {
      orders: Order.where(created_at: start_date..end_date).count,
      revenue: Order.where(created_at: start_date..end_date).sum(:total),
      customers: Order.where(created_at: start_date..end_date).distinct.count(:customer_id),
      avg_order: Order.where(created_at: start_date..end_date).average(:total),
      top_products: Product.joins(order_items: :order)
                          .where(orders: { created_at: start_date..end_date })
                          .group(&#39;products.id, products.name&#39;)
                          .select(&#39;products.*, SUM(order_items.quantity) as sold&#39;)
                          .order(&#39;sold DESC&#39;)
                          .limit(10)
    }
    
    # Takes 2 minutes to generate
  end
end
</code></pre>
<p><strong>After:</strong></p>
<pre><code class="language-ruby"># Pre-computed monthly stats:
CREATE MATERIALIZED VIEW monthly_stats AS
SELECT
  DATE_TRUNC(&#39;month&#39;, orders.created_at) as month,
  COUNT(DISTINCT orders.id) as orders_count,
  COUNT(DISTINCT orders.customer_id) as customers_count,
  SUM(orders.total) as revenue,
  AVG(orders.total) as avg_order_value,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY orders.total) as median_order
FROM orders
WHERE orders.created_at &gt;= DATE_TRUNC(&#39;month&#39;, CURRENT_DATE - INTERVAL &#39;24 months&#39;)
GROUP BY DATE_TRUNC(&#39;month&#39;, orders.created_at);

CREATE MATERIALIZED VIEW monthly_product_sales AS
SELECT
  DATE_TRUNC(&#39;month&#39;, orders.created_at) as month,
  products.id as product_id,
  products.name as product_name,
  SUM(order_items.quantity) as quantity_sold,
  SUM(order_items.quantity * order_items.price) as revenue,
  ROW_NUMBER() OVER (
    PARTITION BY DATE_TRUNC(&#39;month&#39;, orders.created_at)
    ORDER BY SUM(order_items.quantity) DESC
  ) as rank
FROM orders
JOIN order_items ON order_items.order_id = orders.id
JOIN products ON products.id = order_items.product_id
WHERE orders.created_at &gt;= DATE_TRUNC(&#39;month&#39;, CURRENT_DATE - INTERVAL &#39;24 months&#39;)
GROUP BY DATE_TRUNC(&#39;month&#39;, orders.created_at), products.id, products.name;

# Now instant report generation:
class MonthlyReport
  def generate(year, month)
    month_date = Date.new(year, month, 1)
    
    stats = MonthlyStat.find_by(month: month_date)
    top_products = MonthlyProductSale.where(month: month_date, rank: 1..10)
    
    {
      orders: stats.orders_count,
      revenue: stats.revenue,
      customers: stats.customers_count,
      avg_order: stats.avg_order_value,
      top_products: top_products
    }
    
    # Takes 10ms - 12,000x faster!
  end
end
</code></pre>
<hr>
<h3>Optimization Pattern 5: Cascading Materialized Views</h3>
<p><strong>Build materialized views on top of others:</strong></p>
<pre><code class="language-ruby"># Base materialized view:
CREATE MATERIALIZED VIEW daily_order_stats AS
SELECT
  DATE(created_at) as date,
  status,
  COUNT(*) as count,
  SUM(total) as revenue
FROM orders
GROUP BY DATE(created_at), status;

# Monthly rollup (built on daily):
CREATE MATERIALIZED VIEW monthly_order_stats AS
SELECT
  DATE_TRUNC(&#39;month&#39;, date) as month,
  status,
  SUM(count) as count,
  SUM(revenue) as revenue
FROM daily_order_stats
GROUP BY DATE_TRUNC(&#39;month&#39;, date), status;

# Yearly rollup (built on monthly):
CREATE MATERIALIZED VIEW yearly_order_stats AS
SELECT
  DATE_TRUNC(&#39;year&#39;, month) as year,
  status,
  SUM(count) as count,
  SUM(revenue) as revenue
FROM monthly_order_stats
GROUP BY DATE_TRUNC(&#39;year&#39;, month), status;

# Refresh cascade:
class RefreshStatsJob &lt; ApplicationJob
  def perform
    # Refresh in order
    connection.execute(&quot;REFRESH MATERIALIZED VIEW CONCURRENTLY daily_order_stats&quot;)
    connection.execute(&quot;REFRESH MATERIALIZED VIEW CONCURRENTLY monthly_order_stats&quot;)
    connection.execute(&quot;REFRESH MATERIALIZED VIEW CONCURRENTLY yearly_order_stats&quot;)
  end
end
</code></pre>
<hr>
<h3>Performance Monitoring</h3>
<pre><code class="language-ruby">class MaterializedViewMonitor
  def self.report
    views = [
      &#39;daily_stats&#39;,
      &#39;user_leaderboard&#39;,
      &#39;product_search&#39;,
      &#39;monthly_stats&#39;
    ]
    
    views.each do |view_name|
      # Size
      size = connection.execute(&lt;&lt;-SQL).first[&#39;size&#39;]
        SELECT pg_size_pretty(pg_total_relation_size(&#39;#{view_name}&#39;)) as size
      SQL
      
      # Row count
      count = connection.execute(&quot;SELECT COUNT(*) FROM #{view_name}&quot;).first[&#39;count&#39;]
      
      # Last refresh (approximate)
      last_stats = connection.execute(&lt;&lt;-SQL).first
        SELECT pg_stat_get_last_analyze_time(c.oid) as last_time
        FROM pg_class c
        WHERE c.relname = &#39;#{view_name}&#39;
      SQL
      
      puts &quot;#{view_name}:&quot;
      puts &quot;  Size: #{size}&quot;
      puts &quot;  Rows: #{count}&quot;
      puts &quot;  Last refresh: #{last_stats[&#39;last_time&#39;]}&quot;
      puts
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Pre-compute</strong> expensive queries</li>
<li><strong>Eliminate JOINs</strong> in hot paths</li>
<li><strong>Cache aggregations</strong> for analytics</li>
<li><strong>Refresh regularly</strong> but not too often</li>
<li><strong>Index</strong> for fast lookups</li>
<li><strong>Cascade views</strong> for rollups</li>
<li><strong>Monitor size</strong> and refresh time</li>
<li><strong>Use concurrent</strong> refresh in production</li>
<li><strong>10-1000x</strong> performance improvement</li>
<li><strong>Trade freshness</strong> for speed</li>
</ol>
<hr>
<h2>Question 103: How do you perform recursive queries in SQL?</h2>
<h3>Answer</h3>
<p><strong>Recursive queries</strong> use Common Table Expressions (CTEs) with <code>WITH RECURSIVE</code> to traverse hierarchical data like trees, graphs, and nested structures.</p>
<hr>
<h3>Basic Syntax</h3>
<pre><code class="language-sql">WITH RECURSIVE cte_name AS (
  -- Base case (anchor)
  SELECT ... FROM table WHERE condition
  
  UNION ALL
  
  -- Recursive case
  SELECT ... FROM table
  JOIN cte_name ON ...
)
SELECT * FROM cte_name;
</code></pre>
<hr>
<h3>Example 1: Organization Hierarchy</h3>
<p><strong>Schema:</strong></p>
<pre><code class="language-ruby"># Migration:
create_table :employees do |t|
  t.string :name
  t.references :manager, foreign_key: { to_table: :employees }
  t.string :title
end

# Data:
# | id | name  | manager_id | title          |
# |----|-------|------------|----------------|
# | 1  | Alice | NULL       | CEO            |
# | 2  | Bob   | 1          | VP Engineering |
# | 3  | Carol | 1          | VP Sales       |
# | 4  | Dave  | 2          | Engineer       |
# | 5  | Eve   | 2          | Engineer       |
# | 6  | Frank | 3          | Sales Rep      |
</code></pre>
<p><strong>Recursive query - all reports under Bob:</strong></p>
<pre><code class="language-sql">WITH RECURSIVE subordinates AS (
  -- Base case: Start with Bob
  SELECT id, name, manager_id, title, 1 as level
  FROM employees
  WHERE name = &#39;Bob&#39;
  
  UNION ALL
  
  -- Recursive case: Find direct reports
  SELECT e.id, e.name, e.manager_id, e.title, s.level + 1
  FROM employees e
  JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates;

-- Result:
-- | id | name | manager_id | title          | level |
-- |----|------|------------|----------------|-------|
-- | 2  | Bob  | 1          | VP Engineering | 1     |
-- | 4  | Dave | 2          | Engineer       | 2     |
-- | 5  | Eve  | 2          | Engineer       | 2     |
</code></pre>
<p><strong>Rails implementation:</strong></p>
<pre><code class="language-ruby">class Employee &lt; ApplicationRecord
  belongs_to :manager, class_name: &#39;Employee&#39;, optional: true
  has_many :direct_reports, class_name: &#39;Employee&#39;, foreign_key: &#39;manager_id&#39;
  
  def self.subordinates_of(manager_id)
    from(&lt;&lt;-SQL)
      (
        WITH RECURSIVE subordinates AS (
          SELECT id, name, manager_id, title, 1 as level
          FROM employees
          WHERE id = #{manager_id}
          
          UNION ALL
          
          SELECT e.id, e.name, e.manager_id, e.title, s.level + 1
          FROM employees e
          JOIN subordinates s ON e.manager_id = s.id
        )
        SELECT * FROM subordinates
      ) AS employees
    SQL
  end
  
  # All ancestors (managers up the chain)
  def self.ancestors_of(employee_id)
    from(&lt;&lt;-SQL)
      (
        WITH RECURSIVE managers AS (
          SELECT id, name, manager_id, title, 0 as level
          FROM employees
          WHERE id = #{employee_id}
          
          UNION ALL
          
          SELECT e.id, e.name, e.manager_id, e.title, m.level + 1
          FROM employees e
          JOIN managers m ON e.id = m.manager_id
        )
        SELECT * FROM managers WHERE level &gt; 0
      ) AS employees
    SQL
  end
end

# Usage:
subordinates = Employee.subordinates_of(2)  # Bob&#39;s team
managers = Employee.ancestors_of(4)         # Dave&#39;s managers
</code></pre>
<hr>
<h3>Example 2: Category Tree</h3>
<p><strong>Schema:</strong></p>
<pre><code class="language-ruby">create_table :categories do |t|
  t.string :name
  t.references :parent, foreign_key: { to_table: :categories }
end

# Electronics
#   ├─ Computers
#   │  ├─ Laptops
#   │  └─ Desktops
#   └─ Phones
#      ├─ iPhone
#      └─ Android
</code></pre>
<p><strong>Get all subcategories:</strong></p>
<pre><code class="language-sql">WITH RECURSIVE category_tree AS (
  -- Base: Electronics
  SELECT id, name, parent_id, 1 as depth, name as path
  FROM categories
  WHERE name = &#39;Electronics&#39;
  
  UNION ALL
  
  -- Recursive: Children
  SELECT c.id, c.name, c.parent_id, ct.depth + 1, 
         ct.path || &#39; &gt; &#39; || c.name
  FROM categories c
  JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT * FROM category_tree;

-- Result:
-- | id | name        | parent_id | depth | path                          |
-- |----|-------------|-----------|-------|-------------------------------|
-- | 1  | Electronics | NULL      | 1     | Electronics                   |
-- | 2  | Computers   | 1         | 2     | Electronics &gt; Computers       |
-- | 5  | Phones      | 1         | 2     | Electronics &gt; Phones          |
-- | 3  | Laptops     | 2         | 3     | Electronics &gt; Computers &gt; ... |
</code></pre>
<p><strong>Rails implementation:</strong></p>
<pre><code class="language-ruby">class Category &lt; ApplicationRecord
  belongs_to :parent, class_name: &#39;Category&#39;, optional: true
  has_many :children, class_name: &#39;Category&#39;, foreign_key: &#39;parent_id&#39;
  
  # Get entire subtree
  def subtree
    self.class.from(&lt;&lt;-SQL)
      (
        WITH RECURSIVE category_tree AS (
          SELECT id, name, parent_id, 1 as depth
          FROM categories
          WHERE id = #{id}
          
          UNION ALL
          
          SELECT c.id, c.name, c.parent_id, ct.depth + 1
          FROM categories c
          JOIN category_tree ct ON c.parent_id = ct.id
        )
        SELECT * FROM category_tree
      ) AS categories
    SQL
  end
  
  # Get path to root
  def path_to_root
    self.class.from(&lt;&lt;-SQL)
      (
        WITH RECURSIVE path AS (
          SELECT id, name, parent_id, 0 as distance
          FROM categories
          WHERE id = #{id}
          
          UNION ALL
          
          SELECT c.id, c.name, c.parent_id, p.distance + 1
          FROM categories c
          JOIN path p ON c.id = p.parent_id
        )
        SELECT * FROM path ORDER BY distance DESC
      ) AS categories
    SQL
  end
end

# Usage:
category = Category.find_by(name: &#39;Laptops&#39;)
all_subcategories = category.subtree
breadcrumb = category.path_to_root.pluck(:name).join(&#39; &gt; &#39;)
# =&gt; &quot;Electronics &gt; Computers &gt; Laptops&quot;
</code></pre>
<hr>
<h3>Example 3: Graph Traversal</h3>
<p><strong>Find all connected nodes:</strong></p>
<pre><code class="language-ruby"># Schema: friendships
create_table :friendships do |t|
  t.references :user, foreign_key: true
  t.references :friend, foreign_key: { to_table: :users }
end

# Find all friends-of-friends (up to 3 degrees)
WITH RECURSIVE friend_network AS (
  -- Direct friends
  SELECT friend_id as user_id, 1 as degree
  FROM friendships
  WHERE user_id = 1
  
  UNION
  
  -- Friends of friends (prevent cycles with degree limit)
  SELECT f.friend_id, fn.degree + 1
  FROM friendships f
  JOIN friend_network fn ON f.user_id = fn.user_id
  WHERE fn.degree &lt; 3
)
SELECT DISTINCT user_id, degree
FROM friend_network
ORDER BY degree, user_id;
</code></pre>
<hr>
<h3>Example 4: Bill of Materials</h3>
<p><strong>Schema:</strong></p>
<pre><code class="language-ruby">create_table :parts do |t|
  t.string :name
  t.decimal :cost
end

create_table :part_assemblies do |t|
  t.references :part, foreign_key: true
  t.references :component, foreign_key: { to_table: :parts }
  t.integer :quantity
end

# Calculate total cost of assembly
WITH RECURSIVE bom AS (
  -- Top level part
  SELECT 
    p.id, 
    p.name, 
    p.cost, 
    1 as quantity,
    p.cost as total_cost,
    1 as level
  FROM parts p
  WHERE p.name = &#39;Laptop&#39;
  
  UNION ALL
  
  -- Components
  SELECT 
    p.id,
    p.name,
    p.cost,
    pa.quantity * bom.quantity,
    p.cost * pa.quantity * bom.quantity,
    bom.level + 1
  FROM parts p
  JOIN part_assemblies pa ON pa.component_id = p.id
  JOIN bom ON bom.id = pa.part_id
)
SELECT SUM(total_cost) as total_manufacturing_cost
FROM bom;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>WITH RECURSIVE</strong> for hierarchies</li>
<li><strong>Base case</strong> starts recursion</li>
<li><strong>UNION ALL</strong> combines results</li>
<li><strong>JOIN</strong> on CTE itself</li>
<li><strong>Prevent infinite loops</strong> with depth limit</li>
<li><strong>Organization charts</strong> common use</li>
<li><strong>Category trees</strong> with paths</li>
<li><strong>Graph traversal</strong> possible</li>
<li><strong>Rails</strong> supports via raw SQL</li>
<li><strong>Performance</strong> - add depth limit</li>
</ol>
<hr>
<h2>Question 104: What is MVCC (Multi-Version Concurrency Control)?</h2>
<h3>Answer</h3>
<p><strong>MVCC</strong> allows multiple transactions to access the same data concurrently without blocking by maintaining multiple versions of each row. Readers don&#39;t block writers, writers don&#39;t block readers.</p>
<hr>
<h3>How MVCC Works</h3>
<p><strong>Traditional locking (without MVCC):</strong></p>
<pre><code>Transaction 1:           Transaction 2:
BEGIN                    BEGIN
SELECT * FROM users      
WHERE id = 1            
(acquires lock)         
                        SELECT * FROM users
                        WHERE id = 1
                        (WAITS for lock)
UPDATE users...         
COMMIT                  
(releases lock)         
                        (lock acquired, reads data)
                        COMMIT
</code></pre>
<p><strong>With MVCC (PostgreSQL):</strong></p>
<pre><code>Transaction 1:           Transaction 2:
BEGIN                    BEGIN
(xid: 100)              (xid: 101)

SELECT * FROM users      
WHERE id = 1            
(reads version visible  
to xid 100)            
                        SELECT * FROM users
                        WHERE id = 1
                        (reads version visible to xid 101)
                        (NO WAIT - reads snapshot)

UPDATE users            
SET name = &#39;Alice&#39;      
(creates new version    
visible to xid &gt;= 100)  
                        (Still sees old version)

COMMIT                  
(version now visible    
to xid &gt;= 101)         
                        SELECT * FROM users
                        WHERE id = 1
                        (Still sees old version - snapshot isolation)
                        
                        COMMIT
</code></pre>
<hr>
<h3>Row Versioning</h3>
<p><strong>Each row has hidden metadata:</strong></p>
<pre><code class="language-sql">-- PostgreSQL hidden columns:
-- xmin: Transaction that created this version
-- xmax: Transaction that deleted/updated this version
-- cmin, cmax: Command within transaction

SELECT xmin, xmax, * FROM users WHERE id = 1;

-- | xmin | xmax | id | name  |
-- |------|------|----|-------|
-- | 100  | 0    | 1  | Alice |

-- After update:
UPDATE users SET name = &#39;Alice Updated&#39; WHERE id = 1;

-- Old version:
-- | xmin | xmax | id | name  |
-- |------|------|----|-------|
-- | 100  | 105  | 1  | Alice |  (xmax = 105 means deleted by transaction 105)

-- New version:
-- | xmin | xmax | id | name           |
-- |------|------|----|----------------|
-- | 105  | 0    | 1  | Alice Updated | (xmin = 105 means created by transaction 105)
</code></pre>
<hr>
<h3>Visibility Rules</h3>
<p><strong>Which version does a transaction see?</strong></p>
<pre><code class="language-ruby"># Transaction sees a row version if:
# 1. xmin committed before transaction started
# 2. xmax is 0 OR xmax not committed before transaction started

# Example:
# Transaction A (xid: 100) starts
# Transaction B (xid: 101) starts
# Transaction A updates row (xmin: 100, xmax: 105)
# Transaction C (xid: 106) starts

# Transaction A sees: xmin: 100 version (its own update)
# Transaction B sees: xmin: original version (isolation)
# Transaction C sees: xmin: 105 version (committed)
</code></pre>
<hr>
<h3>Benefits of MVCC</h3>
<p><strong>1. No read locks:</strong></p>
<pre><code class="language-ruby"># Transaction 1: Long-running report
Account.transaction do
  report_data = Account.all.to_a
  # Takes 10 minutes to process
end

# Transaction 2: Concurrent updates work!
Account.transaction do
  account.update(balance: 100)
  # Doesn&#39;t block Transaction 1
end

# Both complete successfully
# No lock waits
</code></pre>
<p><strong>2. Consistent snapshots:</strong></p>
<pre><code class="language-ruby"># Transaction starts
Account.transaction do
  # All queries see same snapshot of data
  accounts = Account.all
  
  # Even if other transactions commit changes
  # This transaction sees consistent point-in-time view
  
  accounts.each do |account|
    process(account)
  end
end
</code></pre>
<p><strong>3. High concurrency:</strong></p>
<pre><code class="language-ruby"># 1000 concurrent readers
# 1000 concurrent writers
# All work simultaneously
# No blocking
</code></pre>
<hr>
<h3>MVCC in Rails</h3>
<p><strong>Automatic snapshot isolation:</strong></p>
<pre><code class="language-ruby">Account.transaction do
  # Snapshot taken at BEGIN
  
  account1 = Account.find(1)
  # Reads from snapshot
  
  sleep(5)  # Other transactions might commit
  
  account2 = Account.find(1)
  # Reads same version as before (consistent)
  
  # account1 and account2 identical
end
</code></pre>
<p><strong>Repeatable read:</strong></p>
<pre><code class="language-ruby">Account.transaction(isolation: :repeatable_read) do
  # Stricter isolation
  # Same query always returns same results
  
  balance1 = Account.where(status: &#39;active&#39;).sum(:balance)
  
  # Even if new active accounts created
  
  balance2 = Account.where(status: &#39;active&#39;).sum(:balance)
  
  # balance1 == balance2
end
</code></pre>
<hr>
<h3>MVCC Costs</h3>
<p><strong>1. Storage overhead:</strong></p>
<pre><code class="language-ruby"># Each update creates new version
user.update(name: &quot;Alice&quot;)    # Version 1
user.update(name: &quot;Alice B&quot;)  # Version 2
user.update(name: &quot;Alice C&quot;)  # Version 3

# All 3 versions stored until VACUUM
# Old versions marked as &quot;dead tuples&quot;
</code></pre>
<p><strong>2. VACUUM required:</strong></p>
<pre><code class="language-ruby"># PostgreSQL VACUUM process:
# - Removes dead tuples (old versions)
# - Reclaims disk space
# - Updates statistics

# Auto-vacuum runs automatically
# Manual vacuum:
VACUUM ANALYZE users;

# Check dead tuples:
SELECT 
  schemaname,
  relname,
  n_live_tup,
  n_dead_tup,
  last_vacuum
FROM pg_stat_user_tables
WHERE relname = &#39;users&#39;;

-- | schemaname | relname | n_live_tup | n_dead_tup | last_vacuum |
-- |------------|---------|------------|------------|-------------|
-- | public     | users   | 1000       | 500        | 2024-01-01  |

-- 500 dead tuples need cleanup
</code></pre>
<p><strong>3. Transaction ID wraparound:</strong></p>
<pre><code class="language-ruby"># PostgreSQL uses 32-bit transaction IDs
# After 2 billion transactions, wraps around
# VACUUM prevents wraparound

# Monitor:
SELECT datname, age(datfrozenxid) 
FROM pg_database 
ORDER BY age(datfrozenxid) DESC;

-- If age &gt; 200 million, VACUUM urgently needed
</code></pre>
<hr>
<h3>MVCC vs Locking</h3>
<p><strong>MVCC advantages:</strong></p>
<ul>
<li>✅ Readers don&#39;t block writers</li>
<li>✅ Writers don&#39;t block readers</li>
<li>✅ High concurrency</li>
<li>✅ Consistent snapshots</li>
</ul>
<p><strong>MVCC disadvantages:</strong></p>
<ul>
<li>❌ Storage overhead</li>
<li>❌ VACUUM required</li>
<li>❌ Can still have conflicts</li>
</ul>
<p><strong>When to use explicit locking:</strong></p>
<pre><code class="language-ruby"># Use pessimistic locking when:
# - High contention expected
# - Must prevent conflicts

Account.transaction do
  account = Account.lock.find(1)
  # Explicit lock prevents concurrent updates
  account.balance += 100
  account.save!
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>MVCC</strong> = multiple row versions</li>
<li><strong>No read locks</strong> needed</li>
<li><strong>Consistent snapshots</strong> automatic</li>
<li><strong>High concurrency</strong> possible</li>
<li><strong>Each update</strong> creates new version</li>
<li><strong>VACUUM</strong> cleans old versions</li>
<li><strong>Storage overhead</strong> from versioning</li>
<li><strong>PostgreSQL</strong> uses MVCC</li>
<li><strong>MySQL InnoDB</strong> uses MVCC</li>
<li><strong>Readers/writers</strong> don&#39;t block</li>
</ol>
<h1>Validations and Callbacks Interview Questions</h1>
<h2>Question 105: What are Rails validations, and how do they work?</h2>
<h3>Answer</h3>
<p><strong>Validations</strong> ensure data integrity by checking that model attributes meet specific requirements before saving to the database. They run automatically on <code>save</code>, <code>create</code>, and <code>update</code> operations.</p>
<hr>
<h3>How Validations Work</h3>
<p><strong>Basic flow:</strong></p>
<pre><code class="language-ruby">user = User.new(email: &quot;invalid&quot;)

user.save
# 1. Runs validations
# 2. If valid: saves to database, returns true
# 3. If invalid: doesn&#39;t save, returns false, populates errors

user.valid?  # =&gt; false
user.errors.full_messages  # =&gt; [&quot;Email is invalid&quot;]
</code></pre>
<hr>
<h3>Common Validations</h3>
<p><strong>1. Presence:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email, presence: true
  validates :name, presence: true
  validates :password, presence: true, on: :create
end

user = User.new
user.valid?  # =&gt; false
user.errors[:email]  # =&gt; [&quot;can&#39;t be blank&quot;]
</code></pre>
<p><strong>2. Uniqueness:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email, uniqueness: true
  validates :username, uniqueness: { case_sensitive: false }
  validates :phone, uniqueness: { scope: :country_code }
end

# Database index recommended:
add_index :users, :email, unique: true
add_index :users, [:country_code, :phone], unique: true
</code></pre>
<p><strong>3. Format (Regex):</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email, format: { 
    with: /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i,
    message: &quot;must be a valid email address&quot;
  }
  
  validates :zip_code, format: { with: /\A\d{5}(-\d{4})?\z/ }
end
</code></pre>
<p><strong>4. Length:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :password, length: { minimum: 8 }
  validates :username, length: { in: 3..20 }
  validates :bio, length: { maximum: 500 }
  validates :pin, length: { is: 4 }
end
</code></pre>
<p><strong>5. Numericality:</strong></p>
<pre><code class="language-ruby">class Product &lt; ApplicationRecord
  validates :price, numericality: { greater_than: 0 }
  validates :quantity, numericality: { 
    only_integer: true,
    greater_than_or_equal_to: 0
  }
  validates :discount, numericality: { 
    less_than_or_equal_to: 100,
    greater_than_or_equal_to: 0
  }
end
</code></pre>
<p><strong>6. Inclusion/Exclusion:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  validates :status, inclusion: { 
    in: %w[pending processing shipped delivered cancelled],
    message: &quot;%{value} is not a valid status&quot;
  }
  
  validates :username, exclusion: { 
    in: %w[admin root superuser],
    message: &quot;%{value} is reserved&quot;
  }
end
</code></pre>
<p><strong>7. Confirmation:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
  
  validates :password, confirmation: true
end

# Form must include:
# email
# email_confirmation (virtual attribute)
# password
# password_confirmation (virtual attribute)
</code></pre>
<p><strong>8. Acceptance:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :terms_of_service, acceptance: true
  validates :privacy_policy, acceptance: { accept: [&#39;yes&#39;, &#39;1&#39;] }
end

# For checkboxes in forms
</code></pre>
<hr>
<h3>Conditional Validations</h3>
<p><strong>Using :if and :unless:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  validates :shipping_address, presence: true, if: :requires_shipping?
  validates :billing_address, presence: true, unless: :same_as_shipping?
  
  # With proc
  validates :coupon_code, presence: true, if: -&gt; { total &gt; 100 }
  
  # With method name
  validates :tracking_number, presence: true, if: :shipped?
  
  private
  
  def requires_shipping?
    product_type == &#39;physical&#39;
  end
  
  def same_as_shipping?
    use_shipping_for_billing?
  end
  
  def shipped?
    status == &#39;shipped&#39;
  end
end
</code></pre>
<p><strong>Multiple conditions:</strong></p>
<pre><code class="language-ruby">class Invoice &lt; ApplicationRecord
  validates :paid_at, presence: true, if: [:paid?, :finalized?]
  validates :notes, presence: true, unless: [:draft?, :cancelled?]
end
</code></pre>
<hr>
<h3>Custom Validations</h3>
<p><strong>Method-based:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validate :email_must_be_company_domain
  validate :password_complexity
  
  private
  
  def email_must_be_company_domain
    unless email.present? &amp;&amp; email.end_with?(&#39;@company.com&#39;)
      errors.add(:email, &quot;must be a company email address&quot;)
    end
  end
  
  def password_complexity
    return unless password.present?
    
    unless password.match(/[A-Z]/) &amp;&amp; password.match(/[a-z]/) &amp;&amp; password.match(/\d/)
      errors.add(:password, &quot;must include uppercase, lowercase, and number&quot;)
    end
  end
end
</code></pre>
<p><strong>Validator class:</strong></p>
<pre><code class="language-ruby">class EmailValidator &lt; ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i
      record.errors.add(attribute, options[:message] || &quot;is not a valid email&quot;)
    end
  end
end

class User &lt; ApplicationRecord
  validates :email, email: true
  validates :alternate_email, email: { message: &quot;must be valid&quot; }
end
</code></pre>
<p><strong>Reusable validator:</strong></p>
<pre><code class="language-ruby">class PhoneNumberValidator &lt; ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    return if value.blank?
    
    normalized = value.gsub(/\D/, &#39;&#39;)
    
    unless normalized.length == 10
      record.errors.add(attribute, &quot;must be 10 digits&quot;)
    end
  end
end

class User &lt; ApplicationRecord
  validates :phone, phone_number: true
end
</code></pre>
<hr>
<h3>Validation Contexts</h3>
<p><strong>Different validations for different actions:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :password, presence: true, on: :create
  validates :password, length: { minimum: 8 }, on: :create
  validates :current_password, presence: true, on: :update
end

# Usage:
user = User.new(email: &#39;test@example.com&#39;)
user.save  # Requires password

user = User.find(1)
user.name = &quot;New Name&quot;
user.save  # Doesn&#39;t require password
</code></pre>
<p><strong>Custom contexts:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email, presence: true
  validates :payment_method, presence: true, on: :purchase
  validates :shipping_address, presence: true, on: :purchase
end

# Usage:
user.valid?(:purchase)  # Checks email, payment_method, shipping_address
user.save(context: :purchase)  # Runs purchase validations
</code></pre>
<hr>
<h3>Skipping Validations</h3>
<p><strong>When and how:</strong></p>
<pre><code class="language-ruby"># Skip validations (use cautiously!)
user.save(validate: false)

# Update without validations
user.update_attribute(:name, &quot;New Name&quot;)  # Deprecated
user.update_column(:name, &quot;New Name&quot;)     # Recommended

# Update multiple columns
user.update_columns(name: &quot;New&quot;, email: &quot;new@example.com&quot;)

# Increment/decrement
post.increment!(:views_count)  # Skips validations

# Touch
user.touch(:last_seen_at)  # Skips validations
</code></pre>
<p><strong>When to skip validations:</strong></p>
<pre><code class="language-ruby"># Data migrations
User.find_each do |user|
  user.update_column(:migrated, true)
end

# System updates
post.update_column(:last_viewed_at, Time.current)

# Counter cache updates (automatic)
# Background processing of stale data
</code></pre>
<hr>
<h3>Error Handling</h3>
<p><strong>Checking errors:</strong></p>
<pre><code class="language-ruby">user = User.new(email: &quot;invalid&quot;)
user.save

# Check if valid
user.valid?  # =&gt; false
user.invalid?  # =&gt; true

# Get all errors
user.errors.full_messages
# =&gt; [&quot;Email is invalid&quot;, &quot;Password can&#39;t be blank&quot;]

# Get errors for specific field
user.errors[:email]
# =&gt; [&quot;is invalid&quot;]

# Check if field has errors
user.errors[:email].any?  # =&gt; true

# Get error count
user.errors.count  # =&gt; 2

# Clear errors
user.errors.clear
</code></pre>
<p><strong>Displaying errors in views:</strong></p>
<pre><code class="language-erb">&lt;% if @user.errors.any? %&gt;
  &lt;div class=&quot;error-messages&quot;&gt;
    &lt;h3&gt;&lt;%= pluralize(@user.errors.count, &quot;error&quot;) %&gt; prohibited this user from being saved:&lt;/h3&gt;
    &lt;ul&gt;
      &lt;% @user.errors.full_messages.each do |message| %&gt;
        &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;
      &lt;% end %&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;% end %&gt;

&lt;!-- Field-specific errors --&gt;
&lt;%= form_with model: @user do |f| %&gt;
  &lt;div class=&quot;field&quot;&gt;
    &lt;%= f.label :email %&gt;
    &lt;%= f.text_field :email %&gt;
    &lt;% if @user.errors[:email].any? %&gt;
      &lt;span class=&quot;error&quot;&gt;&lt;%= @user.errors[:email].join(&#39;, &#39;) %&gt;&lt;/span&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Database Constraints vs Validations</h3>
<p><strong>Use both for data integrity:</strong></p>
<pre><code class="language-ruby">class AddConstraints &lt; ActiveRecord::Migration[7.0]
  def change
    # Database constraint
    change_column_null :users, :email, false
    add_index :users, :email, unique: true
  end
end

class User &lt; ApplicationRecord
  # Application validation (better UX)
  validates :email, presence: true, uniqueness: true
end

# Why both?
# - Validations: Better error messages, user-friendly
# - Constraints: Last line of defense, handle race conditions
</code></pre>
<hr>
<h3>Validation Helpers</h3>
<p><strong>Built-in helpers:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Multiple validations on one attribute
  validates :email,
    presence: true,
    uniqueness: true,
    format: { with: URI::MailTo::EMAIL_REGEXP }
  
  # Allow blank (different from allow_nil)
  validates :middle_name, length: { maximum: 50 }, allow_blank: true
  
  # Allow nil
  validates :age, numericality: true, allow_nil: true
  
  # Strict validation (raises exception)
  validates :email, presence: true, strict: true
  # Raises ActiveModel::StrictValidationFailed
end
</code></pre>
<hr>
<h3>Testing Validations</h3>
<pre><code class="language-ruby"># spec/models/user_spec.rb
RSpec.describe User, type: :model do
  describe &#39;validations&#39; do
    it { should validate_presence_of(:email) }
    it { should validate_uniqueness_of(:email).case_insensitive }
    it { should validate_length_of(:password).is_at_least(8) }
    
    it &#39;validates email format&#39; do
      user = User.new(email: &#39;invalid&#39;)
      expect(user).to be_invalid
      expect(user.errors[:email]).to include(&#39;is invalid&#39;)
    end
    
    it &#39;is valid with valid attributes&#39; do
      user = User.new(
        email: &#39;test@example.com&#39;,
        password: &#39;Password123&#39;,
        name: &#39;Test User&#39;
      )
      expect(user).to be_valid
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Validations</strong> ensure data integrity</li>
<li><strong>Run automatically</strong> on save/create/update</li>
<li><strong>Return false</strong> if invalid</li>
<li><strong>Populate errors</strong> object</li>
<li><strong>Common validations</strong> built-in</li>
<li><strong>Custom validations</strong> possible</li>
<li><strong>Conditional</strong> with :if/:unless</li>
<li><strong>Skip</strong> with validate: false (cautiously)</li>
<li><strong>Database constraints</strong> recommended too</li>
<li><strong>Test</strong> all validations</li>
</ol>
<hr>
<h2>Question 106: What is the difference between <code>validate</code> vs <code>validates</code>?</h2>
<h3>Answer</h3>
<p><strong><code>validates</code></strong> is a helper method for built-in validators (presence, format, length, etc.). <strong><code>validate</code></strong> is for custom validation methods you write yourself.</p>
<hr>
<h3><code>validates</code> - Built-in Validators</h3>
<p><strong>For standard validations:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # validates - uses built-in validators
  validates :email, presence: true
  validates :name, length: { minimum: 2 }
  validates :age, numericality: { greater_than: 0 }
  validates :username, uniqueness: true
  validates :password, confirmation: true
  validates :terms, acceptance: true
  validates :role, inclusion: { in: %w[admin user guest] }
end

# Syntax:
# validates attribute_name, validator_name: options
</code></pre>
<p><strong>Multiple validators:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email,
    presence: true,
    uniqueness: { case_sensitive: false },
    format: { with: URI::MailTo::EMAIL_REGEXP },
    length: { maximum: 255 }
end
</code></pre>
<hr>
<h3><code>validate</code> - Custom Validation Methods</h3>
<p><strong>For custom logic:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # validate - calls custom method
  validate :email_domain_must_be_allowed
  validate :password_complexity
  validate :age_must_be_reasonable
  
  private
  
  def email_domain_must_be_allowed
    return unless email.present?
    
    domain = email.split(&#39;@&#39;).last
    allowed_domains = %w[example.com company.com]
    
    unless allowed_domains.include?(domain)
      errors.add(:email, &quot;must be from an allowed domain&quot;)
    end
  end
  
  def password_complexity
    return unless password.present?
    
    unless password.match?(/[A-Z]/)
      errors.add(:password, &quot;must contain at least one uppercase letter&quot;)
    end
    
    unless password.match?(/[a-z]/)
      errors.add(:password, &quot;must contain at least one lowercase letter&quot;)
    end
    
    unless password.match?(/\d/)
      errors.add(:password, &quot;must contain at least one number&quot;)
    end
  end
  
  def age_must_be_reasonable
    return unless age.present?
    
    unless age.between?(13, 120)
      errors.add(:age, &quot;must be between 13 and 120&quot;)
    end
  end
end

# Syntax:
# validate :method_name
</code></pre>
<hr>
<h3>Comparison</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>validates</code></th>
<th><code>validate</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Use case</strong></td>
<td>Built-in validators</td>
<td>Custom logic</td>
</tr>
<tr>
<td><strong>Syntax</strong></td>
<td><code>validates :attr, type: true</code></td>
<td><code>validate :method</code></td>
</tr>
<tr>
<td><strong>Examples</strong></td>
<td>presence, format, length</td>
<td>Custom business rules</td>
</tr>
<tr>
<td><strong>Multiple</strong></td>
<td>Multiple validators at once</td>
<td>One method per validate</td>
</tr>
<tr>
<td><strong>Reusable</strong></td>
<td>Across models easily</td>
<td>Per model</td>
</tr>
</tbody></table>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use <code>validates</code> when:</strong></p>
<p>✅ <strong>Standard validations sufficient</strong></p>
<pre><code class="language-ruby">validates :email, presence: true, format: { with: /.../ }
</code></pre>
<p>✅ <strong>Built-in validators available</strong></p>
<pre><code class="language-ruby">validates :price, numericality: { greater_than: 0 }
validates :status, inclusion: { in: %w[active inactive] }
</code></pre>
<p><strong>Use <code>validate</code> when:</strong></p>
<p>✅ <strong>Complex business logic</strong></p>
<pre><code class="language-ruby">validate :inventory_available_for_order

def inventory_available_for_order
  order_items.each do |item|
    if item.quantity &gt; item.product.stock
      errors.add(:base, &quot;#{item.product.name} is out of stock&quot;)
    end
  end
end
</code></pre>
<p>✅ <strong>Cross-attribute validation</strong></p>
<pre><code class="language-ruby">validate :end_date_after_start_date

def end_date_after_start_date
  return unless start_date &amp;&amp; end_date
  
  if end_date &lt; start_date
    errors.add(:end_date, &quot;must be after start date&quot;)
  end
end
</code></pre>
<p>✅ <strong>Conditional complex logic</strong></p>
<pre><code class="language-ruby">validate :credit_card_valid, if: :paying_with_card?

def credit_card_valid
  unless CreditCardValidator.valid?(card_number)
    errors.add(:card_number, &quot;is invalid&quot;)
  end
end
</code></pre>
<hr>
<h3>Combining Both</h3>
<p><strong>Common pattern:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  # Built-in validations
  validates :customer_email, presence: true, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :total, numericality: { greater_than: 0 }
  validates :status, inclusion: { in: %w[pending paid shipped delivered] }
  
  # Custom validations
  validate :items_in_stock
  validate :payment_method_valid, if: :paid?
  validate :shipping_address_complete, unless: :digital_product?
  
  private
  
  def items_in_stock
    order_items.each do |item|
      unless item.product.in_stock?(item.quantity)
        errors.add(:base, &quot;#{item.product.name} is not available&quot;)
      end
    end
  end
  
  def payment_method_valid
    unless PaymentProcessor.valid?(payment_method)
      errors.add(:payment_method, &quot;is invalid&quot;)
    end
  end
  
  def shipping_address_complete
    if shipping_address.blank? || shipping_address.incomplete?
      errors.add(:shipping_address, &quot;is incomplete&quot;)
    end
  end
end
</code></pre>
<hr>
<h3>Custom Validator Class (Alternative)</h3>
<p><strong>Reusable across models:</strong></p>
<pre><code class="language-ruby"># app/validators/email_domain_validator.rb
class EmailDomainValidator &lt; ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    return if value.blank?
    
    domain = value.split(&#39;@&#39;).last
    allowed_domains = options[:domains] || []
    
    unless allowed_domains.include?(domain)
      record.errors.add(attribute, &quot;must be from: #{allowed_domains.join(&#39;, &#39;)}&quot;)
    end
  end
end

# Now use with validates (not validate!)
class User &lt; ApplicationRecord
  validates :email, email_domain: { domains: %w[company.com example.com] }
end

class Admin &lt; ApplicationRecord
  validates :email, email_domain: { domains: %w[admin.company.com] }
end

# Reusable and cleaner!
</code></pre>
<hr>
<h3>validate with Symbol vs Block</h3>
<p><strong>Symbol (common):</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validate :custom_logic
  
  private
  
  def custom_logic
    # validation code
  end
end
</code></pre>
<p><strong>Block (rare):</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validate do
    if email.present? &amp;&amp; email.split(&#39;@&#39;).last == &#39;blocked.com&#39;
      errors.add(:email, &quot;domain is blocked&quot;)
    end
  end
end

# Inline validation - use for simple cases only
</code></pre>
<hr>
<h3>Practical Examples</h3>
<p><strong>Example 1: Date range validation</strong></p>
<pre><code class="language-ruby">class Event &lt; ApplicationRecord
  # Built-in validations
  validates :title, presence: true, length: { maximum: 100 }
  validates :start_date, presence: true
  validates :end_date, presence: true
  
  # Custom validation
  validate :end_date_after_start_date
  validate :event_not_in_past, on: :create
  
  private
  
  def end_date_after_start_date
    return unless start_date &amp;&amp; end_date
    
    if end_date &lt;= start_date
      errors.add(:end_date, &quot;must be after start date&quot;)
    end
  end
  
  def event_not_in_past
    if start_date &amp;&amp; start_date &lt; Date.today
      errors.add(:start_date, &quot;cannot be in the past&quot;)
    end
  end
end
</code></pre>
<p><strong>Example 2: Password validation</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Built-in
  validates :password,
    presence: true,
    length: { minimum: 8, maximum: 128 },
    confirmation: true,
    on: :create
  
  # Custom
  validate :password_complexity, if: -&gt; { password.present? }
  
  private
  
  def password_complexity
    complexity_checks = {
      &#39;uppercase letter&#39; =&gt; /[A-Z]/,
      &#39;lowercase letter&#39; =&gt; /[a-z]/,
      &#39;number&#39; =&gt; /\d/,
      &#39;special character&#39; =&gt; /[!@#$%^&amp;*]/
    }
    
    complexity_checks.each do |name, regex|
      unless password.match?(regex)
        errors.add(:password, &quot;must include at least one #{name}&quot;)
      end
    end
    
    if password.match?(/password/i)
      errors.add(:password, &quot;cannot contain the word &#39;password&#39;&quot;)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong><code>validates</code></strong> for built-in validators</li>
<li><strong><code>validate</code></strong> for custom methods</li>
<li><strong><code>validates</code></strong> more concise</li>
<li><strong><code>validate</code></strong> more flexible</li>
<li><strong>Both</strong> can coexist</li>
<li><strong>Custom validator class</strong> for reusability</li>
<li><strong><code>validates</code></strong> handles common cases</li>
<li><strong><code>validate</code></strong> for complex logic</li>
<li><strong>Choose</strong> based on complexity</li>
<li><strong>Test</strong> both types thoroughly</li>
</ol>
<hr>
<h2>Question 107: Explain ActiveRecord callbacks and when they are useful</h2>
<h3>Answer</h3>
<p><strong>ActiveRecord callbacks</strong> are hooks that run automatically at specific points in an object&#39;s lifecycle (before/after create, update, save, destroy). They&#39;re useful for side effects, data normalization, and maintaining data consistency.</p>
<hr>
<h3>Available Callbacks</h3>
<p><strong>Creating an object:</strong></p>
<pre><code class="language-ruby"># Order:
before_validation
after_validation
before_save
around_save
before_create
around_create
after_create
after_save
after_commit / after_rollback
</code></pre>
<p><strong>Updating an object:</strong></p>
<pre><code class="language-ruby"># Order:
before_validation
after_validation
before_save
around_save
before_update
around_update
after_update
after_save
after_commit / after_rollback
</code></pre>
<p><strong>Destroying an object:</strong></p>
<pre><code class="language-ruby"># Order:
before_destroy
around_destroy
after_destroy
after_commit / after_rollback
</code></pre>
<hr>
<h3>Basic Usage</h3>
<p><strong>Defining callbacks:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Method name
  before_save :normalize_email
  after_create :send_welcome_email
  
  # Block
  before_validation do
    self.email = email.downcase if email.present?
  end
  
  # Lambda
  after_commit -&gt; { NotificationService.notify_new_user(self) }, on: :create
  
  private
  
  def normalize_email
    self.email = email.strip.downcase if email.present?
  end
  
  def send_welcome_email
    UserMailer.welcome(self).deliver_later
  end
end
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong>1. Data Normalization:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_validation :normalize_phone_number
  before_save :downcase_email
  
  private
  
  def normalize_phone_number
    return unless phone.present?
    
    # Remove all non-digits
    self.phone = phone.gsub(/\D/, &#39;&#39;)
  end
  
  def downcase_email
    self.email = email.downcase if email.present?
  end
end
</code></pre>
<p><strong>2. Setting Default Values:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  before_create :set_order_number
  before_create :set_defaults
  
  private
  
  def set_order_number
    self.order_number = &quot;ORD-#{SecureRandom.hex(4).upcase}&quot;
  end
  
  def set_defaults
    self.status ||= &#39;pending&#39;
    self.currency ||= &#39;USD&#39;
  end
end
</code></pre>
<p><strong>3. Sending Notifications:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  after_create :notify_followers
  after_destroy :notify_deletion
  
  private
  
  def notify_followers
    user.followers.each do |follower|
      NotificationMailer.new_post(follower, self).deliver_later
    end
  end
  
  def notify_deletion
    Rails.logger.info &quot;Post #{id} was deleted at #{Time.current}&quot;
  end
end
</code></pre>
<p><strong>4. Maintaining Related Records:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  has_many :order_items
  
  before_save :calculate_total
  after_save :update_inventory
  
  private
  
  def calculate_total
    self.total = order_items.sum { |item| item.quantity * item.price }
  end
  
  def update_inventory
    order_items.each do |item|
      item.product.decrement!(:stock, item.quantity)
    end
  end
end
</code></pre>
<p><strong>5. Cache Management:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  after_save :clear_cache
  after_destroy :clear_cache
  
  private
  
  def clear_cache
    Rails.cache.delete(&quot;post_#{id}&quot;)
    Rails.cache.delete(&quot;user_#{user_id}_posts&quot;)
  end
end
</code></pre>
<hr>
<h3>Conditional Callbacks</h3>
<p><strong>Using :if and :unless:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_save :encrypt_password, if: :password_changed?
  after_create :send_welcome_email, unless: :admin?
  
  # Multiple conditions
  after_save :sync_to_crm, if: [:email_changed?, :active?]
  
  # Proc
  before_destroy :check_dependencies, 
                 if: -&gt; { orders.exists? }
  
  private
  
  def encrypt_password
    self.encrypted_password = BCrypt::Password.create(password)
  end
  
  def send_welcome_email
    UserMailer.welcome(self).deliver_later
  end
  
  def sync_to_crm
    CrmSyncJob.perform_later(id)
  end
  
  def check_dependencies
    throw(:abort) if orders.any?
  end
end
</code></pre>
<hr>
<h3>Skipping Callbacks</h3>
<p><strong>When necessary:</strong></p>
<pre><code class="language-ruby"># Skip all callbacks
user.save(validate: false)
user.update_column(:name, &quot;New&quot;)  # Skips callbacks and validations
user.update_columns(name: &quot;New&quot;, email: &quot;new@example.com&quot;)

# Increment without callbacks
post.increment!(:views)

# Touch without callbacks
user.touch

# Delete without callbacks (not destroy)
user.delete  # No callbacks
User.delete_all  # No callbacks

# destroy vs delete
user.destroy  # Runs callbacks
user.delete   # No callbacks
</code></pre>
<hr>
<h3>Halting Callback Chain</h3>
<p><strong>throw :abort:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  before_save :check_inventory
  before_destroy :check_cancellable
  
  private
  
  def check_inventory
    if order_items.any? { |item| item.quantity &gt; item.product.stock }
      errors.add(:base, &quot;Insufficient inventory&quot;)
      throw(:abort)  # Stops save
    end
  end
  
  def check_cancellable
    unless cancellable?
      errors.add(:base, &quot;Cannot delete shipped order&quot;)
      throw(:abort)  # Stops destroy
    end
  end
end

# Usage:
order.save  # =&gt; false (if inventory check fails)
order.errors.full_messages  # =&gt; [&quot;Insufficient inventory&quot;]
</code></pre>
<hr>
<h3>after_commit vs after_save</h3>
<p><strong>Important difference:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # after_save runs INSIDE transaction
  after_save :log_change
  
  # after_commit runs AFTER transaction commits
  after_commit :send_notification
  
  private
  
  def log_change
    # Runs in transaction
    # If this fails, save rolls back
    AuditLog.create!(user_id: id, action: &#39;updated&#39;)
  end
  
  def send_notification
    # Runs after transaction commits
    # If this fails, save still succeeds
    UserMailer.update_notification(self).deliver_later
    
    # Safe for:
    # - External API calls
    # - Background jobs
    # - Email sending
    # - Notifications
  end
end
</code></pre>
<p><strong>Specify when:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  # Only on create
  after_commit :notify_followers, on: :create
  
  # Only on update
  after_commit :sync_to_search, on: :update
  
  # Only on destroy
  after_commit :cleanup_files, on: :destroy
  
  # Multiple
  after_commit :log_change, on: [:create, :update]
end
</code></pre>
<hr>
<h3>around_* Callbacks</h3>
<p><strong>Wrapping actions:</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  around_save :log_execution_time
  around_destroy :notify_before_and_after
  
  private
  
  def log_execution_time
    start_time = Time.current
    
    yield  # Executes save
    
    duration = Time.current - start_time
    Rails.logger.info &quot;Post save took #{duration}ms&quot;
  end
  
  def notify_before_and_after
    Rails.logger.info &quot;About to destroy post #{id}&quot;
    
    yield  # Executes destroy
    
    Rails.logger.info &quot;Post #{id} destroyed successfully&quot;
  end
end
</code></pre>
<hr>
<h3>Callback Objects</h3>
<p><strong>Extract to separate class:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/encryption.rb
class Encryption
  def self.before_save(record)
    record.encrypted_field = encrypt(record.field) if record.field_changed?
  end
  
  def self.encrypt(value)
    # Encryption logic
  end
end

class User &lt; ApplicationRecord
  before_save Encryption
end

# Or as instance:
class AuditLogger
  def after_create(record)
    AuditLog.create!(
      record_type: record.class.name,
      record_id: record.id,
      action: &#39;created&#39;
    )
  end
  
  def after_update(record)
    AuditLog.create!(
      record_type: record.class.name,
      record_id: record.id,
      action: &#39;updated&#39;,
      changes: record.saved_changes
    )
  end
end

class Post &lt; ApplicationRecord
  after_create AuditLogger.new
  after_update AuditLogger.new
end
</code></pre>
<hr>
<h3>Concerns for Reusability</h3>
<pre><code class="language-ruby"># app/models/concerns/searchable.rb
module Searchable
  extend ActiveSupport::Concern
  
  included do
    after_commit :update_search_index, on: [:create, :update]
    after_commit :remove_from_search_index, on: :destroy
  end
  
  private
  
  def update_search_index
    SearchIndexJob.perform_later(self.class.name, id)
  end
  
  def remove_from_search_index
    SearchIndexJob.perform_later(self.class.name, id, :delete)
  end
end

class Post &lt; ApplicationRecord
  include Searchable
end

class Product &lt; ApplicationRecord
  include Searchable
end
</code></pre>
<hr>
<h3>Testing Callbacks</h3>
<pre><code class="language-ruby">RSpec.describe User do
  describe &#39;callbacks&#39; do
    describe &#39;before_save&#39; do
      it &#39;normalizes email&#39; do
        user = User.create(email: &#39;  TEST@EXAMPLE.COM  &#39;)
        expect(user.reload.email).to eq(&#39;test@example.com&#39;)
      end
    end
    
    describe &#39;after_create&#39; do
      it &#39;sends welcome email&#39; do
        expect {
          User.create(email: &#39;test@example.com&#39;)
        }.to have_enqueued_job(ActionMailer::MailDeliveryJob)
      end
    end
    
    describe &#39;before_destroy&#39; do
      it &#39;prevents deletion if has orders&#39; do
        user = create(:user)
        create(:order, user: user)
        
        expect { user.destroy }.not_to change { User.count }
        expect(user.errors[:base]).to include(&quot;Cannot delete user with orders&quot;)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Common Pitfalls</h3>
<p><strong>❌ Don&#39;t call callbacks manually:</strong></p>
<pre><code class="language-ruby"># BAD
user.send_welcome_email

# GOOD
# Let callbacks handle it automatically
user.save
</code></pre>
<p><strong>❌ Don&#39;t do too much in callbacks:</strong></p>
<pre><code class="language-ruby"># BAD - slow callback blocks save
after_save :generate_report  # Takes 10 seconds

# GOOD - use background job
after_commit :schedule_report_generation

def schedule_report_generation
  ReportGenerationJob.perform_later(id)
end
</code></pre>
<p><strong>❌ Don&#39;t use after_save for side effects:</strong></p>
<pre><code class="language-ruby"># BAD - in transaction, might rollback
after_save :send_email

# GOOD - after transaction commits
after_commit :send_email, on: [:create, :update]
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Callbacks</strong> run at lifecycle points</li>
<li><strong>before/after</strong> most common</li>
<li><strong>after_commit</strong> for side effects</li>
<li><strong>throw :abort</strong> halts chain</li>
<li><strong>Conditional</strong> with :if/:unless</li>
<li><strong>Extract</strong> to concerns for reuse</li>
<li><strong>Test</strong> callback behavior</li>
<li><strong>Don&#39;t overuse</strong> - keep simple</li>
<li><strong>Background jobs</strong> for slow operations</li>
<li><strong>Skip</strong> when necessary</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 108: What is the difference between Callback vs Observer vs Filter?</h2>
<h3>Answer</h3>
<p><strong>Callbacks</strong> are model lifecycle hooks. <strong>Observers</strong> watch models from outside (deprecated). <strong>Filters</strong> are controller-level hooks for request processing. Each serves different purposes in different layers.</p>
<hr>
<h3>Callbacks (Model Layer)</h3>
<p><strong>Model lifecycle hooks:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Callbacks: Inside the model
  before_save :normalize_email
  after_create :send_welcome_email
  after_commit :update_search_index
  
  private
  
  def normalize_email
    self.email = email.downcase
  end
  
  def send_welcome_email
    UserMailer.welcome(self).deliver_later
  end
  
  def update_search_index
    SearchIndexJob.perform_later(id)
  end
end

# When:
# - Data transformation
# - Related record updates
# - Setting defaults
# - Cache invalidation

# Pros:
# ✅ Colocated with model
# ✅ Always run
# ✅ Part of model logic

# Cons:
# ❌ Can make models fat
# ❌ Hard to skip
# ❌ Implicit behavior
</code></pre>
<hr>
<h3>Observers (Deprecated)</h3>
<p><strong>External model watchers:</strong></p>
<pre><code class="language-ruby"># app/models/user_observer.rb
class UserObserver &lt; ActiveRecord::Observer
  def after_create(user)
    UserMailer.welcome(user).deliver_later
    AuditLog.create(action: &#39;user_created&#39;, user_id: user.id)
  end
  
  def after_update(user)
    if user.saved_change_to_email?
      UserMailer.email_changed(user).deliver_later
    end
  end
  
  def after_destroy(user)
    cleanup_user_data(user)
  end
end

# config/application.rb
config.active_record.observers = :user_observer

# When:
# - Separation of concerns
# - Cross-cutting concerns (audit, logging)
# - Keep models thin

# Status: DEPRECATED in Rails 4.0
# Reason: Hard to test, implicit, order unclear

# Modern alternative: Service objects or callbacks
</code></pre>
<p><strong>Why observers were removed:</strong></p>
<pre><code class="language-ruby"># Problems with observers:
# 1. Hidden - not obvious they exist
# 2. Order unclear - which runs first?
# 3. Hard to test - global state
# 4. Tight coupling - knows too much about model

# Modern approach:
class UserCreationService
  def create(attributes)
    User.transaction do
      user = User.create!(attributes)
      UserMailer.welcome(user).deliver_later
      AuditLog.create(action: &#39;user_created&#39;, user_id: user.id)
      user
    end
  end
end
</code></pre>
<hr>
<h3>Filters (Controller Layer)</h3>
<p><strong>Request processing hooks:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  # Before filters
  before_action :authenticate_user!
  before_action :set_post, only: [:show, :edit, :update, :destroy]
  before_action :authorize_post, only: [:edit, :update, :destroy]
  
  # After filters
  after_action :log_action, only: [:create, :update, :destroy]
  
  # Around filters
  around_action :catch_errors
  
  def show
    # Action code
  end
  
  def create
    @post = current_user.posts.build(post_params)
    if @post.save
      redirect_to @post
    else
      render :new
    end
  end
  
  private
  
  def set_post
    @post = Post.find(params[:id])
  end
  
  def authorize_post
    unless @post.user == current_user
      redirect_to root_path, alert: &quot;Not authorized&quot;
    end
  end
  
  def log_action
    Rails.logger.info &quot;#{current_user.email} #{action_name}d post #{@post.id}&quot;
  end
  
  def catch_errors
    yield
  rescue StandardError =&gt; e
    Rails.logger.error &quot;Error: #{e.message}&quot;
    redirect_to root_path, alert: &quot;Something went wrong&quot;
  end
end

# When:
# - Authentication
# - Authorization
# - Setting instance variables
# - Logging requests
# - Error handling

# Pros:
# ✅ Request-specific
# ✅ Easy to skip
# ✅ Clear execution order
# ✅ Controller-level logic

# Cons:
# ❌ Only for controllers
# ❌ Can make controllers complex
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Callbacks</th>
<th>Observers</th>
<th>Filters</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Layer</strong></td>
<td>Model</td>
<td>Model (external)</td>
<td>Controller</td>
</tr>
<tr>
<td><strong>Scope</strong></td>
<td>Single model</td>
<td>Multiple models</td>
<td>Request processing</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>Active</td>
<td>Deprecated</td>
<td>Active</td>
</tr>
<tr>
<td><strong>When runs</strong></td>
<td>Model lifecycle</td>
<td>Model lifecycle</td>
<td>Request lifecycle</td>
</tr>
<tr>
<td><strong>Location</strong></td>
<td>Inside model</td>
<td>Separate file</td>
<td>Inside controller</td>
</tr>
<tr>
<td><strong>Use for</strong></td>
<td>Data logic</td>
<td>Cross-cutting (was)</td>
<td>Request logic</td>
</tr>
<tr>
<td><strong>Skippable</strong></td>
<td>Hard</td>
<td>N/A</td>
<td>Easy (skip_before_action)</td>
</tr>
<tr>
<td><strong>Testing</strong></td>
<td>Test model</td>
<td>Hard</td>
<td>Test controller</td>
</tr>
</tbody></table>
<hr>
<h3>Real-World Examples</h3>
<p><strong>Callbacks - Model Logic:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  # Data integrity
  before_save :calculate_total
  
  # Related records
  after_save :update_inventory
  
  # Cache
  after_commit :clear_cache
  
  private
  
  def calculate_total
    self.total = order_items.sum { |i| i.quantity * i.price }
  end
  
  def update_inventory
    order_items.each do |item|
      item.product.decrement!(:stock, item.quantity)
    end
  end
  
  def clear_cache
    Rails.cache.delete(&quot;user_#{user_id}_orders&quot;)
  end
end
</code></pre>
<p><strong>Observers - Cross-Cutting (deprecated, use service objects):</strong></p>
<pre><code class="language-ruby"># Old way (deprecated):
class AuditObserver &lt; ActiveRecord::Observer
  observe :user, :post, :comment
  
  def after_create(record)
    AuditLog.create(
      action: &#39;created&#39;,
      record_type: record.class.name,
      record_id: record.id
    )
  end
end

# New way (service objects):
class AuditService
  def self.log_creation(record)
    AuditLog.create(
      action: &#39;created&#39;,
      record_type: record.class.name,
      record_id: record.id
    )
  end
end

class User &lt; ApplicationRecord
  after_create -&gt; { AuditService.log_creation(self) }
end
</code></pre>
<p><strong>Filters - Request Logic:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  # Authentication
  before_action :authenticate_user!
  
  # Performance monitoring
  around_action :monitor_performance
  
  private
  
  def monitor_performance
    start_time = Time.current
    
    yield
    
    duration = ((Time.current - start_time) * 1000).round(2)
    Rails.logger.info &quot;Action: #{action_name}, Duration: #{duration}ms&quot;
  end
end

class PostsController &lt; ApplicationController
  # Authorization
  before_action :set_post, only: [:show, :edit, :update]
  before_action :authorize_owner, only: [:edit, :update]
  
  # Logging
  after_action :log_view, only: [:show]
  
  private
  
  def set_post
    @post = Post.find(params[:id])
  end
  
  def authorize_owner
    unless @post.user == current_user
      redirect_to root_path, alert: &quot;Not authorized&quot;
    end
  end
  
  def log_view
    PostView.create(post: @post, user: current_user)
  end
end
</code></pre>
<hr>
<h3>Modern Alternatives to Observers</h3>
<p><strong>1. Service Objects:</strong></p>
<pre><code class="language-ruby">class UserRegistrationService
  def initialize(user)
    @user = user
  end
  
  def register
    User.transaction do
      @user.save!
      send_welcome_email
      create_default_settings
      log_registration
    end
  end
  
  private
  
  def send_welcome_email
    UserMailer.welcome(@user).deliver_later
  end
  
  def create_default_settings
    @user.create_settings(theme: &#39;light&#39;, notifications: true)
  end
  
  def log_registration
    AuditLog.create(action: &#39;user_registered&#39;, user_id: @user.id)
  end
end

# Usage:
user = User.new(user_params)
UserRegistrationService.new(user).register
</code></pre>
<p><strong>2. Pub/Sub Pattern:</strong></p>
<pre><code class="language-ruby"># Using ActiveSupport::Notifications
# Publisher (Model):
class Order &lt; ApplicationRecord
  after_create do
    ActiveSupport::Notifications.instrument(&#39;order.created&#39;, order: self)
  end
end

# Subscribers:
ActiveSupport::Notifications.subscribe(&#39;order.created&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  order = event.payload[:order]
  
  # Send email
  OrderMailer.confirmation(order).deliver_later
end

ActiveSupport::Notifications.subscribe(&#39;order.created&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  order = event.payload[:order]
  
  # Update analytics
  AnalyticsService.track_order(order)
end

# Decoupled, testable, explicit
</code></pre>
<p><strong>3. Concerns:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/auditable.rb
module Auditable
  extend ActiveSupport::Concern
  
  included do
    after_create :log_creation
    after_update :log_update
    after_destroy :log_destruction
  end
  
  private
  
  def log_creation
    AuditLog.create(action: &#39;created&#39;, record: self)
  end
  
  def log_update
    AuditLog.create(action: &#39;updated&#39;, record: self, changes: saved_changes)
  end
  
  def log_destruction
    AuditLog.create(action: &#39;destroyed&#39;, record: self)
  end
end

# Usage:
class User &lt; ApplicationRecord
  include Auditable
end

class Post &lt; ApplicationRecord
  include Auditable
end
</code></pre>
<hr>
<h3>When to Use What</h3>
<p><strong>Use Callbacks when:</strong></p>
<ul>
<li>✅ Data normalization (downcase email)</li>
<li>✅ Setting defaults</li>
<li>✅ Simple side effects</li>
<li>✅ Related record updates</li>
</ul>
<p><strong>Use Service Objects when:</strong></p>
<ul>
<li>✅ Complex business logic</li>
<li>✅ Multiple models involved</li>
<li>✅ External API calls</li>
<li>✅ Need explicit control</li>
</ul>
<p><strong>Use Filters when:</strong></p>
<ul>
<li>✅ Authentication</li>
<li>✅ Authorization</li>
<li>✅ Request logging</li>
<li>✅ Setting controller instance variables</li>
</ul>
<p><strong>Don&#39;t use Observers:</strong></p>
<ul>
<li>❌ Deprecated</li>
<li>❌ Use service objects instead</li>
<li>❌ Or pub/sub pattern</li>
<li>❌ Or concerns</li>
</ul>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Callbacks</strong> - model lifecycle</li>
<li><strong>Observers</strong> - deprecated</li>
<li><strong>Filters</strong> - controller/request lifecycle</li>
<li><strong>Callbacks</strong> for data logic</li>
<li><strong>Filters</strong> for request logic</li>
<li><strong>Service objects</strong> replace observers</li>
<li><strong>Pub/sub</strong> for decoupling</li>
<li><strong>Concerns</strong> for reusability</li>
<li><strong>Choose</strong> based on layer</li>
<li><strong>Keep</strong> logic in right place</li>
</ol>
<hr>
<h2>Question 109: Explain Model lifecycle flow</h2>
<h3>Answer</h3>
<p>The <strong>model lifecycle</strong> is the sequence of events from object creation through destruction, with callbacks at each stage. Understanding this flow is crucial for proper callback placement.</p>
<hr>
<h3>Complete Lifecycle Diagram</h3>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                    Object Initialization                      │
│                    User.new / User.find                       │
└────────────────────────────┬──────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                    VALIDATION PHASE                          │
├─────────────────────────────────────────────────────────────┤
│  1. before_validation                                        │
│  2. Run validations                                          │
│  3. after_validation                                         │
└────────────────────────────┬──────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                    SAVING PHASE                              │
├─────────────────────────────────────────────────────────────┤
│  4. before_save                                              │
│  5. around_save (before yield)                               │
│  6. before_create (new) OR before_update (existing)          │
│  7. around_create/around_update (before yield)               │
│  8. *** DATABASE INSERT/UPDATE ***                           │
│  9. around_create/around_update (after yield)                │
│ 10. after_create (new) OR after_update (existing)            │
│ 11. around_save (after yield)                                │
│ 12. after_save                                               │
└────────────────────────────┬──────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────┐
│                    COMMIT PHASE                              │
├─────────────────────────────────────────────────────────────┤
│ 13. after_commit OR after_rollback                           │
└─────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────┐
│                    DESTROY PHASE                             │
├─────────────────────────────────────────────────────────────┤
│  1. before_destroy                                           │
│  2. around_destroy (before yield)                            │
│  3. *** DATABASE DELETE ***                                  │
│  4. around_destroy (after yield)                             │
│  5. after_destroy                                            │
│  6. after_commit OR after_rollback                           │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<hr>
<h3>Creating a New Record</h3>
<p><strong>Full flow for <code>User.create</code>:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_validation :normalize_email
  after_validation :log_validation
  
  before_save :set_defaults
  around_save :log_save_time
  
  before_create :generate_token
  around_create :log_creation
  
  after_create :send_welcome_email
  after_save :update_cache
  
  after_commit :sync_to_external_service, on: :create
  
  private
  
  def normalize_email
    puts &quot;1. before_validation&quot;
    self.email = email&amp;.downcase
  end
  
  def log_validation
    puts &quot;2. after_validation&quot;
  end
  
  def set_defaults
    puts &quot;3. before_save&quot;
    self.role ||= &#39;user&#39;
  end
  
  def log_save_time
    puts &quot;4. around_save (before yield)&quot;
    start = Time.current
    
    yield  # Database operation happens here
    
    puts &quot;5. around_save (after yield)&quot;
    duration = Time.current - start
    Rails.logger.info &quot;Save took #{duration}s&quot;
  end
  
  def generate_token
    puts &quot;6. before_create&quot;
    self.auth_token = SecureRandom.hex
  end
  
  def log_creation
    puts &quot;7. around_create (before yield)&quot;
    
    yield  # INSERT INTO database
    
    puts &quot;8. around_create (after yield)&quot;
  end
  
  def send_welcome_email
    puts &quot;9. after_create&quot;
    UserMailer.welcome(self).deliver_later
  end
  
  def update_cache
    puts &quot;10. after_save&quot;
    Rails.cache.write(&quot;user_#{id}&quot;, self)
  end
  
  def sync_to_external_service
    puts &quot;11. after_commit&quot;
    ExternalSyncJob.perform_later(id)
  end
end

# Execute:
User.create(email: &quot;TEST@EXAMPLE.COM&quot;, name: &quot;Alice&quot;)

# Output:
# 1. before_validation
# 2. after_validation
# 3. before_save
# 4. around_save (before yield)
# 6. before_create
# 7. around_create (before yield)
# [SQL] INSERT INTO users...
# 8. around_create (after yield)
# 5. around_save (after yield)
# 9. after_create
# 10. after_save
# 11. after_commit
</code></pre>
<hr>
<h3>Updating an Existing Record</h3>
<p><strong>Full flow for <code>user.update</code>:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_validation :normalize_email
  after_validation :log_validation
  
  before_save :log_changes
  before_update :track_modifications
  
  after_update :invalidate_cache
  after_save :log_save
  
  after_commit :notify_changes, on: :update
  
  private
  
  def normalize_email
    puts &quot;1. before_validation&quot;
    self.email = email&amp;.downcase
  end
  
  def log_validation
    puts &quot;2. after_validation&quot;
  end
  
  def log_changes
    puts &quot;3. before_save&quot;
    puts &quot;Changed: #{changes.keys}&quot; if changes.any?
  end
  
  def track_modifications
    puts &quot;4. before_update&quot;
    self.updated_by = Current.user
  end
  
  def invalidate_cache
    puts &quot;5. after_update&quot;
    Rails.cache.delete(&quot;user_#{id}&quot;)
  end
  
  def log_save
    puts &quot;6. after_save&quot;
    AuditLog.create(record: self, action: &#39;updated&#39;)
  end
  
  def notify_changes
    puts &quot;7. after_commit&quot;
    UserMailer.profile_updated(self).deliver_later if saved_change_to_email?
  end
end

# Execute:
user = User.find(1)
user.update(name: &quot;Bob&quot;)

# Output:
# 1. before_validation
# 2. after_validation
# 3. before_save
# 4. before_update
# [SQL] UPDATE users SET name = &#39;Bob&#39; WHERE id = 1
# 5. after_update
# 6. after_save
# 7. after_commit
</code></pre>
<hr>
<h3>Destroying a Record</h3>
<p><strong>Full flow for <code>user.destroy</code>:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_destroy :check_dependencies
  around_destroy :log_destruction
  after_destroy :cleanup_files
  after_commit :notify_deletion, on: :destroy
  
  private
  
  def check_dependencies
    puts &quot;1. before_destroy&quot;
    if orders.exists?
      errors.add(:base, &quot;Cannot delete user with orders&quot;)
      throw(:abort)  # Stops destruction
    end
  end
  
  def log_destruction
    puts &quot;2. around_destroy (before yield)&quot;
    
    yield  # DELETE FROM database
    
    puts &quot;3. around_destroy (after yield)&quot;
  end
  
  def cleanup_files
    puts &quot;4. after_destroy&quot;
    avatar.purge if avatar.attached?
  end
  
  def notify_deletion
    puts &quot;5. after_commit&quot;
    AdminMailer.user_deleted(id).deliver_later
  end
end

# Execute:
user.destroy

# Output:
# 1. before_destroy
# 2. around_destroy (before yield)
# [SQL] DELETE FROM users WHERE id = 1
# 3. around_destroy (after yield)
# 4. after_destroy
# 5. after_commit
</code></pre>
<hr>
<h3>Validation Flow Detail</h3>
<p><strong>What happens during validation:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  validates :email, presence: true, format: { with: /.../ }
  validates :age, numericality: { greater_than: 0 }
  
  validate :custom_validation
  
  before_validation :normalize_data
  after_validation :log_result
  
  private
  
  def normalize_data
    puts &quot;→ before_validation&quot;
    self.email = email&amp;.strip&amp;.downcase
  end
  
  def custom_validation
    puts &quot;→ Running custom validations&quot;
    errors.add(:base, &quot;Custom error&quot;) if some_condition?
  end
  
  def log_result
    puts &quot;→ after_validation&quot;
    puts &quot;Valid: #{errors.empty?}&quot;
  end
end

# Execute:
user = User.new(email: &quot; TEST@EXAMPLE.COM &quot;, age: -5)
user.valid?

# Output:
# → before_validation
# [Runs built-in validations: presence, format, numericality]
# → Running custom validations
# → after_validation
# Valid: false
</code></pre>
<hr>
<h3>Transaction Boundaries</h3>
<p><strong>Where callbacks run:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_save :callback1      # Inside transaction
  after_save :callback2       # Inside transaction
  after_commit :callback3     # Outside transaction
  after_rollback :callback4   # If transaction rolls back
end

# Visualization:
# BEGIN TRANSACTION
#   before_save
#   [SQL INSERT/UPDATE]
#   after_save
# COMMIT
#   after_commit (only if committed)
# OR
# ROLLBACK
#   after_rollback (only if rolled back)
</code></pre>
<p><strong>Example with rollback:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  after_save :charge_payment
  after_commit :send_confirmation
  after_rollback :refund_payment
  
  private
  
  def charge_payment
    puts &quot;Charging payment...&quot;
    PaymentService.charge(user, total)
  end
  
  def send_confirmation
    puts &quot;Sending confirmation email&quot;
    OrderMailer.confirmation(self).deliver_later
  end
  
  def refund_payment
    puts &quot;Rolling back, refunding payment&quot;
    PaymentService.refund(user, total)
  end
end

# If save succeeds:
order.save
# Output:
# Charging payment...
# Sending confirmation email

# If save fails:
Order.transaction do
  order.save!
  raise &quot;Error!&quot;
end
# Output:
# Charging payment...
# Rolling back, refunding payment
</code></pre>
<hr>
<h3>Halting the Lifecycle</h3>
<p><strong>Using throw :abort:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_save :check_something
  before_destroy :prevent_deletion
  
  private
  
  def check_something
    if invalid_condition?
      errors.add(:base, &quot;Cannot save&quot;)
      throw(:abort)  # Stops save, returns false
    end
  end
  
  def prevent_deletion
    if has_important_data?
      throw(:abort)  # Stops destroy, returns false
    end
  end
end

# Usage:
user.save  # =&gt; false (if check_something throws :abort)
user.destroy  # =&gt; false (if prevent_deletion throws :abort)
</code></pre>
<hr>
<h3>Skipping Callbacks</h3>
<p><strong>Methods that skip callbacks:</strong></p>
<pre><code class="language-ruby"># Skip all callbacks:
user.save(validate: false)

# Skip callbacks and validations:
user.update_column(:name, &quot;Bob&quot;)
user.update_columns(name: &quot;Bob&quot;, email: &quot;bob@example.com&quot;)

# Delete without callbacks:
user.delete  # No callbacks, just DELETE SQL
User.delete_all  # No callbacks

# Increment without callbacks:
post.increment!(:views_count)

# Touch without callbacks:
user.touch
</code></pre>
<hr>
<h3>Real-World Example</h3>
<p><strong>Complete e-commerce order lifecycle:</strong></p>
<pre><code class="language-ruby">class Order &lt; ApplicationRecord
  # VALIDATION
  before_validation :set_defaults
  validates :user, :total, presence: true
  validate :items_available
  
  # SAVING
  before_save :calculate_total
  after_save :update_inventory
  
  # CREATING
  before_create :generate_order_number
  after_create :send_confirmation
  after_commit :sync_to_warehouse, on: :create
  
  # UPDATING
  before_update :log_status_change, if: :status_changed?
  after_update :notify_customer, if: :saved_change_to_status?
  
  # DESTROYING
  before_destroy :check_cancellable
  after_destroy :restore_inventory
  
  private
  
  def set_defaults
    self.status ||= &#39;pending&#39;
    self.currency ||= &#39;USD&#39;
  end
  
  def items_available
    order_items.each do |item|
      if item.quantity &gt; item.product.stock
        errors.add(:base, &quot;#{item.product.name} insufficient stock&quot;)
      end
    end
  end
  
  def calculate_total
    self.total = order_items.sum { |item| item.quantity * item.price }
  end
  
  def update_inventory
    order_items.each do |item|
      item.product.decrement!(:stock, item.quantity)
    end
  end
  
  def generate_order_number
    self.order_number = &quot;ORD-#{Time.now.to_i}-#{rand(1000)}&quot;
  end
  
  def send_confirmation
    OrderMailer.confirmation(self).deliver_later
  end
  
  def sync_to_warehouse
    WarehouseSyncJob.perform_later(id)
  end
  
  def log_status_change
    Rails.logger.info &quot;Order #{id} status: #{status_was} → #{status}&quot;
  end
  
  def notify_customer
    OrderMailer.status_update(self).deliver_later
  end
  
  def check_cancellable
    unless cancellable?
      errors.add(:base, &quot;Cannot delete shipped order&quot;)
      throw(:abort)
    end
  end
  
  def restore_inventory
    order_items.each do |item|
      item.product.increment!(:stock, item.quantity)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Lifecycle</strong> flows through phases</li>
<li><strong>Validation</strong> → Save → Commit</li>
<li><strong>before/after</strong> pairs exist</li>
<li><strong>around</strong> wraps database operation</li>
<li><strong>after_commit</strong> outside transaction</li>
<li><strong>throw :abort</strong> halts lifecycle</li>
<li><strong>Different flows</strong> for create/update/destroy</li>
<li><strong>Transaction boundaries</strong> important</li>
<li><strong>Order matters</strong> for callbacks</li>
<li><strong>Understand flow</strong> for proper callback placement</li>
</ol>
<h1>Strong Parameters and Security Interview Questions</h1>
<h2>Question 110: What are Strong Parameters, and why are they important?</h2>
<h3>Answer</h3>
<p><strong>Strong Parameters</strong> is a security feature that prevents mass assignment vulnerabilities by explicitly whitelisting attributes that can be set from user input. Required for all controller parameters that update models.</p>
<hr>
<h3>Why Strong Parameters?</h3>
<p><strong>Without strong parameters (vulnerable):</strong></p>
<pre><code class="language-ruby"># Rails 3 (vulnerable to mass assignment)
class UsersController &lt; ApplicationController
  def create
    @user = User.new(params[:user])  # DANGEROUS!
    @user.save
  end
end

# Attacker can send:
# params = {
#   user: {
#     name: &quot;Alice&quot;,
#     email: &quot;alice@example.com&quot;,
#     admin: true  # ← Attacker gains admin access!
#   }
# }
</code></pre>
<p><strong>With strong parameters (secure):</strong></p>
<pre><code class="language-ruby"># Rails 4+ (secure)
class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params)
    @user.save
  end
  
  private
  
  def user_params
    params.require(:user).permit(:name, :email)
    # admin not permitted - ignored even if sent
  end
end

# Attacker sends same params:
# params = {
#   user: {
#     name: &quot;Alice&quot;,
#     email: &quot;alice@example.com&quot;,
#     admin: true  # ← IGNORED by strong parameters
#   }
# }
# Only name and email are used
</code></pre>
<hr>
<h3>Basic Usage</h3>
<p><strong>Simple permit:</strong></p>
<pre><code class="language-ruby">class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params)
    @user.save
  end
  
  private
  
  def user_params
    # Require :user key, permit specific attributes
    params.require(:user).permit(:name, :email, :age)
  end
end

# Allowed params:
# { user: { name: &quot;Alice&quot;, email: &quot;alice@example.com&quot;, age: 25 } }

# Any other attributes ignored:
# { user: { name: &quot;Alice&quot;, admin: true } }
# Only name is used, admin is ignored
</code></pre>
<p><strong>Multiple attributes:</strong></p>
<pre><code class="language-ruby">def post_params
  params.require(:post)
        .permit(:title, :body, :published, :author_id, :category_id)
end
</code></pre>
<hr>
<h3>Nested Attributes</h3>
<p><strong>Nested permit:</strong></p>
<pre><code class="language-ruby">class OrdersController &lt; ApplicationController
  def create
    @order = Order.new(order_params)
    @order.save
  end
  
  private
  
  def order_params
    params.require(:order).permit(
      :customer_name,
      :total,
      order_items_attributes: [:product_id, :quantity, :price]
    )
  end
end

# Allowed params structure:
# {
#   order: {
#     customer_name: &quot;Alice&quot;,
#     total: 100,
#     order_items_attributes: [
#       { product_id: 1, quantity: 2, price: 50 },
#       { product_id: 2, quantity: 1, price: 50 }
#     ]
#   }
# }
</code></pre>
<p><strong>Deep nesting:</strong></p>
<pre><code class="language-ruby">def user_params
  params.require(:user).permit(
    :name,
    :email,
    profile_attributes: [
      :bio,
      :avatar,
      address_attributes: [:street, :city, :state, :zip]
    ]
  )
end

# Structure:
# {
#   user: {
#     name: &quot;Alice&quot;,
#     email: &quot;alice@example.com&quot;,
#     profile_attributes: {
#       bio: &quot;Developer&quot;,
#       address_attributes: {
#         street: &quot;123 Main St&quot;,
#         city: &quot;NYC&quot;
#       }
#     }
#   }
# }
</code></pre>
<hr>
<h3>Arrays and Hashes</h3>
<p><strong>Array of values:</strong></p>
<pre><code class="language-ruby">def post_params
  params.require(:post).permit(:title, :body, tag_ids: [])
end

# Allowed:
# { post: { title: &quot;Hello&quot;, tag_ids: [1, 2, 3] } }
</code></pre>
<p><strong>Array of hashes:</strong></p>
<pre><code class="language-ruby">def order_params
  params.require(:order).permit(
    :customer_name,
    items: [:product_id, :quantity]
  )
end

# Allowed:
# {
#   order: {
#     customer_name: &quot;Alice&quot;,
#     items: [
#       { product_id: 1, quantity: 2 },
#       { product_id: 2, quantity: 1 }
#     ]
#   }
# }
</code></pre>
<p><strong>Arbitrary hash (use cautiously):</strong></p>
<pre><code class="language-ruby">def user_params
  params.require(:user).permit(:name, :email, preferences: {})
end

# Allows any hash:
# { user: { name: &quot;Alice&quot;, preferences: { theme: &quot;dark&quot;, lang: &quot;en&quot; } } }

# CAUTION: Can be exploited if not careful
</code></pre>
<hr>
<h3>Conditional Permissions</h3>
<p><strong>Different permissions based on user:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    @post = Post.new(post_params)
    @post.save
  end
  
  private
  
  def post_params
    if current_user.admin?
      # Admins can set featured
      params.require(:post).permit(:title, :body, :featured, :published)
    else
      # Regular users cannot
      params.require(:post).permit(:title, :body)
    end
  end
end
</code></pre>
<p><strong>Based on action:</strong></p>
<pre><code class="language-ruby">class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params_for_create)
    @user.save
  end
  
  def update
    @user = User.find(params[:id])
    @user.update(user_params_for_update)
  end
  
  private
  
  def user_params_for_create
    # Allow password on create
    params.require(:user).permit(:name, :email, :password, :password_confirmation)
  end
  
  def user_params_for_update
    # Don&#39;t allow password change unless explicitly changing it
    if params[:user][:password].present?
      params.require(:user).permit(:name, :email, :password, :password_confirmation)
    else
      params.require(:user).permit(:name, :email)
    end
  end
end
</code></pre>
<hr>
<h3>Error Handling</h3>
<p><strong>Missing required key:</strong></p>
<pre><code class="language-ruby">def user_params
  params.require(:user).permit(:name, :email)
end

# If params = { name: &quot;Alice&quot; } (no :user key)
# Raises: ActionController::ParameterMissing

# Handle it:
def create
  @user = User.new(user_params)
  @user.save
rescue ActionController::ParameterMissing =&gt; e
  render json: { error: &quot;Missing required parameter: #{e.param}&quot; }, status: :bad_request
end
</code></pre>
<p><strong>Checking for unpermitted parameters:</strong></p>
<pre><code class="language-ruby"># In development/test, Rails logs unpermitted params
# [Unpermitted parameters: :admin, :role]

# In production, raise exception:
# config/environments/production.rb
config.action_controller.action_on_unpermitted_parameters = :raise

# Now raises ActionController::UnpermittedParameters
</code></pre>
<hr>
<h3>Advanced Patterns</h3>
<p><strong>Permit all (DANGEROUS - use only for testing):</strong></p>
<pre><code class="language-ruby"># DON&#39;T DO THIS IN PRODUCTION
def user_params
  params.require(:user).permit!
end

# Allows ALL attributes - defeats purpose of strong parameters
</code></pre>
<p><strong>Merge additional attributes:</strong></p>
<pre><code class="language-ruby">def post_params
  params.require(:post)
        .permit(:title, :body)
        .merge(user_id: current_user.id)
end

# Ensures user_id comes from current_user, not params
</code></pre>
<p><strong>Transform values:</strong></p>
<pre><code class="language-ruby">def user_params
  permitted = params.require(:user).permit(:name, :email, :phone)
  
  # Normalize phone
  if permitted[:phone].present?
    permitted[:phone] = permitted[:phone].gsub(/\D/, &#39;&#39;)
  end
  
  permitted
end
</code></pre>
<hr>
<h3>Testing Strong Parameters</h3>
<pre><code class="language-ruby"># spec/controllers/users_controller_spec.rb
RSpec.describe UsersController, type: :controller do
  describe &#39;POST #create&#39; do
    it &#39;permits valid attributes&#39; do
      post :create, params: { 
        user: { name: &#39;Alice&#39;, email: &#39;alice@example.com&#39; } 
      }
      
      expect(assigns(:user).name).to eq(&#39;Alice&#39;)
      expect(assigns(:user).email).to eq(&#39;alice@example.com&#39;)
    end
    
    it &#39;filters unpermitted attributes&#39; do
      post :create, params: { 
        user: { name: &#39;Alice&#39;, admin: true } 
      }
      
      expect(assigns(:user).name).to eq(&#39;Alice&#39;)
      expect(assigns(:user)).not_to be_admin
    end
  end
end

# With shoulda-matchers
RSpec.describe UsersController do
  it { should permit(:name, :email).for(:create, params: { user: { name: &#39;Alice&#39; } }) }
  it { should_not permit(:admin).for(:create) }
end
</code></pre>
<hr>
<h3>Common Mistakes</h3>
<p><strong>❌ Not using strong parameters:</strong></p>
<pre><code class="language-ruby"># VULNERABLE
def create
  @user = User.new(params[:user])
  @user.save
end
</code></pre>
<p><strong>❌ Permit all:</strong></p>
<pre><code class="language-ruby"># DANGEROUS
def user_params
  params.require(:user).permit!
end
</code></pre>
<p><strong>❌ Not requiring key:</strong></p>
<pre><code class="language-ruby"># WRONG
def user_params
  params.permit(:name, :email)  # Missing require(:user)
end
</code></pre>
<p><strong>❌ Permitting sensitive attributes:</strong></p>
<pre><code class="language-ruby"># DANGEROUS
def user_params
  params.require(:user).permit(:name, :email, :admin, :role)
  # Anyone can make themselves admin!
end
</code></pre>
<hr>
<h3>Real-World Example</h3>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  before_action :authenticate_user!
  before_action :set_post, only: [:show, :edit, :update, :destroy]
  before_action :authorize_post, only: [:edit, :update, :destroy]
  
  def create
    @post = current_user.posts.build(post_params)
    
    if @post.save
      redirect_to @post, notice: &#39;Post created successfully&#39;
    else
      render :new
    end
  end
  
  def update
    if @post.update(post_params)
      redirect_to @post, notice: &#39;Post updated successfully&#39;
    else
      render :edit
    end
  end
  
  private
  
  def set_post
    @post = Post.find(params[:id])
  end
  
  def authorize_post
    redirect_to root_path unless @post.user == current_user
  end
  
  def post_params
    permitted_attributes = [:title, :body, :published, tag_ids: []]
    
    # Only admins can feature posts
    if current_user.admin?
      permitted_attributes &lt;&lt; :featured
    end
    
    params.require(:post)
          .permit(permitted_attributes)
          .tap do |p|
            # Ensure user_id is current user
            p[:user_id] = current_user.id if p[:user_id].present?
          end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Strong parameters</strong> prevent mass assignment</li>
<li><strong>Whitelist</strong> attributes explicitly</li>
<li><strong>require(:key)</strong> ensures key exists</li>
<li><strong>permit(attrs)</strong> specifies allowed attributes</li>
<li><strong>Nested</strong> attributes with nested permit</li>
<li><strong>Arrays</strong> with <code>attribute: []</code></li>
<li><strong>Conditional</strong> based on user/action</li>
<li><strong>Never permit!</strong> all in production</li>
<li><strong>Test</strong> parameter filtering</li>
<li><strong>Security critical</strong> - always use</li>
</ol>
<hr>
<h2>Question 111: What is CSRF Token, and how does it work? How does Rails validate it?</h2>
<h3>Answer</h3>
<p><strong>CSRF (Cross-Site Request Forgery) Token</strong> is a security measure that prevents attackers from making unauthorized requests on behalf of authenticated users. Rails generates unique tokens and validates them on state-changing requests.</p>
<hr>
<h3>What is CSRF Attack?</h3>
<p><strong>Without CSRF protection:</strong></p>
<pre><code class="language-html">&lt;!-- Attacker&#39;s malicious website --&gt;
&lt;html&gt;
  &lt;body onload=&quot;document.forms[0].submit()&quot;&gt;
    &lt;form action=&quot;https://yourbank.com/transfer&quot; method=&quot;POST&quot;&gt;
      &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;1000000&quot;&gt;
      &lt;input type=&quot;hidden&quot; name=&quot;to_account&quot; value=&quot;attacker_account&quot;&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;

&lt;!-- If user is logged into yourbank.com and visits this page:
     1. Browser sends request to yourbank.com
     2. Browser includes yourbank.com cookies (session)
     3. Transfer executes as authenticated user
     4. User&#39;s money stolen!
--&gt;
</code></pre>
<p><strong>How CSRF protection prevents this:</strong></p>
<pre><code class="language-html">&lt;!-- Legitimate form with CSRF token --&gt;
&lt;form action=&quot;/transfer&quot; method=&quot;POST&quot;&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;authenticity_token&quot; value=&quot;abc123...&quot;&gt;
  &lt;input name=&quot;amount&quot; value=&quot;100&quot;&gt;
  &lt;input name=&quot;to_account&quot; value=&quot;12345&quot;&gt;
&lt;/form&gt;

&lt;!-- Attacker&#39;s form (missing valid token) --&gt;
&lt;form action=&quot;https://yourbank.com/transfer&quot; method=&quot;POST&quot;&gt;
  &lt;input name=&quot;amount&quot; value=&quot;1000000&quot;&gt;
  &lt;input name=&quot;to_account&quot; value=&quot;attacker_account&quot;&gt;
  &lt;!-- No valid authenticity_token --&gt;
&lt;/form&gt;

&lt;!-- Rails rejects the request - no valid token --&gt;
</code></pre>
<hr>
<h3>How Rails CSRF Protection Works</h3>
<p><strong>1. Token Generation:</strong></p>
<pre><code class="language-ruby"># ApplicationController (default)
class ApplicationController &lt; ActionController::Base
  protect_from_forgery with: :exception
  
  # Rails automatically:
  # - Generates unique token per session
  # - Stores in session
  # - Includes in forms and meta tags
end
</code></pre>
<p><strong>2. Token in Forms:</strong></p>
<pre><code class="language-erb">&lt;!-- Rails form helpers automatically include token --&gt;
&lt;%= form_with model: @post do |f| %&gt;
  &lt;%= f.text_field :title %&gt;
  &lt;%= f.submit %&gt;
&lt;% end %&gt;

&lt;!-- Generated HTML: --&gt;
&lt;form action=&quot;/posts&quot; method=&quot;post&quot;&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;authenticity_token&quot; 
         value=&quot;abc123xyz789...&quot;&gt;
  &lt;input type=&quot;text&quot; name=&quot;post[title]&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Create&quot;&gt;
&lt;/form&gt;
</code></pre>
<p><strong>3. Token in Meta Tag:</strong></p>
<pre><code class="language-erb">&lt;!-- application.html.erb --&gt;
&lt;head&gt;
  &lt;%= csrf_meta_tags %&gt;
&lt;/head&gt;

&lt;!-- Generated HTML: --&gt;
&lt;head&gt;
  &lt;meta name=&quot;csrf-param&quot; content=&quot;authenticity_token&quot;&gt;
  &lt;meta name=&quot;csrf-token&quot; content=&quot;abc123xyz789...&quot;&gt;
&lt;/head&gt;

&lt;!-- JavaScript can read these for AJAX requests --&gt;
</code></pre>
<p><strong>4. Token Validation:</strong></p>
<pre><code class="language-ruby"># On each POST/PUT/PATCH/DELETE request:
# 1. Rails reads token from params or headers
# 2. Compares with session token
# 3. If match: request proceeds
# 4. If no match: raises ActionController::InvalidAuthenticityToken

# ApplicationController
class ApplicationController &lt; ActionController::Base
  protect_from_forgery with: :exception
  # Raises exception if token invalid
  
  # Or:
  # protect_from_forgery with: :null_session
  # Clears session if token invalid
  
  # Or:
  # protect_from_forgery with: :reset_session
  # Resets entire session if token invalid
end
</code></pre>
<hr>
<h3>AJAX Requests</h3>
<p><strong>jQuery/JavaScript:</strong></p>
<pre><code class="language-javascript">// Rails UJS automatically includes token in AJAX
// app/javascript/application.js
import Rails from &quot;@rails/ujs&quot;
Rails.start()

// Manual AJAX with fetch:
const csrfToken = document.querySelector(&#39;meta[name=&quot;csrf-token&quot;]&#39;).content

fetch(&#39;/posts&#39;, {
  method: &#39;POST&#39;,
  headers: {
    &#39;Content-Type&#39;: &#39;application/json&#39;,
    &#39;X-CSRF-Token&#39;: csrfToken
  },
  body: JSON.stringify({ post: { title: &#39;Hello&#39; } })
})
</code></pre>
<p><strong>Axios:</strong></p>
<pre><code class="language-javascript">// Set default header
import axios from &#39;axios&#39;

const token = document.querySelector(&#39;meta[name=&quot;csrf-token&quot;]&#39;).content
axios.defaults.headers.common[&#39;X-CSRF-Token&#39;] = token

// Now all requests include token
axios.post(&#39;/posts&#39;, { post: { title: &#39;Hello&#39; } })
</code></pre>
<hr>
<h3>API Controllers (Disable CSRF)</h3>
<p><strong>For API-only controllers:</strong></p>
<pre><code class="language-ruby">class Api::V1::BaseController &lt; ApplicationController
  # Disable CSRF for API (token-based auth instead)
  protect_from_forgery with: :null_session
  
  # Or skip entirely:
  skip_before_action :verify_authenticity_token
end

class Api::V1::PostsController &lt; Api::V1::BaseController
  # Uses API token authentication instead
  before_action :authenticate_api_token
  
  def create
    # No CSRF check
    @post = Post.create(post_params)
    render json: @post
  end
  
  private
  
  def authenticate_api_token
    token = request.headers[&#39;Authorization&#39;]
    @current_user = User.find_by(api_token: token)
    head :unauthorized unless @current_user
  end
end
</code></pre>
<hr>
<h3>CSRF Token Validation Flow</h3>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                    Browser Request                       │
│                  (includes cookies)                      │
└────────────────────────┬────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│              Rails Middleware Stack                      │
└────────────────────────┬────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│         ActionController::RequestForgeryProtection       │
├─────────────────────────────────────────────────────────┤
│  1. Check if state-changing request (POST/PUT/DELETE)   │
│  2. Extract token from:                                  │
│     - params[:authenticity_token]                        │
│     - request.headers[&#39;X-CSRF-Token&#39;]                    │
│  3. Compare with session token                           │
│  4. If match: ✅ Continue                                │
│  5. If no match: ❌ Raise InvalidAuthenticityToken       │
└────────────────────────┬────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│                   Controller Action                      │
└─────────────────────────────────────────────────────────┘
</code></pre>
<hr>
<h3>Handling CSRF Errors</h3>
<p><strong>Custom error handling:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  protect_from_forgery with: :exception
  
  rescue_from ActionController::InvalidAuthenticityToken do
    # Log the error
    Rails.logger.error &quot;CSRF token validation failed for #{request.path}&quot;
    
    # Respond appropriately
    respond_to do |format|
      format.html do
        flash[:error] = &quot;Your session has expired. Please try again.&quot;
        redirect_to root_path
      end
      
      format.json do
        render json: { error: &#39;Invalid CSRF token&#39; }, status: :unprocessable_entity
      end
    end
  end
end
</code></pre>
<hr>
<h3>Special Cases</h3>
<p><strong>Skip CSRF for specific actions:</strong></p>
<pre><code class="language-ruby">class WebhooksController &lt; ApplicationController
  # Skip CSRF for webhook endpoints
  skip_before_action :verify_authenticity_token, only: [:stripe_webhook]
  
  def stripe_webhook
    # Verify webhook signature instead
    payload = request.body.read
    sig_header = request.headers[&#39;Stripe-Signature&#39;]
    
    event = Stripe::Webhook.construct_event(
      payload, sig_header, ENV[&#39;STRIPE_WEBHOOK_SECRET&#39;]
    )
    
    # Process webhook
  end
end
</code></pre>
<p><strong>Conditional CSRF protection:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  before_action :set_csrf_protection
  
  private
  
  def set_csrf_protection
    if api_request?
      # Skip CSRF for API requests
      skip_before_action :verify_authenticity_token
    else
      protect_from_forgery with: :exception
    end
  end
  
  def api_request?
    request.format.json? &amp;&amp; request.headers[&#39;Authorization&#39;].present?
  end
end
</code></pre>
<hr>
<h3>Testing CSRF Protection</h3>
<pre><code class="language-ruby"># spec/requests/posts_spec.rb
RSpec.describe &#39;Posts&#39;, type: :request do
  describe &#39;POST /posts&#39; do
    it &#39;requires CSRF token&#39; do
      post &#39;/posts&#39;, params: { post: { title: &#39;Test&#39; } }
      expect(response).to have_http_status(:forbidden)
    end
    
    it &#39;succeeds with valid CSRF token&#39; do
      post &#39;/posts&#39;, 
           params: { post: { title: &#39;Test&#39; } },
           headers: { &#39;X-CSRF-Token&#39;: form_authenticity_token }
      
      expect(response).to have_http_status(:success)
    end
  end
end

# System tests automatically handle CSRF
RSpec.describe &#39;Creating posts&#39;, type: :system do
  it &#39;creates a post&#39; do
    visit new_post_path
    fill_in &#39;Title&#39;, with: &#39;Test Post&#39;
    click_button &#39;Create&#39;
    
    # CSRF token automatically included
    expect(page).to have_content(&#39;Post created&#39;)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>CSRF</strong> prevents unauthorized requests</li>
<li><strong>Token</strong> unique per session</li>
<li><strong>Required</strong> for state-changing requests</li>
<li><strong>Automatic</strong> in Rails forms</li>
<li><strong>Meta tags</strong> for AJAX</li>
<li><strong>Disable</strong> for API endpoints</li>
<li><strong>Test</strong> CSRF protection</li>
<li><strong>Handle</strong> errors gracefully</li>
<li><strong>Never disable</strong> for web forms</li>
<li><strong>Security critical</strong> - always use</li>
</ol>
<hr>
<h2>Question 112: How do you prevent SQL Injection, XSS, and CSRF attacks in Rails?</h2>
<h3>Answer</h3>
<p>Rails provides <strong>built-in protection</strong> against common security vulnerabilities through ActiveRecord query methods, HTML escaping, and CSRF tokens. Following Rails conventions keeps applications secure.</p>
<hr>
<h3>SQL Injection Prevention</h3>
<p><strong>What is SQL Injection:</strong></p>
<pre><code class="language-ruby"># VULNERABLE CODE (DON&#39;T DO THIS)
class User &lt; ApplicationRecord
  def self.search(query)
    where(&quot;name = &#39;#{query}&#39;&quot;)
  end
end

# Attack:
User.search(&quot;&#39;; DROP TABLE users; --&quot;)
# Generates: SELECT * FROM users WHERE name = &#39;&#39;; DROP TABLE users; --&#39;
# Deletes entire users table!
</code></pre>
<p><strong>Safe: Use parameterized queries</strong></p>
<pre><code class="language-ruby"># ✅ SAFE - Parameterized query
class User &lt; ApplicationRecord
  def self.search(query)
    where(&quot;name = ?&quot;, query)
    # Or:
    where(name: query)
  end
end

# Attack fails:
User.search(&quot;&#39;; DROP TABLE users; --&quot;)
# Generates: SELECT * FROM users WHERE name = &#39;&#39;&#39;; DROP TABLE users; --&#39;
# Treated as literal string, not SQL
</code></pre>
<p><strong>More examples:</strong></p>
<pre><code class="language-ruby"># ❌ VULNERABLE
User.where(&quot;email = &#39;#{params[:email]}&#39;&quot;)
User.where(&quot;age &gt; #{params[:age]}&quot;)
Product.where(&quot;name LIKE &#39;%#{params[:q]}%&#39;&quot;)

# ✅ SAFE - Placeholder
User.where(&quot;email = ?&quot;, params[:email])
User.where(&quot;age &gt; ?&quot;, params[:age])
Product.where(&quot;name LIKE ?&quot;, &quot;%#{params[:q]}%&quot;)

# ✅ SAFE - Hash conditions
User.where(email: params[:email])
User.where(&quot;age &gt; ?&quot;, params[:age])

# ✅ SAFE - Named placeholders
User.where(&quot;email = :email AND active = :active&quot;, 
           email: params[:email], 
           active: true)
</code></pre>
<p><strong>Array conditions:</strong></p>
<pre><code class="language-ruby"># ✅ SAFE
user_ids = [1, 2, 3]
User.where(&quot;id IN (?)&quot;, user_ids)
# SELECT * FROM users WHERE id IN (1,2,3)

# ✅ SAFE with LIKE
query = params[:q]
Post.where(&quot;title LIKE ? OR body LIKE ?&quot;, &quot;%#{query}%&quot;, &quot;%#{query}%&quot;)
</code></pre>
<p><strong>Avoid raw SQL:</strong></p>
<pre><code class="language-ruby"># ❌ AVOID
ActiveRecord::Base.connection.execute(
  &quot;SELECT * FROM users WHERE email = &#39;#{email}&#39;&quot;
)

# ✅ Use ActiveRecord methods instead
User.find_by_sql([&quot;SELECT * FROM users WHERE email = ?&quot;, email])

# ✅ Or better, use ActiveRecord query interface
User.where(email: email)
</code></pre>
<hr>
<h3>XSS (Cross-Site Scripting) Prevention</h3>
<p><strong>What is XSS:</strong></p>
<pre><code class="language-erb">&lt;!-- VULNERABLE VIEW (DON&#39;T DO THIS) --&gt;
&lt;div&gt;
  &lt;%= raw @user.bio %&gt;
&lt;/div&gt;

&lt;!-- If user.bio = &quot;&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;&quot; --&gt;
&lt;!-- JavaScript executes in victim&#39;s browser --&gt;
</code></pre>
<p><strong>Safe: Auto-escaping</strong></p>
<pre><code class="language-erb">&lt;!-- ✅ SAFE - Automatic HTML escaping --&gt;
&lt;div&gt;
  &lt;%= @user.bio %&gt;
&lt;/div&gt;

&lt;!-- If user.bio = &quot;&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;&quot; --&gt;
&lt;!-- Renders as: &amp;lt;script&amp;gt;alert(&#39;XSS&#39;)&amp;lt;/script&amp;gt; --&gt;
&lt;!-- Displayed as text, not executed --&gt;
</code></pre>
<p><strong>Explicit escaping:</strong></p>
<pre><code class="language-erb">&lt;!-- ✅ Explicit escaping --&gt;
&lt;div&gt;
  &lt;%= h(@user.bio) %&gt;
  &lt;!-- or --&gt;
  &lt;%= html_escape(@user.bio) %&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Sanitizing HTML:</strong></p>
<pre><code class="language-ruby"># Allow some HTML tags, remove dangerous ones
class User &lt; ApplicationRecord
  def safe_bio
    ActionController::Base.helpers.sanitize(
      bio,
      tags: %w[p br strong em],
      attributes: %w[]
    )
  end
end

# View:
&lt;%= @user.safe_bio.html_safe %&gt;
</code></pre>
<p><strong>Sanitize helper:</strong></p>
<pre><code class="language-erb">&lt;!-- Allow specific tags --&gt;
&lt;%= sanitize @post.body, 
    tags: %w[p br strong em a],
    attributes: %w[href] %&gt;

&lt;!-- Strip all HTML --&gt;
&lt;%= strip_tags @post.body %&gt;
</code></pre>
<p><strong>Content Security Policy (CSP):</strong></p>
<pre><code class="language-ruby"># config/initializers/content_security_policy.rb
Rails.application.config.content_security_policy do |policy|
  policy.default_src :self, :https
  policy.font_src    :self, :https, :data
  policy.img_src     :self, :https, :data
  policy.object_src  :none
  policy.script_src  :self, :https
  policy.style_src   :self, :https
  
  # Report violations
  policy.report_uri &quot;/csp-violation-report-endpoint&quot;
end

# Prevents inline scripts and unauthorized sources
</code></pre>
<p><strong>Common XSS vectors:</strong></p>
<pre><code class="language-erb">&lt;!-- ❌ VULNERABLE --&gt;
&lt;script&gt;
  var name = &quot;&lt;%= @user.name %&gt;&quot;;
&lt;/script&gt;

&lt;!-- ✅ SAFE - Use JSON --&gt;
&lt;script&gt;
  var name = &lt;%= @user.name.to_json %&gt;;
&lt;/script&gt;

&lt;!-- ❌ VULNERABLE --&gt;
&lt;div onclick=&quot;alert(&#39;&lt;%= @message %&gt;&#39;)&quot;&gt;

&lt;!-- ✅ SAFE - Use data attributes --&gt;
&lt;div data-message=&quot;&lt;%= @message %&gt;&quot;&gt;
&lt;script&gt;
  const message = element.dataset.message;
&lt;/script&gt;
</code></pre>
<hr>
<h3>CSRF Prevention</h3>
<p><strong>Already covered in Question 111, summary:</strong></p>
<pre><code class="language-ruby"># ApplicationController
class ApplicationController &lt; ActionController::Base
  protect_from_forgery with: :exception
end

# Forms automatically include token
&lt;%= form_with model: @post do |f| %&gt;
  &lt;!-- Token automatically included --&gt;
&lt;% end %&gt;

# AJAX requests include token
const token = document.querySelector(&#39;meta[name=&quot;csrf-token&quot;]&#39;).content
fetch(&#39;/posts&#39;, {
  method: &#39;POST&#39;,
  headers: { &#39;X-CSRF-Token&#39;: token }
})
</code></pre>
<hr>
<h3>Mass Assignment Prevention</h3>
<p><strong>Already covered in Question 110, summary:</strong></p>
<pre><code class="language-ruby"># Use strong parameters
def user_params
  params.require(:user).permit(:name, :email)
  # admin, role, etc. not permitted
end
</code></pre>
<hr>
<h3>Additional Security Best Practices</h3>
<p><strong>1. Secure Headers:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;secure_headers&#39;

# config/initializers/secure_headers.rb
SecureHeaders::Configuration.default do |config|
  config.x_frame_options = &quot;DENY&quot;
  config.x_content_type_options = &quot;nosniff&quot;
  config.x_xss_protection = &quot;1; mode=block&quot;
  config.x_download_options = &quot;noopen&quot;
  config.x_permitted_cross_domain_policies = &quot;none&quot;
  config.referrer_policy = &quot;strict-origin-when-cross-origin&quot;
end
</code></pre>
<p><strong>2. Secure Cookies:</strong></p>
<pre><code class="language-ruby"># config/initializers/session_store.rb
Rails.application.config.session_store :cookie_store,
  key: &#39;_myapp_session&#39;,
  secure: Rails.env.production?,  # HTTPS only in production
  httponly: true,                 # Not accessible via JavaScript
  same_site: :lax                 # CSRF protection
</code></pre>
<p><strong>3. Sensitive Data in Logs:</strong></p>
<pre><code class="language-ruby"># config/initializers/filter_parameter_logging.rb
Rails.application.config.filter_parameters += [
  :password,
  :password_confirmation,
  :credit_card,
  :ssn,
  :api_key,
  :secret,
  :token
]

# Logs show [FILTERED] instead of actual values
</code></pre>
<p><strong>4. Dependency Security:</strong></p>
<pre><code class="language-bash"># Check for vulnerable dependencies
bundle audit

# Update vulnerable gems
bundle update &lt;gem_name&gt;
</code></pre>
<p><strong>5. Brakeman (Security Scanner):</strong></p>
<pre><code class="language-ruby"># Gemfile
group :development do
  gem &#39;brakeman&#39;, require: false
end

# Run security scan
brakeman

# Checks for:
# - SQL injection
# - XSS
# - CSRF issues
# - Mass assignment
# - Command injection
# - Unsafe redirects
</code></pre>
<hr>
<h3>Real-World Security Checklist</h3>
<pre><code class="language-ruby"># ✅ Security Checklist

# 1. SQL Injection
# - Use parameterized queries
# - Never interpolate user input in SQL
# - Use ActiveRecord methods

# 2. XSS
# - Never use raw or html_safe with user input
# - Sanitize HTML when needed
# - Use Content Security Policy
# - Escape JSON in script tags

# 3. CSRF
# - protect_from_forgery enabled
# - Include CSRF token in forms
# - Use csrf_meta_tags for AJAX

# 4. Mass Assignment
# - Use strong parameters
# - Don&#39;t permit sensitive attributes

# 5. Authentication
# - Use has_secure_password
# - Store passwords with bcrypt
# - Implement rate limiting

# 6. Authorization
# - Check permissions before actions
# - Use gems like Pundit or CanCanCan

# 7. Secure Headers
# - Install secure_headers gem
# - Configure CSP

# 8. HTTPS
# - Force SSL in production
# - Secure cookies

# 9. Sensitive Data
# - Filter parameters in logs
# - Encrypt sensitive database fields
# - Use environment variables for secrets

# 10. Dependencies
# - Run bundle audit regularly
# - Keep gems updated
# - Run brakeman
</code></pre>
<hr>
<h3>Testing Security</h3>
<pre><code class="language-ruby"># spec/requests/security_spec.rb
RSpec.describe &#39;Security&#39;, type: :request do
  describe &#39;SQL Injection&#39; do
    it &#39;prevents SQL injection in search&#39; do
      get &#39;/users&#39;, params: { q: &quot;&#39;; DROP TABLE users; --&quot; }
      expect(User.count).to be &gt; 0  # Table still exists
    end
  end
  
  describe &#39;XSS&#39; do
    it &#39;escapes HTML in user content&#39; do
      user = User.create(bio: &#39;&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;&#39;)
      get user_path(user)
      
      expect(response.body).to include(&#39;&amp;lt;script&amp;gt;&#39;)
      expect(response.body).not_to include(&#39;&lt;script&gt;&#39;)
    end
  end
  
  describe &#39;CSRF&#39; do
    it &#39;requires CSRF token for POST&#39; do
      post &#39;/posts&#39;, params: { post: { title: &#39;Test&#39; } }
      expect(response).to have_http_status(:forbidden)
    end
  end
  
  describe &#39;Mass Assignment&#39; do
    it &#39;does not allow setting admin via params&#39; do
      post &#39;/users&#39;, params: { 
        user: { name: &#39;Alice&#39;, email: &#39;alice@example.com&#39;, admin: true } 
      }
      
      expect(User.last).not_to be_admin
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>SQL Injection</strong> - use parameterized queries</li>
<li><strong>XSS</strong> - automatic HTML escaping</li>
<li><strong>CSRF</strong> - protect_from_forgery</li>
<li><strong>Mass Assignment</strong> - strong parameters</li>
<li><strong>Secure headers</strong> - use secure_headers gem</li>
<li><strong>HTTPS</strong> - force SSL in production</li>
<li><strong>Filter logs</strong> - hide sensitive data</li>
<li><strong>Brakeman</strong> - security scanner</li>
<li><strong>Bundle audit</strong> - check dependencies</li>
<li><strong>Test</strong> security measures</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 113: What is Rails Mass Assignment Vulnerability, and how do you prevent it?</h2>
<h3>Answer</h3>
<p><strong>Mass Assignment Vulnerability</strong> allows attackers to modify object attributes they shouldn&#39;t have access to by including unauthorized parameters in requests. <strong>Strong Parameters</strong> prevents this by explicitly whitelisting allowed attributes.</p>
<hr>
<h3>The Vulnerability</h3>
<p><strong>Without protection (Rails 3 and earlier):</strong></p>
<pre><code class="language-ruby"># Model
class User &lt; ApplicationRecord
  # No protection - any attribute can be set
end

# Controller (VULNERABLE)
class UsersController &lt; ApplicationController
  def create
    @user = User.new(params[:user])  # DANGEROUS!
    @user.save
  end
end

# Attacker&#39;s request:
POST /users
{
  user: {
    name: &quot;Alice&quot;,
    email: &quot;alice@example.com&quot;,
    admin: true,              # ← Attacker gains admin access!
    role: &quot;superuser&quot;,        # ← Unauthorized role
    balance: 1000000          # ← Sets own balance
  }
}

# All attributes set, including admin, role, balance
</code></pre>
<hr>
<h3>How Strong Parameters Prevents It</h3>
<p><strong>Rails 4+ (secure):</strong></p>
<pre><code class="language-ruby">class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params)
    @user.save
  end
  
  private
  
  def user_params
    # Only name and email permitted
    params.require(:user).permit(:name, :email)
  end
end

# Same attacker request:
POST /users
{
  user: {
    name: &quot;Alice&quot;,
    email: &quot;alice@example.com&quot;,
    admin: true,              # ← IGNORED
    role: &quot;superuser&quot;,        # ← IGNORED
    balance: 1000000          # ← IGNORED
  }
}

# Only name and email are used
# User created as: { name: &quot;Alice&quot;, email: &quot;alice@example.com&quot;, admin: false }
</code></pre>
<hr>
<h3>Real-World Attack Scenarios</h3>
<p><strong>Scenario 1: Privilege Escalation</strong></p>
<pre><code class="language-ruby"># Vulnerable code
class User &lt; ApplicationRecord
  # has column: admin (boolean, default: false)
end

class UsersController &lt; ApplicationController
  def update
    @user = User.find(params[:id])
    @user.update(params[:user])  # VULNERABLE
  end
end

# Attacker&#39;s request:
PUT /users/123
{ user: { admin: true } }

# User 123 becomes admin!

# ✅ Secure version:
def user_params
  params.require(:user).permit(:name, :email)
  # admin not permitted - can&#39;t be changed via params
end
</code></pre>
<p><strong>Scenario 2: Financial Manipulation</strong></p>
<pre><code class="language-ruby">class Account &lt; ApplicationRecord
  # has column: balance (decimal)
end

# Vulnerable
class AccountsController &lt; ApplicationController
  def update
    @account = Account.find(params[:id])
    @account.update(params[:account])  # VULNERABLE
  end
end

# Attacker sets their own balance:
PUT /accounts/123
{ account: { balance: 1000000 } }

# ✅ Secure: Don&#39;t allow balance in params
def account_params
  params.require(:account).permit(:name, :type)
  # balance never permitted - updated only by system
end
</code></pre>
<p><strong>Scenario 3: Association Manipulation</strong></p>
<pre><code class="language-ruby">class Post &lt; ApplicationRecord
  belongs_to :user
end

# Vulnerable
class PostsController &lt; ApplicationController
  def create
    @post = Post.new(params[:post])  # VULNERABLE
    @post.save
  end
end

# Attacker creates post as another user:
POST /posts
{ post: { title: &quot;Hello&quot;, user_id: 999 } }

# ✅ Secure: Set user from current_user
def create
  @post = current_user.posts.build(post_params)
  @post.save
end

def post_params
  params.require(:post).permit(:title, :body)
  # user_id not permitted - set from current_user
end
</code></pre>
<hr>
<h3>Defense-in-Depth</h3>
<p><strong>1. Strong Parameters (primary defense):</strong></p>
<pre><code class="language-ruby">def user_params
  params.require(:user).permit(:name, :email)
end
</code></pre>
<p><strong>2. attr_readonly (model-level):</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Can only be set on create, not updated
  attr_readonly :admin, :role, :created_by_id
end

user = User.create(name: &quot;Alice&quot;, admin: false)
user.update(admin: true)
user.reload.admin  # =&gt; false (unchanged)
</code></pre>
<p><strong>3. Database constraints:</strong></p>
<pre><code class="language-ruby">class AddUserConstraints &lt; ActiveRecord::Migration[7.0]
  def change
    change_column_default :users, :admin, false
    change_column_null :users, :admin, false
  end
end
</code></pre>
<p><strong>4. Virtual attributes:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Don&#39;t store sensitive attributes in database
  attr_accessor :is_admin_request
  
  before_save :prevent_admin_escalation
  
  private
  
  def prevent_admin_escalation
    # Even if somehow passed, block it
    self.admin = false if is_admin_request &amp;&amp; !Current.user&amp;.admin?
  end
end
</code></pre>
<hr>
<h3>Testing Mass Assignment Protection</h3>
<pre><code class="language-ruby">RSpec.describe UsersController, type: :controller do
  describe &#39;POST #create&#39; do
    it &#39;does not allow mass assignment of admin&#39; do
      post :create, params: { 
        user: { 
          name: &#39;Attacker&#39;, 
          email: &#39;attacker@example.com&#39;,
          admin: true 
        } 
      }
      
      user = User.last
      expect(user.name).to eq(&#39;Attacker&#39;)
      expect(user.admin).to be false  # Not set from params
    end
    
    it &#39;does not allow mass assignment of role&#39; do
      post :create, params: { 
        user: { 
          name: &#39;Attacker&#39;,
          role: &#39;superuser&#39; 
        } 
      }
      
      user = User.last
      expect(user.role).to eq(&#39;user&#39;)  # Default role
    end
  end
  
  describe &#39;PUT #update&#39; do
    let(:user) { create(:user, admin: false) }
    
    it &#39;does not allow escalating to admin&#39; do
      put :update, params: { 
        id: user.id,
        user: { admin: true } 
      }
      
      expect(user.reload.admin).to be false
    end
  end
end

# Security spec
RSpec.describe User, type: :model do
  describe &#39;mass assignment protection&#39; do
    it &#39;does not allow setting admin via mass assignment&#39; do
      user = User.new(name: &#39;Alice&#39;, admin: true)
      expect(user.admin).to be_nil  # or false, depending on default
    end
    
    it &#39;requires explicit assignment for admin&#39; do
      user = User.new(name: &#39;Alice&#39;)
      user.admin = true
      expect(user.admin).to be true
    end
  end
end
</code></pre>
<hr>
<h3>Common Mistakes</h3>
<p><strong>❌ Permitting too many attributes:</strong></p>
<pre><code class="language-ruby"># BAD - overly permissive
def user_params
  params.require(:user).permit!  # Allows EVERYTHING
end
</code></pre>
<p><strong>❌ Not using strong parameters:</strong></p>
<pre><code class="language-ruby"># BAD - vulnerable
def create
  @user = User.new(params[:user])
end
</code></pre>
<p><strong>❌ Permitting sensitive attributes:</strong></p>
<pre><code class="language-ruby"># BAD - allows privilege escalation
def user_params
  params.require(:user).permit(:name, :email, :admin, :role)
end
</code></pre>
<p><strong>❌ Merging params without filtering:</strong></p>
<pre><code class="language-ruby"># BAD - bypasses strong parameters
def create
  safe_params = user_params
  all_params = params[:user].merge(safe_params)  # DANGEROUS
  @user = User.new(all_params)
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>✅ Whitelist attributes explicitly:</strong></p>
<pre><code class="language-ruby">def user_params
  params.require(:user).permit(:name, :email, :bio)
end
</code></pre>
<p><strong>✅ Different params for different actions:</strong></p>
<pre><code class="language-ruby">def user_params_for_create
  params.require(:user).permit(:name, :email, :password)
end

def user_params_for_update
  params.require(:user).permit(:name, :email, :bio)
  # No password unless explicitly changing it
end
</code></pre>
<p><strong>✅ Set sensitive attributes explicitly:</strong></p>
<pre><code class="language-ruby">def create
  @post = current_user.posts.build(post_params)
  @post.published_by = current_user
  @post.save
end
</code></pre>
<p><strong>✅ Use callbacks for constraints:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  before_save :ensure_single_admin, if: :admin_changed?
  
  private
  
  def ensure_single_admin
    # Business logic to prevent multiple admins
    if admin? &amp;&amp; User.where(admin: true).where.not(id: id).exists?
      errors.add(:admin, &quot;Only one admin allowed&quot;)
      throw :abort
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Mass assignment</strong> allows unauthorized attribute changes</li>
<li><strong>Strong parameters</strong> whitelist attributes</li>
<li><strong>Never permit!</strong> all attributes</li>
<li><strong>Sensitive attributes</strong> never in params</li>
<li><strong>Set from context</strong> (current_user, etc.)</li>
<li><strong>attr_readonly</strong> for immutable fields</li>
<li><strong>Database constraints</strong> as backup</li>
<li><strong>Test</strong> mass assignment protection</li>
<li><strong>Different params</strong> for create/update</li>
<li><strong>Defense-in-depth</strong> multiple layers</li>
</ol>
<hr>
<h2>Question 114: How do you encrypt sensitive data in a Rails app?</h2>
<h3>Answer</h3>
<p>Use <strong>ActiveRecord Encryption</strong> (Rails 7+) for transparent field-level encryption, or gems like <strong>attr_encrypted</strong> for older Rails versions. Store encryption keys securely in credentials.</p>
<hr>
<h3>ActiveRecord Encryption (Rails 7+)</h3>
<p><strong>Setup:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.active_record.encryption.primary_key = Rails.application.credentials.dig(:active_record_encryption, :primary_key)
config.active_record.encryption.deterministic_key = Rails.application.credentials.dig(:active_record_encryption, :deterministic_key)
config.active_record.encryption.key_derivation_salt = Rails.application.credentials.dig(:active_record_encryption, :key_derivation_salt)

# Generate keys:
# rails db:encryption:init

# Outputs:
# active_record_encryption:
#   primary_key: &lt;key&gt;
#   deterministic_key: &lt;key&gt;
#   key_derivation_salt: &lt;salt&gt;

# Add to credentials:
# rails credentials:edit
</code></pre>
<p><strong>Encrypt model attributes:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  encrypts :ssn
  encrypts :credit_card_number
  encrypts :bank_account
end

# Usage (transparent):
user = User.create(
  name: &quot;Alice&quot;,
  ssn: &quot;123-45-6789&quot;,
  credit_card_number: &quot;4111111111111111&quot;
)

# Database stores encrypted values:
# ssn: &quot;encrypted_blob_abc123...&quot;

# Reading decrypts automatically:
user.ssn  # =&gt; &quot;123-45-6789&quot;
</code></pre>
<p><strong>Deterministic encryption (for queries):</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  # Non-deterministic (can&#39;t query)
  encrypts :ssn
  
  # Deterministic (can query)
  encrypts :email, deterministic: true
end

# Can search deterministic fields:
User.find_by(email: &quot;alice@example.com&quot;)  # Works

# Can&#39;t search non-deterministic:
User.find_by(ssn: &quot;123-45-6789&quot;)  # Doesn&#39;t work
</code></pre>
<hr>
<h3>attr_encrypted (Older Rails)</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;attr_encrypted&#39;

# Model
class User &lt; ApplicationRecord
  attr_encrypted :ssn, key: Rails.application.credentials.encryption_key
  attr_encrypted :credit_card, key: :encryption_key
  
  def encryption_key
    # Per-record key (more secure)
    # Or use global key from credentials
    Rails.application.credentials.encryption_key
  end
end

# Database columns:
# encrypted_ssn (string)
# encrypted_ssn_iv (string)

# Usage:
user = User.create(ssn: &quot;123-45-6789&quot;)
user.ssn  # =&gt; &quot;123-45-6789&quot; (decrypted)
user.encrypted_ssn  # =&gt; &quot;encrypted_blob...&quot; (encrypted)
</code></pre>
<hr>
<h3>Storing Encryption Keys</h3>
<p><strong>Using Rails Credentials (recommended):</strong></p>
<pre><code class="language-bash"># Edit credentials
EDITOR=vim rails credentials:edit

# Add keys:
encryption_key: your-secret-key-here
active_record_encryption:
  primary_key: abc123...
  deterministic_key: def456...
  key_derivation_salt: ghi789...

# Access in code:
Rails.application.credentials.encryption_key
</code></pre>
<p><strong>Using environment variables (alternative):</strong></p>
<pre><code class="language-ruby"># .env (not in git)
ENCRYPTION_KEY=your-secret-key

# config/application.rb
config.x.encryption_key = ENV[&#39;ENCRYPTION_KEY&#39;]

# Use in model:
attr_encrypted :ssn, key: Rails.configuration.x.encryption_key
</code></pre>
<hr>
<h3>Encrypting Existing Data</h3>
<p><strong>Migration to encrypt existing records:</strong></p>
<pre><code class="language-ruby">class EncryptExistingSSNs &lt; ActiveRecord::Migration[7.0]
  def up
    User.find_each do |user|
      # Skip if already encrypted
      next if user.ssn.blank? || user.ssn.start_with?(&#39;$&#39;)
      
      # Re-save to trigger encryption
      user.save!
    end
  end
  
  def down
    # Can&#39;t decrypt without keys
    # Backup first!
  end
end
</code></pre>
<hr>
<h3>Key Rotation</h3>
<p><strong>Rotating encryption keys:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.active_record.encryption.previous = [
  {
    primary_key: Rails.application.credentials.dig(:active_record_encryption, :old_primary_key),
    deterministic_key: Rails.application.credentials.dig(:active_record_encryption, :old_deterministic_key),
    key_derivation_salt: Rails.application.credentials.dig(:active_record_encryption, :old_key_derivation_salt)
  }
]

# Re-encrypt with new keys:
User.find_each do |user|
  user.save!  # Re-encrypts with new keys
end
</code></pre>
<hr>
<h3>Additional Encryption Use Cases</h3>
<p><strong>1. Encrypting file uploads:</strong></p>
<pre><code class="language-ruby">class Document &lt; ApplicationRecord
  has_one_attached :file
  
  encrypts :encryption_key
  
  before_create :generate_encryption_key
  
  def encrypted_file_data
    # Encrypt file content
    cipher = OpenSSL::Cipher.new(&#39;AES-256-CBC&#39;)
    cipher.encrypt
    cipher.key = encryption_key
    
    encrypted = cipher.update(file.download) + cipher.final
    Base64.encode64(encrypted)
  end
  
  private
  
  def generate_encryption_key
    self.encryption_key = SecureRandom.hex(32)
  end
end
</code></pre>
<p><strong>2. Encrypting API tokens:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  encrypts :api_token
  
  before_create :generate_api_token
  
  private
  
  def generate_api_token
    self.api_token = SecureRandom.hex(32)
  end
end

# Token stored encrypted, compared encrypted:
user = User.find_by(api_token: request.headers[&#39;Authorization&#39;])
</code></pre>
<p><strong>3. Encrypting sensitive logs:</strong></p>
<pre><code class="language-ruby">class AuditLog &lt; ApplicationRecord
  encrypts :sensitive_data
  
  def self.log_action(action, data)
    create(
      action: action,
      sensitive_data: data.to_json
    )
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Rails 7+</strong> - use ActiveRecord Encryption</li>
<li><strong>Older Rails</strong> - use attr_encrypted gem</li>
<li><strong>Store keys</strong> in Rails credentials</li>
<li><strong>Deterministic</strong> for queryable fields</li>
<li><strong>Non-deterministic</strong> for maximum security</li>
<li><strong>Rotate keys</strong> periodically</li>
<li><strong>Encrypt</strong> SSN, credit cards, health data</li>
<li><strong>Never log</strong> encrypted fields</li>
<li><strong>Backup</strong> before key rotation</li>
<li><strong>Compliance</strong> - GDPR, HIPAA, PCI-DSS</li>
</ol>
<hr>
<h2>Question 115: How do you encrypt and store user passwords in Rails?</h2>
<h3>Answer</h3>
<p>Use <strong>has_secure_password</strong> which leverages <strong>bcrypt</strong> to hash passwords with salt. Passwords are never stored in plain text, only the bcrypt digest is saved.</p>
<hr>
<h3>has_secure_password</h3>
<p><strong>Setup:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;bcrypt&#39;

# Migration
class AddPasswordDigestToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :password_digest, :string, null: false
  end
end

# Model
class User &lt; ApplicationRecord
  has_secure_password
  
  validates :email, presence: true, uniqueness: true
end
</code></pre>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby"># Create user
user = User.create(
  email: &quot;alice@example.com&quot;,
  password: &quot;SecurePassword123&quot;,
  password_confirmation: &quot;SecurePassword123&quot;
)

# What happens:
# 1. Password hashed with bcrypt
# 2. Salt automatically generated
# 3. password_digest stored in database
# 4. Plain password NEVER stored

# Database:
# password_digest: &quot;$2a$12$abc123...&quot;
#                   ││ └─ hash
#                   │└─ salt
#                   └─ bcrypt version
</code></pre>
<hr>
<h3>Authentication</h3>
<p><strong>Authenticating users:</strong></p>
<pre><code class="language-ruby"># Find user and authenticate
user = User.find_by(email: params[:email])

if user&amp;.authenticate(params[:password])
  # Password correct - log in
  session[:user_id] = user.id
  redirect_to dashboard_path
else
  # Password incorrect
  flash[:error] = &quot;Invalid email or password&quot;
  render :new
end

# authenticate method:
# 1. Hashes provided password with stored salt
# 2. Compares with password_digest
# 3. Returns user if match, false if no match
</code></pre>
<hr>
<h3>Password Requirements</h3>
<p><strong>Validations:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_secure_password
  
  # Length validation
  validates :password, length: { minimum: 8 }, if: :password_required?
  
  # Custom complexity validation
  validate :password_complexity, if: :password_required?
  
  private
  
  def password_required?
    password_digest.blank? || password.present?
  end
  
  def password_complexity
    return if password.blank?
    
    unless password.match?(/[A-Z]/)
      errors.add :password, &#39;must include at least one uppercase letter&#39;
    end
    
    unless password.match?(/[a-z]/)
      errors.add :password, &#39;must include at least one lowercase letter&#39;
    end
    
    unless password.match?(/\d/)
      errors.add :password, &#39;must include at least one number&#39;
    end
    
    unless password.match?(/[!@#$%^&amp;*]/)
      errors.add :password, &#39;must include at least one special character&#39;
    end
  end
end
</code></pre>
<hr>
<h3>Password Reset</h3>
<p><strong>Complete flow:</strong></p>
<pre><code class="language-ruby"># 1. Generate reset token
class User &lt; ApplicationRecord
  has_secure_password
  
  def generate_password_reset_token
    self.reset_password_token = SecureRandom.urlsafe_base64
    self.reset_password_sent_at = Time.current
    save!
  end
  
  def password_reset_expired?
    reset_password_sent_at &lt; 2.hours.ago
  end
end

# 2. Request reset
class PasswordResetsController &lt; ApplicationController
  def create
    user = User.find_by(email: params[:email])
    
    if user
      user.generate_password_reset_token
      UserMailer.password_reset(user).deliver_later
    end
    
    # Always show same message (security)
    flash[:notice] = &quot;Password reset instructions sent&quot;
    redirect_to root_path
  end
  
  # 3. Reset form
  def edit
    @user = User.find_by(reset_password_token: params[:token])
    
    if @user.nil? || @user.password_reset_expired?
      flash[:error] = &quot;Password reset link is invalid or expired&quot;
      redirect_to new_password_reset_path
    end
  end
  
  # 4. Update password
  def update
    @user = User.find_by(reset_password_token: params[:token])
    
    if @user &amp;&amp; @user.update(password_params)
      @user.update(reset_password_token: nil, reset_password_sent_at: nil)
      flash[:success] = &quot;Password updated successfully&quot;
      redirect_to login_path
    else
      render :edit
    end
  end
  
  private
  
  def password_params
    params.require(:user).permit(:password, :password_confirmation)
  end
end
</code></pre>
<hr>
<h3>Password Change</h3>
<p><strong>Require current password:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_secure_password
  
  attr_accessor :current_password
  
  validate :current_password_valid, on: :update, if: :password_present?
  
  private
  
  def password_present?
    password.present?
  end
  
  def current_password_valid
    return if current_password.blank?
    
    unless authenticate(current_password)
      errors.add(:current_password, &#39;is incorrect&#39;)
    end
  end
end

# Controller
class PasswordsController &lt; ApplicationController
  def update
    if current_user.update(password_params)
      flash[:success] = &quot;Password changed successfully&quot;
      redirect_to profile_path
    else
      render :edit
    end
  end
  
  private
  
  def password_params
    params.require(:user).permit(
      :current_password,
      :password,
      :password_confirmation
    )
  end
end
</code></pre>
<hr>
<h3>Security Best Practices</h3>
<p><strong>1. Never log passwords:</strong></p>
<pre><code class="language-ruby"># config/initializers/filter_parameter_logging.rb
Rails.application.config.filter_parameters += [
  :password,
  :password_confirmation,
  :current_password
]

# Logs show [FILTERED] instead of actual password
</code></pre>
<p><strong>2. Rate limiting for login:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;rack-attack&#39;

# config/initializers/rack_attack.rb
Rack::Attack.throttle(&#39;limit logins per email&#39;, limit: 5, period: 60) do |req|
  if req.path == &#39;/login&#39; &amp;&amp; req.post?
    req.params[&#39;email&#39;]
  end
end

# Blocks after 5 failed attempts in 60 seconds
</code></pre>
<p><strong>3. Account lockout after failed attempts:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_secure_password
  
  def increment_failed_attempts
    self.failed_attempts ||= 0
    self.failed_attempts += 1
    self.locked_at = Time.current if failed_attempts &gt;= 5
    save(validate: false)
  end
  
  def reset_failed_attempts
    self.failed_attempts = 0
    self.locked_at = nil
    save(validate: false)
  end
  
  def locked?
    locked_at.present? &amp;&amp; locked_at &gt; 1.hour.ago
  end
end

# SessionsController
def create
  user = User.find_by(email: params[:email])
  
  if user&amp;.locked?
    flash[:error] = &quot;Account locked due to too many failed attempts&quot;
    render :new
  elsif user&amp;.authenticate(params[:password])
    user.reset_failed_attempts
    session[:user_id] = user.id
    redirect_to dashboard_path
  else
    user&amp;.increment_failed_attempts
    flash[:error] = &quot;Invalid email or password&quot;
    render :new
  end
end
</code></pre>
<hr>
<h3>Testing</h3>
<pre><code class="language-ruby">RSpec.describe User, type: :model do
  describe &#39;password encryption&#39; do
    it &#39;stores encrypted password_digest&#39; do
      user = User.create(
        email: &#39;test@example.com&#39;,
        password: &#39;Password123&#39;
      )
      
      expect(user.password_digest).to be_present
      expect(user.password_digest).not_to eq(&#39;Password123&#39;)
    end
    
    it &#39;authenticates with correct password&#39; do
      user = User.create(
        email: &#39;test@example.com&#39;,
        password: &#39;Password123&#39;
      )
      
      expect(user.authenticate(&#39;Password123&#39;)).to eq(user)
    end
    
    it &#39;fails authentication with wrong password&#39; do
      user = User.create(
        email: &#39;test@example.com&#39;,
        password: &#39;Password123&#39;
      )
      
      expect(user.authenticate(&#39;wrong&#39;)).to be false
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>has_secure_password</strong> for password storage</li>
<li><strong>bcrypt</strong> automatically handles salting</li>
<li><strong>Never store</strong> plain text passwords</li>
<li><strong>authenticate</strong> method checks passwords</li>
<li><strong>Password reset</strong> with time-limited tokens</li>
<li><strong>Require current</strong> password for changes</li>
<li><strong>Filter</strong> password from logs</li>
<li><strong>Rate limit</strong> login attempts</li>
<li><strong>Lock accounts</strong> after failed attempts</li>
<li><strong>Test</strong> authentication thoroughly</li>
</ol>
<h1>Sessions and Cookies Interview Questions</h1>
<h2>Question 116: What is the difference between session and cookies?</h2>
<h3>Answer</h3>
<p><strong>Cookies</strong> are small data stored in the <strong>browser</strong> and sent with every request. <strong>Sessions</strong> are server-side storage that uses a cookie to identify the user. Cookies are client-side, sessions are server-side.</p>
<hr>
<h3>Cookies (Client-Side)</h3>
<p><strong>What they are:</strong></p>
<pre><code class="language-ruby"># Set cookie (stored in browser)
cookies[:user_theme] = &#39;dark&#39;
cookies[:language] = { value: &#39;en&#39;, expires: 1.year.from_now }

# Browser stores:
# user_theme=dark
# language=en; expires=Tue, 01-Jan-2026 00:00:00 GMT

# Sent with EVERY request:
# GET /posts HTTP/1.1
# Cookie: user_theme=dark; language=en
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby"># Size limit: ~4KB per cookie
# Visible: User can see/edit in browser
# Sent: With every request to domain
# Lifetime: Can be permanent or session
# Security: Can be stolen/modified
# Storage: Client browser
</code></pre>
<hr>
<h3>Sessions (Server-Side)</h3>
<p><strong>What they are:</strong></p>
<pre><code class="language-ruby"># Set session (stored on server)
session[:user_id] = 123
session[:cart_items] = [1, 2, 3]

# Browser only stores session ID cookie:
# _myapp_session=abc123xyz789...

# Server stores actual data:
# { user_id: 123, cart_items: [1, 2, 3] }
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby"># Size limit: Depends on storage (typically MBs)
# Visible: User only sees session ID
# Sent: Only session ID cookie sent
# Lifetime: Usually expires with browser close
# Security: Data on server, safer
# Storage: Server (memory, database, cache)
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Cookies</th>
<th>Sessions</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Storage</strong></td>
<td>Browser (client)</td>
<td>Server</td>
</tr>
<tr>
<td><strong>Size limit</strong></td>
<td>~4KB per cookie</td>
<td>MBs (depends on store)</td>
</tr>
<tr>
<td><strong>Visibility</strong></td>
<td>User can see/edit</td>
<td>User only sees ID</td>
</tr>
<tr>
<td><strong>Sent with request</strong></td>
<td>Full data</td>
<td>Only session ID</td>
</tr>
<tr>
<td><strong>Lifetime</strong></td>
<td>Can be permanent</td>
<td>Usually browser session</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>Less secure</td>
<td>More secure</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Fast (no lookup)</td>
<td>Requires lookup</td>
</tr>
<tr>
<td><strong>Use for</strong></td>
<td>Preferences, tracking</td>
<td>Authentication, cart</td>
</tr>
</tbody></table>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use Cookies for:</strong></p>
<p>✅ <strong>User preferences</strong></p>
<pre><code class="language-ruby">cookies[:theme] = &#39;dark&#39;
cookies[:language] = &#39;en&#39;
cookies[:font_size] = &#39;large&#39;

# Doesn&#39;t need to be secret
# Can persist across sessions
# Small data
</code></pre>
<p>✅ <strong>Tracking/Analytics</strong></p>
<pre><code class="language-ruby">cookies[:visitor_id] = SecureRandom.uuid
cookies[:last_visit] = Time.current.to_s

# Track user behavior
# Across multiple sessions
</code></pre>
<p>✅ <strong>&quot;Remember me&quot; functionality</strong></p>
<pre><code class="language-ruby">cookies.permanent.encrypted[:remember_token] = user.remember_token

# Long-lived authentication
# Survives browser close
</code></pre>
<p><strong>Use Sessions for:</strong></p>
<p>✅ <strong>Authentication state</strong></p>
<pre><code class="language-ruby">session[:user_id] = user.id

# Security critical
# Should not be client-side
# Expires with browser
</code></pre>
<p>✅ <strong>Shopping cart</strong></p>
<pre><code class="language-ruby">session[:cart_items] = [1, 2, 3, 4, 5]

# Temporary data
# Can be large
# Not critical if lost
</code></pre>
<p>✅ <strong>Multi-step forms</strong></p>
<pre><code class="language-ruby">session[:registration_step] = 2
session[:registration_data] = { name: &quot;Alice&quot;, email: &quot;...&quot; }

# Temporary workflow state
# Not suitable for cookies (size)
</code></pre>
<hr>
<h3>Cookie Examples</h3>
<p><strong>Simple cookies:</strong></p>
<pre><code class="language-ruby">class PreferencesController &lt; ApplicationController
  def update
    cookies[:theme] = params[:theme]
    cookies[:language] = params[:language]
    
    redirect_back fallback_location: root_path
  end
end

# Reading:
@theme = cookies[:theme] || &#39;light&#39;
</code></pre>
<p><strong>Expiring cookies:</strong></p>
<pre><code class="language-ruby"># Expire in 1 year
cookies[:preference] = {
  value: &#39;dark&#39;,
  expires: 1.year.from_now
}

# Expire when browser closes (session cookie)
cookies[:temp_data] = &#39;value&#39;

# Permanent cookie (20 years)
cookies.permanent[:user_id] = &#39;123&#39;

# Delete cookie
cookies.delete(:preference)
</code></pre>
<p><strong>Encrypted cookies:</strong></p>
<pre><code class="language-ruby"># Encrypted (can&#39;t be read by user)
cookies.encrypted[:user_data] = { id: 123, role: &#39;admin&#39; }

# Reading:
user_data = cookies.encrypted[:user_data]
# =&gt; { id: 123, role: &#39;admin&#39; }

# User sees: encrypted blob in browser
</code></pre>
<p><strong>Signed cookies:</strong></p>
<pre><code class="language-ruby"># Signed (can be read but not modified)
cookies.signed[:user_id] = 123

# Reading:
user_id = cookies.signed[:user_id]
# =&gt; 123

# If user modifies cookie, reading returns nil
</code></pre>
<hr>
<h3>Session Examples</h3>
<p><strong>Setting session data:</strong></p>
<pre><code class="language-ruby">class SessionsController &lt; ApplicationController
  def create
    user = User.find_by(email: params[:email])
    
    if user&amp;.authenticate(params[:password])
      # Store user ID in session
      session[:user_id] = user.id
      redirect_to dashboard_path
    else
      flash[:error] = &quot;Invalid credentials&quot;
      render :new
    end
  end
  
  def destroy
    # Clear session
    session.delete(:user_id)
    # Or reset entire session:
    reset_session
    
    redirect_to root_path
  end
end
</code></pre>
<p><strong>Reading session data:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  def current_user
    @current_user ||= User.find_by(id: session[:user_id]) if session[:user_id]
  end
  
  helper_method :current_user
end
</code></pre>
<hr>
<h3>Security Considerations</h3>
<p><strong>Cookies security:</strong></p>
<pre><code class="language-ruby"># HTTP-only (can&#39;t be accessed by JavaScript)
cookies[:token] = {
  value: &#39;abc123&#39;,
  httponly: true
}

# Secure (only sent over HTTPS)
cookies[:token] = {
  value: &#39;abc123&#39;,
  secure: Rails.env.production?
}

# Same-site (CSRF protection)
cookies[:token] = {
  value: &#39;abc123&#39;,
  same_site: :lax  # or :strict
}

# All together:
cookies[:token] = {
  value: &#39;abc123&#39;,
  httponly: true,
  secure: Rails.env.production?,
  same_site: :lax,
  expires: 1.year.from_now
}
</code></pre>
<p><strong>Session security:</strong></p>
<pre><code class="language-ruby"># Session stored on server - more secure
session[:user_id] = user.id

# Even if attacker gets session ID cookie,
# they can&#39;t modify session data on server
</code></pre>
<hr>
<h3>Real-World Example</h3>
<p><strong>Authentication system:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  before_action :load_current_user
  
  private
  
  # Session for authentication (security critical)
  def load_current_user
    if session[:user_id]
      @current_user = User.find_by(id: session[:user_id])
    elsif cookies.encrypted[:remember_token]
      # Cookie for &quot;remember me&quot;
      user = User.find_by(remember_token: cookies.encrypted[:remember_token])
      if user
        session[:user_id] = user.id
        @current_user = user
      end
    end
  end
  
  helper_method :current_user
end

class SessionsController &lt; ApplicationController
  def create
    user = User.find_by(email: params[:email])
    
    if user&amp;.authenticate(params[:password])
      # Store user_id in session
      session[:user_id] = user.id
      
      # If &quot;remember me&quot; checked, set cookie
      if params[:remember_me] == &#39;1&#39;
        token = user.generate_remember_token
        cookies.permanent.encrypted[:remember_token] = token
      end
      
      redirect_to dashboard_path
    else
      render :new
    end
  end
  
  def destroy
    session.delete(:user_id)
    cookies.delete(:remember_token)
    redirect_to root_path
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Cookies</strong> - client-side, small, visible</li>
<li><strong>Sessions</strong> - server-side, large, secure</li>
<li><strong>Cookies</strong> for preferences, tracking</li>
<li><strong>Sessions</strong> for authentication, cart</li>
<li><strong>Cookies</strong> ~4KB limit</li>
<li><strong>Sessions</strong> MB+ limit</li>
<li><strong>Cookies</strong> can be permanent</li>
<li><strong>Sessions</strong> usually temporary</li>
<li><strong>Security</strong> - sessions more secure</li>
<li><strong>Use both</strong> for different purposes</li>
</ol>
<hr>
<h2>Question 117: How does Rails handle sessions and cookies?</h2>
<h3>Answer</h3>
<p>Rails provides <strong>high-level APIs</strong> for both sessions and cookies, with <strong>automatic encryption</strong>, <strong>security features</strong>, and <strong>multiple storage backends</strong>. Both are accessed through <code>session[]</code> and <code>cookies[]</code> helpers.</p>
<hr>
<h3>Session Handling</h3>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-ruby">class SessionsController &lt; ApplicationController
  def create
    # Set session data
    session[:user_id] = user.id
    session[:last_login] = Time.current
    
    # Session automatically saved at end of request
  end
  
  def show
    # Read session data
    user_id = session[:user_id]
    last_login = session[:last_login]
  end
  
  def destroy
    # Delete specific key
    session.delete(:user_id)
    
    # Or clear entire session
    reset_session
  end
end
</code></pre>
<p><strong>Session operations:</strong></p>
<pre><code class="language-ruby"># Set value
session[:key] = &#39;value&#39;

# Get value
value = session[:key]

# Check existence
session.key?(:key)  # =&gt; true/false

# Delete key
session.delete(:key)

# Clear all
reset_session

# Get all keys
session.keys  # =&gt; [:user_id, :cart_items]

# Get session ID
session.id  # =&gt; &quot;abc123...&quot;
</code></pre>
<hr>
<h3>Cookie Handling</h3>
<p><strong>Basic usage:</strong></p>
<pre><code class="language-ruby">class PreferencesController &lt; ApplicationController
  def update
    # Set cookie
    cookies[:theme] = params[:theme]
    
    # Set with options
    cookies[:language] = {
      value: params[:language],
      expires: 1.year.from_now,
      domain: &#39;.example.com&#39;
    }
  end
  
  def show
    # Read cookie
    theme = cookies[:theme]
  end
  
  def destroy
    # Delete cookie
    cookies.delete(:theme)
  end
end
</code></pre>
<p><strong>Cookie types:</strong></p>
<pre><code class="language-ruby"># Regular cookie (plain text)
cookies[:name] = &#39;value&#39;

# Permanent cookie (20 years)
cookies.permanent[:name] = &#39;value&#39;

# Signed cookie (tamper-proof)
cookies.signed[:user_id] = 123
value = cookies.signed[:user_id]  # =&gt; 123

# Encrypted cookie (confidential)
cookies.encrypted[:secret_data] = { key: &#39;value&#39; }
data = cookies.encrypted[:secret_data]  # =&gt; { key: &#39;value&#39; }

# Permanent + encrypted
cookies.permanent.encrypted[:remember_token] = token
</code></pre>
<hr>
<h3>Session Configuration</h3>
<p><strong>config/initializers/session_store.rb:</strong></p>
<pre><code class="language-ruby">Rails.application.config.session_store :cookie_store,
  key: &#39;_myapp_session&#39;,              # Cookie name
  expire_after: 2.weeks,              # Session lifetime
  secure: Rails.env.production?,      # HTTPS only in production
  httponly: true,                     # Not accessible via JavaScript
  same_site: :lax                     # CSRF protection
</code></pre>
<hr>
<h3>Cookie Configuration</h3>
<p><strong>Cookie options:</strong></p>
<pre><code class="language-ruby">cookies[:name] = {
  value: &#39;value&#39;,
  
  # Expiration
  expires: 1.year.from_now,          # Absolute time
  max_age: 3600,                     # Seconds from now
  
  # Domain/Path
  domain: &#39;.example.com&#39;,            # Available to subdomains
  path: &#39;/admin&#39;,                    # Only /admin paths
  
  # Security
  secure: true,                      # HTTPS only
  httponly: true,                    # No JavaScript access
  same_site: :lax                    # CSRF protection
}
</code></pre>
<p><strong>Domain examples:</strong></p>
<pre><code class="language-ruby"># Only www.example.com
cookies[:name] = { value: &#39;val&#39;, domain: &#39;www.example.com&#39; }

# All subdomains (*.example.com)
cookies[:name] = { value: &#39;val&#39;, domain: &#39;.example.com&#39; }

# Current domain only (default)
cookies[:name] = &#39;val&#39;
</code></pre>
<hr>
<h3>Flash Messages (Special Session)</h3>
<p><strong>Flash for one-time messages:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    if @post.save
      flash[:notice] = &#39;Post created successfully&#39;
      redirect_to @post
    else
      flash.now[:error] = &#39;Failed to create post&#39;
      render :new
    end
  end
end

# View:
&lt;% if flash[:notice] %&gt;
  &lt;div class=&quot;alert alert-success&quot;&gt;&lt;%= flash[:notice] %&gt;&lt;/div&gt;
&lt;% end %&gt;

&lt;% if flash[:error] %&gt;
  &lt;div class=&quot;alert alert-danger&quot;&gt;&lt;%= flash[:error] %&gt;&lt;/div&gt;
&lt;% end %&gt;

# Flash persists for redirect but not for render
</code></pre>
<p><strong>Flash types:</strong></p>
<pre><code class="language-ruby"># Standard flash (persists for next request)
flash[:notice] = &#39;Success&#39;

# flash.now (only current request)
flash.now[:error] = &#39;Error&#39;

# Keep flash for one more request
flash.keep

# Keep specific key
flash.keep(:notice)

# Discard flash
flash.discard
</code></pre>
<hr>
<h3>Session Security</h3>
<p><strong>Encryption:</strong></p>
<pre><code class="language-ruby"># Rails automatically encrypts session cookies
# Uses secret_key_base from credentials

# config/credentials.yml.enc
secret_key_base: abc123...

# Session cookie is encrypted and signed
# User cannot read or modify
</code></pre>
<p><strong>Session fixation protection:</strong></p>
<pre><code class="language-ruby"># Rails automatically rotates session ID on login
def create
  user = User.find_by(email: params[:email])
  
  if user&amp;.authenticate(params[:password])
    # Old session ID discarded
    reset_session
    
    # New session ID generated
    session[:user_id] = user.id
  end
end
</code></pre>
<hr>
<h3>Testing Sessions and Cookies</h3>
<p><strong>RSpec:</strong></p>
<pre><code class="language-ruby">RSpec.describe SessionsController, type: :controller do
  describe &#39;POST #create&#39; do
    it &#39;sets session user_id&#39; do
      user = create(:user)
      post :create, params: { 
        email: user.email, 
        password: &#39;password&#39; 
      }
      
      expect(session[:user_id]).to eq(user.id)
    end
  end
  
  describe &#39;DELETE #destroy&#39; do
    it &#39;clears session&#39; do
      session[:user_id] = 123
      delete :destroy
      
      expect(session[:user_id]).to be_nil
    end
  end
end

RSpec.describe PreferencesController, type: :controller do
  describe &#39;POST #update&#39; do
    it &#39;sets theme cookie&#39; do
      post :update, params: { theme: &#39;dark&#39; }
      
      expect(cookies[:theme]).to eq(&#39;dark&#39;)
    end
  end
end
</code></pre>
<p><strong>System tests:</strong></p>
<pre><code class="language-ruby">RSpec.describe &#39;User login&#39;, type: :system do
  it &#39;sets session cookie on login&#39; do
    user = create(:user)
    
    visit login_path
    fill_in &#39;Email&#39;, with: user.email
    fill_in &#39;Password&#39;, with: &#39;password&#39;
    click_button &#39;Log in&#39;
    
    # Session cookie automatically set
    expect(page).to have_content(&#39;Dashboard&#39;)
  end
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>✅ Use sessions for:</strong></p>
<pre><code class="language-ruby"># Authentication
session[:user_id] = user.id

# Shopping cart (temporary data)
session[:cart_items] = [1, 2, 3]

# Wizard/multi-step forms
session[:step] = 2
session[:form_data] = { ... }
</code></pre>
<p><strong>✅ Use cookies for:</strong></p>
<pre><code class="language-ruby"># User preferences
cookies[:theme] = &#39;dark&#39;

# Analytics tracking
cookies[:visitor_id] = SecureRandom.uuid

# Remember me
cookies.permanent.encrypted[:remember_token] = token
</code></pre>
<p><strong>❌ Don&#39;t store in session:</strong></p>
<pre><code class="language-ruby"># Large objects
session[:entire_database] = ...  # BAD

# Sensitive data in plain cookies
cookies[:credit_card] = ...  # BAD (use encrypted)

# Data that must persist
session[:user_purchases] = ...  # Use database instead
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>session[]</strong> for server-side storage</li>
<li><strong>cookies[]</strong> for client-side storage</li>
<li><strong>Automatic encryption</strong> built-in</li>
<li><strong>Flash</strong> for one-time messages</li>
<li><strong>reset_session</strong> clears session</li>
<li><strong>cookies.encrypted</strong> for sensitive data</li>
<li><strong>httponly</strong> prevents JavaScript access</li>
<li><strong>secure</strong> for HTTPS only</li>
<li><strong>same_site</strong> for CSRF protection</li>
<li><strong>Test</strong> both sessions and cookies</li>
</ol>
<hr>
<h2>Question 118: What are the types of sessions available?</h2>
<h3>Answer</h3>
<p>Rails supports <strong>multiple session storage backends</strong>: <strong>CookieStore</strong> (default), <strong>CacheStore</strong>, <strong>ActiveRecordStore</strong>, <strong>MemCacheStore</strong>, and <strong>RedisStore</strong>. Each has different trade-offs for size, speed, and persistence.</p>
<hr>
<h3>1. CookieStore (Default)</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby"># config/initializers/session_store.rb
Rails.application.config.session_store :cookie_store,
  key: &#39;_myapp_session&#39;

# All session data stored in encrypted cookie
# Sent with every request
# No server-side storage needed
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">Pros:
✅ No server storage needed
✅ Fast (no database lookup)
✅ Stateless (scales horizontally)
✅ Encrypted by default

Cons:
❌ 4KB size limit
❌ Sent with every request (bandwidth)
❌ Can&#39;t invalidate individual sessions
❌ Data in client browser
</code></pre>
<p><strong>When to use:</strong></p>
<pre><code class="language-ruby"># Small session data
session[:user_id] = 123
session[:theme] = &#39;dark&#39;

# Most Rails apps (default choice)
# Good for horizontal scaling
# When session data &lt; 4KB
</code></pre>
<p><strong>When NOT to use:</strong></p>
<pre><code class="language-ruby"># Large session data
session[:shopping_cart] = 1000.times.map { |i| ... }  # Too big!

# Need to invalidate sessions server-side
# Store sensitive data (even encrypted)
</code></pre>
<hr>
<h3>2. CacheStore</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby"># config/initializers/session_store.rb
Rails.application.config.session_store :cache_store,
  key: &#39;_myapp_session&#39;,
  expire_after: 2.weeks

# Session data stored in Rails cache (Redis, Memcached, etc.)
# Session ID in cookie, data on cache server
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">Pros:
✅ Fast (in-memory)
✅ No size limit (reasonable)
✅ Can invalidate server-side
✅ Shared across app servers

Cons:
❌ Requires cache server
❌ Sessions can be evicted (LRU)
❌ Lost on cache restart (unless persisted)
</code></pre>
<p><strong>Setup:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.cache_store = :redis_cache_store, { url: ENV[&#39;REDIS_URL&#39;] }

# config/initializers/session_store.rb
Rails.application.config.session_store :cache_store,
  key: &#39;_myapp_session&#39;,
  expire_after: 2.weeks
</code></pre>
<p><strong>When to use:</strong></p>
<pre><code class="language-ruby"># Medium session data
session[:cart_items] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Multiple app servers
# Already using Redis/Memcached
# Need fast access
</code></pre>
<hr>
<h3>3. ActiveRecordStore</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;activerecord-session_store&#39;

# Generate migration
rails generate active_record:session_migration

# Migration creates:
create_table :sessions do |t|
  t.string :session_id, null: false
  t.text :data
  t.timestamps
end

add_index :sessions, :session_id, unique: true
add_index :sessions, :updated_at

# config/initializers/session_store.rb
Rails.application.config.session_store :active_record_store,
  key: &#39;_myapp_session&#39;
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">Pros:
✅ No size limit (large text field)
✅ Persistent (survives restart)
✅ Can query/invalidate sessions
✅ Audit trail (created_at, updated_at)

Cons:
❌ Slower (database lookup)
❌ Database load increases
❌ Need to clean up old sessions
</code></pre>
<p><strong>Cleanup old sessions:</strong></p>
<pre><code class="language-ruby"># Rake task
namespace :sessions do
  desc &quot;Clean up expired sessions&quot;
  task cleanup: :environment do
    ActiveRecord::SessionStore::Session
      .where(&quot;updated_at &lt; ?&quot;, 2.weeks.ago)
      .delete_all
  end
end

# Cron: 0 2 * * * cd /app &amp;&amp; rake sessions:cleanup
</code></pre>
<p><strong>When to use:</strong></p>
<pre><code class="language-ruby"># Large session data
session[:complex_wizard_data] = { ... }  # Many KBs

# Need to audit sessions
# Need to invalidate specific sessions
# Want persistence across restarts
</code></pre>
<hr>
<h3>4. MemCacheStore</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;dalli&#39;

# config/initializers/session_store.rb
Rails.application.config.session_store :mem_cache_store,
  memcache_server: ENV[&#39;MEMCACHE_SERVERS&#39;],
  key: &#39;_myapp_session&#39;,
  expire_after: 2.weeks
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">Pros:
✅ Very fast (in-memory)
✅ Distributed cache
✅ Scales horizontally

Cons:
❌ Sessions can be evicted (LRU)
❌ Lost on restart
❌ Requires Memcached servers
</code></pre>
<p><strong>When to use:</strong></p>
<pre><code class="language-ruby"># High traffic sites
# Already using Memcached
# Session data not critical
# Need distributed caching
</code></pre>
<hr>
<h3>5. RedisStore</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;redis-rails&#39;

# config/initializers/session_store.rb
Rails.application.config.session_store :redis_store,
  servers: ENV[&#39;REDIS_URL&#39;],
  key: &#39;_myapp_session&#39;,
  expire_after: 2.weeks
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">Pros:
✅ Fast (in-memory)
✅ Persistent (can persist to disk)
✅ Pub/sub for real-time invalidation
✅ Can store complex data structures

Cons:
❌ Requires Redis server
❌ More complex setup
</code></pre>
<p><strong>When to use:</strong></p>
<pre><code class="language-ruby"># Already using Redis
# Need persistence + speed
# Real-time features (Action Cable)
# Medium to large sessions
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Store</th>
<th>Speed</th>
<th>Size Limit</th>
<th>Persistence</th>
<th>Server Required</th>
<th>Best For</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CookieStore</strong></td>
<td>⚡⚡⚡ Fast</td>
<td>4KB</td>
<td>No</td>
<td>No</td>
<td>Small sessions, scaling</td>
</tr>
<tr>
<td><strong>CacheStore</strong></td>
<td>⚡⚡ Fast</td>
<td>~1MB</td>
<td>Depends</td>
<td>Yes (cache)</td>
<td>Medium sessions</td>
</tr>
<tr>
<td><strong>ActiveRecordStore</strong></td>
<td>⚡ Slower</td>
<td>~1MB+</td>
<td>Yes</td>
<td>No (uses DB)</td>
<td>Large sessions, audit</td>
</tr>
<tr>
<td><strong>MemCacheStore</strong></td>
<td>⚡⚡⚡ Fast</td>
<td>~1MB</td>
<td>No</td>
<td>Yes (Memcached)</td>
<td>High traffic</td>
</tr>
<tr>
<td><strong>RedisStore</strong></td>
<td>⚡⚡ Fast</td>
<td>~1MB+</td>
<td>Optional</td>
<td>Yes (Redis)</td>
<td>Persistence + speed</td>
</tr>
</tbody></table>
<hr>
<h3>Choosing the Right Store</h3>
<p><strong>Decision tree:</strong></p>
<pre><code>Session data size &lt; 4KB?
├─ Yes → CookieStore (default) ✅
└─ No ↓

Need persistence?
├─ Yes → ActiveRecordStore or RedisStore
└─ No ↓

Already using Redis/Memcached?
├─ Redis → RedisStore
├─ Memcached → MemCacheStore
└─ Neither → CacheStore (with memory store)
</code></pre>
<hr>
<h3>Hybrid Approach</h3>
<p><strong>Use database for users, cookies for guests:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  before_action :set_session_store
  
  private
  
  def set_session_store
    if current_user
      # Use database store for logged-in users
      request.session_options[:store] = :active_record_store
    else
      # Use cookie store for guests (faster)
      request.session_options[:store] = :cookie_store
    end
  end
end
</code></pre>
<hr>
<h3>Session Expiration</h3>
<p><strong>Configure expiration:</strong></p>
<pre><code class="language-ruby"># Cookie store
Rails.application.config.session_store :cookie_store,
  expire_after: 2.weeks

# ActiveRecord store (manual cleanup)
ActiveRecord::SessionStore::Session
  .where(&quot;updated_at &lt; ?&quot;, 2.weeks.ago)
  .delete_all

# Redis store (automatic TTL)
Rails.application.config.session_store :redis_store,
  expire_after: 2.weeks,
  ttl: 2.weeks
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>CookieStore</strong> - default, 4KB limit</li>
<li><strong>CacheStore</strong> - fast, needs cache server</li>
<li><strong>ActiveRecordStore</strong> - persistent, database</li>
<li><strong>MemCacheStore</strong> - very fast, volatile</li>
<li><strong>RedisStore</strong> - fast + persistent</li>
<li><strong>Choose</strong> based on size and requirements</li>
<li><strong>CookieStore</strong> for most apps</li>
<li><strong>ActiveRecordStore</strong> for large/auditable sessions</li>
<li><strong>RedisStore</strong> for persistence + speed</li>
<li><strong>Test</strong> session behavior</li>
</ol>
<hr>
<h2>Question 119: What is the difference between session storage and cache storage?</h2>
<h3>Answer</h3>
<p><strong>Session storage</strong> maintains user-specific state across requests for authentication and temporary data. <strong>Cache storage</strong> stores computed results to avoid expensive operations. Sessions are per-user and persistent, cache is shared and volatile.</p>
<hr>
<h3>Session Storage</h3>
<p><strong>Purpose:</strong></p>
<pre><code class="language-ruby"># Maintains user state across requests
session[:user_id] = 123
session[:cart_items] = [1, 2, 3]
session[:current_step] = 2

# User-specific
# Persists for session lifetime
# Required for stateful operations
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">Scope: Per-user (isolated)
Lifetime: Session duration (minutes to weeks)
Volatility: Persistent within session
Size: Small to medium (KB to MB)
Purpose: User state, authentication
Cleared: On logout or expiration
</code></pre>
<hr>
<h3>Cache Storage</h3>
<p><strong>Purpose:</strong></p>
<pre><code class="language-ruby"># Stores expensive computations
Rails.cache.fetch(&#39;trending_posts&#39;) do
  Post.trending.limit(10).to_a
end

# Shared across users
# Volatile (can be evicted)
# Performance optimization
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">Scope: Global (shared)
Lifetime: Configurable (seconds to forever)
Volatility: Can be evicted (LRU)
Size: Large (MB to GB)
Purpose: Performance, avoid recomputation
Cleared: Manually or automatically (LRU, expiration)
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Session Storage</th>
<th>Cache Storage</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Purpose</strong></td>
<td>User state</td>
<td>Performance optimization</td>
</tr>
<tr>
<td><strong>Scope</strong></td>
<td>Per-user</td>
<td>Shared (all users)</td>
</tr>
<tr>
<td><strong>Data</strong></td>
<td>User-specific</td>
<td>Computed results</td>
</tr>
<tr>
<td><strong>Lifetime</strong></td>
<td>Session duration</td>
<td>Short to medium</td>
</tr>
<tr>
<td><strong>Volatility</strong></td>
<td>Persistent</td>
<td>Can be evicted</td>
</tr>
<tr>
<td><strong>Size</strong></td>
<td>Small (KB-MB)</td>
<td>Large (MB-GB)</td>
</tr>
<tr>
<td><strong>Examples</strong></td>
<td>user_id, cart</td>
<td>trending_posts, stats</td>
</tr>
<tr>
<td><strong>Cleared</strong></td>
<td>Logout/expiration</td>
<td>Manual/LRU/expiration</td>
</tr>
</tbody></table>
<hr>
<h3>Session Storage Examples</h3>
<p><strong>Authentication:</strong></p>
<pre><code class="language-ruby"># Login
session[:user_id] = user.id

# Current user
@current_user = User.find(session[:user_id])

# Logout
session.delete(:user_id)

# Per-user, must persist across requests
</code></pre>
<p><strong>Shopping cart:</strong></p>
<pre><code class="language-ruby"># Add to cart
session[:cart_items] ||= []
session[:cart_items] &lt;&lt; product_id

# View cart
@cart_items = Product.find(session[:cart_items])

# User-specific, temporary
</code></pre>
<p><strong>Multi-step form:</strong></p>
<pre><code class="language-ruby"># Step 1
session[:registration_data] = { name: &quot;Alice&quot;, email: &quot;...&quot; }
session[:current_step] = 1

# Step 2
session[:registration_data][:address] = &quot;123 Main St&quot;
session[:current_step] = 2

# User&#39;s workflow state
</code></pre>
<hr>
<h3>Cache Storage Examples</h3>
<p><strong>Expensive queries:</strong></p>
<pre><code class="language-ruby"># Cache database query result
def trending_posts
  Rails.cache.fetch(&#39;trending_posts&#39;, expires_in: 1.hour) do
    Post.where(&#39;created_at &gt; ?&#39;, 1.week.ago)
        .order(views_count: :desc)
        .limit(10)
        .to_a
  end
end

# First call: queries database, stores in cache
# Subsequent calls: returns from cache (fast)
# All users see same data
</code></pre>
<p><strong>API responses:</strong></p>
<pre><code class="language-ruby">def weather_data
  Rails.cache.fetch(&quot;weather_#{city}&quot;, expires_in: 30.minutes) do
    WeatherAPI.get_weather(city)
  end
end

# Avoid repeated API calls
# Shared across all users
</code></pre>
<p><strong>Computed statistics:</strong></p>
<pre><code class="language-ruby">def user_statistics
  Rails.cache.fetch(&quot;user_stats&quot;, expires_in: 12.hours) do
    {
      total_users: User.count,
      active_users: User.where(active: true).count,
      premium_users: User.where(premium: true).count
    }
  end
end

# Expensive COUNT queries
# Recalculated every 12 hours
</code></pre>
<hr>
<h3>When Session as Cache Doesn&#39;t Work</h3>
<p><strong>❌ Don&#39;t use session for shared data:</strong></p>
<pre><code class="language-ruby"># BAD - each user has own copy
session[:trending_posts] = Post.trending.to_a

# If 1000 users, 1000 copies stored
# Wastes memory, not updated in real-time

# ✅ GOOD - use cache
Rails.cache.fetch(&#39;trending_posts&#39;) do
  Post.trending.to_a
end

# Single copy shared by all users
</code></pre>
<hr>
<h3>When Cache as Session Doesn&#39;t Work</h3>
<p><strong>❌ Don&#39;t use cache for user-specific data:</strong></p>
<pre><code class="language-ruby"># BAD - conflicts between users
Rails.cache.write(&#39;cart_items&#39;, [1, 2, 3])

# User A adds item 1, 2, 3
# User B adds item 4, 5
# User A&#39;s cart overwritten!

# ✅ GOOD - use session
session[:cart_items] = [1, 2, 3]

# Each user has separate cart
</code></pre>
<hr>
<h3>Hybrid: Cache + Sessions</h3>
<p><strong>User-specific cache:</strong></p>
<pre><code class="language-ruby">def user_dashboard_data
  cache_key = &quot;user_dashboard_#{current_user.id}&quot;
  
  Rails.cache.fetch(cache_key, expires_in: 5.minutes) do
    {
      recent_posts: current_user.posts.recent.limit(5),
      notifications: current_user.notifications.unread,
      stats: calculate_user_stats(current_user)
    }
  end
end

# Cached per-user
# Still benefits from caching
# User-specific key prevents conflicts
</code></pre>
<p><strong>Session with cache fallback:</strong></p>
<pre><code class="language-ruby">def shopping_cart
  # Try session first (fast)
  cart = session[:cart_items]
  return cart if cart.present?
  
  # Fall back to cache (for logged-in users)
  if current_user
    cache_key = &quot;cart_#{current_user.id}&quot;
    cart = Rails.cache.read(cache_key)
    session[:cart_items] = cart if cart
  end
  
  cart || []
end
</code></pre>
<hr>
<h3>Storage Backends</h3>
<p><strong>Session storage options:</strong></p>
<pre><code class="language-ruby"># Cookie (default)
config.session_store :cookie_store

# Database
config.session_store :active_record_store

# Redis
config.session_store :redis_store

# Memcached
config.session_store :mem_cache_store
</code></pre>
<p><strong>Cache storage options:</strong></p>
<pre><code class="language-ruby"># Memory (development)
config.cache_store = :memory_store

# File (development)
config.cache_store = :file_store, Rails.root.join(&#39;tmp/cache&#39;)

# Redis (production)
config.cache_store = :redis_cache_store, { url: ENV[&#39;REDIS_URL&#39;] }

# Memcached (production)
config.cache_store = :mem_cache_store
</code></pre>
<hr>
<h3>Real-World Example</h3>
<p><strong>E-commerce application:</strong></p>
<pre><code class="language-ruby">class ProductsController &lt; ApplicationController
  def show
    @product = Product.find(params[:id])
    
    # Cache: Product data (shared)
    @related_products = Rails.cache.fetch(
      &quot;related_products_#{@product.id}&quot;,
      expires_in: 1.hour
    ) do
      @product.related_products.limit(4).to_a
    end
    
    # Session: User&#39;s cart (user-specific)
    @cart_count = (session[:cart_items] || []).length
    
    # Session: Recently viewed (user-specific)
    session[:recently_viewed] ||= []
    session[:recently_viewed].unshift(@product.id)
    session[:recently_viewed] = session[:recently_viewed].first(10)
  end
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>Sessions:</strong></p>
<pre><code class="language-ruby">✅ Store: user_id, cart_items, preferences
✅ Keep small (&lt; 4KB for cookie store)
✅ User-specific data only
✅ Clear on logout
❌ Don&#39;t store: shared data, large objects
</code></pre>
<p><strong>Cache:</strong></p>
<pre><code class="language-ruby">✅ Store: expensive queries, API responses, computed data
✅ Set expiration times
✅ Shared data
✅ Invalidate on updates
❌ Don&#39;t store: user-specific critical data
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Sessions</strong> - user state</li>
<li><strong>Cache</strong> - performance optimization</li>
<li><strong>Sessions</strong> per-user</li>
<li><strong>Cache</strong> shared</li>
<li><strong>Sessions</strong> persistent</li>
<li><strong>Cache</strong> volatile</li>
<li><strong>Sessions</strong> small</li>
<li><strong>Cache</strong> large</li>
<li><strong>Use sessions</strong> for user state</li>
<li><strong>Use cache</strong> for expensive operations</li>
</ol>
<h1>Background Jobs Interview Questions</h1>
<h2>Question 120: Explain Active Jobs and background jobs</h2>
<h3>Answer</h3>
<p><strong>ActiveJob</strong> is Rails&#39; framework for declaring and executing background jobs. It provides a unified interface across different queuing backends (Sidekiq, Resque, Delayed Job). Background jobs move time-consuming tasks out of the request-response cycle for better performance.</p>
<hr>
<h3>Why Background Jobs?</h3>
<p><strong>Without background jobs (slow):</strong></p>
<pre><code class="language-ruby">class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params)
    
    if @user.save
      # These all block the request:
      UserMailer.welcome(@user).deliver_now    # 2 seconds
      SlackNotifier.notify_new_user(@user)     # 1 second
      CrmService.sync_user(@user)              # 3 seconds
      
      # User waits 6 seconds for response!
      redirect_to @user
    end
  end
end
</code></pre>
<p><strong>With background jobs (fast):</strong></p>
<pre><code class="language-ruby">class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params)
    
    if @user.save
      # Queue jobs for later processing:
      UserMailer.welcome(@user).deliver_later     # Instant
      NotifySlackJob.perform_later(@user)         # Instant
      SyncCrmJob.perform_later(@user.id)          # Instant
      
      # User gets immediate response!
      redirect_to @user
    end
  end
end
</code></pre>
<hr>
<h3>ActiveJob Basics</h3>
<p><strong>Creating a job:</strong></p>
<pre><code class="language-ruby"># app/jobs/example_job.rb
class ExampleJob &lt; ApplicationJob
  queue_as :default
  
  def perform(user_id, options = {})
    user = User.find(user_id)
    # Do work here
    process_user(user)
  end
end

# Enqueue the job
ExampleJob.perform_later(user.id)
</code></pre>
<p><strong>Job anatomy:</strong></p>
<pre><code class="language-ruby">class ProcessOrderJob &lt; ApplicationJob
  # Queue name (priority)
  queue_as :high_priority
  
  # Retry configuration
  retry_on NetworkError, wait: 5.seconds, attempts: 3
  discard_on ActiveJob::DeserializationError
  
  # Timeout
  around_perform do |job, block|
    Timeout.timeout(5.minutes) do
      block.call
    end
  end
  
  # Main logic
  def perform(order)
    order.process_payment
    order.fulfill
    order.send_confirmation
  end
end
</code></pre>
<hr>
<h3>Enqueueing Jobs</h3>
<p><strong>Immediate execution:</strong></p>
<pre><code class="language-ruby"># Enqueue now
ProcessOrderJob.perform_later(order)

# Enqueue with delay
ProcessOrderJob.set(wait: 5.minutes).perform_later(order)

# Enqueue at specific time
ProcessOrderJob.set(wait_until: Date.tomorrow.noon).perform_later(order)

# Set queue dynamically
ProcessOrderJob.set(queue: :urgent).perform_later(order)
</code></pre>
<p><strong>Multiple ways to enqueue:</strong></p>
<pre><code class="language-ruby"># Method 1: perform_later
ProcessOrderJob.perform_later(order)

# Method 2: set + perform_later
ProcessOrderJob.set(wait: 1.hour).perform_later(order)

# Method 3: Manual instantiation
job = ProcessOrderJob.new(order)
job.enqueue(wait: 30.minutes)
</code></pre>
<hr>
<h3>Queue Priorities</h3>
<p><strong>Defining queues:</strong></p>
<pre><code class="language-ruby">class ApplicationJob &lt; ActiveJob::Base
  queue_as :default
end

class UrgentJob &lt; ApplicationJob
  queue_as :urgent
end

class LowPriorityJob &lt; ApplicationJob
  queue_as :low_priority
end

# config/application.rb
config.active_job.queue_name_prefix = &quot;myapp_#{Rails.env}&quot;
# Results in: myapp_production_urgent, myapp_production_default
</code></pre>
<hr>
<h3>Job Callbacks</h3>
<p><strong>Lifecycle hooks:</strong></p>
<pre><code class="language-ruby">class ProcessOrderJob &lt; ApplicationJob
  before_enqueue do |job|
    # Before job is queued
    Rails.logger.info &quot;About to enqueue job for order #{job.arguments.first.id}&quot;
  end
  
  around_enqueue do |job, block|
    # Wrap enqueuing
    start_time = Time.current
    block.call
    duration = Time.current - start_time
    Rails.logger.info &quot;Enqueued in #{duration}ms&quot;
  end
  
  after_enqueue do |job|
    # After job is queued
    Metrics.increment(&#39;jobs.enqueued&#39;)
  end
  
  before_perform do |job|
    # Before job executes
    Rails.logger.info &quot;Starting job #{job.job_id}&quot;
  end
  
  around_perform do |job, block|
    # Wrap execution
    Timeout.timeout(5.minutes) do
      block.call
    end
  end
  
  after_perform do |job|
    # After job completes
    Metrics.increment(&#39;jobs.completed&#39;)
  end
  
  def perform(order)
    # Job logic
  end
end
</code></pre>
<hr>
<h3>Error Handling</h3>
<p><strong>Retry strategies:</strong></p>
<pre><code class="language-ruby">class ProcessPaymentJob &lt; ApplicationJob
  # Retry on specific exceptions
  retry_on NetworkError, wait: 5.seconds, attempts: 3
  retry_on Timeout::Error, wait: :exponentially_longer, attempts: 5
  
  # Discard on unrecoverable errors
  discard_on ActiveRecord::RecordNotFound
  discard_on InvalidPaymentMethod
  
  # Custom retry logic
  retry_on PaymentGatewayError, wait: -&gt;(executions) { executions * 10 }
  
  def perform(payment_id)
    payment = Payment.find(payment_id)
    payment.process!
  end
end
</code></pre>
<p><strong>Manual error handling:</strong></p>
<pre><code class="language-ruby">class ResilientJob &lt; ApplicationJob
  def perform(user_id)
    user = User.find(user_id)
    process_user(user)
  rescue StandardError =&gt; e
    # Log error
    Rails.logger.error &quot;Job failed: #{e.message}&quot;
    
    # Notify monitoring service
    Sentry.capture_exception(e)
    
    # Retry manually
    retry_job(wait: 5.minutes) if executions &lt; 3
  end
end
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong>1. Sending emails:</strong></p>
<pre><code class="language-ruby"># Instead of:
UserMailer.welcome(user).deliver_now  # Blocks request

# Use:
UserMailer.welcome(user).deliver_later  # Background job

# With delay:
UserMailer.welcome(user).deliver_later(wait: 5.minutes)
</code></pre>
<p><strong>2. Processing uploads:</strong></p>
<pre><code class="language-ruby">class ProcessUploadJob &lt; ApplicationJob
  queue_as :uploads
  
  def perform(upload_id)
    upload = Upload.find(upload_id)
    
    # Process file
    image = MiniMagick::Image.open(upload.file.path)
    image.resize &#39;800x600&#39;
    image.write(upload.processed_path)
    
    # Generate thumbnails
    generate_thumbnails(upload)
    
    # Update status
    upload.update(status: &#39;processed&#39;)
  end
end

# Enqueue after upload
upload = Upload.create(file: params[:file])
ProcessUploadJob.perform_later(upload.id)
</code></pre>
<p><strong>3. API integrations:</strong></p>
<pre><code class="language-ruby">class SyncToExternalServiceJob &lt; ApplicationJob
  queue_as :integrations
  
  retry_on NetworkError, wait: 5.seconds, attempts: 5
  
  def perform(user_id)
    user = User.find(user_id)
    
    response = HTTParty.post(
      &#39;https://api.external.com/users&#39;,
      body: user.to_json,
      headers: { &#39;Authorization&#39;: &quot;Bearer #{ENV[&#39;API_TOKEN&#39;]}&quot; }
    )
    
    if response.success?
      user.update(synced_at: Time.current)
    else
      raise ExternalServiceError, response.body
    end
  end
end
</code></pre>
<p><strong>4. Scheduled tasks:</strong></p>
<pre><code class="language-ruby">class DailyReportJob &lt; ApplicationJob
  queue_as :reports
  
  def perform
    users = User.where(premium: true)
    
    users.find_each do |user|
      ReportMailer.daily_summary(user).deliver_later
    end
  end
end

# Schedule with cron
# config/schedule.rb (using whenever gem)
every 1.day, at: &#39;6:00 am&#39; do
  runner &quot;DailyReportJob.perform_later&quot;
end
</code></pre>
<p><strong>5. Data cleanup:</strong></p>
<pre><code class="language-ruby">class CleanupOldRecordsJob &lt; ApplicationJob
  queue_as :maintenance
  
  def perform
    # Delete old sessions
    ActiveRecord::SessionStore::Session
      .where(&#39;updated_at &lt; ?&#39;, 30.days.ago)
      .delete_all
    
    # Archive old orders
    Order.where(&#39;created_at &lt; ?&#39;, 1.year.ago)
         .find_each { |order| order.archive! }
  end
end
</code></pre>
<hr>
<h3>Testing Jobs</h3>
<p><strong>RSpec:</strong></p>
<pre><code class="language-ruby">RSpec.describe ProcessOrderJob, type: :job do
  describe &#39;#perform&#39; do
    let(:order) { create(:order) }
    
    it &#39;processes the order&#39; do
      expect {
        ProcessOrderJob.perform_now(order)
      }.to change { order.reload.status }.to(&#39;processed&#39;)
    end
    
    it &#39;enqueues the job&#39; do
      expect {
        ProcessOrderJob.perform_later(order)
      }.to have_enqueued_job(ProcessOrderJob).with(order)
    end
    
    it &#39;retries on network error&#39; do
      allow_any_instance_of(Order).to receive(:process!)
        .and_raise(NetworkError)
      
      expect {
        ProcessOrderJob.perform_now(order)
      }.to raise_error(NetworkError)
      
      expect(ProcessOrderJob).to have_been_enqueued.exactly(1).times
    end
  end
end
</code></pre>
<hr>
<h3>Backend Adapters</h3>
<p><strong>Supported backends:</strong></p>
<pre><code class="language-ruby"># config/application.rb

# Async (development - in-process)
config.active_job.queue_adapter = :async

# Inline (testing - no queue)
config.active_job.queue_adapter = :inline

# Sidekiq (production)
config.active_job.queue_adapter = :sidekiq

# Resque
config.active_job.queue_adapter = :resque

# Delayed Job
config.active_job.queue_adapter = :delayed_job

# Sucker Punch (in-process threads)
config.active_job.queue_adapter = :sucker_punch
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>ActiveJob</strong> - Rails&#39; job framework</li>
<li><strong>perform_later</strong> - enqueue job</li>
<li><strong>Queue names</strong> for priorities</li>
<li><strong>Retry</strong> on failures</li>
<li><strong>Callbacks</strong> for lifecycle</li>
<li><strong>Common uses</strong> - emails, uploads, API calls</li>
<li><strong>Test</strong> job behavior</li>
<li><strong>Backend agnostic</strong> - works with Sidekiq, Resque, etc.</li>
<li><strong>Move slow work</strong> out of requests</li>
<li><strong>Improves</strong> user experience</li>
</ol>
<hr>
<h2>Question 121: What are the types of background jobs?</h2>
<h3>Answer</h3>
<p>Background jobs fall into <strong>four main types</strong>: <strong>Immediate</strong> (ASAP), <strong>Delayed</strong> (scheduled), <strong>Recurring</strong> (periodic), and <strong>Batch</strong> (multiple related jobs). Each serves different use cases and scheduling needs.</p>
<hr>
<h3>1. Immediate Jobs (Fire and Forget)</h3>
<p><strong>Execute ASAP:</strong></p>
<pre><code class="language-ruby"># Enqueue immediately
ProcessOrderJob.perform_later(order)

# Use cases:
# - Send welcome email
# - Process file upload
# - Sync to external service
# - Update search index

class WelcomeEmailJob &lt; ApplicationJob
  queue_as :high_priority
  
  def perform(user_id)
    user = User.find(user_id)
    UserMailer.welcome(user).deliver_now
  end
end

# Enqueue when user signs up
user = User.create(user_params)
WelcomeEmailJob.perform_later(user.id)
</code></pre>
<hr>
<h3>2. Delayed Jobs (Scheduled)</h3>
<p><strong>Execute at specific time:</strong></p>
<pre><code class="language-ruby"># Delay by duration
SendReminderJob.set(wait: 1.hour).perform_later(user)

# Schedule for specific time
SendReminderJob.set(wait_until: Date.tomorrow.noon).perform_later(user)

# Use cases:
# - Reminder emails
# - Trial expiration warnings
# - Delayed notifications
# - Follow-up surveys

class TrialExpiringJob &lt; ApplicationJob
  queue_as :notifications
  
  def perform(user_id)
    user = User.find(user_id)
    
    if user.trial_expires_in?(3.days)
      UserMailer.trial_expiring_soon(user).deliver_now
    end
  end
end

# Schedule when user starts trial
user.update(trial_ends_at: 7.days.from_now)
TrialExpiringJob.set(wait: 4.days).perform_later(user.id)
</code></pre>
<hr>
<h3>3. Recurring Jobs (Periodic/Cron)</h3>
<p><strong>Execute on schedule:</strong></p>
<pre><code class="language-ruby"># Using whenever gem
# Gemfile
gem &#39;whenever&#39;, require: false

# config/schedule.rb
every 1.day, at: &#39;6:00 am&#39; do
  runner &quot;DailySummaryJob.perform_later&quot;
end

every 1.hour do
  runner &quot;CleanupExpiredSessionsJob.perform_later&quot;
end

every :monday, at: &#39;9:00 am&#39; do
  runner &quot;WeeklyReportJob.perform_later&quot;
end

# Use cases:
# - Daily reports
# - Data cleanup
# - Cache warming
# - Subscription renewals
# - Analytics aggregation

class DailySummaryJob &lt; ApplicationJob
  queue_as :reports
  
  def perform
    User.where(daily_summary: true).find_each do |user|
      summary = generate_summary(user)
      UserMailer.daily_summary(user, summary).deliver_now
    end
  end
end
</code></pre>
<p><strong>Alternative: Sidekiq-Cron:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;sidekiq-cron&#39;

# config/schedule.yml
daily_summary:
  cron: &quot;0 6 * * *&quot;
  class: &quot;DailySummaryJob&quot;
  queue: reports

cleanup_sessions:
  cron: &quot;0 * * * *&quot;  # Every hour
  class: &quot;CleanupSessionsJob&quot;
  queue: maintenance

# Or in Ruby:
Sidekiq::Cron::Job.create(
  name: &#39;Daily Summary&#39;,
  cron: &#39;0 6 * * *&#39;,
  class: &#39;DailySummaryJob&#39;
)
</code></pre>
<hr>
<h3>4. Batch Jobs (Multiple Related Jobs)</h3>
<p><strong>Process multiple items:</strong></p>
<pre><code class="language-ruby"># Simple batch
users = User.where(active: true)
users.find_each do |user|
  SendNewsletterJob.perform_later(user.id)
end

# Using Sidekiq Batch
class BulkNotificationJob &lt; ApplicationJob
  def perform(user_ids)
    batch = Sidekiq::Batch.new
    batch.description = &#39;Bulk Notifications&#39;
    batch.on(:complete, self.class, &#39;batch_complete&#39;)
    
    batch.jobs do
      user_ids.each do |user_id|
        SendNotificationJob.perform_later(user_id)
      end
    end
  end
  
  def self.batch_complete(status, options)
    Rails.logger.info &quot;Batch completed: #{status.total} jobs&quot;
  end
end

# Use cases:
# - Bulk email campaigns
# - Mass data migrations
# - Batch exports
# - Multiple file processing
</code></pre>
<hr>
<h3>5. Chained Jobs (Sequential)</h3>
<p><strong>Jobs that depend on others:</strong></p>
<pre><code class="language-ruby">class ProcessImageJob &lt; ApplicationJob
  def perform(image_id)
    image = Image.find(image_id)
    
    # Process image
    processed_path = ImageProcessor.process(image)
    image.update(processed_path: processed_path)
    
    # Chain next job
    GenerateThumbnailsJob.perform_later(image.id)
  end
end

class GenerateThumbnailsJob &lt; ApplicationJob
  def perform(image_id)
    image = Image.find(image_id)
    
    # Generate thumbnails
    ThumbnailGenerator.generate(image)
    
    # Chain next job
    NotifyUserJob.perform_later(image.user_id)
  end
end

# Use cases:
# - Multi-step processing
# - Dependent operations
# - Workflow execution
</code></pre>
<hr>
<h3>6. Priority Jobs</h3>
<p><strong>Different urgency levels:</strong></p>
<pre><code class="language-ruby">class UrgentJob &lt; ApplicationJob
  queue_as :urgent  # Processed first
  
  def perform(payment_id)
    Payment.find(payment_id).process!
  end
end

class NormalJob &lt; ApplicationJob
  queue_as :default  # Normal priority
  
  def perform(order_id)
    Order.find(order_id).fulfill
  end
end

class LowPriorityJob &lt; ApplicationJob
  queue_as :low_priority  # Processed last
  
  def perform
    cleanup_old_logs
  end
end

# Queue processing order:
# urgent &gt; default &gt; low_priority
</code></pre>
<hr>
<h3>7. Unique Jobs (Prevent Duplicates)</h3>
<p><strong>Ensure job runs only once:</strong></p>
<pre><code class="language-ruby"># Using Sidekiq Enterprise
class UniqueJob &lt; ApplicationJob
  sidekiq_options lock: :until_executed, 
                   unique_for: 10.minutes
  
  def perform(user_id)
    # Only one job per user in 10 minutes
    expensive_operation(user_id)
  end
end

# Using custom logic
class ProcessUserJob &lt; ApplicationJob
  def perform(user_id)
    lock_key = &quot;process_user_#{user_id}&quot;
    
    Redis.current.set(lock_key, &#39;1&#39;, ex: 5.minutes, nx: true) do
      # Job executes only if lock acquired
      User.find(user_id).process!
    end
  end
end
</code></pre>
<hr>
<h3>Job Type Comparison</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Timing</th>
<th>Frequency</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Immediate</strong></td>
<td>ASAP</td>
<td>Once</td>
<td>Welcome email</td>
</tr>
<tr>
<td><strong>Delayed</strong></td>
<td>Scheduled</td>
<td>Once</td>
<td>Trial reminder</td>
</tr>
<tr>
<td><strong>Recurring</strong></td>
<td>Periodic</td>
<td>Repeated</td>
<td>Daily report</td>
</tr>
<tr>
<td><strong>Batch</strong></td>
<td>ASAP</td>
<td>Multiple</td>
<td>Bulk emails</td>
</tr>
<tr>
<td><strong>Chained</strong></td>
<td>Sequential</td>
<td>Once</td>
<td>Image processing</td>
</tr>
<tr>
<td><strong>Priority</strong></td>
<td>ASAP</td>
<td>Once</td>
<td>Payment processing</td>
</tr>
<tr>
<td><strong>Unique</strong></td>
<td>ASAP</td>
<td>Once (dedupe)</td>
<td>Cache warming</td>
</tr>
</tbody></table>
<hr>
<h3>Real-World Example: E-commerce Order</h3>
<pre><code class="language-ruby">class OrderWorkflow
  def self.process(order)
    # 1. Immediate: Process payment
    ProcessPaymentJob.perform_later(order.id)
    
    # 2. Delayed: Send confirmation after payment clears
    SendConfirmationJob.set(wait: 5.minutes).perform_later(order.id)
    
    # 3. Chained: Fulfill order
    FulfillOrderJob.set(wait: 10.minutes).perform_later(order.id)
    
    # 4. Delayed: Request review after delivery
    RequestReviewJob.set(wait: 7.days).perform_later(order.id)
  end
end

class ProcessPaymentJob &lt; ApplicationJob
  queue_as :urgent  # Priority
  retry_on PaymentError, wait: 5.seconds, attempts: 3
  
  def perform(order_id)
    order = Order.find(order_id)
    order.process_payment!
  end
end

class FulfillOrderJob &lt; ApplicationJob
  queue_as :default
  
  def perform(order_id)
    order = Order.find(order_id)
    
    if order.paid?
      order.items.each do |item|
        WarehouseJob.perform_later(item.id)
      end
    end
  end
end

# Recurring: Check payment status
# config/schedule.rb
every 1.hour do
  runner &quot;CheckPendingPaymentsJob.perform_later&quot;
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Immediate</strong> - execute ASAP</li>
<li><strong>Delayed</strong> - scheduled for later</li>
<li><strong>Recurring</strong> - periodic execution</li>
<li><strong>Batch</strong> - process multiple items</li>
<li><strong>Chained</strong> - sequential dependencies</li>
<li><strong>Priority</strong> - different urgency levels</li>
<li><strong>Unique</strong> - prevent duplicates</li>
<li><strong>Choose type</strong> based on requirements</li>
<li><strong>Combine types</strong> for workflows</li>
<li><strong>Monitor</strong> job execution</li>
</ol>
<hr>
<h2>Question 122: What is Sidekiq, and how do you use it?</h2>
<h3>Answer</h3>
<p><strong>Sidekiq</strong> is a background job processor for Ruby that uses threads for concurrent processing. It&#39;s faster and more efficient than alternatives, integrates seamlessly with ActiveJob, and provides a web UI for monitoring.</p>
<hr>
<h3>Why Sidekiq?</h3>
<p><strong>Comparison:</strong></p>
<pre><code class="language-ruby"># Sidekiq
- Multi-threaded (25 threads by default)
- Redis-backed
- Fast (thousands of jobs/second)
- Low memory footprint
- Web UI included
- Pro/Enterprise versions available

# vs Delayed Job
- Single process
- Database-backed
- Slower
- Higher memory usage

# vs Resque
- Multi-process (fork per job)
- Redis-backed
- More memory usage
- Simpler architecture
</code></pre>
<hr>
<h3>Setup</h3>
<p><strong>Installation:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;sidekiq&#39;

# Install
bundle install

# Generate config
# config/sidekiq.yml
:concurrency: 5
:queues:
  - [urgent, 2]
  - [default, 1]
  - [low_priority, 1]
</code></pre>
<p><strong>Rails configuration:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.active_job.queue_adapter = :sidekiq

# config/initializers/sidekiq.rb
Sidekiq.configure_server do |config|
  config.redis = { url: ENV[&#39;REDIS_URL&#39;] }
end

Sidekiq.configure_client do |config|
  config.redis = { url: ENV[&#39;REDIS_URL&#39;] }
end
</code></pre>
<hr>
<h3>Creating Jobs</h3>
<p><strong>Basic job:</strong></p>
<pre><code class="language-ruby">class HardWorker
  include Sidekiq::Worker
  
  def perform(user_id, count)
    user = User.find(user_id)
    # Do work
    process_user(user, count)
  end
end

# Enqueue
HardWorker.perform_async(user.id, 5)
</code></pre>
<p><strong>With options:</strong></p>
<pre><code class="language-ruby">class ComplexWorker
  include Sidekiq::Worker
  
  sidekiq_options queue: &#39;high_priority&#39;,
                   retry: 5,
                   backtrace: true,
                   dead: false
  
  def perform(data)
    # Process data
  end
end
</code></pre>
<p><strong>Using ActiveJob:</strong></p>
<pre><code class="language-ruby">class ProcessOrderJob &lt; ApplicationJob
  queue_as :urgent
  
  def perform(order_id)
    order = Order.find(order_id)
    order.process!
  end
end

# Enqueue
ProcessOrderJob.perform_later(order.id)
</code></pre>
<hr>
<h3>Enqueueing Jobs</h3>
<p><strong>Different methods:</strong></p>
<pre><code class="language-ruby"># Immediate
MyWorker.perform_async(arg1, arg2)

# Scheduled (delay)
MyWorker.perform_in(5.minutes, arg1, arg2)
MyWorker.perform_at(1.hour.from_now, arg1, arg2)

# Bulk enqueue (efficient)
args = [[1, 2], [3, 4], [5, 6]]
Sidekiq::Client.push_bulk(
  &#39;class&#39; =&gt; &#39;MyWorker&#39;,
  &#39;args&#39; =&gt; args
)

# With ActiveJob
MyJob.perform_later(arg1)
MyJob.set(wait: 5.minutes).perform_later(arg1)
</code></pre>
<hr>
<h3>Queue Configuration</h3>
<p><strong>Priority queues:</strong></p>
<pre><code class="language-ruby"># config/sidekiq.yml
:concurrency: 25
:queues:
  - [urgent, 5]     # Weight 5
  - [default, 3]    # Weight 3
  - [low, 1]        # Weight 1

# Worker processes:
# - 5 out of 9 jobs from urgent
# - 3 out of 9 jobs from default
# - 1 out of 9 jobs from low
</code></pre>
<p><strong>Multiple queues:</strong></p>
<pre><code class="language-ruby">class HighPriorityWorker
  include Sidekiq::Worker
  sidekiq_options queue: &#39;urgent&#39;
end

class NormalWorker
  include Sidekiq::Worker
  sidekiq_options queue: &#39;default&#39;
end

class BackgroundWorker
  include Sidekiq::Worker
  sidekiq_options queue: &#39;low_priority&#39;
end
</code></pre>
<hr>
<h3>Error Handling</h3>
<p><strong>Retry configuration:</strong></p>
<pre><code class="language-ruby">class ReliableWorker
  include Sidekiq::Worker
  
  # Retry up to 5 times
  sidekiq_options retry: 5
  
  # Custom retry logic
  sidekiq_retry_in do |count, exception|
    case exception
    when NetworkError
      10 * (count + 1)  # 10, 20, 30, 40, 50 seconds
    when Timeout::Error
      60 * count        # 0, 60, 120, 180, 240 seconds
    else
      10                # Default: 10 seconds
    end
  end
  
  def perform(data)
    # Risky operation
  end
end
</code></pre>
<p><strong>Death handlers:</strong></p>
<pre><code class="language-ruby">class ImportantWorker
  include Sidekiq::Worker
  
  # Don&#39;t send to dead job queue
  sidekiq_options retry: 3, dead: false
  
  sidekiq_retries_exhausted do |msg, exception|
    # Called when retries exhausted
    Rails.logger.error &quot;Job failed permanently: #{msg[&#39;class&#39;]}&quot;
    Sentry.capture_exception(exception)
    
    # Notify admin
    AdminMailer.job_failed(msg).deliver_now
  end
  
  def perform(user_id)
    # Critical operation
  end
end
</code></pre>
<hr>
<h3>Monitoring</h3>
<p><strong>Web UI:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
require &#39;sidekiq/web&#39;

# Secure with authentication
Sidekiq::Web.use Rack::Auth::Basic do |username, password|
  ActiveSupport::SecurityUtils.secure_compare(
    Digest::SHA256.hexdigest(username),
    Digest::SHA256.hexdigest(ENV[&quot;SIDEKIQ_USERNAME&quot;])
  ) &amp;
  ActiveSupport::SecurityUtils.secure_compare(
    Digest::SHA256.hexdigest(password),
    Digest::SHA256.hexdigest(ENV[&quot;SIDEKIQ_PASSWORD&quot;])
  )
end

mount Sidekiq::Web =&gt; &#39;/sidekiq&#39;

# Access at: http://localhost:3000/sidekiq
</code></pre>
<p><strong>Programmatic monitoring:</strong></p>
<pre><code class="language-ruby"># Queue stats
Sidekiq::Stats.new.processed  # Total processed
Sidekiq::Stats.new.failed     # Total failed
Sidekiq::Stats.new.enqueued   # Currently enqueued

# Queue size
Sidekiq::Queue.new(&#39;default&#39;).size

# Scheduled jobs
Sidekiq::ScheduledSet.new.size

# Retry set
Sidekiq::RetrySet.new.size

# Dead set
Sidekiq::DeadSet.new.size
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Keep jobs small and focused:</strong></p>
<pre><code class="language-ruby"># ❌ BAD - one big job
class ProcessEverythingJob
  include Sidekiq::Worker
  
  def perform(order_id)
    order = Order.find(order_id)
    order.charge_payment!
    order.fulfill!
    order.send_confirmation!
    order.update_inventory!
  end
end

# ✅ GOOD - separate jobs
class ChargePaymentJob
  include Sidekiq::Worker
  def perform(order_id)
    Order.find(order_id).charge_payment!
  end
end

class FulfillOrderJob
  include Sidekiq::Worker
  def perform(order_id)
    Order.find(order_id).fulfill!
  end
end
</code></pre>
<p><strong>2. Pass IDs, not objects:</strong></p>
<pre><code class="language-ruby"># ❌ BAD - serialize entire object
MyWorker.perform_async(user)

# ✅ GOOD - pass ID
MyWorker.perform_async(user.id)

def perform(user_id)
  user = User.find(user_id)
  # Work with fresh user data
end
</code></pre>
<p><strong>3. Idempotent jobs:</strong></p>
<pre><code class="language-ruby"># Job should produce same result if run multiple times
class ProcessOrderJob
  include Sidekiq::Worker
  
  def perform(order_id)
    order = Order.find(order_id)
    
    # Check if already processed
    return if order.processed?
    
    # Process
    order.process!
  end
end
</code></pre>
<p><strong>4. Timeout protection:</strong></p>
<pre><code class="language-ruby">class LongRunningJob
  include Sidekiq::Worker
  
  def perform(data)
    Timeout.timeout(5.minutes) do
      expensive_operation(data)
    end
  rescue Timeout::Error
    Rails.logger.error &quot;Job timed out&quot;
    raise  # Retry
  end
end
</code></pre>
<hr>
<h3>Testing</h3>
<p><strong>RSpec:</strong></p>
<pre><code class="language-ruby">RSpec.describe MyWorker, type: :worker do
  describe &#39;#perform&#39; do
    it &#39;processes the data&#39; do
      user = create(:user)
      
      MyWorker.new.perform(user.id)
      
      expect(user.reload.processed).to be true
    end
    
    it &#39;enqueues the job&#39; do
      expect {
        MyWorker.perform_async(123)
      }.to change(MyWorker.jobs, :size).by(1)
    end
    
    # Test with Sidekiq::Testing
    it &#39;drains the queue&#39; do
      Sidekiq::Testing.inline! do
        expect {
          MyWorker.perform_async(123)
        }.to change { User.count }.by(1)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Production Deployment</h3>
<p><strong>Procfile (Heroku):</strong></p>
<pre><code>web: bundle exec puma -C config/puma.rb
worker: bundle exec sidekiq -C config/sidekiq.yml
</code></pre>
<p><strong>Systemd service:</strong></p>
<pre><code class="language-ini"># /etc/systemd/system/sidekiq.service
[Unit]
Description=Sidekiq
After=syslog.target network.target

[Service]
Type=simple
WorkingDirectory=/var/www/myapp
ExecStart=/bin/bash -lc &#39;bundle exec sidekiq -C config/sidekiq.yml&#39;
User=deploy
Group=deploy
Restart=always

[Install]
WantedBy=multi-user.target
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Sidekiq</strong> uses threads (fast, efficient)</li>
<li><strong>Redis-backed</strong> for job storage</li>
<li><strong>ActiveJob compatible</strong></li>
<li><strong>Web UI</strong> for monitoring</li>
<li><strong>Queue priorities</strong> for different jobs</li>
<li><strong>Retry logic</strong> for failures</li>
<li><strong>Pass IDs</strong> not objects</li>
<li><strong>Idempotent</strong> jobs important</li>
<li><strong>Test</strong> with Sidekiq::Testing</li>
<li><strong>Production ready</strong> with monitoring</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 123: How do you implement background processing in APIs?</h2>
<h3>Answer</h3>
<p>API background processing uses <strong>job queues with status tracking</strong>, <strong>webhooks for completion</strong>, <strong>polling endpoints</strong>, or <strong>WebSockets for real-time updates</strong>. Return job ID immediately, process asynchronously, notify when done.</p>
<hr>
<h3>Pattern 1: Job ID with Polling</h3>
<p><strong>Most common for REST APIs:</strong></p>
<pre><code class="language-ruby"># Controller
class Api::V1::ExportsController &lt; Api::V1::BaseController
  def create
    # Enqueue job
    job = ExportDataJob.perform_later(
      current_user.id,
      export_params
    )
    
    # Return job ID immediately
    render json: {
      job_id: job.job_id,
      status: &#39;processing&#39;,
      status_url: api_v1_export_status_url(job.job_id)
    }, status: :accepted  # 202 Accepted
  end
  
  def status
    # Check job status
    job_status = JobStatus.find_by(job_id: params[:id])
    
    if job_status.completed?
      render json: {
        status: &#39;completed&#39;,
        download_url: job_status.result_url
      }
    elsif job_status.failed?
      render json: {
        status: &#39;failed&#39;,
        error: job_status.error_message
      }, status: :unprocessable_entity
    else
      render json: {
        status: &#39;processing&#39;,
        progress: job_status.progress_percentage
      }
    end
  end
end

# Job with progress tracking
class ExportDataJob &lt; ApplicationJob
  def perform(user_id, params)
    user = User.find(user_id)
    
    # Create status record
    status = JobStatus.create!(
      job_id: job_id,
      user: user,
      status: &#39;processing&#39;
    )
    
    begin
      # Process with progress updates
      total = user.records.count
      processed = 0
      
      user.records.find_each do |record|
        process_record(record)
        processed += 1
        
        # Update progress
        status.update(progress_percentage: (processed.to_f / total * 100).round)
      end
      
      # Store result
      result_url = upload_to_s3(export_file)
      status.update(
        status: &#39;completed&#39;,
        result_url: result_url
      )
    rescue StandardError =&gt; e
      status.update(
        status: &#39;failed&#39;,
        error_message: e.message
      )
      raise
    end
  end
end

# Client usage:
# 1. POST /api/v1/exports → Get job_id
# 2. Poll GET /api/v1/exports/:job_id/status every 2 seconds
# 3. Download file when status: completed
</code></pre>
<hr>
<h3>Pattern 2: Webhooks</h3>
<p><strong>Server notifies client when done:</strong></p>
<pre><code class="language-ruby">class Api::V1::ProcessingController &lt; Api::V1::BaseController
  def create
    job = ProcessDataJob.perform_later(
      current_user.id,
      params[:data],
      params[:callback_url]  # Client provides webhook URL
    )
    
    render json: {
      job_id: job.job_id,
      status: &#39;processing&#39;
    }, status: :accepted
  end
end

class ProcessDataJob &lt; ApplicationJob
  def perform(user_id, data, callback_url)
    user = User.find(user_id)
    
    # Process data
    result = process_data(data)
    
    # Notify client via webhook
    HTTP.post(callback_url, json: {
      job_id: job_id,
      status: &#39;completed&#39;,
      result: result
    })
  rescue StandardError =&gt; e
    # Notify failure
    HTTP.post(callback_url, json: {
      job_id: job_id,
      status: &#39;failed&#39;,
      error: e.message
    })
  end
end

# Client implements webhook endpoint:
# POST https://client.com/webhooks/processing
# Receives notification when job completes
</code></pre>
<hr>
<h3>Pattern 3: WebSockets (Real-time)</h3>
<p><strong>Push updates via WebSocket:</strong></p>
<pre><code class="language-ruby"># Cable
class JobChannel &lt; ApplicationCable::Channel
  def subscribed
    stream_for current_user
  end
end

# Job
class ProcessDataJob &lt; ApplicationJob
  def perform(user_id, data)
    user = User.find(user_id)
    
    # Send real-time updates
    JobChannel.broadcast_to(user, {
      job_id: job_id,
      status: &#39;started&#39;
    })
    
    total = data.length
    data.each_with_index do |item, index|
      process_item(item)
      
      # Broadcast progress
      JobChannel.broadcast_to(user, {
        job_id: job_id,
        status: &#39;processing&#39;,
        progress: ((index + 1).to_f / total * 100).round
      })
    end
    
    # Broadcast completion
    JobChannel.broadcast_to(user, {
      job_id: job_id,
      status: &#39;completed&#39;,
      result: result
    })
  end
end

# Client subscribes to channel
# Receives real-time updates
</code></pre>
<hr>
<h3>Pattern 4: Server-Sent Events (SSE)</h3>
<p><strong>Stream progress via HTTP:</strong></p>
<pre><code class="language-ruby">class Api::V1::StreamsController &lt; Api::V1::BaseController
  include ActionController::Live
  
  def job_progress
    response.headers[&#39;Content-Type&#39;] = &#39;text/event-stream&#39;
    response.headers[&#39;Cache-Control&#39;] = &#39;no-cache&#39;
    
    job_id = params[:job_id]
    
    loop do
      status = JobStatus.find_by(job_id: job_id)
      
      # Send progress update
      response.stream.write(&quot;data: #{status.to_json}\n\n&quot;)
      
      break if status.completed? || status.failed?
      
      sleep 1
    end
  ensure
    response.stream.close
  end
end

# Client connects to stream:
# GET /api/v1/streams/job_progress?job_id=123
# Receives server-sent events with updates
</code></pre>
<hr>
<h3>Job Status Tracking</h3>
<p><strong>Database model:</strong></p>
<pre><code class="language-ruby">class JobStatus &lt; ApplicationRecord
  belongs_to :user
  
  enum status: {
    pending: 0,
    processing: 1,
    completed: 2,
    failed: 3
  }
  
  # Columns:
  # - job_id (string)
  # - status (integer)
  # - progress_percentage (integer)
  # - result_url (string)
  # - error_message (text)
  # - started_at (datetime)
  # - completed_at (datetime)
end

# Create on job start
class ProcessDataJob &lt; ApplicationJob
  before_perform do |job|
    JobStatus.create!(
      job_id: job.job_id,
      user_id: arguments.first,
      status: :processing,
      started_at: Time.current
    )
  end
  
  after_perform do |job|
    status = JobStatus.find_by(job_id: job.job_id)
    status.update(
      status: :completed,
      completed_at: Time.current
    )
  end
end
</code></pre>
<hr>
<h3>Retry and Idempotency</h3>
<p><strong>Handle retries safely:</strong></p>
<pre><code class="language-ruby">class ProcessPaymentJob &lt; ApplicationJob
  retry_on PaymentGatewayError, wait: 5.seconds, attempts: 3
  
  def perform(payment_id, idempotency_key)
    payment = Payment.find(payment_id)
    
    # Check if already processed
    return if payment.processed?
    
    # Use idempotency key with external API
    PaymentGateway.charge(
      payment,
      idempotency_key: idempotency_key
    )
    
    payment.update(
      processed: true,
      processed_at: Time.current
    )
  end
end

# API endpoint
def create_payment
  payment = Payment.create!(payment_params)
  idempotency_key = SecureRandom.uuid
  
  ProcessPaymentJob.perform_later(payment.id, idempotency_key)
  
  render json: {
    payment_id: payment.id,
    status: &#39;processing&#39;,
    idempotency_key: idempotency_key
  }, status: :accepted
end
</code></pre>
<hr>
<h3>Real-World Example: Bulk Import API</h3>
<p><strong>Complete implementation:</strong></p>
<pre><code class="language-ruby"># API Controller
class Api::V1::ImportsController &lt; Api::V1::BaseController
  def create
    # Validate file
    unless valid_csv?(params[:file])
      return render json: { error: &#39;Invalid CSV file&#39; }, status: :bad_request
    end
    
    # Store file
    import = Import.create!(
      user: current_user,
      file: params[:file],
      status: &#39;pending&#39;
    )
    
    # Enqueue job
    BulkImportJob.perform_later(
      import.id,
      params[:callback_url]
    )
    
    render json: {
      import_id: import.id,
      status: &#39;processing&#39;,
      status_url: api_v1_import_status_url(import),
      estimated_time: estimate_processing_time(params[:file])
    }, status: :accepted
  end
  
  def status
    import = current_user.imports.find(params[:id])
    
    render json: {
      import_id: import.id,
      status: import.status,
      progress: import.progress_percentage,
      processed_rows: import.processed_rows,
      total_rows: import.total_rows,
      errors: import.errors_summary
    }
  end
end

# Background Job
class BulkImportJob &lt; ApplicationJob
  queue_as :imports
  
  def perform(import_id, callback_url = nil)
    import = Import.find(import_id)
    
    import.update!(
      status: &#39;processing&#39;,
      started_at: Time.current
    )
    
    # Process CSV
    csv = CSV.read(import.file.path)
    total_rows = csv.length
    processed_rows = 0
    errors = []
    
    csv.each_with_index do |row, index|
      begin
        create_record_from_row(row)
        processed_rows += 1
      rescue StandardError =&gt; e
        errors &lt;&lt; { row: index + 1, error: e.message }
      end
      
      # Update progress every 100 rows
      if (index + 1) % 100 == 0
        import.update!(
          processed_rows: processed_rows,
          progress_percentage: (processed_rows.to_f / total_rows * 100).round
        )
      end
    end
    
    # Mark complete
    import.update!(
      status: &#39;completed&#39;,
      processed_rows: processed_rows,
      total_rows: total_rows,
      errors_count: errors.length,
      errors_summary: errors.to_json,
      completed_at: Time.current
    )
    
    # Send webhook if provided
    if callback_url.present?
      HTTP.post(callback_url, json: {
        import_id: import.id,
        status: &#39;completed&#39;,
        processed_rows: processed_rows,
        errors_count: errors.length
      })
    end
  rescue StandardError =&gt; e
    import.update!(
      status: &#39;failed&#39;,
      error_message: e.message
    )
    
    # Notify via webhook
    if callback_url.present?
      HTTP.post(callback_url, json: {
        import_id: import.id,
        status: &#39;failed&#39;,
        error: e.message
      })
    end
    
    raise
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Return immediately</strong> - don&#39;t block API</li>
<li><strong>Job ID</strong> for tracking</li>
<li><strong>Polling</strong> for status updates</li>
<li><strong>Webhooks</strong> for completion notification</li>
<li><strong>WebSockets</strong> for real-time updates</li>
<li><strong>Progress tracking</strong> in database</li>
<li><strong>Idempotency</strong> for retries</li>
<li><strong>Error handling</strong> crucial</li>
<li><strong>Timeouts</strong> for long jobs</li>
<li><strong>Test</strong> async behavior</li>
</ol>
<hr>
<h2>Question 124: How do you secure background jobs in Sidekiq?</h2>
<h3>Answer</h3>
<p>Secure Sidekiq through <strong>authentication on web UI</strong>, <strong>encrypted job arguments</strong>, <strong>job signing</strong>, <strong>resource limits</strong>, <strong>monitoring</strong>, and <strong>proper Redis security</strong>. Prevent unauthorized access and data leaks.</p>
<hr>
<h3>1. Secure Web UI</h3>
<p><strong>Authentication:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
require &#39;sidekiq/web&#39;

# Basic Auth
Sidekiq::Web.use Rack::Auth::Basic do |username, password|
  ActiveSupport::SecurityUtils.secure_compare(
    Digest::SHA256.hexdigest(username),
    Digest::SHA256.hexdigest(ENV[&#39;SIDEKIQ_USERNAME&#39;])
  ) &amp;
  ActiveSupport::SecurityUtils.secure_compare(
    Digest::SHA256.hexdigest(password),
    Digest::SHA256.hexdigest(ENV[&#39;SIDEKIQ_PASSWORD&#39;])
  )
end

mount Sidekiq::Web =&gt; &#39;/sidekiq&#39;
</code></pre>
<p><strong>Devise authentication:</strong></p>
<pre><code class="language-ruby"># Restrict to admin users only
authenticate :user, -&gt;(user) { user.admin? } do
  mount Sidekiq::Web =&gt; &#39;/sidekiq&#39;
end
</code></pre>
<p><strong>Custom middleware:</strong></p>
<pre><code class="language-ruby">class SidekiqAuth
  def initialize(app)
    @app = app
  end
  
  def call(env)
    # Check for valid API token
    token = env[&#39;HTTP_AUTHORIZATION&#39;]
    
    if valid_admin_token?(token)
      @app.call(env)
    else
      [403, {}, [&#39;Forbidden&#39;]]
    end
  end
  
  private
  
  def valid_admin_token?(token)
    token == ENV[&#39;ADMIN_API_TOKEN&#39;]
  end
end

Sidekiq::Web.use SidekiqAuth
mount Sidekiq::Web =&gt; &#39;/sidekiq&#39;
</code></pre>
<hr>
<h3>2. Encrypt Sensitive Data</h3>
<p><strong>Don&#39;t pass sensitive data directly:</strong></p>
<pre><code class="language-ruby"># ❌ BAD - credit card in job arguments
ProcessPaymentJob.perform_later(
  user.id,
  credit_card_number: &#39;4111111111111111&#39;
)

# ✅ GOOD - pass ID, fetch from secure storage
ProcessPaymentJob.perform_later(user.id, payment_method_id)

class ProcessPaymentJob &lt; ApplicationJob
  def perform(user_id, payment_method_id)
    user = User.find(user_id)
    payment_method = user.payment_methods.find(payment_method_id)
    # payment_method.encrypted_card_number decrypted here
  end
end
</code></pre>
<p><strong>Encrypt job arguments:</strong></p>
<pre><code class="language-ruby">class SecureJob &lt; ApplicationJob
  def perform(encrypted_data)
    # Decrypt in job
    data = decrypt(encrypted_data)
    process(data)
  end
  
  private
  
  def decrypt(encrypted_data)
    cipher = OpenSSL::Cipher.new(&#39;AES-256-CBC&#39;)
    cipher.decrypt
    cipher.key = Rails.application.credentials.encryption_key
    
    decrypted = cipher.update(Base64.decode64(encrypted_data))
    decrypted &lt;&lt; cipher.final
  end
end

# Encrypt before enqueueing
def enqueue_secure_job(sensitive_data)
  encrypted = encrypt(sensitive_data)
  SecureJob.perform_later(encrypted)
end
</code></pre>
<hr>
<h3>3. Redis Security</h3>
<p><strong>Secure Redis connection:</strong></p>
<pre><code class="language-ruby"># config/initializers/sidekiq.rb
Sidekiq.configure_server do |config|
  config.redis = {
    url: ENV[&#39;REDIS_URL&#39;],
    password: ENV[&#39;REDIS_PASSWORD&#39;],  # Require password
    ssl_params: { verify_mode: OpenSSL::SSL::VERIFY_NONE }  # For SSL
  }
end

Sidekiq.configure_client do |config|
  config.redis = {
    url: ENV[&#39;REDIS_URL&#39;],
    password: ENV[&#39;REDIS_PASSWORD&#39;]
  }
end
</code></pre>
<p><strong>Redis configuration:</strong></p>
<pre><code class="language-bash"># redis.conf
requirepass your-strong-password
bind 127.0.0.1  # Only local connections
protected-mode yes
rename-command CONFIG &quot;&quot;  # Disable dangerous commands
rename-command FLUSHDB &quot;&quot;
rename-command FLUSHALL &quot;&quot;
</code></pre>
<hr>
<h3>4. Job Signing (Sidekiq Pro)</h3>
<p><strong>Prevent job tampering:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;sidekiq-pro&#39;

# config/initializers/sidekiq.rb
Sidekiq::Pro.configure do |config|
  # Enable job signing
  config.signature = ENV[&#39;SIDEKIQ_SIGNATURE_SECRET&#39;]
end

# Jobs are now signed
# Tampered jobs rejected automatically
</code></pre>
<hr>
<h3>5. Resource Limits</h3>
<p><strong>Prevent DoS via job bombing:</strong></p>
<pre><code class="language-ruby"># Rate limit job creation
class RateLimitedJob &lt; ApplicationJob
  def perform(user_id)
    # Limit: 10 jobs per user per minute
    cache_key = &quot;job_rate_limit:#{user_id}&quot;
    
    count = Rails.cache.increment(cache_key, 1, expires_in: 1.minute)
    
    if count &gt; 10
      raise RateLimitError, &quot;Too many jobs for user #{user_id}&quot;
    end
    
    # Process job
  end
end
</code></pre>
<p><strong>Memory limits:</strong></p>
<pre><code class="language-ruby"># config/sidekiq.yml
:concurrency: 10  # Limit concurrent jobs
:timeout: 300     # Kill jobs after 5 minutes

# Per-job memory limit
class HeavyJob &lt; ApplicationJob
  around_perform do |job, block|
    memory_before = GetProcessMem.new.bytes
    
    block.call
    
    memory_after = GetProcessMem.new.bytes
    memory_used = (memory_after - memory_before) / 1024 / 1024
    
    if memory_used &gt; 500  # 500 MB
      Rails.logger.error &quot;Job used too much memory: #{memory_used}MB&quot;
    end
  end
end
</code></pre>
<hr>
<h3>6. Input Validation</h3>
<p><strong>Validate job arguments:</strong></p>
<pre><code class="language-ruby">class ValidatedJob &lt; ApplicationJob
  def perform(user_id, amount)
    # Validate inputs
    raise ArgumentError, &quot;Invalid user_id&quot; unless user_id.is_a?(Integer)
    raise ArgumentError, &quot;Invalid amount&quot; unless amount.is_a?(Numeric) &amp;&amp; amount &gt; 0
    
    user = User.find(user_id)
    
    # Additional authorization check
    raise UnauthorizedError unless authorized_for_amount?(user, amount)
    
    process_payment(user, amount)
  end
  
  private
  
  def authorized_for_amount?(user, amount)
    amount &lt;= user.max_transaction_limit
  end
end
</code></pre>
<hr>
<h3>7. Job Authorization</h3>
<p><strong>Check permissions in jobs:</strong></p>
<pre><code class="language-ruby">class AdminOnlyJob &lt; ApplicationJob
  def perform(user_id, action)
    user = User.find(user_id)
    
    # Verify user is admin
    unless user.admin?
      Rails.logger.warn &quot;Unauthorized job attempt by user #{user_id}&quot;
      raise UnauthorizedError
    end
    
    perform_admin_action(action)
  end
end
</code></pre>
<hr>
<h3>8. Monitoring and Alerting</h3>
<p><strong>Monitor for suspicious activity:</strong></p>
<pre><code class="language-ruby"># Middleware
class SecurityMonitoring
  def call(worker, job, queue)
    start_time = Time.current
    
    yield
    
    duration = Time.current - start_time
    
    # Alert on unusually long jobs
    if duration &gt; 10.minutes
      alert_slow_job(worker, job, duration)
    end
    
  rescue StandardError =&gt; e
    # Alert on failures
    alert_job_failure(worker, job, e)
    raise
  end
  
  private
  
  def alert_slow_job(worker, job, duration)
    Sentry.capture_message(
      &quot;Slow job detected&quot;,
      extra: {
        worker: worker.class.name,
        job_id: job[&#39;jid&#39;],
        duration: duration
      }
    )
  end
  
  def alert_job_failure(worker, job, error)
    # Custom alerting logic
  end
end

# config/initializers/sidekiq.rb
Sidekiq.configure_server do |config|
  config.server_middleware do |chain|
    chain.add SecurityMonitoring
  end
end
</code></pre>
<hr>
<h3>9. Dead Job Security</h3>
<p><strong>Limit dead job retention:</strong></p>
<pre><code class="language-ruby"># config/initializers/sidekiq.rb
Sidekiq.configure_server do |config|
  # Keep dead jobs for 7 days only
  config.death_handlers &lt;&lt; -&gt;(job, ex) {
    # Custom handling
    Sidekiq.logger.warn &quot;Job #{job[&#39;jid&#39;]} died: #{ex.message}&quot;
  }
end

# Cleanup old dead jobs
class CleanupDeadJobsJob &lt; ApplicationJob
  def perform
    dead_set = Sidekiq::DeadSet.new
    
    dead_set.each do |job|
      # Remove jobs older than 7 days
      if Time.at(job.at) &lt; 7.days.ago
        job.delete
      end
    end
  end
end
</code></pre>
<hr>
<h3>10. Audit Logging</h3>
<p><strong>Log job execution:</strong></p>
<pre><code class="language-ruby">class AuditedJob &lt; ApplicationJob
  around_perform do |job, block|
    AuditLog.create!(
      job_class: self.class.name,
      job_id: job.job_id,
      arguments: job.arguments,
      user_id: job.arguments.first,  # Assuming first arg is user_id
      status: &#39;started&#39;,
      started_at: Time.current
    )
    
    begin
      block.call
      
      AuditLog.find_by(job_id: job.job_id).update!(
        status: &#39;completed&#39;,
        completed_at: Time.current
      )
    rescue StandardError =&gt; e
      AuditLog.find_by(job_id: job.job_id).update!(
        status: &#39;failed&#39;,
        error_message: e.message,
        completed_at: Time.current
      )
      raise
    end
  end
end
</code></pre>
<hr>
<h3>Security Checklist</h3>
<pre><code class="language-ruby"># ✅ Security Checklist

# 1. Web UI
☐ Authentication enabled
☐ Restricted to admins only
☐ Strong passwords
☐ HTTPS in production

# 2. Data
☐ Don&#39;t pass sensitive data in arguments
☐ Use IDs, fetch from database
☐ Encrypt if necessary
☐ No PII in job names/arguments

# 3. Redis
☐ Password protected
☐ Bind to localhost only
☐ Disable dangerous commands
☐ Use SSL/TLS

# 4. Jobs
☐ Input validation
☐ Authorization checks
☐ Resource limits
☐ Timeout protection

# 5. Monitoring
☐ Alert on failures
☐ Monitor job duration
☐ Track dead jobs
☐ Audit logging

# 6. Code
☐ No hardcoded secrets
☐ Environment variables
☐ Rate limiting
☐ Error handling
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Authenticate</strong> web UI</li>
<li><strong>Don&#39;t pass</strong> sensitive data</li>
<li><strong>Secure Redis</strong> with password</li>
<li><strong>Validate</strong> job inputs</li>
<li><strong>Check authorization</strong> in jobs</li>
<li><strong>Rate limit</strong> job creation</li>
<li><strong>Monitor</strong> for suspicious activity</li>
<li><strong>Audit log</strong> job execution</li>
<li><strong>Encrypt</strong> sensitive arguments</li>
<li><strong>Keep</strong> dead jobs limited</li>
</ol>
<h1>Testing and Rails Configuration Interview Questions</h1>
<h2>Question 125: Explain RSpec basic format</h2>
<h3>Answer</h3>
<p><strong>RSpec</strong> uses a <strong>describe/context/it</strong> structure with <strong>expect</strong> assertions. Tests are organized hierarchically: <strong>describe</strong> for components, <strong>context</strong> for scenarios, <strong>it</strong> for individual examples.</p>
<hr>
<h3>Basic Structure</h3>
<pre><code class="language-ruby">RSpec.describe User, type: :model do
  # describe: What you&#39;re testing (class, method, feature)
  describe &#39;#full_name&#39; do
    # context: Specific scenario or state
    context &#39;when user has first and last name&#39; do
      # it: Individual test example
      it &#39;returns the full name&#39; do
        user = User.new(first_name: &#39;John&#39;, last_name: &#39;Doe&#39;)
        expect(user.full_name).to eq(&#39;John Doe&#39;)
      end
    end
    
    context &#39;when user has no last name&#39; do
      it &#39;returns only the first name&#39; do
        user = User.new(first_name: &#39;John&#39;)
        expect(user.full_name).to eq(&#39;John&#39;)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Spec Types</h3>
<p><strong>Model specs:</strong></p>
<pre><code class="language-ruby"># spec/models/user_spec.rb
RSpec.describe User, type: :model do
  describe &#39;validations&#39; do
    it { should validate_presence_of(:email) }
    it { should validate_uniqueness_of(:email) }
    it { should validate_length_of(:password).is_at_least(8) }
  end
  
  describe &#39;associations&#39; do
    it { should have_many(:posts) }
    it { should belong_to(:company) }
  end
  
  describe &#39;#active?&#39; do
    it &#39;returns true for active users&#39; do
      user = create(:user, status: &#39;active&#39;)
      expect(user.active?).to be true
    end
  end
end
</code></pre>
<p><strong>Controller specs:</strong></p>
<pre><code class="language-ruby"># spec/controllers/posts_controller_spec.rb
RSpec.describe PostsController, type: :controller do
  describe &#39;GET #index&#39; do
    it &#39;returns success&#39; do
      get :index
      expect(response).to have_http_status(:success)
    end
    
    it &#39;assigns @posts&#39; do
      post = create(:post)
      get :index
      expect(assigns(:posts)).to eq([post])
    end
  end
  
  describe &#39;POST #create&#39; do
    context &#39;with valid params&#39; do
      it &#39;creates a new post&#39; do
        expect {
          post :create, params: { post: attributes_for(:post) }
        }.to change(Post, :count).by(1)
      end
    end
    
    context &#39;with invalid params&#39; do
      it &#39;does not create a post&#39; do
        expect {
          post :create, params: { post: { title: &#39;&#39; } }
        }.not_to change(Post, :count)
      end
    end
  end
end
</code></pre>
<p><strong>Request specs (integration):</strong></p>
<pre><code class="language-ruby"># spec/requests/api/posts_spec.rb
RSpec.describe &#39;Posts API&#39;, type: :request do
  describe &#39;GET /api/posts&#39; do
    it &#39;returns posts&#39; do
      create_list(:post, 3)
      
      get &#39;/api/posts&#39;
      
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body).length).to eq(3)
    end
  end
  
  describe &#39;POST /api/posts&#39; do
    it &#39;creates a post&#39; do
      post &#39;/api/posts&#39;, params: { post: { title: &#39;Test&#39; } }
      
      expect(response).to have_http_status(:created)
      expect(Post.last.title).to eq(&#39;Test&#39;)
    end
  end
end
</code></pre>
<hr>
<h3>Expectations</h3>
<p><strong>Basic matchers:</strong></p>
<pre><code class="language-ruby"># Equality
expect(actual).to eq(expected)           # ==
expect(actual).to eql(expected)          # eql?
expect(actual).to equal(expected)        # same object
expect(actual).to be(expected)           # same object

# Comparison
expect(actual).to be &gt; expected
expect(actual).to be &gt;= expected
expect(actual).to be &lt; expected
expect(actual).to be &lt;= expected

# Boolean
expect(actual).to be true
expect(actual).to be false
expect(actual).to be_nil
expect(actual).to be_truthy
expect(actual).to be_falsey

# Type/Class
expect(actual).to be_a(Class)
expect(actual).to be_an(Class)
expect(actual).to be_kind_of(Class)
expect(actual).to be_instance_of(Class)

# Inclusion
expect(array).to include(element)
expect(hash).to include(key: value)
expect(string).to include(&#39;substring&#39;)

# Regular expressions
expect(string).to match(/regex/)
expect(string).to start_with(&#39;prefix&#39;)
expect(string).to end_with(&#39;suffix&#39;)

# Ranges
expect(actual).to be_within(delta).of(expected)
expect(actual).to be_between(min, max)
</code></pre>
<hr>
<h3>Let and Subject</h3>
<p><strong>let (lazy evaluation):</strong></p>
<pre><code class="language-ruby">RSpec.describe Post do
  # Evaluated only when first referenced
  let(:user) { create(:user) }
  let(:post) { create(:post, user: user) }
  
  it &#39;belongs to user&#39; do
    expect(post.user).to eq(user)
  end
  
  # let! (eager evaluation - always runs)
  let!(:published_post) { create(:post, published: true) }
  
  it &#39;finds published posts&#39; do
    expect(Post.published).to include(published_post)
  end
end
</code></pre>
<p><strong>subject:</strong></p>
<pre><code class="language-ruby">RSpec.describe User do
  # Implicit subject
  it { should validate_presence_of(:email) }
  
  # Explicit subject
  subject(:user) { User.new(email: &#39;test@example.com&#39;) }
  
  it &#39;has an email&#39; do
    expect(user.email).to eq(&#39;test@example.com&#39;)
  end
  
  # is_expected
  it { is_expected.to be_valid }
end
</code></pre>
<hr>
<h3>Hooks (before/after)</h3>
<pre><code class="language-ruby">RSpec.describe Post do
  # Run once before all examples in this block
  before(:all) do
    @category = create(:category)
  end
  
  # Run before each example
  before(:each) do
    @user = create(:user)
  end
  
  # Alias for before(:each)
  before do
    @post = create(:post, user: @user)
  end
  
  # Run after each example
  after(:each) do
    # Cleanup
  end
  
  # Run once after all examples
  after(:all) do
    # Final cleanup
  end
  
  it &#39;has a user&#39; do
    expect(@post.user).to eq(@user)
  end
end
</code></pre>
<hr>
<h3>Shared Examples</h3>
<pre><code class="language-ruby"># spec/support/shared_examples/timestampable.rb
RSpec.shared_examples &#39;timestampable&#39; do
  it { should have_db_column(:created_at).of_type(:datetime) }
  it { should have_db_column(:updated_at).of_type(:datetime) }
  
  it &#39;sets created_at on creation&#39; do
    record = described_class.create!(valid_attributes)
    expect(record.created_at).to be_present
  end
end

# Use in specs
RSpec.describe Post do
  it_behaves_like &#39;timestampable&#39; do
    let(:valid_attributes) { { title: &#39;Test&#39; } }
  end
end

RSpec.describe User do
  it_behaves_like &#39;timestampable&#39; do
    let(:valid_attributes) { { email: &#39;test@example.com&#39; } }
  end
end
</code></pre>
<hr>
<h3>Factories (FactoryBot)</h3>
<pre><code class="language-ruby"># spec/factories/users.rb
FactoryBot.define do
  factory :user do
    email { Faker::Internet.email }
    password { &#39;password123&#39; }
    first_name { &#39;John&#39; }
    last_name { &#39;Doe&#39; }
    
    trait :admin do
      role { &#39;admin&#39; }
    end
    
    trait :with_posts do
      after(:create) do |user|
        create_list(:post, 3, user: user)
      end
    end
  end
end

# Usage:
user = create(:user)
admin = create(:user, :admin)
user_with_posts = create(:user, :with_posts)
users = create_list(:user, 5)
</code></pre>
<hr>
<h3>Mocking and Stubbing</h3>
<p><strong>Stubs (replace methods):</strong></p>
<pre><code class="language-ruby">RSpec.describe PostsController do
  describe &#39;#create&#39; do
    it &#39;sends notification&#39; do
      allow(NotificationService).to receive(:send_notification)
      
      post :create, params: { post: attributes_for(:post) }
      
      expect(NotificationService).to have_received(:send_notification)
    end
  end
end
</code></pre>
<p><strong>Mocks (expect calls):</strong></p>
<pre><code class="language-ruby">it &#39;calls external API&#39; do
  api_client = double(&#39;APIClient&#39;)
  expect(api_client).to receive(:post).with(&#39;/users&#39;, anything)
  
  service = UserService.new(api_client)
  service.create_user({ name: &#39;John&#39; })
end
</code></pre>
<p><strong>Doubles:</strong></p>
<pre><code class="language-ruby"># Full double
user_double = double(&#39;User&#39;, name: &#39;John&#39;, email: &#39;john@example.com&#39;)

# Instance double (verified against actual class)
user_double = instance_double(&#39;User&#39;, name: &#39;John&#39;)

# Partial double (real object with stubbed methods)
user = create(:user)
allow(user).to receive(:save).and_return(false)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>describe</strong> - what you&#39;re testing</li>
<li><strong>context</strong> - specific scenario</li>
<li><strong>it</strong> - individual example</li>
<li><strong>expect</strong> - assertion</li>
<li><strong>let</strong> - lazy variables</li>
<li><strong>subject</strong> - test subject</li>
<li><strong>before/after</strong> - setup/teardown</li>
<li><strong>Factories</strong> - test data</li>
<li><strong>Stubs/mocks</strong> - fake dependencies</li>
<li><strong>Shared examples</strong> - reusable tests</li>
</ol>
<hr>
<h2>Question 126: What is the difference between <code>context</code> and <code>describe</code> in RSpec?</h2>
<h3>Answer</h3>
<p><strong>No functional difference</strong> - both create example groups. <strong>describe</strong> conventionally describes &quot;what&quot;, <strong>context</strong> describes &quot;when/in what state&quot;. It&#39;s purely semantic for readability.</p>
<hr>
<h3>Technical Equivalence</h3>
<pre><code class="language-ruby"># Functionally identical:
describe &#39;something&#39; do
  # tests
end

context &#39;something&#39; do
  # tests
end

# Both create ExampleGroup
# Both can be nested
# Both can have before/after hooks
</code></pre>
<hr>
<h3>Conventional Usage</h3>
<p><strong>describe for &quot;what&quot;:</strong></p>
<pre><code class="language-ruby">RSpec.describe User do
  # describe: class or method being tested
  describe &#39;#full_name&#39; do
    # Tests for full_name method
  end
  
  describe &#39;.active&#39; do
    # Tests for class method active
  end
end
</code></pre>
<p><strong>context for &quot;when&quot;:</strong></p>
<pre><code class="language-ruby">RSpec.describe User do
  describe &#39;#full_name&#39; do
    # context: specific scenario or state
    context &#39;when user has both names&#39; do
      it &#39;returns full name&#39; do
        user = User.new(first_name: &#39;John&#39;, last_name: &#39;Doe&#39;)
        expect(user.full_name).to eq(&#39;John Doe&#39;)
      end
    end
    
    context &#39;when user has only first name&#39; do
      it &#39;returns first name only&#39; do
        user = User.new(first_name: &#39;John&#39;)
        expect(user.full_name).to eq(&#39;John&#39;)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>Clear hierarchy:</strong></p>
<pre><code class="language-ruby"># ✅ GOOD - clear and readable
RSpec.describe User, type: :model do
  describe &#39;#save&#39; do
    context &#39;when valid&#39; do
      it &#39;saves successfully&#39; do
        # test
      end
    end
    
    context &#39;when invalid&#39; do
      it &#39;returns false&#39; do
        # test
      end
      
      it &#39;populates errors&#39; do
        # test
      end
    end
  end
end

# ❌ CONFUSING - all describes
RSpec.describe User do
  describe &#39;#save&#39; do
    describe &#39;when valid&#39; do  # Should be context
      # tests
    end
  end
end
</code></pre>
<p><strong>Context naming:</strong></p>
<pre><code class="language-ruby"># ✅ GOOD - starts with &quot;when&quot; or &quot;with&quot;
context &#39;when user is admin&#39; do
context &#39;when email is invalid&#39; do
context &#39;with valid params&#39; do
context &#39;with missing attributes&#39; do

# ❌ LESS CLEAR
context &#39;admin user&#39; do  # Prefer: when user is admin
context &#39;no params&#39; do   # Prefer: with no params
</code></pre>
<hr>
<h3>Real-World Example</h3>
<pre><code class="language-ruby">RSpec.describe PostsController, type: :controller do
  # describe: controller action
  describe &#39;POST #create&#39; do
    let(:user) { create(:user) }
    
    before { sign_in user }
    
    # context: request state
    context &#39;with valid params&#39; do
      let(:valid_params) { { post: attributes_for(:post) } }
      
      it &#39;creates a post&#39; do
        expect {
          post :create, params: valid_params
        }.to change(Post, :count).by(1)
      end
      
      it &#39;redirects to the post&#39; do
        post :create, params: valid_params
        expect(response).to redirect_to(Post.last)
      end
    end
    
    # context: different request state
    context &#39;with invalid params&#39; do
      let(:invalid_params) { { post: { title: &#39;&#39; } } }
      
      it &#39;does not create a post&#39; do
        expect {
          post :create, params: invalid_params
        }.not_to change(Post, :count)
      end
      
      it &#39;re-renders the new template&#39; do
        post :create, params: invalid_params
        expect(response).to render_template(:new)
      end
    end
    
    # context: user state
    context &#39;when user is not authenticated&#39; do
      before { sign_out user }
      
      it &#39;redirects to login&#39; do
        post :create, params: { post: attributes_for(:post) }
        expect(response).to redirect_to(login_path)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Nested Contexts</h3>
<pre><code class="language-ruby">RSpec.describe Order do
  describe &#39;#total&#39; do
    context &#39;with standard shipping&#39; do
      context &#39;when order is under $50&#39; do
        it &#39;adds $5 shipping&#39; do
          order = Order.new(subtotal: 40, shipping: &#39;standard&#39;)
          expect(order.total).to eq(45)
        end
      end
      
      context &#39;when order is over $50&#39; do
        it &#39;has free shipping&#39; do
          order = Order.new(subtotal: 60, shipping: &#39;standard&#39;)
          expect(order.total).to eq(60)
        end
      end
    end
    
    context &#39;with express shipping&#39; do
      it &#39;adds $15 shipping&#39; do
        order = Order.new(subtotal: 40, shipping: &#39;express&#39;)
        expect(order.total).to eq(55)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Functionally identical</strong> - just aliases</li>
<li><strong>describe</strong> for &quot;what&quot; you&#39;re testing</li>
<li><strong>context</strong> for &quot;when/in what state&quot;</li>
<li><strong>Convention</strong> for readability</li>
<li><strong>Start context</strong> with &quot;when&quot; or &quot;with&quot;</li>
<li><strong>Nest contexts</strong> for complex scenarios</li>
<li><strong>describe</strong> methods and classes</li>
<li><strong>context</strong> states and conditions</li>
<li><strong>Both</strong> create example groups</li>
<li><strong>Choose</strong> based on what reads better</li>
</ol>
<hr>
<h2>Question 127: What are the different Rails environments (development, test, production)?</h2>
<h3>Answer</h3>
<p>Rails has <strong>three default environments</strong>: <strong>development</strong> (local work), <strong>test</strong> (automated testing), <strong>production</strong> (live server). Each has different configurations for performance, debugging, and safety.</p>
<hr>
<h3>Development Environment</h3>
<p><strong>Purpose: Local development</strong></p>
<pre><code class="language-ruby"># config/environments/development.rb
Rails.application.configure do
  # Don&#39;t cache
  config.cache_classes = false
  
  # Reload code on every request
  config.eager_load = false
  
  # Show detailed errors
  config.consider_all_requests_local = true
  
  # Cache in memory
  config.cache_store = :memory_store
  
  # Asset pipeline not precompiled
  config.assets.debug = true
  config.assets.compile = true
  
  # Action Mailer
  config.action_mailer.raise_delivery_errors = false
  config.action_mailer.perform_caching = false
  config.action_mailer.default_url_options = { host: &#39;localhost&#39;, port: 3000 }
  
  # Active Record
  config.active_record.verbose_query_logs = true
  config.active_record.migration_error = :page_load
end
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">✅ Code reloading (changes visible immediately)
✅ Detailed error pages
✅ No caching (fresh data)
✅ Verbose logging
✅ Asset debugging
✅ Email preview (no real sending)

❌ Slower (reloading overhead)
❌ Not secure (shows errors)
</code></pre>
<hr>
<h3>Test Environment</h3>
<p><strong>Purpose: Automated testing</strong></p>
<pre><code class="language-ruby"># config/environments/test.rb
Rails.application.configure do
  # Cache classes (faster)
  config.cache_classes = true
  
  # Eager load for test coverage
  config.eager_load = false
  
  # Show errors
  config.consider_all_requests_local = true
  
  # Disable caching
  config.cache_store = :null_store
  config.action_controller.perform_caching = false
  
  # Disable mailer delivery
  config.action_mailer.delivery_method = :test
  
  # Use test database
  config.active_record.maintain_test_schema = true
  
  # Faster password hashing
  config.active_support.test_order = :random
end
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">✅ Database cleaned between tests
✅ Fast (code cached)
✅ Isolated (no side effects)
✅ Emails captured, not sent
✅ Repeatable

# Test database separate from development
database:
  test: myapp_test
  development: myapp_development
</code></pre>
<hr>
<h3>Production Environment</h3>
<p><strong>Purpose: Live server</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
Rails.application.configure do
  # Cache everything
  config.cache_classes = true
  
  # Eager load all code
  config.eager_load = true
  
  # Hide errors from users
  config.consider_all_requests_local = false
  
  # Use external cache (Redis)
  config.cache_store = :redis_cache_store, { url: ENV[&#39;REDIS_URL&#39;] }
  
  # Precompile assets
  config.assets.compile = false
  config.assets.digest = true
  
  # Force SSL
  config.force_ssl = true
  
  # Minimal logging
  config.log_level = :info
  
  # Action Mailer
  config.action_mailer.perform_caching = false
  config.action_mailer.delivery_method = :smtp
  
  # Error tracking
  config.active_support.report_deprecations = false
end
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">✅ Fast (precompiled, cached)
✅ Secure (no error details)
✅ Scalable
✅ Monitored

⚠️  Must precompile assets
⚠️  Requires restart for code changes
⚠️  External dependencies (Redis, etc.)
</code></pre>
<hr>
<h3>Environment Comparison</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Development</th>
<th>Test</th>
<th>Production</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Code reload</strong></td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><strong>Caching</strong></td>
<td>Minimal</td>
<td>No</td>
<td>Full</td>
</tr>
<tr>
<td><strong>Error pages</strong></td>
<td>Detailed</td>
<td>Detailed</td>
<td>Generic</td>
</tr>
<tr>
<td><strong>Asset compile</strong></td>
<td>On-demand</td>
<td>No</td>
<td>Precompiled</td>
</tr>
<tr>
<td><strong>Database</strong></td>
<td>dev DB</td>
<td>test DB</td>
<td>prod DB</td>
</tr>
<tr>
<td><strong>Emails</strong></td>
<td>Preview</td>
<td>Captured</td>
<td>Sent</td>
</tr>
<tr>
<td><strong>Speed</strong></td>
<td>Slower</td>
<td>Fast</td>
<td>Fastest</td>
</tr>
<tr>
<td><strong>Security</strong></td>
<td>Low</td>
<td>N/A</td>
<td>High</td>
</tr>
</tbody></table>
<hr>
<h3>Checking Current Environment</h3>
<pre><code class="language-ruby"># In code:
Rails.env                    # =&gt; &quot;development&quot;
Rails.env.development?       # =&gt; true
Rails.env.production?        # =&gt; false
Rails.env.test?              # =&gt; false

# Environment-specific code:
if Rails.env.production?
  # Production-only code
end

unless Rails.env.test?
  # Skip in tests
end

# Case statement:
case Rails.env
when &#39;development&#39;
  # Dev code
when &#39;production&#39;
  # Prod code
end
</code></pre>
<hr>
<h3>Custom Environments</h3>
<p><strong>Creating staging environment:</strong></p>
<pre><code class="language-ruby"># config/environments/staging.rb
require_relative &#39;production&#39;

Rails.application.configure do
  # Same as production but with debugging
  config.log_level = :debug
  config.consider_all_requests_local = true
end
</code></pre>
<p><strong>Using custom environment:</strong></p>
<pre><code class="language-bash"># Start server
RAILS_ENV=staging rails server

# Run console
RAILS_ENV=staging rails console

# Run migrations
RAILS_ENV=staging rails db:migrate

# Precompile assets
RAILS_ENV=staging rails assets:precompile
</code></pre>
<hr>
<h3>Environment-Specific Config</h3>
<p><strong>Database:</strong></p>
<pre><code class="language-yaml"># config/database.yml
development:
  adapter: postgresql
  database: myapp_development
  host: localhost

test:
  adapter: postgresql
  database: myapp_test
  host: localhost

production:
  adapter: postgresql
  database: myapp_production
  url: &lt;%= ENV[&#39;DATABASE_URL&#39;] %&gt;
</code></pre>
<p><strong>Secrets:</strong></p>
<pre><code class="language-yaml"># config/credentials.yml.enc
development:
  secret_key_base: abc123...

test:
  secret_key_base: def456...

production:
  secret_key_base: &lt;%= ENV[&#39;SECRET_KEY_BASE&#39;] %&gt;
</code></pre>
<hr>
<h3>Environment Variables</h3>
<pre><code class="language-bash"># .env.development
DATABASE_URL=postgresql://localhost/myapp_dev
REDIS_URL=redis://localhost:6379/0
AWS_ACCESS_KEY_ID=dev_key

# .env.test
DATABASE_URL=postgresql://localhost/myapp_test
REDIS_URL=redis://localhost:6379/1

# .env.production
DATABASE_URL=postgresql://prod-server/myapp
REDIS_URL=redis://prod-cache:6379/0
AWS_ACCESS_KEY_ID=prod_key
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Three defaults</strong> - dev, test, prod</li>
<li><strong>Development</strong> - code reload, detailed errors</li>
<li><strong>Test</strong> - isolated, fast, repeatable</li>
<li><strong>Production</strong> - cached, secure, fast</li>
<li><strong>Rails.env</strong> to check environment</li>
<li><strong>Environment-specific</strong> configs</li>
<li><strong>Custom environments</strong> possible</li>
<li><strong>Database per environment</strong></li>
<li><strong>Secrets per environment</strong></li>
<li><strong>Choose</strong> based on use case</li>
</ol>
<hr>
<h2>Question 128: What is the purpose of <code>config/application.rb</code> and <code>config/environment.rb</code>?</h2>
<h3>Answer</h3>
<p><strong><code>config/application.rb</code></strong> defines application-wide configuration and loads Rails framework. <strong><code>config/environment.rb</code></strong> initializes the Rails application by loading application.rb. application.rb = configuration, environment.rb = initialization.</p>
<hr>
<h3>config/application.rb</h3>
<p><strong>Purpose: Application configuration</strong></p>
<pre><code class="language-ruby"># config/application.rb
require_relative &quot;boot&quot;
require &quot;rails/all&quot;

# Require gems from Gemfile
Bundler.require(*Rails.groups)

module MyApp
  class Application &lt; Rails::Application
    # Initialize configuration defaults for Rails version
    config.load_defaults 7.0
    
    # Application-wide settings
    config.time_zone = &quot;Eastern Time (US &amp; Canada)&quot;
    config.i18n.default_locale = :en
    
    # Active Job adapter
    config.active_job.queue_adapter = :sidekiq
    
    # Middleware
    config.middleware.use Rack::Attack
    
    # Autoload paths
    config.autoload_paths += %W[#{config.root}/lib]
    config.eager_load_paths += %W[#{config.root}/lib]
    
    # Asset configuration
    config.assets.paths &lt;&lt; Rails.root.join(&#39;app&#39;, &#39;assets&#39;, &#39;fonts&#39;)
    
    # Session store
    config.session_store :cookie_store, key: &#39;_myapp_session&#39;
    
    # Generators
    config.generators do |g|
      g.test_framework :rspec
      g.template_engine :slim
      g.stylesheets false
      g.javascripts false
    end
  end
end
</code></pre>
<p><strong>What it does:</strong></p>
<pre><code class="language-ruby">1. Loads Rails framework
2. Requires gems from Gemfile
3. Defines application module and class
4. Sets application-wide configuration
5. Configures middleware
6. Sets autoload paths
7. Configures generators
8. Defines defaults for all environments
</code></pre>
<hr>
<h3>config/environment.rb</h3>
<p><strong>Purpose: Initialize Rails</strong></p>
<pre><code class="language-ruby"># config/environment.rb
# Load the Rails application
require_relative &quot;application&quot;

# Initialize the Rails application
Rails.application.initialize!
</code></pre>
<p><strong>What it does:</strong></p>
<pre><code class="language-ruby">1. Loads application.rb
2. Runs initializers (config/initializers/*)
3. Loads environment file (config/environments/*.rb)
4. Finalizes configuration
5. Makes application ready to receive requests

# Boot sequence:
# 1. config/boot.rb        (Bundler setup)
# 2. config/application.rb (App definition)
# 3. config/environment.rb (Initialization)
# 4. config/environments/[env].rb (Environment config)
# 5. config/initializers/* (Custom initializers)
</code></pre>
<hr>
<h3>Boot Sequence</h3>
<pre><code>┌──────────────────────────────────────────────────────┐
│  1. config/boot.rb                                   │
│     - Sets up Bundler                                │
│     - Requires gems                                  │
└────────────────┬─────────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────────┐
│  2. config/application.rb                            │
│     - Loads Rails                                    │
│     - Defines application class                      │
│     - Sets default configuration                     │
└────────────────┬─────────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────────┐
│  3. config/environment.rb                            │
│     - Loads application.rb                           │
│     - Calls Rails.application.initialize!            │
└────────────────┬─────────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────────┐
│  4. config/environments/[environment].rb             │
│     - Environment-specific configuration             │
│     - Overrides application.rb settings              │
└────────────────┬─────────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────────────────────┐
│  5. config/initializers/* (alphabetical)             │
│     - Custom initializers                            │
│     - Gem configurations                             │
└──────────────────────────────────────────────────────┘
</code></pre>
<hr>
<h3>Common application.rb Configurations</h3>
<p><strong>Time zone and localization:</strong></p>
<pre><code class="language-ruby">config.time_zone = &#39;Pacific Time (US &amp; Canada)&#39;
config.active_record.default_timezone = :local
config.i18n.default_locale = :en
config.i18n.available_locales = [:en, :es, :fr]
</code></pre>
<p><strong>Autoloading:</strong></p>
<pre><code class="language-ruby"># Add directories to autoload
config.autoload_paths += %W[
  #{config.root}/app/services
  #{config.root}/app/presenters
  #{config.root}/lib
]

# Eager load paths (preload in production)
config.eager_load_paths += %W[
  #{config.root}/lib
]
</code></pre>
<p><strong>Middleware:</strong></p>
<pre><code class="language-ruby"># Add middleware
config.middleware.use Rack::Attack
config.middleware.use Rack::Deflater

# Remove middleware
config.middleware.delete Rack::Runtime

# Insert middleware at position
config.middleware.insert_before ActionDispatch::Static, Rack::Cors
</code></pre>
<p><strong>Active Job:</strong></p>
<pre><code class="language-ruby">config.active_job.queue_adapter = :sidekiq
config.active_job.queue_name_prefix = &quot;myapp_#{Rails.env}&quot;
</code></pre>
<p><strong>Active Storage:</strong></p>
<pre><code class="language-ruby">config.active_storage.service = :local
config.active_storage.variant_processor = :vips
</code></pre>
<p><strong>Generators:</strong></p>
<pre><code class="language-ruby">config.generators do |g|
  g.orm :active_record
  g.test_framework :rspec, fixtures: false
  g.fixture_replacement :factory_bot, dir: &#39;spec/factories&#39;
  g.stylesheets false
  g.javascripts false
  g.helper false
end
</code></pre>
<hr>
<h3>When to Modify Each</h3>
<p><strong>Modify application.rb when:</strong></p>
<pre><code class="language-ruby">✅ Adding application-wide settings
✅ Configuring generators
✅ Adding middleware
✅ Setting autoload paths
✅ Configuring Active Job adapter
✅ Setting time zone
✅ Adding asset paths
</code></pre>
<p><strong>Modify environment.rb when:</strong></p>
<pre><code class="language-ruby">❌ Almost never!
⚠️  Only for very unusual initialization needs
⚠️  Most config goes in application.rb or environments/*.rb
</code></pre>
<hr>
<h3>Example Configurations</h3>
<p><strong>application.rb:</strong></p>
<pre><code class="language-ruby">module MyApp
  class Application &lt; Rails::Application
    config.load_defaults 7.0
    
    # Basics
    config.time_zone = &#39;UTC&#39;
    config.active_record.default_timezone = :utc
    
    # I18n
    config.i18n.default_locale = :en
    config.i18n.load_path += Dir[
      Rails.root.join(&#39;config&#39;, &#39;locales&#39;, &#39;**&#39;, &#39;*.{rb,yml}&#39;)
    ]
    
    # Jobs
    config.active_job.queue_adapter = :sidekiq
    config.active_job.queue_name_prefix = &quot;myapp_#{Rails.env}&quot;
    
    # Mailer
    config.action_mailer.default_url_options = { 
      host: ENV[&#39;APP_HOST&#39;]
    }
    
    # Assets
    config.assets.paths &lt;&lt; Rails.root.join(&#39;app&#39;, &#39;assets&#39;, &#39;fonts&#39;)
    config.assets.precompile += %w[admin.css admin.js]
    
    # Autoload
    config.autoload_paths += %W[
      #{config.root}/app/services
      #{config.root}/app/presenters
    ]
    
    # Middleware
    config.middleware.use Rack::Attack
    config.middleware.insert_before 0, Rack::Cors do
      allow do
        origins &#39;*&#39;
        resource &#39;*&#39;, headers: :any, methods: [:get, :post]
      end
    end
    
    # Generators
    config.generators do |g|
      g.test_framework :rspec
      g.fixture_replacement :factory_bot
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>application.rb</strong> - app configuration</li>
<li><strong>environment.rb</strong> - app initialization</li>
<li><strong>application.rb</strong> loaded first</li>
<li><strong>environment.rb</strong> calls initialize!</li>
<li><strong>Modify application.rb</strong> frequently</li>
<li><strong>Rarely touch</strong> environment.rb</li>
<li><strong>Boot sequence</strong> matters</li>
<li><strong>Environment-specific</strong> in environments/</li>
<li><strong>Custom initializers</strong> in initializers/</li>
<li><strong>Test changes</strong> in all environments</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 129: What is Rails autoloading, and how does it work?</h2>
<h3>Answer</h3>
<p><strong>Autoloading</strong> automatically loads Ruby classes and modules without explicit <code>require</code> statements. Rails uses <strong>Zeitwerk</strong> (Rails 6+) to load constants on-demand based on file naming conventions.</p>
<hr>
<h3>How Autoloading Works</h3>
<p><strong>Without autoloading:</strong></p>
<pre><code class="language-ruby"># Manually require every file
require &#39;app/models/user&#39;
require &#39;app/models/post&#39;
require &#39;app/services/user_service&#39;
require &#39;app/services/post_service&#39;

user = User.new
post = Post.new
</code></pre>
<p><strong>With autoloading:</strong></p>
<pre><code class="language-ruby"># No requires needed!
user = User.new  # Rails automatically loads app/models/user.rb
post = Post.new  # Rails automatically loads app/models/post.rb

UserService.call  # Loads app/services/user_service.rb
</code></pre>
<hr>
<h3>File Naming Conventions</h3>
<p><strong>Class/Module to File mapping:</strong></p>
<pre><code class="language-ruby"># Class name → File path

User → app/models/user.rb
Post → app/models/post.rb
UserService → app/services/user_service.rb
Api::V1::PostsController → app/controllers/api/v1/posts_controller.rb

# Rules:
# 1. CamelCase → snake_case
# 2. Namespace :: → directory /
# 3. Class name must match file name
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-ruby"># app/models/user.rb
class User &lt; ApplicationRecord
end

# app/models/admin/user.rb
module Admin
  class User &lt; ApplicationRecord
  end
end

# app/services/user_service.rb
class UserService
  def self.call(user)
    # ...
  end
end

# app/controllers/api/v1/users_controller.rb
module Api
  module V1
    class UsersController &lt; ApplicationController
    end
  end
end
</code></pre>
<hr>
<h3>Autoload Paths</h3>
<p><strong>Default autoload paths:</strong></p>
<pre><code class="language-ruby"># Rails automatically loads from:
app/models
app/controllers
app/helpers
app/mailers
app/jobs
app/channels
app/lib

# Check autoload paths:
Rails.application.config.autoload_paths
# =&gt; [
#   &quot;/app/models&quot;,
#   &quot;/app/controllers&quot;,
#   ...
# ]
</code></pre>
<p><strong>Adding custom paths:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.autoload_paths += %W[
  #{config.root}/app/services
  #{config.root}/app/presenters
  #{config.root}/app/decorators
]

# Now autoload works:
UserService.call  # Loads app/services/user_service.rb
UserPresenter.new # Loads app/presenters/user_presenter.rb
</code></pre>
<hr>
<h3>Development vs Production</h3>
<p><strong>Development mode:</strong></p>
<pre><code class="language-ruby"># Code reloading enabled
config.cache_classes = false
config.eager_load = false

# Files loaded on-demand
user = User.new  # Loads user.rb now

# Files reloaded on each request
# Change user.rb, refresh browser - sees changes
</code></pre>
<p><strong>Production mode:</strong></p>
<pre><code class="language-ruby"># Code cached, no reloading
config.cache_classes = true
config.eager_load = true

# All files loaded at startup
# No on-demand loading
# Faster (no file system checks)
</code></pre>
<hr>
<h3>Eager Loading</h3>
<p><strong>Load all files at startup:</strong></p>
<pre><code class="language-ruby"># Eager load in production
config.eager_load = true

# All files loaded when app starts:
Rails.application.eager_load!

# Benefits:
# - Catches missing constant errors at boot
# - No autoload overhead in requests
# - Better for production

# Drawbacks:
# - Slower startup
# - More memory usage
</code></pre>
<hr>
<h3>Common Autoloading Issues</h3>
<p><strong>Issue 1: Naming mismatch</strong></p>
<pre><code class="language-ruby"># ❌ WRONG
# File: app/services/user_service.rb
class UserServices  # Class name doesn&#39;t match file name
end

# Error: Unable to autoload constant UserService

# ✅ CORRECT
# File: app/services/user_service.rb
class UserService
end
</code></pre>
<p><strong>Issue 2: Nested module wrong</strong></p>
<pre><code class="language-ruby"># ❌ WRONG
# File: app/services/api/user_service.rb
module Api
  class UserService
  end
end

# Error: Expected app/services/api/user_service.rb to define Api::UserService

# ✅ CORRECT
# File: app/services/api/user_service.rb
class Api::UserService
end

# Or use proper nesting:
module Api
  class UserService
  end
end
</code></pre>
<p><strong>Issue 3: Missing directory</strong></p>
<pre><code class="language-ruby"># ❌ WRONG
# File: app/services/user_service.rb
module Services
  class UserService
  end
end

# Error: uninitialized constant Services

# ✅ CORRECT - create directory
# File: app/services/services/user_service.rb
module Services
  class UserService
  end
end

# Or don&#39;t use module:
# File: app/services/user_service.rb
class UserService
end
</code></pre>
<hr>
<h3>Reloading in Development</h3>
<p><strong>How it works:</strong></p>
<pre><code class="language-ruby"># Request 1:
User.first  # Loads app/models/user.rb

# Modify user.rb

# Request 2:
User.first  # Reloads app/models/user.rb with changes

# Rails tracks file modification times
# Reloads changed files between requests
</code></pre>
<p><strong>Force reload:</strong></p>
<pre><code class="language-ruby"># In rails console
reload!

# Reloads all code
# Useful after modifying files
</code></pre>
<hr>
<h3>Autoload vs Require</h3>
<p><strong>When to use require:</strong></p>
<pre><code class="language-ruby"># ❌ Don&#39;t require app code
require &#39;app/models/user&#39;  # Autoloaded automatically

# ✅ Use require for:
# - Gems from lib/
require &#39;my_gem&#39;

# - Standard library
require &#39;json&#39;
require &#39;csv&#39;

# - Files in lib/ that aren&#39;t autoloaded
require &#39;lib/custom_logger&#39;
</code></pre>
<hr>
<h3>Autoload Gotchas</h3>
<p><strong>1. Constants in wrong place:</strong></p>
<pre><code class="language-ruby"># app/models/user.rb
class User &lt; ApplicationRecord
  STATUSES = [&#39;active&#39;, &#39;inactive&#39;]
end

# Access:
User::STATUSES  # Works

# ❌ Don&#39;t define outside class:
STATUSES = [&#39;active&#39;, &#39;inactive&#39;]  # Won&#39;t autoload

class User &lt; ApplicationRecord
end
</code></pre>
<p><strong>2. Single Table Inheritance (STI):</strong></p>
<pre><code class="language-ruby"># app/models/user.rb
class User &lt; ApplicationRecord
end

# app/models/admin.rb
class Admin &lt; User  # Subclass of User
end

# Autoload works:
Admin.first  # Loads admin.rb, then user.rb
</code></pre>
<p><strong>3. Circular dependencies:</strong></p>
<pre><code class="language-ruby"># app/models/user.rb
class User
  has_many :posts
end

# app/models/post.rb  
class Post
  belongs_to :user
end

# Works fine - Rails handles circular references
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Autoloading</strong> loads files on-demand</li>
<li><strong>CamelCase → snake_case</strong></li>
<li><strong>Namespace :: → directory /</strong></li>
<li><strong>Development</strong> reloads code</li>
<li><strong>Production</strong> eager loads all</li>
<li><strong>File name</strong> must match class</li>
<li><strong>Autoload paths</strong> configurable</li>
<li><strong>No require</strong> for app code</li>
<li><strong>reload!</strong> in console</li>
<li><strong>Eager load</strong> catches errors early</li>
</ol>
<hr>
<h2>Question 130: What is Zeitwerk, and how does it impact Rails applications?</h2>
<h3>Answer</h3>
<p><strong>Zeitwerk</strong> is Rails&#39; autoloader (since Rails 6) that uses Ruby&#39;s <code>Module#autoload</code> for efficient constant loading. It&#39;s faster, more reliable, and enforces stricter naming conventions than the old autoloader.</p>
<hr>
<h3>What is Zeitwerk?</h3>
<p><strong>Modern autoloader:</strong></p>
<pre><code class="language-ruby"># Gem by Xavier Noria
# Replaces Rails&#39; classic autoloader (Rails &lt;= 5)
# Default in Rails 6+
# Uses Ruby&#39;s native autoload mechanism
# Faster and more efficient
</code></pre>
<p><strong>Key improvements:</strong></p>
<pre><code class="language-ruby">✅ Thread-safe
✅ Faster loading
✅ Stricter conventions
✅ Better error messages
✅ Reloads without memory leaks
✅ Handles edge cases better
</code></pre>
<hr>
<h3>How Zeitwerk Works</h3>
<p><strong>Constant resolution:</strong></p>
<pre><code class="language-ruby"># When you reference a constant:
User.first

# Zeitwerk:
# 1. Checks if User is loaded
# 2. If not, looks for app/models/user.rb
# 3. Loads the file
# 4. Verifies User constant is defined
# 5. Returns the constant

# Caches the mapping for future references
</code></pre>
<p><strong>Automatic mapping:</strong></p>
<pre><code class="language-ruby"># Zeitwerk maps constants to files automatically:

User                 → app/models/user.rb
UserService          → app/services/user_service.rb
Api::V1::UsersController → app/controllers/api/v1/users_controller.rb

# No configuration needed for standard paths
</code></pre>
<hr>
<h3>Naming Conventions (Strict!)</h3>
<p><strong>Inflection rules:</strong></p>
<pre><code class="language-ruby"># CamelCase → snake_case
User → user.rb
UserPost → user_post.rb
HTTPServer → http_server.rb

# Acronyms inflected:
API → api.rb
HTMLParser → html_parser.rb

# Custom inflections:
# config/initializers/inflections.rb
ActiveSupport::Inflector.inflections(:en) do |inflect|
  inflect.acronym &#39;API&#39;
  inflect.acronym &#39;HTML&#39;
end

# Now:
API → api.rb (not a_p_i.rb)
HTMLParser → html_parser.rb (not h_t_m_l_parser.rb)
</code></pre>
<hr>
<h3>File Structure Requirements</h3>
<p><strong>Must match exactly:</strong></p>
<pre><code class="language-ruby"># ✅ CORRECT
# app/models/user.rb
class User &lt; ApplicationRecord
end

# app/models/admin/user.rb
module Admin
  class User &lt; ApplicationRecord
  end
end

# ❌ WRONG - class name doesn&#39;t match file
# app/models/user.rb
class Users  # Should be User
end

# ❌ WRONG - module nesting incorrect
# app/models/admin/user.rb
class User  # Should be Admin::User or module Admin
end
</code></pre>
<hr>
<h3>Configuration</h3>
<p><strong>Enable/disable:</strong></p>
<pre><code class="language-ruby"># config/application.rb
# Zeitwerk enabled by default in Rails 6+
config.autoloader = :zeitwerk

# Classic autoloader (deprecated):
config.autoloader = :classic
</code></pre>
<p><strong>Autoload paths:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.autoload_paths += %W[
  #{config.root}/app/services
  #{config.root}/app/presenters
]

# Zeitwerk automatically watches these paths
</code></pre>
<p><strong>Ignored files:</strong></p>
<pre><code class="language-ruby"># config/initializers/zeitwerk.rb
Rails.autoloaders.main.ignore(
  Rails.root.join(&#39;app&#39;, &#39;models&#39;, &#39;concerns&#39;, &#39;legacy.rb&#39;)
)

# File won&#39;t be autoloaded
</code></pre>
<p><strong>Custom inflections:</strong></p>
<pre><code class="language-ruby"># config/initializers/zeitwerk.rb
Rails.autoloaders.main.inflector.inflect(
  &quot;html_parser&quot; =&gt; &quot;HTMLParser&quot;,
  &quot;api&quot; =&gt; &quot;API&quot;
)
</code></pre>
<hr>
<h3>Benefits Over Classic Autoloader</h3>
<p><strong>1. Thread safety:</strong></p>
<pre><code class="language-ruby"># Classic autoloader:
# Race conditions possible with concurrent requests

# Zeitwerk:
# Uses Ruby&#39;s autoload (thread-safe)
# No race conditions
</code></pre>
<p><strong>2. Better error messages:</strong></p>
<pre><code class="language-ruby"># Classic:
# &quot;uninitialized constant User&quot;

# Zeitwerk:
# &quot;expected file app/models/user.rb to define constant User, 
#  but didn&#39;t&quot;
# Much more helpful!
</code></pre>
<p><strong>3. No reloading issues:</strong></p>
<pre><code class="language-ruby"># Classic:
# Memory leaks with code reloading
# Stale constants

# Zeitwerk:
# Clean reloading
# No memory leaks
</code></pre>
<p><strong>4. Explicit errors:</strong></p>
<pre><code class="language-ruby"># Classic:
# Silent failures
# Wrong constants loaded

# Zeitwerk:
# Explicit errors for mismatches
# Enforces conventions
</code></pre>
<hr>
<h3>Migration from Classic to Zeitwerk</h3>
<p><strong>Upgrade steps:</strong></p>
<pre><code class="language-ruby"># 1. Update Rails to 6+
gem &#39;rails&#39;, &#39;~&gt; 7.0&#39;

# 2. Run Zeitwerk check
rails zeitwerk:check

# 3. Fix reported issues
# - Rename mismatched files
# - Fix namespace issues
# - Update custom inflections

# 4. Test thoroughly
# - Run full test suite
# - Check development reloading
# - Test production eager loading

# 5. Deploy
</code></pre>
<p><strong>Common migration issues:</strong></p>
<pre><code class="language-ruby"># Issue 1: Misnamed files
# app/models/users.rb (plural)
class User  # singular

# Fix: Rename file to user.rb

# Issue 2: Wrong namespace
# app/services/api/user_service.rb
class UserService  # Missing Api::

# Fix:
class Api::UserService
end

# Issue 3: Files not in autoload paths
# lib/custom_service.rb
class CustomService
end

# Fix: Add to autoload_paths
config.autoload_paths &lt;&lt; Rails.root.join(&#39;lib&#39;)
</code></pre>
<hr>
<h3>Eager Loading</h3>
<p><strong>Production preloading:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.eager_load = true

# Zeitwerk loads all files at boot:
Rails.application.eager_load!

# Catches issues:
# - Missing constants
# - Naming mismatches
# - Loading errors

# Before deploy:
RAILS_ENV=production rails zeitwerk:check
</code></pre>
<hr>
<h3>Debugging Zeitwerk</h3>
<p><strong>Check setup:</strong></p>
<pre><code class="language-ruby"># rails console
Rails.autoloaders.main.dirs
# Shows all autoload directories

Rails.autoloaders.main.eager_load_dir(Rails.root.join(&#39;app/models&#39;))
# Eager load specific directory

Rails.autoloaders.main.all_expected_cptrs
# List all expected constants
</code></pre>
<p><strong>Enable logging:</strong></p>
<pre><code class="language-ruby"># config/environments/development.rb
Rails.autoloaders.log!

# Now see:
# Zeitwerk@rails.main: autoload set for User, to be loaded from app/models/user.rb
# Zeitwerk@rails.main: constant User loaded from app/models/user.rb
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Follow conventions strictly:</strong></p>
<pre><code class="language-ruby">✅ File names match class names
✅ Directory structure matches namespaces
✅ One class/module per file
✅ Use standard inflections
</code></pre>
<p><strong>2. Use zeitwerk:check:</strong></p>
<pre><code class="language-ruby"># Before deploy:
rails zeitwerk:check

# Catches all naming issues
# Run in CI pipeline
</code></pre>
<p><strong>3. Eager load in tests:</strong></p>
<pre><code class="language-ruby"># spec/rails_helper.rb
RSpec.configure do |config|
  config.before(:suite) do
    Rails.application.eager_load!
  end
end

# Catches autoload issues in tests
</code></pre>
<p><strong>4. Avoid explicit requires:</strong></p>
<pre><code class="language-ruby"># ❌ Don&#39;t require app code
require &#39;app/models/user&#39;

# ✅ Let Zeitwerk handle it
User.first
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Zeitwerk</strong> - Rails 6+ autoloader</li>
<li><strong>Thread-safe</strong> and efficient</li>
<li><strong>Strict conventions</strong> enforced</li>
<li><strong>Better errors</strong> than classic</li>
<li><strong>File names</strong> must match exactly</li>
<li><strong>zeitwerk:check</strong> before deploy</li>
<li><strong>No memory leaks</strong> on reload</li>
<li><strong>Eager load</strong> in production</li>
<li><strong>Custom inflections</strong> possible</li>
<li><strong>Default</strong> in Rails 6+</li>
</ol>
<h1>Rails Components Interview Questions</h1>
<h2>Question 131: What is Action Controller in Rails?</h2>
<h3>Answer</h3>
<p><strong>Action Controller</strong> is the <strong>C</strong> in MVC - it handles HTTP requests, processes business logic, and renders responses. Controllers receive requests from the router, interact with models, and decide what view to render or data to return.</p>
<hr>
<h3>Basic Structure</h3>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  # ApplicationController inherits from ActionController::Base
  
  # Action: public method that handles a request
  def index
    @posts = Post.all
    # Implicitly renders views/posts/index.html.erb
  end
  
  def show
    @post = Post.find(params[:id])
    # Implicitly renders views/posts/show.html.erb
  end
  
  def create
    @post = Post.new(post_params)
    
    if @post.save
      redirect_to @post, notice: &#39;Post created&#39;
    else
      render :new
    end
  end
  
  private
  
  def post_params
    params.require(:post).permit(:title, :body)
  end
end
</code></pre>
<hr>
<h3>Controller Responsibilities</h3>
<p><strong>1. Request handling:</strong></p>
<pre><code class="language-ruby">class UsersController &lt; ApplicationController
  # Handle GET /users
  def index
    @users = User.all
  end
  
  # Handle GET /users/:id
  def show
    @user = User.find(params[:id])
  end
  
  # Handle POST /users
  def create
    @user = User.new(user_params)
    @user.save
  end
end
</code></pre>
<p><strong>2. Parameter processing:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    # Access URL parameters
    @category_id = params[:category_id]
    
    # Access form data
    @title = params[:post][:title]
    
    # Strong parameters (secure)
    @post = Post.new(post_params)
  end
  
  private
  
  def post_params
    params.require(:post).permit(:title, :body, :published)
  end
end
</code></pre>
<p><strong>3. Response rendering:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    
    respond_to do |format|
      format.html  # Renders show.html.erb
      format.json { render json: @post }
      format.xml  { render xml: @post }
    end
  end
end
</code></pre>
<hr>
<h3>Common Controller Methods</h3>
<p><strong>Rendering:</strong></p>
<pre><code class="language-ruby"># Render template
render :new
render &#39;shared/error&#39;
render template: &#39;posts/show&#39;

# Render inline
render plain: &#39;Hello World&#39;
render html: &#39;&lt;h1&gt;Hello&lt;/h1&gt;&#39;.html_safe
render json: { status: &#39;ok&#39; }
render xml: @post.to_xml

# Render with status
render :new, status: :unprocessable_entity
render json: { error: &#39;Not found&#39; }, status: :not_found

# Render file
render file: &#39;/path/to/file&#39;
</code></pre>
<p><strong>Redirecting:</strong></p>
<pre><code class="language-ruby"># Redirect to URL
redirect_to posts_path
redirect_to @post
redirect_to root_url

# Redirect with flash
redirect_to @post, notice: &#39;Post created&#39;
redirect_to posts_path, alert: &#39;Error occurred&#39;

# Redirect with status
redirect_to @post, status: :moved_permanently
</code></pre>
<p><strong>Responding:</strong></p>
<pre><code class="language-ruby"># Head (no body)
head :ok
head :not_found
head :no_content

# Send file
send_file &#39;/path/to/file.pdf&#39;
send_data pdf_data, filename: &#39;report.pdf&#39;
</code></pre>
<hr>
<h3>Filters (Callbacks)</h3>
<p><strong>before_action:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  before_action :authenticate_user!
  before_action :set_post, only: [:show, :edit, :update, :destroy]
  before_action :authorize_post, only: [:edit, :update, :destroy]
  
  def show
    # @post already set by before_action
  end
  
  def edit
    # @post set, user authorized
  end
  
  private
  
  def set_post
    @post = Post.find(params[:id])
  end
  
  def authorize_post
    redirect_to root_path unless @post.user == current_user
  end
end
</code></pre>
<p><strong>after_action and around_action:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  after_action :log_activity
  around_action :wrap_in_transaction
  
  private
  
  def log_activity
    ActivityLog.create(
      user: current_user,
      action: action_name,
      controller: controller_name
    )
  end
  
  def wrap_in_transaction
    ActiveRecord::Base.transaction do
      yield
    end
  end
end
</code></pre>
<p><strong>Skip filters:</strong></p>
<pre><code class="language-ruby">class PublicPostsController &lt; ApplicationController
  skip_before_action :authenticate_user!, only: [:index, :show]
end
</code></pre>
<hr>
<h3>Request and Response Objects</h3>
<p><strong>Request:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    # Request method
    request.get?     # false
    request.post?    # true
    request.put?     # false
    request.delete?  # false
    
    # Request info
    request.remote_ip        # Client IP
    request.user_agent       # Browser
    request.referer          # Previous URL
    request.format           # :html, :json, etc.
    
    # Headers
    request.headers[&#39;Authorization&#39;]
    request.headers[&#39;Content-Type&#39;]
    
    # Full URL
    request.url              # http://example.com/posts/1
    request.protocol         # http://
    request.host             # example.com
    request.path             # /posts/1
    request.query_string     # ?page=2
  end
end
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    
    # Set headers
    response.headers[&#39;X-Custom-Header&#39;] = &#39;value&#39;
    
    # Set status
    response.status = 200
    
    # Set content type
    response.content_type = &#39;application/json&#39;
    
    render json: @post
  end
end
</code></pre>
<hr>
<h3>Session and Cookies</h3>
<pre><code class="language-ruby">class SessionsController &lt; ApplicationController
  def create
    user = User.find_by(email: params[:email])
    
    if user&amp;.authenticate(params[:password])
      # Set session
      session[:user_id] = user.id
      
      # Set cookie
      cookies[:remember_token] = user.remember_token
      
      redirect_to root_path
    else
      flash.now[:alert] = &#39;Invalid credentials&#39;
      render :new
    end
  end
  
  def destroy
    # Clear session
    session.delete(:user_id)
    reset_session
    
    # Clear cookie
    cookies.delete(:remember_token)
    
    redirect_to root_path
  end
end
</code></pre>
<hr>
<h3>Flash Messages</h3>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    @post = Post.new(post_params)
    
    if @post.save
      # Flash for redirect
      flash[:notice] = &#39;Post created&#39;
      redirect_to @post
    else
      # Flash for render (current request only)
      flash.now[:alert] = &#39;Failed to create post&#39;
      render :new
    end
  end
end

# View:
&lt;% if flash[:notice] %&gt;
  &lt;div class=&quot;alert alert-success&quot;&gt;&lt;%= flash[:notice] %&gt;&lt;/div&gt;
&lt;% end %&gt;

&lt;% if flash[:alert] %&gt;
  &lt;div class=&quot;alert alert-danger&quot;&gt;&lt;%= flash[:alert] %&gt;&lt;/div&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Exception Handling</h3>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  rescue_from ActiveRecord::RecordNotFound, with: :not_found
  rescue_from ActionController::ParameterMissing, with: :bad_request
  rescue_from StandardError, with: :internal_error
  
  private
  
  def not_found
    render file: &quot;#{Rails.root}/public/404.html&quot;, status: :not_found
  end
  
  def bad_request
    render json: { error: &#39;Bad request&#39; }, status: :bad_request
  end
  
  def internal_error(exception)
    logger.error exception.message
    Sentry.capture_exception(exception)
    render json: { error: &#39;Internal error&#39; }, status: :internal_server_error
  end
end
</code></pre>
<hr>
<h3>RESTful Actions</h3>
<p><strong>Standard CRUD:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  # GET /posts
  def index
    @posts = Post.all
  end
  
  # GET /posts/:id
  def show
    @post = Post.find(params[:id])
  end
  
  # GET /posts/new
  def new
    @post = Post.new
  end
  
  # POST /posts
  def create
    @post = Post.new(post_params)
    
    if @post.save
      redirect_to @post
    else
      render :new
    end
  end
  
  # GET /posts/:id/edit
  def edit
    @post = Post.find(params[:id])
  end
  
  # PATCH/PUT /posts/:id
  def update
    @post = Post.find(params[:id])
    
    if @post.update(post_params)
      redirect_to @post
    else
      render :edit
    end
  end
  
  # DELETE /posts/:id
  def destroy
    @post = Post.find(params[:id])
    @post.destroy
    
    redirect_to posts_path
  end
  
  private
  
  def post_params
    params.require(:post).permit(:title, :body)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Action Controller</strong> handles requests</li>
<li><strong>Actions</strong> are public methods</li>
<li><strong>before_action</strong> for setup</li>
<li><strong>Strong parameters</strong> for security</li>
<li><strong>render</strong> for views</li>
<li><strong>redirect_to</strong> for redirects</li>
<li><strong>session</strong> and <strong>cookies</strong> for state</li>
<li><strong>flash</strong> for messages</li>
<li><strong>rescue_from</strong> for errors</li>
<li><strong>RESTful</strong> actions standard</li>
</ol>
<hr>
<h2>Question 132: What is scaffolding in Rails? (Dynamic vs Static, Nested Scaffolding)</h2>
<h3>Answer</h3>
<p><strong>Scaffolding</strong> generates complete CRUD (Create, Read, Update, Delete) code for a resource - model, migration, controller, views, routes, and tests. It&#39;s a quick way to bootstrap an application with working functionality.</p>
<hr>
<h3>Basic Scaffolding</h3>
<p><strong>Generate scaffold:</strong></p>
<pre><code class="language-bash">rails generate scaffold Post title:string body:text published:boolean

# Generates:
# - Model: app/models/post.rb
# - Migration: db/migrate/xxx_create_posts.rb
# - Controller: app/controllers/posts_controller.rb
# - Views: app/views/posts/*.html.erb (index, show, new, edit, _form)
# - Routes: resources :posts
# - Tests: spec/models/post_spec.rb, spec/requests/posts_spec.rb
# - Helper: app/helpers/posts_helper.rb
# - Assets: app/assets/stylesheets/posts.scss
</code></pre>
<p><strong>Run migration:</strong></p>
<pre><code class="language-bash">rails db:migrate
</code></pre>
<p><strong>Generated code:</strong></p>
<pre><code class="language-ruby"># app/models/post.rb
class Post &lt; ApplicationRecord
end

# app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  before_action :set_post, only: %i[ show edit update destroy ]

  def index
    @posts = Post.all
  end

  def show
  end

  def new
    @post = Post.new
  end

  def edit
  end

  def create
    @post = Post.new(post_params)
    if @post.save
      redirect_to @post, notice: &quot;Post was successfully created.&quot;
    else
      render :new, status: :unprocessable_entity
    end
  end

  def update
    if @post.update(post_params)
      redirect_to @post, notice: &quot;Post was successfully updated.&quot;
    else
      render :edit, status: :unprocessable_entity
    end
  end

  def destroy
    @post.destroy
    redirect_to posts_url, notice: &quot;Post was successfully destroyed.&quot;
  end

  private
  
  def set_post
    @post = Post.find(params[:id])
  end

  def post_params
    params.require(:post).permit(:title, :body, :published)
  end
end

# config/routes.rb
resources :posts
</code></pre>
<hr>
<h3>Scaffold Options</h3>
<p><strong>With namespace:</strong></p>
<pre><code class="language-bash">rails generate scaffold Admin::Post title:string body:text

# Generates:
# - app/models/admin/post.rb
# - app/controllers/admin/posts_controller.rb
# - app/views/admin/posts/
# - namespace :admin in routes
</code></pre>
<p><strong>Specify parent:</strong></p>
<pre><code class="language-bash">rails generate scaffold Comment post:references body:text

# Generates with belongs_to :post
# Migration includes foreign key
</code></pre>
<p><strong>API-only scaffold:</strong></p>
<pre><code class="language-bash">rails generate scaffold Post title:string body:text --api

# Skips views
# Generates API controller
# Returns JSON
</code></pre>
<p><strong>Skip tests:</strong></p>
<pre><code class="language-bash">rails generate scaffold Post title:string --no-test-framework
</code></pre>
<hr>
<h3>Dynamic vs Static Scaffolding</h3>
<p><strong>Static Scaffolding (Current Rails):</strong></p>
<pre><code class="language-ruby"># Generated files are static
# Can be modified freely
# Changes don&#39;t affect generator

# Pros:
✅ Full control over generated code
✅ Can customize everything
✅ No magic

# Cons:
❌ Can&#39;t regenerate without losing changes
❌ Must manually update if schema changes
</code></pre>
<p><strong>Dynamic Scaffolding (Old Rails 1.x):</strong></p>
<pre><code class="language-ruby"># Controllers generated at runtime
# scaffold :post in controller
# Code generated on each request

class PostsController &lt; ApplicationController
  scaffold :post  # Generates CRUD dynamically
end

# Pros:
✅ Automatic updates
✅ No code to maintain

# Cons:
❌ No customization
❌ Performance overhead
❌ Deprecated/removed

# Removed in Rails 2.0
</code></pre>
<hr>
<h3>Nested Scaffolding</h3>
<p><strong>Generate nested resource:</strong></p>
<pre><code class="language-bash"># Blog has many Posts
rails generate scaffold Post blog:references title:string body:text

# Posts have many Comments
rails generate scaffold Comment post:references body:text author:string
</code></pre>
<p><strong>Nested routes:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
resources :blogs do
  resources :posts
end

resources :posts do
  resources :comments
end

# URLs:
# /blogs/1/posts
# /blogs/1/posts/2
# /posts/2/comments
# /posts/2/comments/3
</code></pre>
<p><strong>Nested controller:</strong></p>
<pre><code class="language-ruby">class CommentsController &lt; ApplicationController
  before_action :set_post
  before_action :set_comment, only: [:show, :edit, :update, :destroy]
  
  def index
    @comments = @post.comments
  end
  
  def show
  end
  
  def new
    @comment = @post.comments.build
  end
  
  def create
    @comment = @post.comments.build(comment_params)
    
    if @comment.save
      redirect_to [@post, @comment], notice: &#39;Comment created&#39;
    else
      render :new
    end
  end
  
  def update
    if @comment.update(comment_params)
      redirect_to [@post, @comment], notice: &#39;Comment updated&#39;
    else
      render :edit
    end
  end
  
  def destroy
    @comment.destroy
    redirect_to post_comments_path(@post), notice: &#39;Comment deleted&#39;
  end
  
  private
  
  def set_post
    @post = Post.find(params[:post_id])
  end
  
  def set_comment
    @comment = @post.comments.find(params[:id])
  end
  
  def comment_params
    params.require(:comment).permit(:body, :author)
  end
end
</code></pre>
<hr>
<h3>Customizing Scaffolds</h3>
<p><strong>Override templates:</strong></p>
<pre><code class="language-bash"># Copy scaffold templates to app
rails generate scaffold_controller --help

# Templates location:
lib/templates/erb/scaffold/
lib/templates/rails/scaffold_controller/

# Customize:
# lib/templates/erb/scaffold/index.html.erb.tt
&lt;h1&gt;&lt;%= plural_table_name.titleize %&gt;&lt;/h1&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;% attributes.each do |attribute| -%&gt;
      &lt;th&gt;&lt;%= attribute.human_name %&gt;&lt;/th&gt;
      &lt;% end -%&gt;
      &lt;th&gt;Actions&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;%%= render @&lt;%= plural_table_name %&gt; %&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<hr>
<h3>When to Use Scaffolding</h3>
<p><strong>✅ Good for:</strong></p>
<pre><code class="language-ruby"># Prototyping
# Learning Rails
# Admin interfaces
# Internal tools
# Quick MVPs
</code></pre>
<p><strong>❌ Not good for:</strong></p>
<pre><code class="language-ruby"># Production apps (customize instead)
# Complex business logic
# Non-standard UI
# API-heavy apps
# Highly customized workflows
</code></pre>
<hr>
<h3>Scaffold Alternatives</h3>
<p><strong>Generate individual pieces:</strong></p>
<pre><code class="language-bash"># Just model
rails generate model Post title:string body:text

# Just controller
rails generate controller Posts index show

# Just migration
rails generate migration AddPublishedToPosts published:boolean
</code></pre>
<p><strong>Manual CRUD:</strong></p>
<pre><code class="language-ruby"># More control, less magic
class PostsController &lt; ApplicationController
  def index
    @posts = current_user.posts.published
  end
  
  def show
    @post = current_user.posts.find(params[:id])
  end
  
  # Custom actions for business logic
  def publish
    @post = current_user.posts.find(params[:id])
    @post.publish!
    redirect_to @post
  end
end
</code></pre>
<hr>
<h3>Destroying Scaffolds</h3>
<p><strong>Remove scaffold:</strong></p>
<pre><code class="language-bash">rails destroy scaffold Post

# Removes all generated files:
# - Model
# - Migration
# - Controller
# - Views
# - Routes
# - Tests
</code></pre>
<p><strong>Manual cleanup:</strong></p>
<pre><code class="language-bash"># If scaffold destroy doesn&#39;t work:
rm app/models/post.rb
rm app/controllers/posts_controller.rb
rm -rf app/views/posts
rm db/migrate/*_create_posts.rb

# Remove routes manually
# config/routes.rb - delete: resources :posts
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Scaffolding</strong> generates complete CRUD</li>
<li><strong>Static</strong> scaffolds (current Rails)</li>
<li><strong>Dynamic</strong> scaffolds (deprecated)</li>
<li><strong>Nested</strong> scaffolds for associations</li>
<li><strong>Customize</strong> templates in lib/templates</li>
<li><strong>Good for</strong> prototyping</li>
<li><strong>Not for</strong> production (usually)</li>
<li><strong>Destroy</strong> to remove</li>
<li><strong>Generate</strong> individual pieces</li>
<li><strong>Learn</strong> from generated code</li>
</ol>
<hr>
<h2>Question 133: What is Action Cable? Explain WebSockets</h2>
<h3>Answer</h3>
<p><strong>Action Cable</strong> seamlessly integrates <strong>WebSockets</strong> with Rails for real-time features. It provides full-duplex communication between server and client, enabling features like chat, notifications, live updates, and collaborative editing.</p>
<hr>
<h3>WebSockets Basics</h3>
<p><strong>HTTP vs WebSockets:</strong></p>
<pre><code class="language-ruby"># Traditional HTTP:
# 1. Client requests → Server responds
# 2. Connection closes
# 3. New request for updates
# 4. Polling wastes resources

Client:  Request  →  Server
Client:  ← Response  Server
Client:  Request  →  Server  (poll)
Client:  ← Response  Server

# WebSocket:
# 1. Initial HTTP handshake
# 2. Upgrade to WebSocket
# 3. Persistent connection
# 4. Bidirectional communication
# 5. Real-time updates

Client:  Handshake  →  Server
Client:  ← Upgrade  Server
Client:  ↔ Messages ↔  Server (persistent)
</code></pre>
<hr>
<h3>Action Cable Architecture</h3>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                    Client (Browser)                      │
│                 JavaScript Consumer                      │
└────────────────────┬────────────────────────────────────┘
                     │ WebSocket
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Action Cable Server (Rails)                 │
│                                                          │
│  ┌──────────────────────────────────────────────────┐  │
│  │              Connection                           │  │
│  │  (Identifies user, authenticates)                 │  │
│  └────────────┬─────────────────────────────────────┘  │
│               │                                          │
│  ┌────────────▼─────────────────────────────────────┐  │
│  │              Channel                               │  │
│  │  (Handles subscribe, receive, broadcast)          │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
</code></pre>
<hr>
<h3>Setting Up Action Cable</h3>
<p><strong>1. Mount Action Cable:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
Rails.application.routes.draw do
  mount ActionCable.server =&gt; &#39;/cable&#39;
end
</code></pre>
<p><strong>2. Configure Action Cable:</strong></p>
<pre><code class="language-ruby"># config/cable.yml
development:
  adapter: async

test:
  adapter: test

production:
  adapter: redis
  url: &lt;%= ENV.fetch(&quot;REDIS_URL&quot;) { &quot;redis://localhost:6379/1&quot; } %&gt;
  channel_prefix: myapp_production
</code></pre>
<hr>
<h3>Creating a Channel</h3>
<p><strong>Generate channel:</strong></p>
<pre><code class="language-bash">rails generate channel Chat

# Generates:
# - app/channels/chat_channel.rb
# - app/javascript/channels/chat_channel.js
</code></pre>
<p><strong>Server-side channel:</strong></p>
<pre><code class="language-ruby"># app/channels/chat_channel.rb
class ChatChannel &lt; ApplicationCable::Channel
  def subscribed
    # Called when consumer connects
    stream_from &quot;chat_#{params[:room_id]}&quot;
  end

  def unsubscribed
    # Called when consumer disconnects
    stop_all_streams
  end

  def receive(data)
    # Called when consumer sends data
    message = Message.create!(
      user: current_user,
      room_id: params[:room_id],
      body: data[&#39;body&#39;]
    )
    
    # Broadcast to all subscribers
    ActionCable.server.broadcast(
      &quot;chat_#{params[:room_id]}&quot;,
      message: render_message(message)
    )
  end
  
  def speak(data)
    # Custom action
    ActionCable.server.broadcast(
      &quot;chat_#{params[:room_id]}&quot;,
      user: current_user.name,
      typing: true
    )
  end
  
  private
  
  def render_message(message)
    ApplicationController.render(
      partial: &#39;messages/message&#39;,
      locals: { message: message }
    )
  end
end
</code></pre>
<hr>
<h3>Client-Side Consumer</h3>
<p><strong>JavaScript consumer:</strong></p>
<pre><code class="language-javascript">// app/javascript/channels/chat_channel.js
import consumer from &quot;./consumer&quot;

const chatChannel = consumer.subscriptions.create(
  { 
    channel: &quot;ChatChannel&quot;,
    room_id: 1
  },
  {
    connected() {
      // Called when subscription established
      console.log(&quot;Connected to chat&quot;)
    },

    disconnected() {
      // Called when subscription disconnected
      console.log(&quot;Disconnected from chat&quot;)
    },

    received(data) {
      // Called when data received from server
      const messagesContainer = document.getElementById(&#39;messages&#39;)
      messagesContainer.insertAdjacentHTML(&#39;beforeend&#39;, data.message)
    },
    
    send(message) {
      // Send data to server
      this.perform(&#39;receive&#39;, { body: message })
    },
    
    typing() {
      // Call custom action
      this.perform(&#39;speak&#39;, {})
    }
  }
)

// Usage:
document.getElementById(&#39;send-button&#39;).addEventListener(&#39;click&#39;, () =&gt; {
  const input = document.getElementById(&#39;message-input&#39;)
  chatChannel.send(input.value)
  input.value = &#39;&#39;
})

document.getElementById(&#39;message-input&#39;).addEventListener(&#39;keyup&#39;, () =&gt; {
  chatChannel.typing()
})
</code></pre>
<hr>
<h3>Authentication</h3>
<p><strong>Connection:</strong></p>
<pre><code class="language-ruby"># app/channels/application_cable/connection.rb
module ApplicationCable
  class Connection &lt; ActionCable::Connection::Base
    identified_by :current_user

    def connect
      self.current_user = find_verified_user
    end

    private

    def find_verified_user
      # Find user from session/cookie
      if verified_user = User.find_by(id: cookies.encrypted[:user_id])
        verified_user
      else
        reject_unauthorized_connection
      end
    end
  end
end
</code></pre>
<p><strong>Using current_user in channels:</strong></p>
<pre><code class="language-ruby">class ChatChannel &lt; ApplicationCable::Channel
  def subscribed
    # current_user available from connection
    return reject unless current_user.can_access_room?(params[:room_id])
    
    stream_from &quot;chat_#{params[:room_id]}&quot;
  end
end
</code></pre>
<hr>
<h3>Broadcasting</h3>
<p><strong>From anywhere in Rails:</strong></p>
<pre><code class="language-ruby"># In controller
class MessagesController &lt; ApplicationController
  def create
    @message = Message.create!(message_params)
    
    # Broadcast to channel
    ActionCable.server.broadcast(
      &quot;chat_#{@message.room_id}&quot;,
      message: render_to_string(
        partial: &#39;messages/message&#39;,
        locals: { message: @message }
      )
    )
    
    head :ok
  end
end

# In model callback
class Message &lt; ApplicationRecord
  after_create_commit :broadcast_message
  
  private
  
  def broadcast_message
    ActionCable.server.broadcast(
      &quot;chat_#{room_id}&quot;,
      message: ApplicationController.render(
        partial: &#39;messages/message&#39;,
        locals: { message: self }
      )
    )
  end
end

# In background job
class NotificationBroadcastJob &lt; ApplicationJob
  def perform(user_id)
    ActionCable.server.broadcast(
      &quot;notifications_#{user_id}&quot;,
      count: Notification.where(user_id: user_id, read: false).count
    )
  end
end
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Live notifications:</strong></p>
<pre><code class="language-ruby"># Channel
class NotificationsChannel &lt; ApplicationCable::Channel
  def subscribed
    stream_for current_user
  end
end

# Broadcast when notification created
class Notification &lt; ApplicationRecord
  after_create_commit :broadcast_notification
  
  private
  
  def broadcast_notification
    NotificationsChannel.broadcast_to(
      user,
      notification: ApplicationController.render(
        partial: &#39;notifications/notification&#39;,
        locals: { notification: self }
      ),
      count: user.notifications.unread.count
    )
  end
end

# JavaScript
consumer.subscriptions.create(&quot;NotificationsChannel&quot;, {
  received(data) {
    document.getElementById(&#39;notifications&#39;).innerHTML = data.notification
    document.getElementById(&#39;notification-count&#39;).innerText = data.count
  }
})
</code></pre>
<p><strong>2. Live comments:</strong></p>
<pre><code class="language-ruby"># Channel
class PostChannel &lt; ApplicationCable::Channel
  def subscribed
    stream_from &quot;post_#{params[:post_id]}&quot;
  end
end

# Broadcast new comment
class Comment &lt; ApplicationRecord
  after_create_commit :broadcast_comment
  
  private
  
  def broadcast_comment
    ActionCable.server.broadcast(
      &quot;post_#{post_id}&quot;,
      comment: ApplicationController.render(
        partial: &#39;comments/comment&#39;,
        locals: { comment: self }
      )
    )
  end
end

# JavaScript
consumer.subscriptions.create(
  { channel: &quot;PostChannel&quot;, post_id: postId },
  {
    received(data) {
      document.getElementById(&#39;comments&#39;).insertAdjacentHTML(&#39;beforeend&#39;, data.comment)
    }
  }
)
</code></pre>
<p><strong>3. Collaborative editing:</strong></p>
<pre><code class="language-ruby"># Channel
class DocumentChannel &lt; ApplicationCable::Channel
  def subscribed
    stream_from &quot;document_#{params[:document_id]}&quot;
  end
  
  def update(data)
    # Broadcast to others (not sender)
    ActionCable.server.broadcast(
      &quot;document_#{params[:document_id]}&quot;,
      { 
        changes: data[&#39;changes&#39;],
        user: current_user.name 
      },
      except: [self]
    )
  end
end

# JavaScript
const documentChannel = consumer.subscriptions.create(
  { channel: &quot;DocumentChannel&quot;, document_id: docId },
  {
    received(data) {
      applyChanges(data.changes)
      showUserCursor(data.user)
    }
  }
)

editor.on(&#39;change&#39;, (changes) =&gt; {
  documentChannel.perform(&#39;update&#39;, { changes: changes })
})
</code></pre>
<hr>
<h3>Testing Action Cable</h3>
<pre><code class="language-ruby"># RSpec
RSpec.describe ChatChannel, type: :channel do
  let(:user) { create(:user) }
  let(:room) { create(:room) }
  
  before do
    stub_connection current_user: user
  end
  
  it &#39;subscribes to stream&#39; do
    subscribe(room_id: room.id)
    
    expect(subscription).to be_confirmed
    expect(subscription).to have_stream_from(&quot;chat_#{room.id}&quot;)
  end
  
  it &#39;receives messages&#39; do
    subscribe(room_id: room.id)
    
    perform :receive, body: &#39;Hello&#39;
    
    expect(Message.last.body).to eq(&#39;Hello&#39;)
    expect(Message.last.user).to eq(user)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Action Cable</strong> for WebSockets</li>
<li><strong>Real-time</strong> bidirectional communication</li>
<li><strong>Channels</strong> handle subscriptions</li>
<li><strong>Connection</strong> authenticates users</li>
<li><strong>Broadcast</strong> from anywhere</li>
<li><strong>stream_from</strong> for subscriptions</li>
<li><strong>Redis</strong> in production</li>
<li><strong>JavaScript</strong> consumer</li>
<li><strong>Use for</strong> chat, notifications, live updates</li>
<li><strong>Test</strong> with RSpec</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 134: What are Rails Generators, and how do you create custom generators?</h2>
<h3>Answer</h3>
<p><strong>Rails Generators</strong> are scripts that create boilerplate code (models, controllers, migrations, etc.). You can create <strong>custom generators</strong> to generate application-specific code patterns, enforce conventions, and speed up development.</p>
<hr>
<h3>Built-in Generators</h3>
<pre><code class="language-bash"># List all generators
rails generate

# Common generators:
rails generate model User name:string email:string
rails generate controller Posts index show
rails generate scaffold Post title:string body:text
rails generate migration AddAgeToUsers age:integer
rails generate mailer UserMailer welcome
rails generate job ProcessPayment
rails generate channel Chat
rails generate helper Posts
</code></pre>
<hr>
<h3>Creating Custom Generator</h3>
<p><strong>Generate generator:</strong></p>
<pre><code class="language-bash">rails generate generator service
# Creates: lib/generators/service/service_generator.rb
</code></pre>
<p><strong>Basic custom generator:</strong></p>
<pre><code class="language-ruby"># lib/generators/service/service_generator.rb
class ServiceGenerator &lt; Rails::Generators::NamedBase
  source_root File.expand_path(&#39;templates&#39;, __dir__)
  
  def create_service_file
    template &#39;service.rb.tt&#39;, &quot;app/services/#{file_name}_service.rb&quot;
  end
  
  def create_spec_file
    template &#39;service_spec.rb.tt&#39;, &quot;spec/services/#{file_name}_service_spec.rb&quot;
  end
end
</code></pre>
<p><strong>Template file:</strong></p>
<pre><code class="language-ruby"># lib/generators/service/templates/service.rb.tt
class &lt;%= class_name %&gt;Service
  def initialize(&lt;%= file_name %&gt;)
    @&lt;%= file_name %&gt; = &lt;%= file_name %&gt;
  end
  
  def call
    # Implementation here
  end
  
  private
  
  attr_reader :&lt;%= file_name %&gt;
end
</code></pre>
<p><strong>Spec template:</strong></p>
<pre><code class="language-ruby"># lib/generators/service/templates/service_spec.rb.tt
require &#39;rails_helper&#39;

RSpec.describe &lt;%= class_name %&gt;Service do
  describe &#39;#call&#39; do
    let(:&lt;%= file_name %&gt;) { create(:&lt;%= file_name %&gt;) }
    let(:service) { described_class.new(&lt;%= file_name %&gt;) }
    
    it &#39;works&#39; do
      expect(service.call).to be_truthy
    end
  end
end
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">rails generate service User
# Creates:
# app/services/user_service.rb
# spec/services/user_service_spec.rb
</code></pre>
<hr>
<h3>Generator with Options</h3>
<p><strong>Generator with arguments and options:</strong></p>
<pre><code class="language-ruby"># lib/generators/api_resource/api_resource_generator.rb
class ApiResourceGenerator &lt; Rails::Generators::NamedBase
  source_root File.expand_path(&#39;templates&#39;, __dir__)
  
  # Arguments
  argument :attributes, type: :array, default: [], banner: &quot;field:type field:type&quot;
  
  # Options
  class_option :namespace, type: :string, default: &#39;api/v1&#39;, desc: &quot;API namespace&quot;
  class_option :skip_model, type: :boolean, default: false, desc: &quot;Skip model generation&quot;
  class_option :skip_tests, type: :boolean, default: false, desc: &quot;Skip test generation&quot;
  
  def create_model
    return if options[:skip_model]
    
    generate :model, &quot;#{file_name} #{attributes.join(&#39; &#39;)}&quot;
  end
  
  def create_controller
    template &#39;controller.rb.tt&#39;, &quot;app/controllers/#{namespace_path}/#{file_name.pluralize}_controller.rb&quot;
  end
  
  def create_routes
    route &quot;namespace :#{namespace_name} do\n    resources :#{file_name.pluralize}\n  end&quot;
  end
  
  def create_serializer
    template &#39;serializer.rb.tt&#39;, &quot;app/serializers/#{file_name}_serializer.rb&quot;
  end
  
  def create_spec
    return if options[:skip_tests]
    
    template &#39;request_spec.rb.tt&#39;, &quot;spec/requests/#{namespace_path}/#{file_name.pluralize}_spec.rb&quot;
  end
  
  private
  
  def namespace_path
    options[:namespace].gsub(&#39;::&#39;, &#39;/&#39;)
  end
  
  def namespace_name
    options[:namespace].gsub(&#39;/&#39;, &#39;::&#39;)
  end
end
</code></pre>
<p><strong>Templates:</strong></p>
<pre><code class="language-ruby"># lib/generators/api_resource/templates/controller.rb.tt
module &lt;%= namespace_name.camelize %&gt;
  class &lt;%= class_name.pluralize %&gt;Controller &lt; ApplicationController
    before_action :set_&lt;%= file_name %&gt;, only: [:show, :update, :destroy]
    
    def index
      @&lt;%= file_name.pluralize %&gt; = &lt;%= class_name %&gt;.all
      render json: @&lt;%= file_name.pluralize %&gt;
    end
    
    def show
      render json: @&lt;%= file_name %&gt;
    end
    
    def create
      @&lt;%= file_name %&gt; = &lt;%= class_name %&gt;.new(&lt;%= file_name %&gt;_params)
      
      if @&lt;%= file_name %&gt;.save
        render json: @&lt;%= file_name %&gt;, status: :created
      else
        render json: @&lt;%= file_name %&gt;.errors, status: :unprocessable_entity
      end
    end
    
    def update
      if @&lt;%= file_name %&gt;.update(&lt;%= file_name %&gt;_params)
        render json: @&lt;%= file_name %&gt;
      else
        render json: @&lt;%= file_name %&gt;.errors, status: :unprocessable_entity
      end
    end
    
    def destroy
      @&lt;%= file_name %&gt;.destroy
      head :no_content
    end
    
    private
    
    def set_&lt;%= file_name %&gt;
      @&lt;%= file_name %&gt; = &lt;%= class_name %&gt;.find(params[:id])
    end
    
    def &lt;%= file_name %&gt;_params
      params.require(:&lt;%= file_name %&gt;).permit(&lt;%= attributes.map { |a| &quot;:#{a.name}&quot; }.join(&#39;, &#39;) %&gt;)
    end
  end
end
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">rails generate api_resource Post title:string body:text published:boolean --namespace=api/v2
# Creates full API resource with controller, routes, serializer, specs
</code></pre>
<hr>
<h3>Generator Methods</h3>
<p><strong>File operations:</strong></p>
<pre><code class="language-ruby">class MyGenerator &lt; Rails::Generators::Base
  def create_files
    # Create file
    create_file &#39;config/my_config.yml&#39;, &lt;&lt;~YAML
      development:
        key: value
    YAML
    
    # Copy file
    copy_file &#39;template.rb&#39;, &#39;lib/template.rb&#39;
    
    # Template with interpolation
    template &#39;service.rb.tt&#39;, &#39;app/services/my_service.rb&#39;
    
    # Create directory
    empty_directory &#39;app/custom&#39;
    
    # Inside directory
    inside(&#39;config&#39;) do
      create_file &#39;custom.yml&#39;, &quot;key: value&quot;
    end
  end
  
  def modify_files
    # Insert into file
    inject_into_file &#39;config/routes.rb&#39;, after: &quot;Rails.application.routes.draw do\n&quot; do
      &quot;  resources :my_resources\n&quot;
    end
    
    # Append to file
    append_to_file &#39;config/application.rb&#39;, &quot;\nconfig.custom = true&quot;
    
    # Prepend to file
    prepend_to_file &#39;app/models/application_record.rb&#39;, &quot;# frozen_string_literal: true\n&quot;
    
    # Remove file
    remove_file &#39;public/index.html&#39;
  end
  
  def run_commands
    # Run shell command
    run &#39;bundle install&#39;
    
    # Run rake task
    rake &#39;db:migrate&#39;
    
    # Run another generator
    generate &#39;model&#39;, &#39;User name:string email:string&#39;
    
    # Route
    route &quot;resources :posts&quot;
  end
  
  def conditional_logic
    if yes?(&#39;Do you want to include tests?&#39;)
      create_file &#39;spec/my_spec.rb&#39;
    end
  end
end
</code></pre>
<hr>
<h3>Advanced Features</h3>
<p><strong>Thor actions:</strong></p>
<pre><code class="language-ruby">class SetupGenerator &lt; Rails::Generators::Base
  def create_structure
    # Create directory structure
    %w[app/services app/presenters app/decorators].each do |dir|
      empty_directory dir
    end
  end
  
  def install_gems
    # Add gems to Gemfile
    gem &#39;sidekiq&#39;
    gem &#39;pundit&#39;
    
    # Run bundler
    run &#39;bundle install&#39;
  end
  
  def create_initializers
    initializer &#39;sidekiq.rb&#39;, &lt;&lt;~RUBY
      Sidekiq.configure_server do |config|
        config.redis = { url: ENV[&#39;REDIS_URL&#39;] }
      end
    RUBY
  end
  
  def setup_routes
    route &lt;&lt;~RUBY
      require &#39;sidekiq/web&#39;
      mount Sidekiq::Web =&gt; &#39;/sidekiq&#39;
    RUBY
  end
end
</code></pre>
<p><strong>Interactive prompts:</strong></p>
<pre><code class="language-ruby">class InteractiveGenerator &lt; Rails::Generators::Base
  def ask_questions
    # Yes/No
    if yes?(&#39;Include authentication?&#39;)
      generate &#39;devise:install&#39;
    end
    
    # Text input
    app_name = ask(&#39;What is your app name?&#39;)
    
    # Multiple choice (Thor doesn&#39;t have built-in, use ask + validation)
    database = ask(&#39;Which database? (postgresql/mysql/sqlite)&#39;, limited_to: %w[postgresql mysql sqlite])
  end
end
</code></pre>
<hr>
<h3>Real-World Example: API Generator</h3>
<p><strong>Complete API generator:</strong></p>
<pre><code class="language-ruby"># lib/generators/api_scaffold/api_scaffold_generator.rb
class ApiScaffoldGenerator &lt; Rails::Generators::NamedBase
  source_root File.expand_path(&#39;templates&#39;, __dir__)
  
  argument :attributes, type: :array, default: [], banner: &quot;field:type&quot;
  class_option :version, type: :string, default: &#39;v1&#39;, desc: &quot;API version&quot;
  
  def create_model
    generate :model, &quot;#{file_name} #{attributes.join(&#39; &#39;)}&quot;
  end
  
  def create_controller
    template &#39;controller.rb.tt&#39;, 
             &quot;app/controllers/api/#{options[:version]}/#{file_name.pluralize}_controller.rb&quot;
  end
  
  def create_serializer
    template &#39;serializer.rb.tt&#39;,
             &quot;app/serializers/api/#{options[:version]}/#{file_name}_serializer.rb&quot;
  end
  
  def create_policy
    template &#39;policy.rb.tt&#39;,
             &quot;app/policies/#{file_name}_policy.rb&quot;
  end
  
  def create_spec
    template &#39;request_spec.rb.tt&#39;,
             &quot;spec/requests/api/#{options[:version]}/#{file_name.pluralize}_spec.rb&quot;
  end
  
  def add_routes
    route &lt;&lt;~RUBY
      namespace :api do
        namespace :#{options[:version]} do
          resources :#{file_name.pluralize}
        end
      end
    RUBY
  end
  
  def show_readme
    readme &#39;README&#39; if behavior == :invoke
  end
  
  private
  
  def attributes_list
    attributes.map(&amp;:name)
  end
end

# lib/generators/api_scaffold/templates/serializer.rb.tt
module Api
  module &lt;%= options[:version].camelize %&gt;
    class &lt;%= class_name %&gt;Serializer
      include Alba::Resource
      
      attributes &lt;%= attributes_list.map { |a| &quot;:#{a}&quot; }.join(&#39;, &#39;) %&gt;
    end
  end
end

# lib/generators/api_scaffold/USAGE
Description:
    Generates API resource with controller, serializer, policy, and specs

Example:
    rails generate api_scaffold Post title:string body:text --version=v2

    This will create:
        Controller: app/controllers/api/v2/posts_controller.rb
        Serializer: app/serializers/api/v2/post_serializer.rb
        Policy: app/policies/post_policy.rb
        Spec: spec/requests/api/v2/posts_spec.rb
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-bash">rails generate api_scaffold Post title:string body:text published:boolean --version=v2
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Generators</strong> create boilerplate code</li>
<li><strong>Custom generators</strong> for patterns</li>
<li><strong>NamedBase</strong> for models/resources</li>
<li><strong>Templates</strong> with .tt extension</li>
<li><strong>source_root</strong> for template location</li>
<li><strong>Options</strong> for flexibility</li>
<li><strong>Thor</strong> provides file operations</li>
<li><strong>generate</strong> calls other generators</li>
<li><strong>route</strong> adds routes</li>
<li><strong>Test</strong> generators before using</li>
</ol>
<hr>
<h2>Question 135: Explain Generator vs Responder</h2>
<h3>Answer</h3>
<p><strong>Generators</strong> create code files (models, controllers, etc.). <strong>Responders</strong> handle HTTP responses (format.html, format.json). Generators = code generation, Responders = request/response handling.</p>
<hr>
<h3>Generators</h3>
<p><strong>What they do:</strong></p>
<pre><code class="language-ruby"># Generate files
rails generate model User name:string
rails generate controller Posts index show

# Creates:
# - app/models/user.rb
# - app/controllers/posts_controller.rb
# - etc.

# Purpose: Code generation, scaffolding, boilerplate
</code></pre>
<hr>
<h3>Responders</h3>
<p><strong>What they do:</strong></p>
<pre><code class="language-ruby"># Handle HTTP responses
class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    
    respond_to do |format|
      format.html { render :show }
      format.json { render json: @post }
      format.xml  { render xml: @post }
    end
  end
end

# Purpose: Content negotiation, format handling
</code></pre>
<hr>
<h3>Responders Gem</h3>
<p><strong>Advanced responders:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;responders&#39;

# ApplicationController
class ApplicationController &lt; ActionController::Base
  include ActionController::RespondWith
  
  respond_to :html, :json
end

# Controller
class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    respond_with @post
  end
  
  def create
    @post = Post.create(post_params)
    respond_with @post, location: posts_path
  end
end

# Automatically handles:
# - HTML: render show.html.erb
# - JSON: render json: @post
# - Redirects on create/update
# - Error handling
</code></pre>
<hr>
<h3>Comparison</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Generator</th>
<th>Responder</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Purpose</strong></td>
<td>Create code files</td>
<td>Handle HTTP responses</td>
</tr>
<tr>
<td><strong>When runs</strong></td>
<td>Development (command line)</td>
<td>Runtime (requests)</td>
</tr>
<tr>
<td><strong>Input</strong></td>
<td>Command line args</td>
<td>HTTP request</td>
</tr>
<tr>
<td><strong>Output</strong></td>
<td>Ruby files</td>
<td>HTTP response</td>
</tr>
<tr>
<td><strong>Examples</strong></td>
<td>model, controller, scaffold</td>
<td>respond_to, respond_with</td>
</tr>
</tbody></table>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Generator</strong> = code creation</li>
<li><strong>Responder</strong> = response handling</li>
<li><strong>Different purposes</strong></li>
<li><strong>Generators</strong> at dev time</li>
<li><strong>Responders</strong> at runtime</li>
<li><strong>Generators</strong> create files</li>
<li><strong>Responders</strong> format output</li>
<li><strong>Both</strong> part of Rails</li>
<li><strong>Responders gem</strong> for advanced</li>
<li><strong>Not related</strong> to each other</li>
</ol>
<h1>Advanced Rails Concepts Interview Questions</h1>
<h2>Question 136: What are concerns in Rails, and how do they help with code reusability?</h2>
<h3>Answer</h3>
<p><strong>Concerns</strong> are modules that extract common code into reusable, mixable components. They help follow DRY principles, organize code, and share functionality across models or controllers.</p>
<hr>
<h3>Basic Concern</h3>
<p><strong>Model concern:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/publishable.rb
module Publishable
  extend ActiveSupport::Concern
  
  included do
    scope :published, -&gt; { where(published: true) }
    scope :draft, -&gt; { where(published: false) }
    
    validates :published_at, presence: true, if: :published?
  end
  
  def publish!
    update(published: true, published_at: Time.current)
  end
  
  def unpublish!
    update(published: false, published_at: nil)
  end
  
  class_methods do
    def recent_published
      published.where(&#39;published_at &gt; ?&#39;, 1.week.ago)
    end
  end
end

# Usage in models:
class Post &lt; ApplicationRecord
  include Publishable
end

class Article &lt; ApplicationRecord
  include Publishable
end

# Now both have:
Post.published
Post.draft
Post.recent_published
post.publish!
post.unpublish!
</code></pre>
<hr>
<h3>Why Use Concerns?</h3>
<p><strong>Without concerns (duplication):</strong></p>
<pre><code class="language-ruby"># ❌ Code duplication across models
class Post &lt; ApplicationRecord
  scope :published, -&gt; { where(published: true) }
  
  def publish!
    update(published: true, published_at: Time.current)
  end
end

class Article &lt; ApplicationRecord
  scope :published, -&gt; { where(published: true) }
  
  def publish!
    update(published: true, published_at: Time.current)
  end
end

# Same code in multiple places!
</code></pre>
<p><strong>With concerns (DRY):</strong></p>
<pre><code class="language-ruby"># ✅ Concern extracts common functionality
module Publishable
  extend ActiveSupport::Concern
  # ... (code once)
end

class Post &lt; ApplicationRecord
  include Publishable
end

class Article &lt; ApplicationRecord
  include Publishable
end

# Code in one place, used everywhere
</code></pre>
<hr>
<h3>Concern Structure</h3>
<p><strong>Parts of a concern:</strong></p>
<pre><code class="language-ruby">module MyConcern
  extend ActiveSupport::Concern
  
  # 1. included block - runs when mixed in
  included do
    # Scopes
    scope :active, -&gt; { where(active: true) }
    
    # Validations
    validates :status, presence: true
    
    # Callbacks
    before_save :set_defaults
    
    # Associations
    has_many :items
  end
  
  # 2. Instance methods
  def instance_method
    # Available on model instances
  end
  
  # 3. Class methods block
  class_methods do
    def class_method
      # Available on model class
    end
  end
end
</code></pre>
<hr>
<h3>Common Model Concerns</h3>
<p><strong>1. Sluggable:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/sluggable.rb
module Sluggable
  extend ActiveSupport::Concern
  
  included do
    before_validation :generate_slug
    validates :slug, presence: true, uniqueness: true
  end
  
  def to_param
    slug
  end
  
  private
  
  def generate_slug
    return if slug.present?
    self.slug = title.parameterize
  end
  
  class_methods do
    def find_by_slug(slug)
      find_by(slug: slug)
    end
  end
end

# Usage:
class Post &lt; ApplicationRecord
  include Sluggable
end

post = Post.create(title: &#39;Hello World&#39;)
post.slug  # =&gt; &quot;hello-world&quot;
post.to_param  # =&gt; &quot;hello-world&quot;
Post.find_by_slug(&#39;hello-world&#39;)
</code></pre>
<p><strong>2. Searchable:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/searchable.rb
module Searchable
  extend ActiveSupport::Concern
  
  included do
    scope :search, -&gt;(query) {
      return all if query.blank?
      
      where(
        &quot;#{table_name}.#{search_column} ILIKE :query&quot;,
        query: &quot;%#{sanitize_sql_like(query)}%&quot;
      )
    }
  end
  
  class_methods do
    def search_column
      # Override in model if needed
      :name
    end
  end
end

# Usage:
class Product &lt; ApplicationRecord
  include Searchable
  
  def self.search_column
    :title
  end
end

Product.search(&#39;laptop&#39;)
</code></pre>
<p><strong>3. Timestampable with timezone:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/timezoned.rb
module Timezoned
  extend ActiveSupport::Concern
  
  def created_at_in_timezone(timezone = &#39;UTC&#39;)
    created_at.in_time_zone(timezone)
  end
  
  def updated_at_in_timezone(timezone = &#39;UTC&#39;)
    updated_at.in_time_zone(timezone)
  end
  
  class_methods do
    def created_today(timezone = &#39;UTC&#39;)
      start_of_day = Time.current.in_time_zone(timezone).beginning_of_day
      end_of_day = Time.current.in_time_zone(timezone).end_of_day
      where(created_at: start_of_day..end_of_day)
    end
  end
end
</code></pre>
<p><strong>4. Soft deletable:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/soft_deletable.rb
module SoftDeletable
  extend ActiveSupport::Concern
  
  included do
    scope :active, -&gt; { where(deleted_at: nil) }
    scope :deleted, -&gt; { where.not(deleted_at: nil) }
    
    default_scope { active }
  end
  
  def soft_delete
    update(deleted_at: Time.current)
  end
  
  def restore
    update(deleted_at: nil)
  end
  
  def deleted?
    deleted_at.present?
  end
  
  class_methods do
    def with_deleted
      unscoped
    end
  end
end

# Usage:
class User &lt; ApplicationRecord
  include SoftDeletable
end

user.soft_delete
user.deleted?  # =&gt; true
user.restore
User.deleted
User.with_deleted
</code></pre>
<hr>
<h3>Controller Concerns</h3>
<p><strong>Authentication concern:</strong></p>
<pre><code class="language-ruby"># app/controllers/concerns/authenticatable.rb
module Authenticatable
  extend ActiveSupport::Concern
  
  included do
    before_action :authenticate_user!
    helper_method :current_user, :logged_in?
  end
  
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
  
  def logged_in?
    current_user.present?
  end
  
  def authenticate_user!
    redirect_to login_path unless logged_in?
  end
  
  class_methods do
    def skip_authentication(*actions)
      skip_before_action :authenticate_user!, only: actions
    end
  end
end

# Usage:
class ApplicationController &lt; ActionController::Base
  include Authenticatable
end

class PostsController &lt; ApplicationController
  skip_authentication :index, :show
end
</code></pre>
<p><strong>Authorization concern:</strong></p>
<pre><code class="language-ruby"># app/controllers/concerns/authorizable.rb
module Authorizable
  extend ActiveSupport::Concern
  
  included do
    rescue_from UnauthorizedError, with: :unauthorized
  end
  
  def authorize!(action, resource)
    policy = &quot;#{resource.class}Policy&quot;.constantize.new(current_user, resource)
    
    unless policy.public_send(&quot;#{action}?&quot;)
      raise UnauthorizedError
    end
  end
  
  def unauthorized
    render file: &#39;public/403.html&#39;, status: :forbidden
  end
end
</code></pre>
<hr>
<h3>Concern Dependencies</h3>
<p><strong>Concerns can depend on other concerns:</strong></p>
<pre><code class="language-ruby"># app/models/concerns/timestampable.rb
module Timestampable
  extend ActiveSupport::Concern
  # Basic timestamp functionality
end

# app/models/concerns/auditable.rb
module Auditable
  extend ActiveSupport::Concern
  
  include Timestampable  # Depends on Timestampable
  
  included do
    after_create :log_creation
    after_update :log_update
  end
  
  private
  
  def log_creation
    AuditLog.create(
      action: &#39;create&#39;,
      resource: self,
      timestamp: created_at
    )
  end
  
  def log_update
    AuditLog.create(
      action: &#39;update&#39;,
      resource: self,
      timestamp: updated_at,
      changes: saved_changes
    )
  end
end
</code></pre>
<hr>
<h3>Testing Concerns</h3>
<p><strong>RSpec shared examples:</strong></p>
<pre><code class="language-ruby"># spec/support/shared_examples/publishable.rb
RSpec.shared_examples &#39;publishable&#39; do
  describe &#39;.published&#39; do
    it &#39;returns only published records&#39; do
      published = create(described_class.name.underscore, published: true)
      create(described_class.name.underscore, published: false)
      
      expect(described_class.published).to contain_exactly(published)
    end
  end
  
  describe &#39;#publish!&#39; do
    it &#39;publishes the record&#39; do
      record = create(described_class.name.underscore, published: false)
      
      expect {
        record.publish!
      }.to change { record.published }.from(false).to(true)
    end
  end
end

# spec/models/post_spec.rb
RSpec.describe Post do
  it_behaves_like &#39;publishable&#39;
end

# spec/models/article_spec.rb
RSpec.describe Article do
  it_behaves_like &#39;publishable&#39;
end
</code></pre>
<hr>
<h3>When to Use Concerns</h3>
<p><strong>✅ Good for:</strong></p>
<pre><code class="language-ruby"># Shared behavior across models
# Cross-cutting functionality
# DRY principle
# Organization

Examples:
- Publishable (posts, articles, videos)
- Commentable (posts, photos, videos)
- Likeable (posts, comments, photos)
- Taggable (posts, products, users)
</code></pre>
<p><strong>❌ Avoid for:</strong></p>
<pre><code class="language-ruby"># Single-use code
# Complex business logic (use service objects)
# Multiple responsibilities (breaks SRP)
# Deep hierarchies

Bad examples:
- Kitchen sink concerns (too much unrelated code)
- God concerns (does everything)
- Concerns including other concerns including...
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Concerns</strong> extract common code</li>
<li><strong>extend ActiveSupport::Concern</strong></li>
<li><strong>included</strong> block for scopes/validations</li>
<li><strong>Instance methods</strong> directly defined</li>
<li><strong>class_methods</strong> block for class methods</li>
<li><strong>Both models and controllers</strong></li>
<li><strong>Test with shared examples</strong></li>
<li><strong>DRY</strong> principle</li>
<li><strong>Good for</strong> cross-cutting features</li>
<li><strong>Avoid</strong> kitchen sink concerns</li>
</ol>
<hr>
<h2>Question 137: What is the difference between Concerns, Service Objects, and Decorators?</h2>
<h3>Answer</h3>
<p><strong>Concerns</strong> extract shared behavior. <strong>Service Objects</strong> encapsulate business logic. <strong>Decorators</strong> add presentation logic. Each serves a different purpose in organizing Rails code.</p>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Concern</th>
<th>Service Object</th>
<th>Decorator</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Purpose</strong></td>
<td>Share behavior</td>
<td>Business logic</td>
<td>Presentation logic</td>
</tr>
<tr>
<td><strong>Location</strong></td>
<td>app/models/concerns</td>
<td>app/services</td>
<td>app/decorators</td>
</tr>
<tr>
<td><strong>Mixed into</strong></td>
<td>Models/Controllers</td>
<td>Standalone</td>
<td>Models (presentation)</td>
</tr>
<tr>
<td><strong>When to use</strong></td>
<td>Shared functionality</td>
<td>Complex operations</td>
<td>View logic</td>
</tr>
<tr>
<td><strong>Example</strong></td>
<td>Publishable, Sluggable</td>
<td>UserRegistration</td>
<td>UserDecorator</td>
</tr>
</tbody></table>
<hr>
<h3>Concerns</h3>
<p><strong>What:</strong> Modules for shared behavior</p>
<pre><code class="language-ruby"># app/models/concerns/publishable.rb
module Publishable
  extend ActiveSupport::Concern
  
  included do
    scope :published, -&gt; { where(published: true) }
  end
  
  def publish!
    update(published: true, published_at: Time.current)
  end
end

# Usage: Include in multiple models
class Post &lt; ApplicationRecord
  include Publishable
end

class Article &lt; ApplicationRecord
  include Publishable
end

# When to use:
# - Shared behavior across models
# - Cross-cutting concerns
# - DRY principle
</code></pre>
<hr>
<h3>Service Objects</h3>
<p><strong>What:</strong> Encapsulate business logic</p>
<pre><code class="language-ruby"># app/services/user_registration_service.rb
class UserRegistrationService
  def initialize(params)
    @params = params
  end
  
  def call
    ActiveRecord::Base.transaction do
      create_user
      create_profile
      send_welcome_email
      notify_admin
    end
    
    @user
  rescue StandardError =&gt; e
    handle_error(e)
    false
  end
  
  private
  
  def create_user
    @user = User.create!(@params[:user])
  end
  
  def create_profile
    @user.create_profile!(@params[:profile])
  end
  
  def send_welcome_email
    UserMailer.welcome(@user).deliver_later
  end
  
  def notify_admin
    AdminNotifier.new_user(@user).deliver_later
  end
  
  def handle_error(error)
    Rails.logger.error(&quot;Registration failed: #{error.message}&quot;)
    @user&amp;.destroy
  end
end

# Usage: Controller calls service
class UsersController &lt; ApplicationController
  def create
    service = UserRegistrationService.new(params)
    
    if service.call
      redirect_to root_path, notice: &#39;Welcome!&#39;
    else
      render :new
    end
  end
end

# When to use:
# - Complex business logic
# - Multi-step operations
# - Transaction coordination
# - External API calls
</code></pre>
<hr>
<h3>Decorators</h3>
<p><strong>What:</strong> Add presentation logic</p>
<pre><code class="language-ruby"># app/decorators/user_decorator.rb
class UserDecorator &lt; SimpleDelegator
  def full_name
    &quot;#{first_name} #{last_name}&quot;.strip
  end
  
  def formatted_created_at
    created_at.strftime(&#39;%B %d, %Y&#39;)
  end
  
  def avatar_url
    gravatar_url || default_avatar_url
  end
  
  def display_role
    role.titleize
  end
  
  def membership_badge
    return &#39;⭐ Premium&#39; if premium?
    return &#39;🎖️ Pro&#39; if pro?
    &#39;Regular&#39;
  end
  
  private
  
  def gravatar_url
    return nil unless email.present?
    hash = Digest::MD5.hexdigest(email.downcase)
    &quot;https://www.gravatar.com/avatar/#{hash}&quot;
  end
  
  def default_avatar_url
    &#39;/assets/default-avatar.png&#39;
  end
end

# Usage: Decorate in controller
class UsersController &lt; ApplicationController
  def show
    @user = UserDecorator.new(User.find(params[:id]))
  end
end

# View:
&lt;h1&gt;&lt;%= @user.full_name %&gt;&lt;/h1&gt;
&lt;img src=&quot;&lt;%= @user.avatar_url %&gt;&quot;&gt;
&lt;p&gt;Member since &lt;%= @user.formatted_created_at %&gt;&lt;/p&gt;
&lt;span class=&quot;badge&quot;&gt;&lt;%= @user.membership_badge %&gt;&lt;/span&gt;

# When to use:
# - Presentation logic
# - View helpers replacement
# - Formatting data for views
# - Computed display attributes
</code></pre>
<hr>
<h3>Real-World Example: Order Processing</h3>
<p><strong>All three together:</strong></p>
<pre><code class="language-ruby"># 1. Concern: Shared behavior
# app/models/concerns/discountable.rb
module Discountable
  extend ActiveSupport::Concern
  
  included do
    has_many :discounts, as: :discountable
  end
  
  def apply_discount(code)
    discount = Discount.find_by(code: code)
    return false unless discount&amp;.valid_for?(self)
    
    discounts &lt;&lt; discount
    calculate_total
  end
end

class Order &lt; ApplicationRecord
  include Discountable
end

class Subscription &lt; ApplicationRecord
  include Discountable
end

# 2. Service Object: Business logic
# app/services/order_processing_service.rb
class OrderProcessingService
  def initialize(order, payment_method)
    @order = order
    @payment_method = payment_method
  end
  
  def call
    ActiveRecord::Base.transaction do
      charge_payment
      update_inventory
      create_shipment
      send_confirmation
    end
    
    true
  rescue PaymentError =&gt; e
    handle_payment_failure(e)
    false
  end
  
  private
  
  def charge_payment
    PaymentGateway.charge(
      amount: @order.total,
      method: @payment_method
    )
  end
  
  def update_inventory
    @order.items.each do |item|
      item.product.decrement_stock!(item.quantity)
    end
  end
  
  def create_shipment
    Shipment.create!(
      order: @order,
      carrier: select_carrier,
      tracking_number: generate_tracking
    )
  end
  
  def send_confirmation
    OrderMailer.confirmation(@order).deliver_later
  end
end

# 3. Decorator: Presentation
# app/decorators/order_decorator.rb
class OrderDecorator &lt; SimpleDelegator
  def formatted_total
    &quot;$#{sprintf(&#39;%.2f&#39;, total)}&quot;
  end
  
  def status_badge
    case status
    when &#39;pending&#39; then &#39;⏳ Pending&#39;
    when &#39;processing&#39; then &#39;⚙️ Processing&#39;
    when &#39;shipped&#39; then &#39;📦 Shipped&#39;
    when &#39;delivered&#39; then &#39;✅ Delivered&#39;
    else &#39;❓ Unknown&#39;
    end
  end
  
  def shipping_estimate
    return &#39;Processing&#39; if status == &#39;pending&#39;
    return &#39;Shipped!&#39; if status == &#39;shipped&#39;
    
    estimated_date = created_at + 3.days
    &quot;Arrives by #{estimated_date.strftime(&#39;%B %d&#39;)}&quot;
  end
  
  def items_summary
    &quot;#{items.count} items (#{total_quantity} total)&quot;
  end
  
  private
  
  def total_quantity
    items.sum(&amp;:quantity)
  end
end

# Controller
class OrdersController &lt; ApplicationController
  def create
    @order = current_user.orders.build(order_params)
    
    if @order.save
      # Service Object handles complex logic
      service = OrderProcessingService.new(@order, params[:payment_method])
      
      if service.call
        redirect_to order_path(@order)
      else
        flash.now[:error] = &#39;Payment failed&#39;
        render :new
      end
    else
      render :new
    end
  end
  
  def show
    # Decorator adds presentation logic
    @order = OrderDecorator.new(Order.find(params[:id]))
  end
end

# View
&lt;h2&gt;Order #&lt;%= @order.id %&gt;&lt;/h2&gt;
&lt;div class=&quot;status&quot;&gt;&lt;%= @order.status_badge %&gt;&lt;/div&gt;
&lt;div class=&quot;total&quot;&gt;&lt;%= @order.formatted_total %&gt;&lt;/div&gt;
&lt;div class=&quot;shipping&quot;&gt;&lt;%= @order.shipping_estimate %&gt;&lt;/div&gt;
&lt;div class=&quot;summary&quot;&gt;&lt;%= @order.items_summary %&gt;&lt;/div&gt;
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Concerns:</strong></p>
<pre><code class="language-ruby">✅ Shared behavior across models
✅ Cross-cutting functionality
✅ Mixins for common patterns

Examples:
- Publishable (posts, articles)
- Commentable (posts, videos)
- Taggable (posts, products)
</code></pre>
<p><strong>Service Objects:</strong></p>
<pre><code class="language-ruby">✅ Complex business logic
✅ Multi-step operations
✅ External service integration
✅ Fat controller refactoring

Examples:
- UserRegistration
- OrderProcessing
- PaymentProcessing
- ReportGeneration
</code></pre>
<p><strong>Decorators:</strong></p>
<pre><code class="language-ruby">✅ Presentation logic
✅ View formatting
✅ Computed display attributes
✅ Helper method replacement

Examples:
- UserDecorator (full_name, avatar_url)
- ProductDecorator (formatted_price, sale_badge)
- OrderDecorator (status_badge, shipping_estimate)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Different purposes</strong> for each</li>
<li><strong>Concerns</strong> = shared behavior</li>
<li><strong>Service Objects</strong> = business logic</li>
<li><strong>Decorators</strong> = presentation</li>
<li><strong>Concerns</strong> mixed in</li>
<li><strong>Service Objects</strong> standalone</li>
<li><strong>Decorators</strong> wrap models</li>
<li><strong>Use together</strong> for clean code</li>
<li><strong>Separation of concerns</strong></li>
<li><strong>Choose</strong> based on responsibility</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 138: What are Service Objects, and when should you use them?</h2>
<h3>Answer</h3>
<p><strong>Service Objects</strong> are Plain Old Ruby Objects (POROs) that encapsulate complex business logic into single-responsibility classes. Use them to extract fat controller/model logic, coordinate multi-step operations, and improve testability.</p>
<hr>
<h3>Why Service Objects?</h3>
<p><strong>Fat controller (bad):</strong></p>
<pre><code class="language-ruby"># ❌ Controller with too much logic
class OrdersController &lt; ApplicationController
  def create
    @order = Order.new(order_params)
    @order.user = current_user
    
    ActiveRecord::Base.transaction do
      if @order.save
        @order.items.each do |item|
          item.product.decrement!(:stock, item.quantity)
        end
        
        payment = Payment.create!(
          order: @order,
          amount: @order.total,
          method: params[:payment_method]
        )
        
        begin
          PaymentGateway.charge(payment)
        rescue PaymentError =&gt; e
          raise ActiveRecord::Rollback
        end
        
        shipment = Shipment.create!(
          order: @order,
          address: @order.shipping_address
        )
        
        OrderMailer.confirmation(@order).deliver_later
        InventoryService.update_stock(@order)
        AnalyticsService.track_purchase(@order)
        
        redirect_to @order, notice: &#39;Order created&#39;
      else
        render :new
      end
    end
  end
end

# Problems:
# - Controller doing too much
# - Hard to test
# - Business logic in controller
# - Not reusable
</code></pre>
<p><strong>With service object (good):</strong></p>
<pre><code class="language-ruby"># ✅ Service object handles complexity
class OrdersController &lt; ApplicationController
  def create
    service = CreateOrderService.new(
      user: current_user,
      params: order_params,
      payment_method: params[:payment_method]
    )
    
    if service.call
      redirect_to service.order, notice: &#39;Order created&#39;
    else
      @order = service.order
      flash.now[:error] = service.errors.full_messages
      render :new
    end
  end
end

# app/services/create_order_service.rb
class CreateOrderService
  attr_reader :order, :errors
  
  def initialize(user:, params:, payment_method:)
    @user = user
    @params = params
    @payment_method = payment_method
    @errors = ActiveModel::Errors.new(self)
  end
  
  def call
    ActiveRecord::Base.transaction do
      create_order
      process_payment
      update_inventory
      create_shipment
      send_notifications
      track_analytics
    end
    
    true
  rescue StandardError =&gt; e
    handle_error(e)
    false
  end
  
  private
  
  def create_order
    @order = @user.orders.create!(@params)
  end
  
  def process_payment
    payment = @order.create_payment!(
      amount: @order.total,
      method: @payment_method
    )
    
    PaymentGateway.charge(payment)
  end
  
  def update_inventory
    @order.items.each do |item|
      item.product.decrement_stock!(item.quantity)
    end
  end
  
  def create_shipment
    @order.create_shipment!(address: @order.shipping_address)
  end
  
  def send_notifications
    OrderMailer.confirmation(@order).deliver_later
  end
  
  def track_analytics
    AnalyticsService.track_purchase(@order)
  end
  
  def handle_error(error)
    @errors.add(:base, error.message)
    Rails.logger.error(&quot;Order creation failed: #{error.message}&quot;)
  end
end

# Benefits:
# ✅ Single responsibility
# ✅ Easy to test
# ✅ Reusable
# ✅ Clean controller
</code></pre>
<hr>
<h3>Service Object Patterns</h3>
<p><strong>1. Simple call pattern:</strong></p>
<pre><code class="language-ruby">class MyService
  def initialize(params)
    @params = params
  end
  
  def call
    # Do work
    result
  end
end

# Usage:
service = MyService.new(params)
service.call
</code></pre>
<p><strong>2. Class method pattern:</strong></p>
<pre><code class="language-ruby">class MyService
  def self.call(params)
    new(params).call
  end
  
  def initialize(params)
    @params = params
  end
  
  def call
    # Do work
  end
end

# Usage:
MyService.call(params)
</code></pre>
<p><strong>3. Result object pattern:</strong></p>
<pre><code class="language-ruby">class MyService
  Result = Struct.new(:success?, :value, :errors)
  
  def self.call(params)
    new(params).call
  end
  
  def initialize(params)
    @params = params
  end
  
  def call
    # Do work
    Result.new(true, @value, [])
  rescue StandardError =&gt; e
    Result.new(false, nil, [e.message])
  end
end

# Usage:
result = MyService.call(params)
if result.success?
  # Handle success
else
  # Handle errors
end
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. User Registration:</strong></p>
<pre><code class="language-ruby">class UserRegistrationService
  attr_reader :user, :errors
  
  def initialize(params)
    @params = params
    @errors = []
  end
  
  def call
    ActiveRecord::Base.transaction do
      create_user
      create_profile
      assign_default_role
      send_welcome_email
      track_registration
    end
    
    true
  rescue StandardError =&gt; e
    @errors &lt;&lt; e.message
    cleanup
    false
  end
  
  private
  
  def create_user
    @user = User.create!(@params[:user])
  end
  
  def create_profile
    @user.create_profile!(@params[:profile])
  end
  
  def assign_default_role
    @user.add_role(:member)
  end
  
  def send_welcome_email
    UserMailer.welcome(@user).deliver_later
  end
  
  def track_registration
    Analytics.track(
      user_id: @user.id,
      event: &#39;user_registered&#39;
    )
  end
  
  def cleanup
    @user&amp;.destroy
  end
end
</code></pre>
<p><strong>2. CSV Import:</strong></p>
<pre><code class="language-ruby">class ImportUsersService
  attr_reader :imported_count, :failed_count, :errors
  
  def initialize(file)
    @file = file
    @imported_count = 0
    @failed_count = 0
    @errors = []
  end
  
  def call
    CSV.foreach(@file.path, headers: true) do |row|
      process_row(row)
    end
    
    log_results
    true
  rescue StandardError =&gt; e
    @errors &lt;&lt; e.message
    false
  end
  
  private
  
  def process_row(row)
    user = User.create(
      email: row[&#39;email&#39;],
      name: row[&#39;name&#39;]
    )
    
    if user.persisted?
      @imported_count += 1
    else
      @failed_count += 1
      @errors &lt;&lt; &quot;Row #{row[&#39;email&#39;]}: #{user.errors.full_messages.join(&#39;, &#39;)}&quot;
    end
  end
  
  def log_results
    Rails.logger.info(&quot;Import completed: #{@imported_count} imported, #{@failed_count} failed&quot;)
  end
end
</code></pre>
<p><strong>3. Report Generation:</strong></p>
<pre><code class="language-ruby">class GenerateMonthlyReportService
  def initialize(month, year)
    @month = month
    @year = year
  end
  
  def call
    data = gather_data
    pdf = generate_pdf(data)
    upload_to_s3(pdf)
    notify_managers
    
    pdf
  end
  
  private
  
  def gather_data
    {
      revenue: calculate_revenue,
      orders: Order.where(created_at: date_range).count,
      customers: new_customers,
      top_products: top_products
    }
  end
  
  def calculate_revenue
    Order.where(created_at: date_range).sum(:total)
  end
  
  def new_customers
    User.where(created_at: date_range).count
  end
  
  def top_products
    Product.joins(:order_items)
           .where(order_items: { created_at: date_range })
           .group(:id)
           .order(&#39;COUNT(order_items.id) DESC&#39;)
           .limit(10)
  end
  
  def date_range
    Date.new(@year, @month, 1).beginning_of_month..Date.new(@year, @month, 1).end_of_month
  end
  
  def generate_pdf(data)
    PdfGenerator.new(data).generate
  end
  
  def upload_to_s3(pdf)
    S3Uploader.upload(pdf, &quot;reports/#{@year}-#{@month}.pdf&quot;)
  end
  
  def notify_managers
    User.managers.each do |manager|
      ReportMailer.monthly_report(manager, @month, @year).deliver_later
    end
  end
end
</code></pre>
<hr>
<h3>When to Use Service Objects</h3>
<p><strong>✅ Good for:</strong></p>
<pre><code class="language-ruby"># Complex business logic
# Multi-step operations
# Coordinating multiple models
# External API calls
# Background job logic
# Fat controller extraction
# Transactional operations

Examples:
- User registration
- Order processing
- Payment handling
- Report generation
- Data import/export
- Email campaigns
- Batch operations
</code></pre>
<p><strong>❌ Not needed for:</strong></p>
<pre><code class="language-ruby"># Simple CRUD
# Single model operations
# Basic validations
# Simple queries

Examples:
- User.create(params)  # Too simple
- Post.find(id)        # Just a query
- user.update(params)  # Basic update
</code></pre>
<hr>
<h3>Testing Service Objects</h3>
<pre><code class="language-ruby">RSpec.describe CreateOrderService do
  let(:user) { create(:user) }
  let(:params) { attributes_for(:order) }
  let(:payment_method) { &#39;credit_card&#39; }
  let(:service) { described_class.new(user: user, params: params, payment_method: payment_method) }
  
  describe &#39;#call&#39; do
    context &#39;with valid data&#39; do
      it &#39;creates an order&#39; do
        expect {
          service.call
        }.to change(Order, :count).by(1)
      end
      
      it &#39;processes payment&#39; do
        expect(PaymentGateway).to receive(:charge)
        service.call
      end
      
      it &#39;updates inventory&#39; do
        product = create(:product, stock: 10)
        params[:items_attributes] = [{ product: product, quantity: 2 }]
        
        expect {
          service.call
        }.to change { product.reload.stock }.by(-2)
      end
      
      it &#39;sends confirmation email&#39; do
        expect {
          service.call
        }.to have_enqueued_job(ActionMailer::MailDeliveryJob)
      end
    end
    
    context &#39;with invalid data&#39; do
      let(:params) { {} }
      
      it &#39;does not create order&#39; do
        expect {
          service.call
        }.not_to change(Order, :count)
      end
      
      it &#39;returns false&#39; do
        expect(service.call).to be false
      end
      
      it &#39;populates errors&#39; do
        service.call
        expect(service.errors).to be_present
      end
    end
    
    context &#39;when payment fails&#39; do
      before do
        allow(PaymentGateway).to receive(:charge).and_raise(PaymentError)
      end
      
      it &#39;rolls back transaction&#39; do
        expect {
          service.call
        }.not_to change(Order, :count)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Service Objects</strong> encapsulate logic</li>
<li><strong>Single responsibility</strong></li>
<li><strong>Extract from</strong> fat controllers/models</li>
<li><strong>Use for</strong> complex operations</li>
<li><strong>Easy to test</strong></li>
<li><strong>Reusable</strong></li>
<li><strong>Transaction safe</strong></li>
<li><strong>Error handling</strong></li>
<li><strong>Plain Ruby</strong> (no Rails magic)</li>
<li><strong>Call pattern</strong> common</li>
</ol>
<hr>
<h2>Question 139: What are Rails Engines, and how do they differ from applications?</h2>
<h3>Answer</h3>
<p><strong>Rails Engines</strong> are miniature Rails applications that can be mounted inside other Rails applications. They provide reusable functionality, plugins, and modular features. Engines = mountable mini-apps, Applications = full apps.</p>
<hr>
<h3>Engine vs Application</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Application</th>
<th>Engine</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Purpose</strong></td>
<td>Full app</td>
<td>Reusable module</td>
</tr>
<tr>
<td><strong>Mounted</strong></td>
<td>No</td>
<td>Yes (inside apps)</td>
</tr>
<tr>
<td><strong>Routes</strong></td>
<td>Root level</td>
<td>Mounted at path</td>
</tr>
<tr>
<td><strong>Namespace</strong></td>
<td>Global</td>
<td>Isolated</td>
</tr>
<tr>
<td><strong>Database</strong></td>
<td>Own migrations</td>
<td>Shared or separate</td>
</tr>
<tr>
<td><strong>Assets</strong></td>
<td>App assets</td>
<td>Engine assets</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Standalone</td>
<td>Plugin/module</td>
</tr>
</tbody></table>
<hr>
<h3>Creating an Engine</h3>
<p><strong>Generate engine:</strong></p>
<pre><code class="language-bash">rails plugin new my_engine --mountable

# Creates engine structure:
my_engine/
├── app/
│   ├── controllers/my_engine/
│   ├── models/my_engine/
│   ├── views/my_engine/
│   └── helpers/my_engine/
├── config/
│   └── routes.rb
├── lib/
│   ├── my_engine/
│   │   ├── engine.rb
│   │   └── version.rb
│   └── my_engine.rb
├── test/
└── my_engine.gemspec
</code></pre>
<p><strong>Engine definition:</strong></p>
<pre><code class="language-ruby"># lib/my_engine/engine.rb
module MyEngine
  class Engine &lt; ::Rails::Engine
    isolate_namespace MyEngine
    
    # Engine configuration
    config.generators do |g|
      g.test_framework :rspec
    end
  end
end
</code></pre>
<hr>
<h3>Mounting an Engine</h3>
<p><strong>In host application:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;my_engine&#39;, path: &#39;../my_engine&#39;

# config/routes.rb
Rails.application.routes.draw do
  mount MyEngine::Engine =&gt; &#39;/blog&#39;, as: &#39;blog&#39;
end

# Now accessible at:
# /blog
# /blog/posts
# /blog/comments
</code></pre>
<hr>
<h3>Real-World Engine Example: Blog Engine</h3>
<p><strong>Engine structure:</strong></p>
<pre><code class="language-ruby"># lib/blog_engine/engine.rb
module BlogEngine
  class Engine &lt; ::Rails::Engine
    isolate_namespace BlogEngine
    
    # Share parent app&#39;s User model
    config.to_prepare do
      BlogEngine::Post.belongs_to :author, class_name: &#39;::User&#39;
    end
  end
end

# app/models/blog_engine/post.rb
module BlogEngine
  class Post &lt; ApplicationRecord
    belongs_to :author, class_name: &#39;::User&#39;
    validates :title, :body, presence: true
    
    scope :published, -&gt; { where(published: true) }
  end
end

# app/controllers/blog_engine/posts_controller.rb
module BlogEngine
  class PostsController &lt; ApplicationController
    def index
      @posts = Post.published
    end
    
    def show
      @post = Post.find(params[:id])
    end
    
    def new
      @post = Post.new
    end
    
    def create
      @post = Post.new(post_params)
      @post.author = current_user
      
      if @post.save
        redirect_to @post
      else
        render :new
      end
    end
    
    private
    
    def post_params
      params.require(:post).permit(:title, :body, :published)
    end
  end
end

# config/routes.rb
BlogEngine::Engine.routes.draw do
  resources :posts
end
</code></pre>
<p><strong>Usage in host app:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;blog_engine&#39;, path: &#39;engines/blog_engine&#39;

# config/routes.rb
mount BlogEngine::Engine =&gt; &#39;/blog&#39;

# Access blog at:
# /blog/posts
# /blog/posts/new
# /blog/posts/1
</code></pre>
<hr>
<h3>Engine Features</h3>
<p><strong>1. Isolated namespace:</strong></p>
<pre><code class="language-ruby">module BlogEngine
  class Engine &lt; ::Rails::Engine
    isolate_namespace BlogEngine
  end
end

# Routes are isolated:
BlogEngine::Engine.routes.draw do
  resources :posts  # blog_engine_posts_path
end

# Models are isolated:
BlogEngine::Post  # Not ::Post
</code></pre>
<p><strong>2. Migrations:</strong></p>
<pre><code class="language-ruby"># db/migrate/create_blog_engine_posts.rb
class CreateBlogEnginePosts &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :blog_engine_posts do |t|
      t.string :title
      t.text :body
      t.boolean :published, default: false
      t.references :author, null: false
      
      t.timestamps
    end
  end
end

# Host app runs engine migrations:
rails blog_engine:install:migrations
rails db:migrate
</code></pre>
<p><strong>3. Configuration:</strong></p>
<pre><code class="language-ruby"># lib/blog_engine/engine.rb
module BlogEngine
  class Engine &lt; ::Rails::Engine
    isolate_namespace BlogEngine
    
    # Engine configuration
    config.blog_engine = ActiveSupport::OrderedOptions.new
    config.blog_engine.posts_per_page = 10
    config.blog_engine.allow_comments = true
  end
end

# Host app can override:
# config/initializers/blog_engine.rb
BlogEngine::Engine.config.blog_engine.posts_per_page = 20
</code></pre>
<p><strong>4. Assets:</strong></p>
<pre><code class="language-ruby"># Engine assets automatically available
# app/assets/javascripts/blog_engine/application.js
# app/assets/stylesheets/blog_engine/application.css

# Host app can use:
//= require blog_engine/application
</code></pre>
<hr>
<h3>Famous Rails Engines</h3>
<p><strong>1. Devise (Authentication):</strong></p>
<pre><code class="language-ruby"># Mountable engine for authentication
mount Devise::Engine =&gt; &#39;/users&#39;

# Provides:
# /users/sign_in
# /users/sign_up
# /users/password/new
</code></pre>
<p><strong>2. Spree (E-commerce):</strong></p>
<pre><code class="language-ruby"># Full e-commerce solution as engine
mount Spree::Core::Engine =&gt; &#39;/&#39;

# Provides complete store
</code></pre>
<p><strong>3. RailsAdmin:</strong></p>
<pre><code class="language-ruby"># Admin interface engine
mount RailsAdmin::Engine =&gt; &#39;/admin&#39;

# Complete admin panel
</code></pre>
<hr>
<h3>When to Use Engines</h3>
<p><strong>✅ Good for:</strong></p>
<pre><code class="language-ruby"># Reusable features across apps
# Extracting functionality
# Third-party plugins
# White-label features
# Multi-tenant modules

Examples:
- Blog system
- Comment system
- Admin panel
- Payment processing
- Analytics dashboard
</code></pre>
<p><strong>❌ Not needed for:</strong></p>
<pre><code class="language-ruby"># Single application
# Simple features
# App-specific logic
# One-off functionality
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Engines</strong> = mini Rails apps</li>
<li><strong>Mountable</strong> in other apps</li>
<li><strong>isolate_namespace</strong> for isolation</li>
<li><strong>Own routes</strong> and models</li>
<li><strong>Migrations</strong> copied to host</li>
<li><strong>Assets</strong> automatically available</li>
<li><strong>Configuration</strong> customizable</li>
<li><strong>Famous examples</strong>: Devise, Spree</li>
<li><strong>Good for</strong> reusable features</li>
<li><strong>Test</strong> like regular Rails app</li>
</ol>
<hr>
<h2>Question 140: What is the difference between <code>render</code> and <code>redirect</code>?</h2>
<h3>Answer</h3>
<p><strong><code>render</code></strong> returns a view in the same request. <strong><code>redirect_to</code></strong> sends a new HTTP request to a different URL. render = same request, redirect = new request.</p>
<hr>
<h3>Render</h3>
<p><strong>Stays in same request:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    @post = Post.new(post_params)
    
    if @post.save
      redirect_to @post  # Success: redirect
    else
      render :new        # Failure: render form again
    end
  end
end

# render :new
# - Same HTTP request
# - No new request to server
# - Instance variables preserved (@post with errors)
# - URL stays: /posts (POST)
# - Status: 200 or custom
</code></pre>
<p><strong>Render examples:</strong></p>
<pre><code class="language-ruby"># Render template
render :show
render &#39;posts/show&#39;
render template: &#39;posts/show&#39;

# Render different controller&#39;s template
render &#39;admin/posts/show&#39;

# Render inline
render plain: &#39;Hello World&#39;
render html: &#39;&lt;h1&gt;Hello&lt;/h1&gt;&#39;.html_safe
render json: { status: &#39;ok&#39; }
render xml: @post.to_xml

# Render with status
render :new, status: :unprocessable_entity  # 422
render json: { error: &#39;Not found&#39; }, status: :not_found  # 404

# Render nothing (empty response)
head :ok                    # 200 with no body
head :no_content           # 204
head :not_found            # 404
</code></pre>
<hr>
<h3>Redirect</h3>
<p><strong>New HTTP request:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def create
    @post = Post.new(post_params)
    
    if @post.save
      redirect_to @post
      # 1. Returns 302 Found
      # 2. Browser makes GET /posts/1
      # 3. PostsController#show runs
      # 4. @post needs to be loaded again
    end
  end
end
</code></pre>
<p><strong>Redirect examples:</strong></p>
<pre><code class="language-ruby"># Redirect to URL
redirect_to posts_path
redirect_to @post
redirect_to root_url

# Redirect with status
redirect_to @post, status: :moved_permanently  # 301
redirect_to @post, status: :see_other          # 303

# Redirect with flash
redirect_to @post, notice: &#39;Post created&#39;
redirect_to @post, alert: &#39;Error occurred&#39;

# Redirect back
redirect_back(fallback_location: root_path)

# External redirect
redirect_to &#39;https://example.com&#39;
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>render</th>
<th>redirect_to</th>
</tr>
</thead>
<tbody><tr>
<td><strong>HTTP request</strong></td>
<td>Same</td>
<td>New</td>
</tr>
<tr>
<td><strong>Browser</strong></td>
<td>Sees original URL</td>
<td>Sees new URL</td>
</tr>
<tr>
<td><strong>Instance vars</strong></td>
<td>Preserved</td>
<td>Lost</td>
</tr>
<tr>
<td><strong>Flash</strong></td>
<td>Use flash.now</td>
<td>Use flash</td>
</tr>
<tr>
<td><strong>Status</strong></td>
<td>200 (or custom)</td>
<td>302/301/303</td>
</tr>
<tr>
<td><strong>Use when</strong></td>
<td>Re-showing form</td>
<td>Successful action</td>
</tr>
</tbody></table>
<hr>
<h3>Common Mistakes</h3>
<p><strong>❌ Redirect after render:</strong></p>
<pre><code class="language-ruby"># WRONG - both execute
def create
  if @post.save
    redirect_to @post
    render :new  # This still runs!
  end
end

# Fix: return after redirect
def create
  if @post.save
    redirect_to @post
    return
  end
  render :new
end

# Or use if/else
def create
  if @post.save
    redirect_to @post
  else
    render :new
  end
end
</code></pre>
<p><strong>❌ Render without instance variables:</strong></p>
<pre><code class="language-ruby"># WRONG - @post not loaded
def create
  Post.create(post_params)
  render :new  # @post is nil in view
end

# Fix:
def create
  @post = Post.new(post_params)
  if @post.save
    redirect_to @post
  else
    render :new  # @post available with errors
  end
end
</code></pre>
<p><strong>❌ Redirect with form errors:</strong></p>
<pre><code class="language-ruby"># WRONG - errors lost
def create
  @post = Post.new(post_params)
  if @post.save
    redirect_to @post
  else
    redirect_to new_post_path  # @post.errors lost!
  end
end

# Fix: render form
def create
  @post = Post.new(post_params)
  if @post.save
    redirect_to @post
  else
    render :new  # @post.errors preserved
  end
end
</code></pre>
<hr>
<h3>Flash Messages</h3>
<p><strong>With redirect:</strong></p>
<pre><code class="language-ruby">def create
  if @post.save
    # flash persists to next request
    redirect_to @post, notice: &#39;Post created&#39;
  end
end

# Next request (show action):
# flash[:notice] available in view
</code></pre>
<p><strong>With render:</strong></p>
<pre><code class="language-ruby">def create
  if @post.save
    redirect_to @post
  else
    # flash.now only for current request
    flash.now[:alert] = &#39;Could not create post&#39;
    render :new
  end
end
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use render when:</strong></p>
<pre><code class="language-ruby">✅ Form has validation errors
✅ Need to preserve instance variables
✅ Returning JSON/XML
✅ Showing error page
✅ Re-displaying form with errors

Examples:
render :new           # Form has errors
render :edit          # Update failed
render json: @post    # API response
render plain: &#39;Error&#39; # Simple text
</code></pre>
<p><strong>Use redirect when:</strong></p>
<pre><code class="language-ruby">✅ Successful create/update/delete
✅ After POST to prevent duplicate submission
✅ Changing user location
✅ After login/logout
✅ Post-Redirect-Get pattern

Examples:
redirect_to @post           # Created successfully
redirect_to posts_path      # Deleted successfully
redirect_to login_path      # Unauthorized
redirect_to root_path       # After logout
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>render</strong> = same request</li>
<li><strong>redirect_to</strong> = new request</li>
<li><strong>render</strong> preserves variables</li>
<li><strong>redirect_to</strong> loses variables</li>
<li><strong>render</strong> for errors</li>
<li><strong>redirect_to</strong> for success</li>
<li><strong>flash</strong> for redirect</li>
<li><strong>flash.now</strong> for render</li>
<li><strong>return</strong> after redirect</li>
<li><strong>PRG pattern</strong> common</li>
</ol>
<hr>
<h2>Question 141: What is the difference between methods and actions?</h2>
<h3>Answer</h3>
<p><strong>Actions</strong> are public controller methods that respond to HTTP requests. <strong>Methods</strong> are all other methods (private, protected, helpers). Actions = public request handlers, Methods = supporting code.</p>
<hr>
<h3>Actions (Public Methods)</h3>
<p><strong>Handle HTTP requests:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  # ACTIONS - public methods that handle requests
  def index    # GET /posts
    @posts = Post.all
  end
  
  def show     # GET /posts/:id
    @post = Post.find(params[:id])
  end
  
  def create   # POST /posts
    @post = Post.create(post_params)
  end
  
  # Routes map to these actions
end
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">✅ Public visibility
✅ Mapped to routes
✅ Respond to HTTP requests
✅ Render views or return responses
✅ RESTful: index, show, new, create, edit, update, destroy
</code></pre>
<hr>
<h3>Methods (Private/Protected)</h3>
<p><strong>Supporting code:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  # ACTION
  def create
    @post = Post.new(post_params)  # Uses private method
    
    if @post.save
      redirect_to @post
    else
      render :new
    end
  end
  
  # METHODS - not actions
  private
  
  def post_params  # Helper method
    params.require(:post).permit(:title, :body)
  end
  
  def authorize_post  # Helper method
    redirect_to root_path unless @post.user == current_user
  end
  
  def set_post  # Helper method
    @post = Post.find(params[:id])
  end
end
</code></pre>
<p><strong>Characteristics:</strong></p>
<pre><code class="language-ruby">✅ Private/protected visibility
✅ NOT mapped to routes
✅ Cannot handle HTTP requests
✅ Called by actions
✅ Used in before_action, etc.
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Action</th>
<th>Method</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Visibility</strong></td>
<td>Public</td>
<td>Private/Protected</td>
</tr>
<tr>
<td><strong>Routes</strong></td>
<td>Mapped</td>
<td>Not mapped</td>
</tr>
<tr>
<td><strong>HTTP</strong></td>
<td>Handles requests</td>
<td>No</td>
</tr>
<tr>
<td><strong>Purpose</strong></td>
<td>Request handler</td>
<td>Helper/Support</td>
</tr>
<tr>
<td><strong>Examples</strong></td>
<td>index, show, create</td>
<td>set_post, authorize</td>
</tr>
</tbody></table>
<hr>
<h3>Example</h3>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  before_action :set_post, only: [:show, :edit, :update]
  before_action :authorize_post, only: [:edit, :update]
  
  # ACTION - public, handles GET /posts
  def index
    @posts = Post.all
  end
  
  # ACTION - public, handles GET /posts/:id
  def show
    # @post set by before_action
  end
  
  # ACTION - public, handles PATCH /posts/:id
  def update
    if @post.update(post_params)
      redirect_to @post
    else
      render :edit
    end
  end
  
  # METHOD - private, called by before_action
  private
  
  def set_post
    @post = Post.find(params[:id])
  end
  
  # METHOD - private, called by before_action
  def authorize_post
    redirect_to root_path unless @post.user == current_user
  end
  
  # METHOD - private, called by actions
  def post_params
    params.require(:post).permit(:title, :body)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Actions</strong> = public methods</li>
<li><strong>Methods</strong> = private/protected</li>
<li><strong>Actions</strong> handle HTTP</li>
<li><strong>Methods</strong> support actions</li>
<li><strong>Routes</strong> map to actions only</li>
<li><strong>before_action</strong> uses methods</li>
<li><strong>Actions</strong> respond to requests</li>
<li><strong>Methods</strong> organize code</li>
<li><strong>Convention</strong> = private helpers</li>
<li><strong>Security</strong> = don&#39;t expose methods</li>
</ol>
<hr>
<h2>Question 142: How do you override default Rails generators?</h2>
<h3>Answer</h3>
<p>Override default generators by creating custom templates in <strong><code>lib/templates</code></strong> or configuring generator defaults in <strong><code>config/application.rb</code></strong>. This customizes generated code to match your conventions.</p>
<hr>
<h3>Method 1: Custom Templates</h3>
<p><strong>Override scaffold templates:</strong></p>
<pre><code class="language-bash"># Create template directory
mkdir -p lib/templates/erb/scaffold

# Copy default template to customize
# lib/templates/erb/scaffold/index.html.erb.tt
&lt;div class=&quot;container&quot;&gt;
  &lt;h1&gt;&lt;%= plural_table_name.titleize %&gt;&lt;/h1&gt;
  
  &lt;div class=&quot;actions&quot;&gt;
    &lt;%%= link_to &quot;New &lt;%= human_name %&gt;&quot;, new_&lt;%= singular_route_name %&gt;_path, class: &quot;btn btn-primary&quot; %&gt;
  &lt;/div&gt;
  
  &lt;table class=&quot;table&quot;&gt;
    &lt;thead&gt;
      &lt;tr&gt;
        &lt;% attributes.reject(&amp;:password_digest?).each do |attribute| -%&gt;
        &lt;th&gt;&lt;%= attribute.human_name %&gt;&lt;/th&gt;
        &lt;% end -%&gt;
        &lt;th colspan=&quot;3&quot;&gt;Actions&lt;/th&gt;
      &lt;/tr&gt;
    &lt;/thead&gt;
    
    &lt;tbody&gt;
      &lt;%% @&lt;%= plural_table_name %&gt;.each do |&lt;%= singular_table_name %&gt;| %&gt;
        &lt;tr&gt;
          &lt;% attributes.reject(&amp;:password_digest?).each do |attribute| -%&gt;
          &lt;td&gt;&lt;%%= &lt;%= singular_table_name %&gt;.&lt;%= attribute.column_name %&gt; %&gt;&lt;/td&gt;
          &lt;% end -%&gt;
          &lt;td&gt;&lt;%%= link_to &quot;Show&quot;, &lt;%= singular_table_name %&gt;, class: &quot;btn btn-sm btn-info&quot; %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;%%= link_to &quot;Edit&quot;, edit_&lt;%= singular_route_name %&gt;_path(&lt;%= singular_table_name %&gt;), class: &quot;btn btn-sm btn-warning&quot; %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;%%= button_to &quot;Delete&quot;, &lt;%= singular_table_name %&gt;, method: :delete, class: &quot;btn btn-sm btn-danger&quot; %&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;%% end %&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Available template paths:</strong></p>
<pre><code class="language-bash">lib/templates/
├── erb/
│   └── scaffold/
│       ├── index.html.erb.tt
│       ├── show.html.erb.tt
│       ├── new.html.erb.tt
│       ├── edit.html.erb.tt
│       └── _form.html.erb.tt
├── rails/
│   └── scaffold_controller/
│       └── controller.rb.tt
└── active_record/
    └── model/
        └── model.rb.tt
</code></pre>
<hr>
<h3>Method 2: Configure Generators</h3>
<p><strong>config/application.rb:</strong></p>
<pre><code class="language-ruby">module MyApp
  class Application &lt; Rails::Application
    config.generators do |g|
      # Test framework
      g.test_framework :rspec,
        fixtures: false,
        view_specs: false,
        helper_specs: false,
        routing_specs: false,
        request_specs: true
      
      # Factory instead of fixtures
      g.fixture_replacement :factory_bot, dir: &#39;spec/factories&#39;
      
      # Template engine
      g.template_engine :slim
      
      # Stylesheet engine
      g.stylesheets false
      g.stylesheet_engine :sass
      
      # JavaScript
      g.javascripts false
      g.javascript_engine :js
      
      # Helpers
      g.helper false
      
      # Assets
      g.assets false
      
      # Jbuilder
      g.jbuilder false
      
      # System tests
      g.system_tests false
    end
  end
end
</code></pre>
<hr>
<h3>Method 3: Override Controller Template</h3>
<p><strong>lib/templates/rails/scaffold_controller/controller.rb.tt:</strong></p>
<pre><code class="language-ruby">&lt;% module_namespacing do -%&gt;
class &lt;%= controller_class_name %&gt;Controller &lt; ApplicationController
  before_action :authenticate_user!
  before_action :set_&lt;%= singular_table_name %&gt;, only: %i[show edit update destroy]
  before_action :authorize_&lt;%= singular_table_name %&gt;, only: %i[edit update destroy]

  def index
    @&lt;%= plural_table_name %&gt; = &lt;%= orm_class.all(class_name) %&gt;
    @pagy, @&lt;%= plural_table_name %&gt; = pagy(@&lt;%= plural_table_name %&gt;)
  end

  def show
  end

  def new
    @&lt;%= singular_table_name %&gt; = &lt;%= orm_class.build(class_name) %&gt;
  end

  def edit
  end

  def create
    @&lt;%= singular_table_name %&gt; = current_user.&lt;%= plural_table_name %&gt;.build(&lt;%= &quot;#{singular_table_name}_params&quot; %&gt;)

    if @&lt;%= orm_instance.save %&gt;
      redirect_to @&lt;%= singular_table_name %&gt;, notice: &lt;%= &quot;&#39;#{human_name} was successfully created.&#39;&quot; %&gt;
    else
      render :new, status: :unprocessable_entity
    end
  end

  def update
    if @&lt;%= orm_instance.update(&quot;#{singular_table_name}_params&quot;) %&gt;
      redirect_to @&lt;%= singular_table_name %&gt;, notice: &lt;%= &quot;&#39;#{human_name} was successfully updated.&#39;&quot; %&gt;
    else
      render :edit, status: :unprocessable_entity
    end
  end

  def destroy
    @&lt;%= orm_instance.destroy %&gt;
    redirect_to &lt;%= index_helper %&gt;_url, notice: &lt;%= &quot;&#39;#{human_name} was successfully destroyed.&#39;&quot; %&gt;
  end

  private

  def set_&lt;%= singular_table_name %&gt;
    @&lt;%= singular_table_name %&gt; = &lt;%= orm_class.find(class_name, &quot;params[:id]&quot;) %&gt;
  end
  
  def authorize_&lt;%= singular_table_name %&gt;
    redirect_to root_path unless @&lt;%= singular_table_name %&gt;.user == current_user
  end

  def &lt;%= &quot;#{singular_table_name}_params&quot; %&gt;
    params.require(:&lt;%= singular_table_name %&gt;).permit(&lt;%= attributes.map { |a| &quot;:#{a.name}&quot; }.join(&#39;, &#39;) %&gt;)
  end
end
&lt;% end -%&gt;
</code></pre>
<hr>
<h3>Method 4: Override Model Template</h3>
<p><strong>lib/templates/active_record/model/model.rb.tt:</strong></p>
<pre><code class="language-ruby">&lt;% module_namespacing do -%&gt;
class &lt;%= class_name %&gt; &lt; &lt;%= parent_class_name.classify %&gt;
&lt;% attributes.select(&amp;:reference?).each do |attribute| -%&gt;
  belongs_to :&lt;%= attribute.name %&gt;&lt;%= &#39;, polymorphic: true&#39; if attribute.polymorphic? %&gt;&lt;%= &#39;, required: true&#39; if attribute.required? %&gt;
&lt;% end -%&gt;
&lt;% attributes.select(&amp;:token?).each do |attribute| -%&gt;
  has_secure_token&lt;%= &quot; :#{attribute.name}&quot; if attribute.name != &quot;token&quot; %&gt;
&lt;% end -%&gt;
&lt;% if attributes.any?(&amp;:password_digest?) -%&gt;
  has_secure_password
&lt;% end -%&gt;

  # Validations
&lt;% attributes.reject { |a| a.reference? || a.token? || a.password_digest? }.each do |attribute| -%&gt;
  validates :&lt;%= attribute.name %&gt;, presence: true
&lt;% end -%&gt;

  # Scopes
  scope :recent, -&gt; { order(created_at: :desc) }
  scope :active, -&gt; { where(active: true) }

  # Class methods
  def self.search(query)
    where(&quot;name ILIKE ?&quot;, &quot;%#{query}%&quot;)
  end

  # Instance methods
  def to_s
    &lt;%= attributes.first&amp;.name || &#39;id&#39; %&gt;
  end
end
&lt;% end -%&gt;
</code></pre>
<hr>
<h3>Real-World Example</h3>
<p><strong>Custom API scaffold:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.generators do |g|
  g.scaffold_controller :custom_api_scaffold
end

# lib/generators/custom_api_scaffold/custom_api_scaffold_generator.rb
class CustomApiScaffoldGenerator &lt; Rails::Generators::NamedBase
  source_root File.expand_path(&#39;templates&#39;, __dir__)
  
  def create_controller
    template &#39;controller.rb.tt&#39;, 
             &quot;app/controllers/api/v1/#{file_name.pluralize}_controller.rb&quot;
  end
  
  def create_serializer
    template &#39;serializer.rb.tt&#39;,
             &quot;app/serializers/#{file_name}_serializer.rb&quot;
  end
  
  def create_spec
    template &#39;request_spec.rb.tt&#39;,
             &quot;spec/requests/api/v1/#{file_name.pluralize}_spec.rb&quot;
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>lib/templates</strong> for custom templates</li>
<li><strong>config.generators</strong> for defaults</li>
<li><strong>Override</strong> any generator template</li>
<li><strong>Template variables</strong> available (class_name, etc.)</li>
<li><strong>Test framework</strong> configurable</li>
<li><strong>Fixture replacement</strong> (FactoryBot)</li>
<li><strong>Asset generation</strong> configurable</li>
<li><strong>Helper generation</strong> can be disabled</li>
<li><strong>Custom generators</strong> possible</li>
<li><strong>Team conventions</strong> enforceable</li>
</ol>
<hr>
<h2>Question 143: How do you override gem functionality?</h2>
<h3>Answer</h3>
<p>Override gem functionality by: <strong>(1) Monkey patching</strong>, <strong>(2) Prepending modules</strong>, <strong>(3) Decorators</strong>, <strong>(4) Initializers</strong>, or <strong>(5) Forking the gem</strong>. Choose method based on complexity and maintainability.</p>
<hr>
<h3>Method 1: Monkey Patching (Not Recommended)</h3>
<p><strong>Direct class modification:</strong></p>
<pre><code class="language-ruby"># config/initializers/devise_override.rb

# ❌ Dangerous - opens class and modifies
class Devise::SessionsController
  def create
    # Override behavior
    super
    log_sign_in
  end
  
  private
  
  def log_sign_in
    Rails.logger.info &quot;User signed in: #{current_user.id}&quot;
  end
end

# Problems:
# - Breaks on gem updates
# - Hard to debug
# - No clear override intention
# - Difficult to test
</code></pre>
<hr>
<h3>Method 2: Prepending Modules (Recommended)</h3>
<p><strong>Safe override with super:</strong></p>
<pre><code class="language-ruby"># config/initializers/devise_override.rb
module DeviseSessionsControllerExtension
  def create
    super  # Call original method
    log_sign_in
  end
  
  private
  
  def log_sign_in
    Rails.logger.info &quot;User signed in: #{current_user.id}&quot;
  end
end

# Prepend (method lookup finds this first)
Devise::SessionsController.prepend(DeviseSessionsControllerExtension)

# Benefits:
# ✅ Clean override
# ✅ Can call super
# ✅ Easy to test
# ✅ Clear intention
</code></pre>
<p><strong>More examples:</strong></p>
<pre><code class="language-ruby"># Override Devise User model
# app/models/concerns/user_extension.rb
module UserExtension
  def send_devise_notification(notification, *args)
    # Custom notification logic
    devise_mailer.send(notification, self, *args).deliver_later(queue: :mailers)
  end
end

User.prepend(UserExtension)
</code></pre>
<hr>
<h3>Method 3: Inheritance</h3>
<p><strong>Subclass gem class:</strong></p>
<pre><code class="language-ruby"># app/controllers/users/sessions_controller.rb
class Users::SessionsController &lt; Devise::SessionsController
  def create
    super
    track_login
  end
  
  private
  
  def track_login
    Analytics.track(
      user_id: current_user.id,
      event: &#39;user_login&#39;
    )
  end
end

# config/routes.rb
devise_for :users, controllers: {
  sessions: &#39;users/sessions&#39;
}
</code></pre>
<hr>
<h3>Method 4: Decorators</h3>
<p><strong>Wrap gem objects:</strong></p>
<pre><code class="language-ruby"># app/decorators/devise_user_decorator.rb
class DeviseUserDecorator &lt; SimpleDelegator
  def greeting
    &quot;Hello, #{first_name || email}!&quot;
  end
  
  def avatar_url
    gravatar_url || default_avatar
  end
  
  def membership_status
    premium? ? &#39;Premium Member&#39; : &#39;Free Member&#39;
  end
end

# Usage in controller:
def show
  user = User.find(params[:id])
  @user = DeviseUserDecorator.new(user)
end

# View:
&lt;%= @user.greeting %&gt;
&lt;%= image_tag @user.avatar_url %&gt;
</code></pre>
<hr>
<h3>Method 5: Configuration</h3>
<p><strong>Use gem&#39;s configuration API:</strong></p>
<pre><code class="language-ruby"># config/initializers/devise.rb
Devise.setup do |config|
  # Override gem behavior through config
  config.mailer_sender = &#39;no-reply@myapp.com&#39;
  config.password_length = 12..128
  config.sign_out_via = :delete
  config.timeout_in = 30.minutes
  
  # Custom warden strategies
  config.warden do |manager|
    manager.strategies.add(:custom_auth, CustomAuthStrategy)
    manager.default_strategies(scope: :user).unshift :custom_auth
  end
end
</code></pre>
<hr>
<h3>Method 6: Callbacks/Hooks</h3>
<p><strong>Use gem&#39;s callback system:</strong></p>
<pre><code class="language-ruby"># config/initializers/paperclip.rb
Paperclip.configure do |config|
  config.register_processor :custom_thumbnail, CustomThumbnailProcessor
end

# app/models/user.rb
class User &lt; ApplicationRecord
  has_attached_file :avatar,
    styles: { medium: &quot;300x300&gt;&quot;, thumb: &quot;100x100&gt;&quot; },
    processors: [:custom_thumbnail]
end
</code></pre>
<hr>
<h3>Method 7: Fork and Patch</h3>
<p><strong>Last resort:</strong></p>
<pre><code class="language-bash"># Fork gem on GitHub
# Make changes
# Use forked version

# Gemfile
gem &#39;devise&#39;, github: &#39;myusername/devise&#39;, branch: &#39;custom-changes&#39;

# Better: Submit PR to original gem
</code></pre>
<hr>
<h3>Real-World Example: Devise Override</h3>
<p><strong>Complete Devise customization:</strong></p>
<pre><code class="language-ruby"># 1. Custom controller
# app/controllers/users/sessions_controller.rb
class Users::SessionsController &lt; Devise::SessionsController
  before_action :configure_sign_in_params, only: [:create]
  after_action :log_sign_in, only: [:create]
  
  def create
    super do |resource|
      track_login(resource)
    end
  end
  
  def destroy
    track_logout(current_user) if current_user
    super
  end
  
  private
  
  def configure_sign_in_params
    devise_parameter_sanitizer.permit(:sign_in, keys: [:two_factor_code])
  end
  
  def log_sign_in
    Rails.logger.info &quot;User signed in: #{current_user&amp;.id}&quot;
  end
  
  def track_login(user)
    LoginEvent.create!(user: user, ip: request.remote_ip)
  end
  
  def track_logout(user)
    LogoutEvent.create!(user: user, ip: request.remote_ip)
  end
end

# 2. Module prepend for model
# config/initializers/devise_user_extension.rb
module DeviseUserExtension
  def active_for_authentication?
    super &amp;&amp; !banned?
  end
  
  def inactive_message
    banned? ? :banned : super
  end
  
  def send_devise_notification(notification, *args)
    devise_mailer.send(notification, self, *args).deliver_later
  end
end

Rails.configuration.to_prepare do
  User.prepend(DeviseUserExtension)
end

# 3. Custom mailer
# app/mailers/users/mailer.rb
class Users::Mailer &lt; Devise::Mailer
  helper :application
  include Devise::Controllers::UrlHelpers
  default template_path: &#39;users/mailer&#39;
  default from: &#39;no-reply@myapp.com&#39;
  
  def confirmation_instructions(record, token, opts={})
    @token = token
    @user = record
    
    # Custom logic
    track_email_sent(@user, &#39;confirmation&#39;)
    
    super
  end
  
  private
  
  def track_email_sent(user, type)
    EmailEvent.create!(user: user, email_type: type)
  end
end

# 4. Configure Devise
# config/initializers/devise.rb
Devise.setup do |config|
  config.mailer = &#39;Users::Mailer&#39;
  config.parent_mailer = &#39;ActionMailer::Base&#39;
end

# 5. Update routes
# config/routes.rb
devise_for :users, controllers: {
  sessions: &#39;users/sessions&#39;,
  registrations: &#39;users/registrations&#39;,
  passwords: &#39;users/passwords&#39;
}
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>✅ Do:</strong></p>
<pre><code class="language-ruby"># Prepend modules (safe)
MyClass.prepend(MyExtension)

# Use gem configuration
Devise.setup do |config|
  # ...
end

# Subclass gem classes
class MyController &lt; GemController

# Document overrides
# This overrides Devise&#39;s default session behavior
# to add login tracking

# Test overrides
RSpec.describe DeviseUserExtension
</code></pre>
<p><strong>❌ Don&#39;t:</strong></p>
<pre><code class="language-ruby"># Monkey patch without prepend
class GemClass
  def method
    # overridden
  end
end

# Modify gem files directly
# Edit gem code in vendor/bundle

# Override without understanding
# Read gem source first

# Ignore gem updates
# Keep gems updated, test overrides
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Prepend modules</strong> preferred</li>
<li><strong>Inheritance</strong> for controllers</li>
<li><strong>Decorators</strong> for presentation</li>
<li><strong>Configuration</strong> when available</li>
<li><strong>Callbacks</strong> for hooks</li>
<li><strong>Fork</strong> as last resort</li>
<li><strong>Document</strong> overrides</li>
<li><strong>Test</strong> thoroughly</li>
<li><strong>Update</strong> gems safely</li>
<li><strong>Contribute</strong> back to gem</li>
</ol>
<hr>
<h2>Question 144: What is obstructive JavaScript?</h2>
<h3>Answer</h3>
<p><strong>Obstructive JavaScript</strong> is JavaScript mixed with HTML (inline handlers, scattered code). <strong>Unobtrusive JavaScript</strong> (UJS) separates JavaScript from HTML using data attributes and event delegation. Modern Rails uses UJS for cleaner, maintainable code.</p>
<hr>
<h3>Obstructive JavaScript (Old Way)</h3>
<p><strong>JavaScript in HTML:</strong></p>
<pre><code class="language-html">&lt;!-- ❌ Obstructive - inline JavaScript --&gt;
&lt;a href=&quot;/posts/1&quot; onclick=&quot;deletePost(1); return false;&quot;&gt;Delete&lt;/a&gt;

&lt;button onclick=&quot;alert(&#39;Clicked!&#39;)&quot;&gt;Click Me&lt;/button&gt;

&lt;form onsubmit=&quot;return validateForm();&quot;&gt;
  &lt;input type=&quot;text&quot; onchange=&quot;checkValue(this);&quot;&gt;
  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
  function deletePost(id) {
    if (confirm(&#39;Are you sure?&#39;)) {
      fetch(`/posts/${id}`, { method: &#39;DELETE&#39; })
    }
  }
  
  function validateForm() {
    // validation logic
    return true;
  }
&lt;/script&gt;
</code></pre>
<p><strong>Problems:</strong></p>
<pre><code class="language-ruby">❌ JavaScript mixed with HTML
❌ Hard to maintain
❌ Difficult to test
❌ Not reusable
❌ CSP (Content Security Policy) violations
❌ Inline event handlers everywhere
</code></pre>
<hr>
<h3>Unobtrusive JavaScript (Modern Way)</h3>
<p><strong>Separated concerns:</strong></p>
<pre><code class="language-html">&lt;!-- ✅ Unobtrusive - clean HTML with data attributes --&gt;
&lt;a href=&quot;/posts/1&quot; 
   data-turbo-method=&quot;delete&quot;
   data-turbo-confirm=&quot;Are you sure?&quot;&gt;
  Delete
&lt;/a&gt;

&lt;button class=&quot;alert-button&quot;&gt;Click Me&lt;/button&gt;

&lt;form data-remote=&quot;true&quot;&gt;
  &lt;input type=&quot;text&quot; class=&quot;validated-input&quot;&gt;
  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p><strong>JavaScript in separate file:</strong></p>
<pre><code class="language-javascript">// app/javascript/application.js

// Event delegation
document.addEventListener(&#39;click&#39;, (e) =&gt; {
  if (e.target.matches(&#39;.alert-button&#39;)) {
    alert(&#39;Clicked!&#39;);
  }
});

// Form validation
document.querySelectorAll(&#39;.validated-input&#39;).forEach(input =&gt; {
  input.addEventListener(&#39;change&#39;, (e) =&gt; {
    validateInput(e.target);
  });
});

function validateInput(input) {
  // validation logic
}
</code></pre>
<p><strong>Benefits:</strong></p>
<pre><code class="language-ruby">✅ Separation of concerns
✅ Easy to maintain
✅ Testable
✅ Reusable
✅ CSP compliant
✅ Progressive enhancement
</code></pre>
<hr>
<h3>Rails UJS (Unobtrusive JavaScript)</h3>
<p><strong>Before (Rails 5):</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;jquery-rails&#39;
gem &#39;jquery-ujs&#39;

# application.js
//= require jquery
//= require jquery_ujs
</code></pre>
<p><strong>Now (Rails 7 - Turbo):</strong></p>
<pre><code class="language-ruby"># application.js
import &quot;@hotwired/turbo-rails&quot;

# HTML with Turbo
&lt;%= link_to &quot;Delete&quot;, post_path(@post), 
    data: { 
      turbo_method: :delete,
      turbo_confirm: &quot;Are you sure?&quot; 
    } %&gt;
</code></pre>
<hr>
<h3>Examples</h3>
<p><strong>1. Delete link:</strong></p>
<pre><code class="language-erb">&lt;!-- Obstructive --&gt;
&lt;a href=&quot;#&quot; onclick=&quot;if(confirm(&#39;Sure?&#39;)) { fetch(&#39;/posts/1&#39;, {method:&#39;DELETE&#39;}); return false; }&quot;&gt;Delete&lt;/a&gt;

&lt;!-- Unobtrusive --&gt;
&lt;%= link_to &quot;Delete&quot;, post_path(@post), 
    data: { turbo_method: :delete, turbo_confirm: &quot;Are you sure?&quot; } %&gt;
</code></pre>
<p><strong>2. AJAX form:</strong></p>
<pre><code class="language-erb">&lt;!-- Obstructive --&gt;
&lt;form onsubmit=&quot;event.preventDefault(); fetch(&#39;/posts&#39;, {method:&#39;POST&#39;, body:new FormData(this)})&quot;&gt;
  ...
&lt;/form&gt;

&lt;!-- Unobtrusive --&gt;
&lt;%= form_with model: @post, data: { turbo: true } do |f| %&gt;
  ...
&lt;% end %&gt;
</code></pre>
<p><strong>3. Dynamic behavior:</strong></p>
<pre><code class="language-erb">&lt;!-- Obstructive --&gt;
&lt;button onclick=&quot;this.classList.add(&#39;clicked&#39;)&quot;&gt;Click&lt;/button&gt;

&lt;!-- Unobtrusive --&gt;
&lt;button class=&quot;dynamic-button&quot;&gt;Click&lt;/button&gt;

&lt;script&gt;
document.querySelectorAll(&#39;.dynamic-button&#39;).forEach(btn =&gt; {
  btn.addEventListener(&#39;click&#39;, (e) =&gt; {
    e.target.classList.add(&#39;clicked&#39;);
  });
});
&lt;/script&gt;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Obstructive</strong> = mixed JS/HTML</li>
<li><strong>Unobtrusive</strong> = separated concerns</li>
<li><strong>data attributes</strong> for behavior</li>
<li><strong>Event delegation</strong> preferred</li>
<li><strong>Rails UJS</strong> / <strong>Turbo</strong> modern approach</li>
<li><strong>Progressive enhancement</strong></li>
<li><strong>CSP compliant</strong></li>
<li><strong>Testable</strong></li>
<li><strong>Maintainable</strong></li>
<li><strong>Reusable</strong></li>
</ol>
<h1>Rails 7 and Modern Features Interview Questions</h1>
<h2>Question 145: What is Hotwire (Turbo + Stimulus)?</h2>
<h3>Answer</h3>
<p><strong>Hotwire</strong> (HTML Over The Wire) is a modern approach to building fast, reactive web applications using server-rendered HTML instead of heavy JavaScript frameworks. It consists of <strong>Turbo</strong> (navigation and updates) and <strong>Stimulus</strong> (JavaScript sprinkles).</p>
<hr>
<h3>Hotwire Philosophy</h3>
<p><strong>Traditional SPA approach:</strong></p>
<pre><code>Browser ←→ JSON API ←→ Server
   ↓
Heavy JavaScript
React/Vue/Angular
Client-side rendering
Large bundle sizes
</code></pre>
<p><strong>Hotwire approach:</strong></p>
<pre><code>Browser ←→ HTML ←→ Server
   ↓
Minimal JavaScript
Server-side rendering
Small footprint
Progressive enhancement
</code></pre>
<hr>
<h3>Turbo (Navigation &amp; Updates)</h3>
<p><strong>Three main features:</strong></p>
<pre><code class="language-ruby">1. Turbo Drive  - Fast navigation (replaces Turbolinks)
2. Turbo Frames - Independent page segments
3. Turbo Streams - Real-time partial updates
</code></pre>
<hr>
<h3>1. Turbo Drive</h3>
<p><strong>Fast page navigation:</strong></p>
<pre><code class="language-html">&lt;!-- Traditional: Full page reload --&gt;
&lt;a href=&quot;/posts/1&quot;&gt;View Post&lt;/a&gt;
&lt;!-- Browser loads entire page, CSS, JS --&gt;

&lt;!-- Turbo Drive: AJAX replacement --&gt;
&lt;a href=&quot;/posts/1&quot;&gt;View Post&lt;/a&gt;
&lt;!-- 1. Intercepts click
     2. Fetches HTML via AJAX
     3. Replaces &lt;body&gt;
     4. Updates URL
     5. No full reload
--&gt;
</code></pre>
<p><strong>Configuration:</strong></p>
<pre><code class="language-html">&lt;!-- Disable on specific link --&gt;
&lt;a href=&quot;/posts/1&quot; data-turbo=&quot;false&quot;&gt;View Post&lt;/a&gt;

&lt;!-- Disable for entire page --&gt;
&lt;meta name=&quot;turbo-visit-control&quot; content=&quot;reload&quot;&gt;

&lt;!-- Force reload on specific action --&gt;
&lt;%= link_to &quot;Logout&quot;, logout_path, data: { turbo_method: :delete, turbo: false } %&gt;
</code></pre>
<hr>
<h3>2. Turbo Frames</h3>
<p><strong>Independent page segments:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/index.html.erb --&gt;
&lt;h1&gt;Posts&lt;/h1&gt;

&lt;!-- Turbo Frame - independent section --&gt;
&lt;%= turbo_frame_tag &quot;posts_list&quot; do %&gt;
  &lt;%= render @posts %&gt;
  &lt;%= link_to &quot;Next Page&quot;, posts_path(page: @page + 1) %&gt;
&lt;% end %&gt;

&lt;!-- Clicking &quot;Next Page&quot;:
     1. Finds matching turbo_frame_tag on next page
     2. Replaces only that frame
     3. Rest of page unchanged
--&gt;
</code></pre>
<p><strong>Lazy loading:</strong></p>
<pre><code class="language-erb">&lt;!-- Lazy load frame content --&gt;
&lt;%= turbo_frame_tag &quot;comments&quot;, src: post_comments_path(@post), loading: :lazy do %&gt;
  &lt;p&gt;Loading comments...&lt;/p&gt;
&lt;% end %&gt;

&lt;!-- Loads comments when scrolled into view --&gt;
</code></pre>
<p><strong>Nested frames:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/show.html.erb --&gt;
&lt;%= turbo_frame_tag &quot;post_#{@post.id}&quot; do %&gt;
  &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
  
  &lt;%= turbo_frame_tag &quot;post_body&quot; do %&gt;
    &lt;%= @post.body %&gt;
    &lt;%= link_to &quot;Edit&quot;, edit_post_path(@post) %&gt;
  &lt;% end %&gt;
  
  &lt;%= turbo_frame_tag &quot;comments&quot;, src: post_comments_path(@post) do %&gt;
    Loading comments...
  &lt;% end %&gt;
&lt;% end %&gt;

&lt;!-- Each frame updates independently --&gt;
</code></pre>
<hr>
<h3>3. Turbo Streams</h3>
<p><strong>Real-time partial updates:</strong></p>
<pre><code class="language-ruby"># Controller
class PostsController &lt; ApplicationController
  def create
    @post = Post.new(post_params)
    
    respond_to do |format|
      if @post.save
        format.turbo_stream
        format.html { redirect_to @post }
      else
        format.html { render :new, status: :unprocessable_entity }
      end
    end
  end
end

# app/views/posts/create.turbo_stream.erb
&lt;%= turbo_stream.append &quot;posts&quot;, @post %&gt;
&lt;%= turbo_stream.update &quot;post_form&quot;, &quot;&quot; %&gt;
&lt;%= turbo_stream.update &quot;flash&quot;, partial: &quot;shared/flash&quot;, locals: { notice: &quot;Post created!&quot; } %&gt;
</code></pre>
<p><strong>7 Turbo Stream actions:</strong></p>
<pre><code class="language-erb">&lt;!-- 1. Append - add to end --&gt;
&lt;%= turbo_stream.append &quot;posts&quot;, @post %&gt;

&lt;!-- 2. Prepend - add to beginning --&gt;
&lt;%= turbo_stream.prepend &quot;posts&quot;, @post %&gt;

&lt;!-- 3. Replace - replace element --&gt;
&lt;%= turbo_stream.replace &quot;post_#{@post.id}&quot;, @post %&gt;

&lt;!-- 4. Update - replace innerHTML --&gt;
&lt;%= turbo_stream.update &quot;post_#{@post.id}&quot;, @post %&gt;

&lt;!-- 5. Remove - delete element --&gt;
&lt;%= turbo_stream.remove &quot;post_#{@post.id}&quot; %&gt;

&lt;!-- 6. Before - insert before element --&gt;
&lt;%= turbo_stream.before &quot;post_#{@post.id}&quot;, @new_post %&gt;

&lt;!-- 7. After - insert after element --&gt;
&lt;%= turbo_stream.after &quot;post_#{@post.id}&quot;, @new_post %&gt;
</code></pre>
<p><strong>Broadcasting (Action Cable integration):</strong></p>
<pre><code class="language-ruby"># Model
class Post &lt; ApplicationRecord
  after_create_commit -&gt; { broadcast_prepend_to &quot;posts&quot;, target: &quot;posts&quot; }
  after_update_commit -&gt; { broadcast_replace_to &quot;posts&quot; }
  after_destroy_commit -&gt; { broadcast_remove_to &quot;posts&quot; }
end

# View - subscribe to broadcasts
&lt;%= turbo_stream_from &quot;posts&quot; %&gt;
&lt;div id=&quot;posts&quot;&gt;
  &lt;%= render @posts %&gt;
&lt;/div&gt;

# When post created, all subscribed clients get update
</code></pre>
<hr>
<h3>Stimulus (JavaScript Sprinkles)</h3>
<p><strong>Modest JavaScript framework:</strong></p>
<pre><code class="language-javascript">// app/javascript/controllers/hello_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  // Targets - elements to interact with
  static targets = [ &quot;name&quot;, &quot;output&quot; ]
  
  // Values - data attributes
  static values = { 
    greeting: String,
    count: { type: Number, default: 0 }
  }
  
  // Connect - runs when controller connects
  connect() {
    console.log(&quot;Hello controller connected&quot;)
  }
  
  // Action - responds to events
  greet() {
    const name = this.nameTarget.value
    this.outputTarget.textContent = `${this.greetingValue}, ${name}!`
  }
  
  increment() {
    this.countValue++
  }
  
  // Value changed callback
  countValueChanged() {
    this.outputTarget.textContent = `Count: ${this.countValue}`
  }
}
</code></pre>
<p><strong>HTML:</strong></p>
<pre><code class="language-html">&lt;div data-controller=&quot;hello&quot; 
     data-hello-greeting-value=&quot;Hello&quot;&gt;
  
  &lt;input type=&quot;text&quot; 
         data-hello-target=&quot;name&quot;
         data-action=&quot;input-&gt;hello#greet&quot;&gt;
  
  &lt;p data-hello-target=&quot;output&quot;&gt;&lt;/p&gt;
  
  &lt;button data-action=&quot;click-&gt;hello#increment&quot;&gt;
    Increment
  &lt;/button&gt;
&lt;/div&gt;

&lt;!-- Naming convention:
     data-controller=&quot;hello&quot;        → hello_controller.js
     data-hello-target=&quot;name&quot;       → nameTarget
     data-hello-greeting-value=&quot;Hi&quot; → greetingValue
     data-action=&quot;click-&gt;hello#greet&quot; → greet() method
--&gt;
</code></pre>
<hr>
<h3>Real-World Example: Live Search</h3>
<p><strong>Turbo Frames + Stimulus:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/products/index.html.erb --&gt;
&lt;div data-controller=&quot;search&quot;&gt;
  &lt;input type=&quot;text&quot; 
         data-search-target=&quot;input&quot;
         data-action=&quot;input-&gt;search#perform&quot;
         placeholder=&quot;Search products...&quot;&gt;
  
  &lt;%= turbo_frame_tag &quot;results&quot; do %&gt;
    &lt;%= render @products %&gt;
  &lt;% end %&gt;
&lt;/div&gt;

&lt;!-- app/views/products/_product.html.erb --&gt;
&lt;div class=&quot;product&quot;&gt;
  &lt;h3&gt;&lt;%= product.name %&gt;&lt;/h3&gt;
  &lt;p&gt;&lt;%= product.description %&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Stimulus controller:</strong></p>
<pre><code class="language-javascript">// app/javascript/controllers/search_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  static targets = [ &quot;input&quot; ]
  static values = { url: String }
  
  connect() {
    this.timeout = null
  }
  
  perform() {
    clearTimeout(this.timeout)
    
    this.timeout = setTimeout(() =&gt; {
      this.search()
    }, 300) // Debounce 300ms
  }
  
  search() {
    const query = this.inputTarget.value
    const url = this.urlValue || &#39;/products&#39;
    const params = new URLSearchParams({ q: query })
    
    // Turbo Frame will handle the response
    fetch(`${url}?${params}`, {
      headers: {
        &#39;Accept&#39;: &#39;text/vnd.turbo-stream.html&#39;
      }
    })
  }
}
</code></pre>
<p><strong>Controller:</strong></p>
<pre><code class="language-ruby">class ProductsController &lt; ApplicationController
  def index
    @products = Product.search(params[:q])
    
    respond_to do |format|
      format.html
      format.turbo_stream do
        render turbo_stream: turbo_stream.update(&quot;results&quot;, partial: &quot;products&quot;)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Real-World Example: Inline Editing</h3>
<pre><code class="language-erb">&lt;!-- app/views/posts/show.html.erb --&gt;
&lt;%= turbo_frame_tag &quot;post_#{@post.id}&quot; do %&gt;
  &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
  &lt;div class=&quot;content&quot;&gt;&lt;%= @post.body %&gt;&lt;/div&gt;
  &lt;%= link_to &quot;Edit&quot;, edit_post_path(@post) %&gt;
&lt;% end %&gt;

&lt;!-- app/views/posts/edit.html.erb --&gt;
&lt;%= turbo_frame_tag &quot;post_#{@post.id}&quot; do %&gt;
  &lt;%= form_with model: @post, data: { controller: &quot;autosave&quot; } do |f| %&gt;
    &lt;%= f.text_field :title, 
        data: { 
          autosave_target: &quot;field&quot;,
          action: &quot;input-&gt;autosave#save&quot; 
        } %&gt;
    
    &lt;%= f.text_area :body,
        data: { 
          autosave_target: &quot;field&quot;,
          action: &quot;input-&gt;autosave#save&quot;
        } %&gt;
    
    &lt;%= f.submit &quot;Update&quot; %&gt;
    &lt;%= link_to &quot;Cancel&quot;, @post %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>Autosave controller:</strong></p>
<pre><code class="language-javascript">// app/javascript/controllers/autosave_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  static targets = [ &quot;field&quot; ]
  
  connect() {
    this.timeout = null
  }
  
  save() {
    clearTimeout(this.timeout)
    
    this.timeout = setTimeout(() =&gt; {
      this.element.requestSubmit()
    }, 1000)
  }
}
</code></pre>
<hr>
<h3>Hotwire Benefits</h3>
<pre><code class="language-ruby">✅ Server-rendered HTML (SEO friendly)
✅ No build step required
✅ Small JavaScript footprint
✅ Progressive enhancement
✅ Real-time updates with Turbo Streams
✅ Fast navigation with Turbo Drive
✅ Independent updates with Turbo Frames
✅ Modest JavaScript with Stimulus
✅ Works with existing Rails patterns
✅ No need for separate API
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Hotwire</strong> = HTML over the wire</li>
<li><strong>Turbo Drive</strong> = fast navigation</li>
<li><strong>Turbo Frames</strong> = independent sections</li>
<li><strong>Turbo Streams</strong> = real-time updates</li>
<li><strong>Stimulus</strong> = minimal JavaScript</li>
<li><strong>Server-rendered</strong> HTML</li>
<li><strong>Progressive enhancement</strong></li>
<li><strong>No heavy frameworks</strong> needed</li>
<li><strong>Works with</strong> Rails conventions</li>
<li><strong>Fast and responsive</strong> UX</li>
</ol>
<hr>
<h2>Question 146: What are the differences between Webpacker and Import Maps in Rails 7?</h2>
<h3>Answer</h3>
<p><strong>Webpacker</strong> bundles JavaScript with Webpack (complex, build step). <strong>Import Maps</strong> uses native ES modules (simple, no build). Rails 7 defaults to Import Maps for simpler setups.</p>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Webpacker</th>
<th>Import Maps</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bundling</strong></td>
<td>Yes (Webpack)</td>
<td>No</td>
</tr>
<tr>
<td><strong>Build step</strong></td>
<td>Required</td>
<td>None</td>
</tr>
<tr>
<td><strong>Dependencies</strong></td>
<td>npm/yarn</td>
<td>CDN or vendored</td>
</tr>
<tr>
<td><strong>Complexity</strong></td>
<td>High</td>
<td>Low</td>
</tr>
<tr>
<td><strong>Setup time</strong></td>
<td>Slow</td>
<td>Fast</td>
</tr>
<tr>
<td><strong>Compilation</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Tree shaking</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Browser support</strong></td>
<td>All (transpiled)</td>
<td>Modern only</td>
</tr>
<tr>
<td><strong>Rails default</strong></td>
<td>Rails 5-6</td>
<td>Rails 7+</td>
</tr>
</tbody></table>
<hr>
<h3>Webpacker (Old Approach)</h3>
<p><strong>Setup:</strong></p>
<pre><code class="language-bash"># Install Webpacker
rails webpacker:install

# Directory structure
app/javascript/
├── packs/
│   └── application.js  # Entry point
├── controllers/
├── channels/
└── stylesheets/
</code></pre>
<p><strong>Configuration:</strong></p>
<pre><code class="language-javascript">// app/javascript/packs/application.js
import Rails from &quot;@rails/ujs&quot;
import Turbolinks from &quot;turbolinks&quot;
import * as ActiveStorage from &quot;@rails/activestorage&quot;
import &quot;channels&quot;

Rails.start()
Turbolinks.start()
ActiveStorage.start()

// Import other files
import &quot;../controllers&quot;
import &quot;../stylesheets/application.scss&quot;
</code></pre>
<p><strong>View:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/layouts/application.html.erb --&gt;
&lt;%= javascript_pack_tag &#39;application&#39;, &#39;data-turbolinks-track&#39;: &#39;reload&#39; %&gt;
&lt;%= stylesheet_pack_tag &#39;application&#39;, &#39;data-turbolinks-track&#39;: &#39;reload&#39; %&gt;
</code></pre>
<p><strong>Install packages:</strong></p>
<pre><code class="language-bash">yarn add stimulus
yarn add lodash
</code></pre>
<p><strong>Use packages:</strong></p>
<pre><code class="language-javascript">// app/javascript/packs/application.js
import { Application } from &quot;stimulus&quot;
import _ from &quot;lodash&quot;

const application = Application.start()
console.log(_.capitalize(&#39;hello&#39;))
</code></pre>
<p><strong>Build:</strong></p>
<pre><code class="language-bash"># Development
bin/webpack-dev-server

# Production
RAILS_ENV=production rails assets:precompile
</code></pre>
<p><strong>Pros:</strong></p>
<pre><code class="language-ruby">✅ Full Webpack features
✅ Tree shaking
✅ Code splitting
✅ Transpilation (Babel)
✅ Supports older browsers
✅ CSS preprocessing
✅ Image optimization
</code></pre>
<p><strong>Cons:</strong></p>
<pre><code class="language-ruby">❌ Complex configuration
❌ Slow build times
❌ Node.js required
❌ Large dependency tree
❌ Frequent breaking changes
❌ Webpack knowledge needed
</code></pre>
<hr>
<h3>Import Maps (Rails 7 Default)</h3>
<p><strong>Setup:</strong></p>
<pre><code class="language-bash"># Comes with Rails 7
rails new myapp

# Or add to existing app
./bin/importmap pin @hotwired/stimulus
</code></pre>
<p><strong>Configuration:</strong></p>
<pre><code class="language-ruby"># config/importmap.rb
pin &quot;application&quot;, preload: true
pin &quot;@hotwired/turbo-rails&quot;, to: &quot;turbo.min.js&quot;, preload: true
pin &quot;@hotwired/stimulus&quot;, to: &quot;stimulus.min.js&quot;, preload: true
pin &quot;@hotwired/stimulus-loading&quot;, to: &quot;stimulus-loading.js&quot;, preload: true

pin &quot;lodash&quot;, to: &quot;https://ga.jspm.io/npm:lodash@4.17.21/lodash.js&quot;
</code></pre>
<p><strong>View:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/layouts/application.html.erb --&gt;
&lt;%= javascript_importmap_tags %&gt;

&lt;!-- Generates: --&gt;
&lt;script type=&quot;importmap&quot;&gt;{
  &quot;imports&quot;: {
    &quot;application&quot;: &quot;/assets/application-abc123.js&quot;,
    &quot;@hotwired/stimulus&quot;: &quot;/assets/stimulus-def456.js&quot;,
    &quot;lodash&quot;: &quot;https://ga.jspm.io/npm:lodash@4.17.21/lodash.js&quot;
  }
}&lt;/script&gt;
&lt;script type=&quot;module&quot;&gt;import &quot;application&quot;&lt;/script&gt;
</code></pre>
<p><strong>Use modules:</strong></p>
<pre><code class="language-javascript">// app/javascript/application.js
import &quot;@hotwired/turbo-rails&quot;
import &quot;controllers&quot;

// Import from CDN
import _ from &quot;lodash&quot;
console.log(_.capitalize(&#39;hello&#39;))
</code></pre>
<p><strong>Pin packages:</strong></p>
<pre><code class="language-bash"># From CDN
./bin/importmap pin lodash

# Download and vendor
./bin/importmap pin lodash --download

# Specific version
./bin/importmap pin react@18.0.0
</code></pre>
<p><strong>Pros:</strong></p>
<pre><code class="language-ruby">✅ No build step
✅ Fast setup
✅ Simple configuration
✅ Native ES modules
✅ No Node.js required
✅ Instant reload
✅ Rails-friendly
</code></pre>
<p><strong>Cons:</strong></p>
<pre><code class="language-ruby">❌ Modern browsers only
❌ No tree shaking
❌ No transpilation
❌ Larger file sizes
❌ CDN dependencies
❌ Limited tooling
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use Import Maps when:</strong></p>
<pre><code class="language-ruby">✅ Building modern Rails apps
✅ Targeting modern browsers
✅ Want simplicity
✅ Using Hotwire/Turbo/Stimulus
✅ Don&#39;t need complex builds
✅ Prefer Rails conventions
✅ Want fast development

Examples:
- Standard CRUD apps
- Hotwire applications
- Admin interfaces
- Content-heavy sites
</code></pre>
<p><strong>Use Webpacker/jsbundling when:</strong></p>
<pre><code class="language-ruby">✅ Need React/Vue/Angular
✅ Complex JavaScript app
✅ Tree shaking required
✅ Support old browsers
✅ Heavy npm dependencies
✅ Custom build pipeline

Examples:
- SPAs with Rails API
- Complex interactive UIs
- Legacy browser support
- Large JavaScript codebases
</code></pre>
<hr>
<h3>Migration Path</h3>
<p><strong>From Webpacker to Import Maps:</strong></p>
<pre><code class="language-bash"># 1. Remove Webpacker
bundle remove webpacker
rm -rf node_modules
rm package.json yarn.lock

# 2. Install importmap-rails
bundle add importmap-rails
./bin/rails importmap:install

# 3. Pin dependencies
./bin/importmap pin @hotwired/turbo-rails
./bin/importmap pin @hotwired/stimulus
./bin/importmap pin @hotwired/stimulus-loading

# 4. Update application.js
# app/javascript/application.js
import &quot;@hotwired/turbo-rails&quot;
import &quot;controllers&quot;

# 5. Update layout
# &lt;%= javascript_importmap_tags %&gt;

# 6. Test thoroughly
</code></pre>
<hr>
<h3>Alternative: jsbundling-rails</h3>
<p><strong>If you need bundling but not Webpacker:</strong></p>
<pre><code class="language-bash"># Install with esbuild (fast)
rails new myapp -j esbuild

# Or with rollup
rails new myapp -j rollup

# Or with webpack
rails new myapp -j webpack

# Simpler than Webpacker
# Uses modern bundlers
# Still requires Node.js
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Webpacker</strong> = Webpack bundling</li>
<li><strong>Import Maps</strong> = native ES modules</li>
<li><strong>Rails 7</strong> defaults to Import Maps</li>
<li><strong>Import Maps</strong> = simpler</li>
<li><strong>Webpacker</strong> = more features</li>
<li><strong>Import Maps</strong> = modern browsers</li>
<li><strong>Webpacker</strong> = all browsers</li>
<li><strong>Choose based</strong> on needs</li>
<li><strong>jsbundling</strong> as middle ground</li>
<li><strong>Import Maps</strong> preferred for new apps</li>
</ol>
<hr>
<h2>Question 147: How do you use Hotwire Turbo Frames and Turbo Streams effectively?</h2>
<h3>Answer</h3>
<p><strong>Turbo Frames</strong> isolate page sections for independent updates. <strong>Turbo Streams</strong> enable real-time partial updates. Use Frames for navigation, Streams for live updates and broadcasts.</p>
<hr>
<h3>Turbo Frames - Core Concepts</h3>
<p><strong>Basic frame:</strong></p>
<pre><code class="language-erb">&lt;!-- Independent section --&gt;
&lt;%= turbo_frame_tag &quot;posts&quot; do %&gt;
  &lt;%= render @posts %&gt;
  &lt;%= link_to &quot;Load More&quot;, posts_path(page: 2) %&gt;
&lt;% end %&gt;

&lt;!-- Clicking &quot;Load More&quot;:
     1. Fetches /posts?page=2
     2. Finds matching turbo_frame_tag with id=&quot;posts&quot;
     3. Replaces only that frame
     4. Rest of page unchanged
--&gt;
</code></pre>
<hr>
<h3>Turbo Frames - Patterns</h3>
<p><strong>1. Inline editing:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/show.html.erb --&gt;
&lt;h1&gt;Post&lt;/h1&gt;

&lt;%= turbo_frame_tag &quot;post_#{@post.id}&quot; do %&gt;
  &lt;div class=&quot;post-content&quot;&gt;
    &lt;h2&gt;&lt;%= @post.title %&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;%= @post.body %&gt;&lt;/p&gt;
    &lt;%= link_to &quot;Edit&quot;, edit_post_path(@post) %&gt;
  &lt;/div&gt;
&lt;% end %&gt;

&lt;!-- app/views/posts/edit.html.erb --&gt;
&lt;%= turbo_frame_tag &quot;post_#{@post.id}&quot; do %&gt;
  &lt;%= form_with model: @post do |f| %&gt;
    &lt;%= f.text_field :title %&gt;
    &lt;%= f.text_area :body %&gt;
    &lt;%= f.submit &quot;Update&quot; %&gt;
    &lt;%= link_to &quot;Cancel&quot;, @post %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

&lt;!-- Flow:
     1. Click &quot;Edit&quot; → Loads edit page
     2. Only frame replaced with form
     3. Submit → Updates and shows post
     4. All within same frame
--&gt;
</code></pre>
<p><strong>2. Modal dialogs:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/index.html.erb --&gt;
&lt;%= link_to &quot;New Post&quot;, 
    new_post_path, 
    data: { turbo_frame: &quot;modal&quot; } %&gt;

&lt;%= turbo_frame_tag &quot;modal&quot; %&gt;

&lt;!-- app/views/posts/new.html.erb --&gt;
&lt;%= turbo_frame_tag &quot;modal&quot; do %&gt;
  &lt;div class=&quot;modal&quot;&gt;
    &lt;div class=&quot;modal-content&quot;&gt;
      &lt;h2&gt;New Post&lt;/h2&gt;
      &lt;%= form_with model: @post do |f| %&gt;
        &lt;%= f.text_field :title %&gt;
        &lt;%= f.text_area :body %&gt;
        &lt;%= f.submit %&gt;
      &lt;% end %&gt;
      &lt;%= link_to &quot;Close&quot;, posts_path %&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;% end %&gt;

&lt;!-- Click &quot;New Post&quot; → Opens in modal
     Submit/Close → Removes modal
--&gt;
</code></pre>
<p><strong>3. Lazy loading:</strong></p>
<pre><code class="language-erb">&lt;!-- Load content when visible --&gt;
&lt;%= turbo_frame_tag &quot;comments&quot;, 
    src: post_comments_path(@post),
    loading: :lazy do %&gt;
  &lt;p&gt;Loading comments...&lt;/p&gt;
&lt;% end %&gt;

&lt;!-- Loads comments when scrolled into view --&gt;
</code></pre>
<p><strong>4. Pagination:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/posts/index.html.erb --&gt;
&lt;%= turbo_frame_tag &quot;posts&quot; do %&gt;
  &lt;div class=&quot;posts&quot;&gt;
    &lt;%= render @posts %&gt;
  &lt;/div&gt;
  
  &lt;%= link_to &quot;Load More&quot;, 
      posts_path(page: @page + 1), 
      class: &quot;load-more&quot; if @posts.next_page %&gt;
&lt;% end %&gt;

&lt;!-- Loads next page into same frame --&gt;
</code></pre>
<p><strong>5. Tabs:</strong></p>
<pre><code class="language-erb">&lt;!-- Navigation --&gt;
&lt;div class=&quot;tabs&quot;&gt;
  &lt;%= link_to &quot;Profile&quot;, 
      user_profile_path(@user), 
      data: { turbo_frame: &quot;tab_content&quot; } %&gt;
  
  &lt;%= link_to &quot;Posts&quot;, 
      user_posts_path(@user), 
      data: { turbo_frame: &quot;tab_content&quot; } %&gt;
  
  &lt;%= link_to &quot;Comments&quot;, 
      user_comments_path(@user), 
      data: { turbo_frame: &quot;tab_content&quot; } %&gt;
&lt;/div&gt;

&lt;!-- Content --&gt;
&lt;%= turbo_frame_tag &quot;tab_content&quot; do %&gt;
  &lt;%= render @user.profile %&gt;
&lt;% end %&gt;

&lt;!-- Each tab loads into same frame --&gt;
</code></pre>
<hr>
<h3>Turbo Frames - Advanced</h3>
<p><strong>Target different frame:</strong></p>
<pre><code class="language-erb">&lt;!-- Link targets different frame --&gt;
&lt;%= link_to &quot;Edit Profile&quot;, 
    edit_user_path(@user),
    data: { turbo_frame: &quot;modal&quot; } %&gt;

&lt;!-- Opens in modal frame instead of current frame --&gt;
</code></pre>
<p><strong>Break out of frame:</strong></p>
<pre><code class="language-erb">&lt;!-- Navigate entire page --&gt;
&lt;%= link_to &quot;Back to Posts&quot;, 
    posts_path,
    data: { turbo_frame: &quot;_top&quot; } %&gt;

&lt;!-- _top = full page navigation --&gt;
</code></pre>
<p><strong>Nested frames:</strong></p>
<pre><code class="language-erb">&lt;%= turbo_frame_tag &quot;post&quot; do %&gt;
  &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
  
  &lt;%= turbo_frame_tag &quot;comments&quot; do %&gt;
    &lt;%= render @post.comments %&gt;
  &lt;% end %&gt;
  
  &lt;%= turbo_frame_tag &quot;related&quot; do %&gt;
    &lt;%= render @post.related_posts %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

&lt;!-- Each frame independent --&gt;
</code></pre>
<hr>
<h3>Turbo Streams - Core Concepts</h3>
<p><strong>7 actions:</strong></p>
<pre><code class="language-erb">&lt;!-- 1. Append - add to end --&gt;
&lt;%= turbo_stream.append &quot;posts&quot;, @post %&gt;

&lt;!-- 2. Prepend - add to beginning --&gt;
&lt;%= turbo_stream.prepend &quot;posts&quot;, @post %&gt;

&lt;!-- 3. Replace - replace entire element --&gt;
&lt;%= turbo_stream.replace &quot;post_#{@post.id}&quot;, @post %&gt;

&lt;!-- 4. Update - replace innerHTML --&gt;
&lt;%= turbo_stream.update &quot;post_#{@post.id}&quot;, @post %&gt;

&lt;!-- 5. Remove - delete element --&gt;
&lt;%= turbo_stream.remove &quot;post_#{@post.id}&quot; %&gt;

&lt;!-- 6. Before - insert before --&gt;
&lt;%= turbo_stream.before &quot;post_#{@post.id}&quot;, @new_post %&gt;

&lt;!-- 7. After - insert after --&gt;
&lt;%= turbo_stream.after &quot;post_#{@post.id}&quot;, @new_post %&gt;
</code></pre>
<hr>
<h3>Turbo Streams - Patterns</h3>
<p><strong>1. Create (prepend):</strong></p>
<pre><code class="language-ruby"># Controller
class PostsController &lt; ApplicationController
  def create
    @post = Post.new(post_params)
    
    respond_to do |format|
      if @post.save
        format.turbo_stream
        format.html { redirect_to @post }
      else
        format.html { render :new, status: :unprocessable_entity }
      end
    end
  end
end

# app/views/posts/create.turbo_stream.erb
&lt;%= turbo_stream.prepend &quot;posts&quot;, @post %&gt;
&lt;%= turbo_stream.update &quot;new_post&quot;, partial: &quot;form&quot;, locals: { post: Post.new } %&gt;
&lt;%= turbo_stream.update &quot;flash&quot;, partial: &quot;shared/flash&quot;, locals: { notice: &quot;Post created!&quot; } %&gt;
</code></pre>
<p><strong>2. Update (replace):</strong></p>
<pre><code class="language-ruby"># Controller
def update
  respond_to do |format|
    if @post.update(post_params)
      format.turbo_stream
      format.html { redirect_to @post }
    else
      format.turbo_stream do
        render turbo_stream: turbo_stream.replace(
          &quot;post_form&quot;,
          partial: &quot;form&quot;,
          locals: { post: @post }
        )
      end
      format.html { render :edit, status: :unprocessable_entity }
    end
  end
end

# app/views/posts/update.turbo_stream.erb
&lt;%= turbo_stream.replace &quot;post_#{@post.id}&quot;, @post %&gt;
&lt;%= turbo_stream.update &quot;flash&quot;, partial: &quot;shared/flash&quot;, locals: { notice: &quot;Post updated!&quot; } %&gt;
</code></pre>
<p><strong>3. Delete (remove):</strong></p>
<pre><code class="language-ruby"># Controller
def destroy
  @post.destroy
  
  respond_to do |format|
    format.turbo_stream
    format.html { redirect_to posts_path }
  end
end

# app/views/posts/destroy.turbo_stream.erb
&lt;%= turbo_stream.remove &quot;post_#{@post.id}&quot; %&gt;
&lt;%= turbo_stream.update &quot;flash&quot;, partial: &quot;shared/flash&quot;, locals: { notice: &quot;Post deleted!&quot; } %&gt;
</code></pre>
<hr>
<h3>Turbo Streams - Broadcasting</h3>
<p><strong>Real-time updates:</strong></p>
<pre><code class="language-ruby"># Model
class Post &lt; ApplicationRecord
  broadcasts_to -&gt;(post) { &quot;posts&quot; }, inserts_by: :prepend
  
  # Or manually:
  after_create_commit -&gt; { 
    broadcast_prepend_to &quot;posts&quot;, 
    target: &quot;posts&quot;,
    partial: &quot;posts/post&quot;,
    locals: { post: self }
  }
  
  after_update_commit -&gt; { 
    broadcast_replace_to &quot;posts&quot; 
  }
  
  after_destroy_commit -&gt; { 
    broadcast_remove_to &quot;posts&quot; 
  }
end

# View - subscribe to channel
&lt;%= turbo_stream_from &quot;posts&quot; %&gt;
&lt;div id=&quot;posts&quot;&gt;
  &lt;%= render @posts %&gt;
&lt;/div&gt;

&lt;!-- All connected clients receive updates --&gt;
</code></pre>
<p><strong>User-specific broadcasts:</strong></p>
<pre><code class="language-ruby"># Model
class Notification &lt; ApplicationRecord
  belongs_to :user
  
  after_create_commit -&gt; {
    broadcast_prepend_to(
      &quot;user_#{user_id}_notifications&quot;,
      target: &quot;notifications&quot;,
      partial: &quot;notifications/notification&quot;
    )
  }
end

# View - each user subscribes to their channel
&lt;%= turbo_stream_from &quot;user_#{current_user.id}_notifications&quot; %&gt;
&lt;div id=&quot;notifications&quot;&gt;
  &lt;%= render current_user.notifications %&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h3>Real-World Example: Live Chat</h3>
<p><strong>Complete implementation:</strong></p>
<pre><code class="language-ruby"># Model
class Message &lt; ApplicationRecord
  belongs_to :room
  belongs_to :user
  
  after_create_commit -&gt; {
    broadcast_append_to(
      &quot;room_#{room_id}&quot;,
      target: &quot;messages&quot;,
      partial: &quot;messages/message&quot;
    )
  }
end

# Controller
class MessagesController &lt; ApplicationController
  def create
    @message = current_room.messages.build(message_params)
    @message.user = current_user
    
    if @message.save
      respond_to do |format|
        format.turbo_stream do
          render turbo_stream: turbo_stream.update(
            &quot;new_message&quot;,
            partial: &quot;form&quot;,
            locals: { message: Message.new }
          )
        end
        format.html { redirect_to current_room }
      end
    end
  end
end
</code></pre>
<p><strong>Views:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/rooms/show.html.erb --&gt;
&lt;h1&gt;&lt;%= @room.name %&gt;&lt;/h1&gt;

&lt;%= turbo_stream_from &quot;room_#{@room.id}&quot; %&gt;

&lt;div id=&quot;messages&quot; class=&quot;messages&quot;&gt;
  &lt;%= render @messages %&gt;
&lt;/div&gt;

&lt;%= turbo_frame_tag &quot;new_message&quot; do %&gt;
  &lt;%= render &quot;messages/form&quot;, message: Message.new %&gt;
&lt;% end %&gt;

&lt;!-- app/views/messages/_message.html.erb --&gt;
&lt;div id=&quot;&lt;%= dom_id(message) %&gt;&quot; class=&quot;message&quot;&gt;
  &lt;strong&gt;&lt;%= message.user.name %&gt;:&lt;/strong&gt;
  &lt;%= message.body %&gt;
  &lt;span class=&quot;timestamp&quot;&gt;&lt;%= time_ago_in_words(message.created_at) %&gt; ago&lt;/span&gt;
&lt;/div&gt;

&lt;!-- app/views/messages/_form.html.erb --&gt;
&lt;%= form_with model: message, url: room_messages_path(current_room) do |f| %&gt;
  &lt;%= f.text_area :body, 
      placeholder: &quot;Type a message...&quot;,
      data: { 
        controller: &quot;autogrow&quot;,
        action: &quot;input-&gt;autogrow#grow&quot; 
      } %&gt;
  &lt;%= f.submit &quot;Send&quot; %&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Use meaningful IDs:</strong></p>
<pre><code class="language-erb">&lt;!-- ❌ Bad --&gt;
&lt;div id=&quot;item_1&quot;&gt;

&lt;!-- ✅ Good --&gt;
&lt;div id=&quot;&lt;%= dom_id(post) %&gt;&quot;&gt;  &lt;!-- &quot;post_1&quot; --&gt;
</code></pre>
<p><strong>2. Handle errors:</strong></p>
<pre><code class="language-ruby"># Controller
def create
  @post = Post.new(post_params)
  
  respond_to do |format|
    if @post.save
      format.turbo_stream
    else
      format.turbo_stream do
        render turbo_stream: turbo_stream.replace(
          &quot;post_form&quot;,
          partial: &quot;form&quot;,
          locals: { post: @post }
        ), status: :unprocessable_entity
      end
    end
  end
end
</code></pre>
<p><strong>3. Combine multiple streams:</strong></p>
<pre><code class="language-erb">&lt;!-- create.turbo_stream.erb --&gt;
&lt;%= turbo_stream.prepend &quot;posts&quot;, @post %&gt;
&lt;%= turbo_stream.update &quot;post_count&quot;, Post.count %&gt;
&lt;%= turbo_stream.update &quot;new_post_form&quot;, partial: &quot;form&quot;, locals: { post: Post.new } %&gt;
</code></pre>
<p><strong>4. Lazy load heavy content:</strong></p>
<pre><code class="language-erb">&lt;%= turbo_frame_tag &quot;analytics&quot;,
    src: dashboard_analytics_path,
    loading: :lazy do %&gt;
  &lt;p&gt;Loading analytics...&lt;/p&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Turbo Frames</strong> = independent sections</li>
<li><strong>Turbo Streams</strong> = partial updates</li>
<li><strong>Frames</strong> for navigation</li>
<li><strong>Streams</strong> for live updates</li>
<li><strong>broadcasts</strong> for real-time</li>
<li><strong>7 stream actions</strong> available</li>
<li><strong>Lazy loading</strong> with frames</li>
<li><strong>Modals</strong> with frames</li>
<li><strong>Chat/notifications</strong> with streams</li>
<li><strong>Combine both</strong> for rich UX</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 148: How do you handle state management in StimulusJS?</h2>
<h3>Answer</h3>
<p>StimulusJS manages state through <strong>Values</strong> (data attributes), <strong>Targets</strong> (DOM references), <strong>Classes</strong> (CSS management), and <strong>Outlets</strong> (controller communication). No complex state management library needed.</p>
<hr>
<h3>1. Values (Data Attributes)</h3>
<p><strong>Define and use values:</strong></p>
<pre><code class="language-javascript">// app/javascript/controllers/counter_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  // Define values with types and defaults
  static values = {
    count: { type: Number, default: 0 },
    step: { type: Number, default: 1 },
    max: Number,
    enabled: Boolean,
    user: Object,
    tags: Array,
    color: String
  }
  
  connect() {
    console.log(this.countValue)  // Access value
  }
  
  increment() {
    if (this.hasMaxValue &amp;&amp; this.countValue &gt;= this.maxValue) {
      return
    }
    
    this.countValue += this.stepValue  // Update value
  }
  
  decrement() {
    this.countValue -= this.stepValue
  }
  
  // Callback when value changes
  countValueChanged(value, previousValue) {
    this.element.textContent = value
    
    if (value &gt; 10) {
      this.element.classList.add(&#39;high&#39;)
    }
  }
}
</code></pre>
<p><strong>HTML:</strong></p>
<pre><code class="language-html">&lt;div data-controller=&quot;counter&quot;
     data-counter-count-value=&quot;0&quot;
     data-counter-step-value=&quot;2&quot;
     data-counter-max-value=&quot;100&quot;
     data-counter-enabled-value=&quot;true&quot;
     data-counter-user-value=&#39;{&quot;name&quot;: &quot;Alice&quot;, &quot;id&quot;: 1}&#39;
     data-counter-tags-value=&#39;[&quot;tag1&quot;, &quot;tag2&quot;]&#39;
     data-counter-color-value=&quot;blue&quot;&gt;
  
  &lt;span&gt;Count: 0&lt;/span&gt;
  &lt;button data-action=&quot;click-&gt;counter#increment&quot;&gt;+&lt;/button&gt;
  &lt;button data-action=&quot;click-&gt;counter#decrement&quot;&gt;-&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h3>2. Targets (DOM References)</h3>
<p><strong>Define and use targets:</strong></p>
<pre><code class="language-javascript">// app/javascript/controllers/form_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  static targets = [ &quot;input&quot;, &quot;output&quot;, &quot;submit&quot;, &quot;error&quot; ]
  
  connect() {
    // Single target
    console.log(this.inputTarget)  // First matching element
    
    // Multiple targets
    console.log(this.inputTargets)  // Array of all matching
    
    // Check existence
    if (this.hasErrorTarget) {
      this.errorTarget.classList.add(&#39;visible&#39;)
    }
  }
  
  validate() {
    const value = this.inputTarget.value
    
    if (value.length &lt; 3) {
      this.showError(&quot;Too short&quot;)
      this.submitTarget.disabled = true
    } else {
      this.hideError()
      this.submitTarget.disabled = false
      this.outputTarget.textContent = value
    }
  }
  
  showError(message) {
    if (this.hasErrorTarget) {
      this.errorTarget.textContent = message
      this.errorTarget.classList.add(&#39;visible&#39;)
    }
  }
  
  hideError() {
    if (this.hasErrorTarget) {
      this.errorTarget.classList.remove(&#39;visible&#39;)
    }
  }
}
</code></pre>
<p><strong>HTML:</strong></p>
<pre><code class="language-html">&lt;div data-controller=&quot;form&quot;&gt;
  &lt;input type=&quot;text&quot; 
         data-form-target=&quot;input&quot;
         data-action=&quot;input-&gt;form#validate&quot;&gt;
  
  &lt;p data-form-target=&quot;output&quot;&gt;&lt;/p&gt;
  
  &lt;div data-form-target=&quot;error&quot; class=&quot;error&quot;&gt;&lt;/div&gt;
  
  &lt;button data-form-target=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h3>3. Classes (CSS Management)</h3>
<p><strong>Define and use classes:</strong></p>
<pre><code class="language-javascript">// app/javascript/controllers/dropdown_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  static classes = [ &quot;open&quot;, &quot;closed&quot;, &quot;active&quot; ]
  
  static targets = [ &quot;menu&quot; ]
  
  toggle() {
    if (this.menuTarget.classList.contains(this.openClass)) {
      this.close()
    } else {
      this.open()
    }
  }
  
  open() {
    this.menuTarget.classList.remove(this.closedClass)
    this.menuTarget.classList.add(this.openClass)
    this.element.classList.add(this.activeClass)
  }
  
  close() {
    this.menuTarget.classList.remove(this.openClass)
    this.menuTarget.classList.add(this.closedClass)
    this.element.classList.remove(this.activeClass)
  }
}
</code></pre>
<p><strong>HTML:</strong></p>
<pre><code class="language-html">&lt;div data-controller=&quot;dropdown&quot;
     data-dropdown-open-class=&quot;dropdown-open&quot;
     data-dropdown-closed-class=&quot;dropdown-closed&quot;
     data-dropdown-active-class=&quot;active&quot;&gt;
  
  &lt;button data-action=&quot;click-&gt;dropdown#toggle&quot;&gt;Menu&lt;/button&gt;
  
  &lt;div data-dropdown-target=&quot;menu&quot; class=&quot;dropdown-closed&quot;&gt;
    &lt;a href=&quot;/profile&quot;&gt;Profile&lt;/a&gt;
    &lt;a href=&quot;/settings&quot;&gt;Settings&lt;/a&gt;
    &lt;a href=&quot;/logout&quot;&gt;Logout&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h3>4. Outlets (Controller Communication)</h3>
<p><strong>Define and use outlets:</strong></p>
<pre><code class="language-javascript">// Parent controller
// app/javascript/controllers/search_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  static outlets = [ &quot;results&quot; ]
  
  static values = { url: String }
  
  perform(event) {
    const query = event.target.value
    
    fetch(`${this.urlValue}?q=${query}`)
      .then(r =&gt; r.text())
      .then(html =&gt; {
        // Communicate with results controller
        this.resultsOutlet.update(html)
      })
  }
  
  clear() {
    this.resultsOutlet.clear()
  }
}

// Child controller
// app/javascript/controllers/results_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  update(html) {
    this.element.innerHTML = html
  }
  
  clear() {
    this.element.innerHTML = &#39;&#39;
  }
}
</code></pre>
<p><strong>HTML:</strong></p>
<pre><code class="language-html">&lt;div data-controller=&quot;search&quot;
     data-search-url-value=&quot;/search&quot;
     data-search-results-outlet=&quot;.results&quot;&gt;
  
  &lt;input type=&quot;text&quot; 
         data-action=&quot;input-&gt;search#perform&quot;&gt;
  
  &lt;button data-action=&quot;click-&gt;search#clear&quot;&gt;Clear&lt;/button&gt;
&lt;/div&gt;

&lt;div data-controller=&quot;results&quot; class=&quot;results&quot;&gt;
  &lt;!-- Results appear here --&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h3>Real-World Example: Shopping Cart</h3>
<p><strong>Complete state management:</strong></p>
<pre><code class="language-javascript">// app/javascript/controllers/cart_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  static targets = [ &quot;item&quot;, &quot;total&quot;, &quot;count&quot;, &quot;empty&quot; ]
  
  static values = {
    items: { type: Array, default: [] },
    total: { type: Number, default: 0 }
  }
  
  static classes = [ &quot;hidden&quot; ]
  
  connect() {
    this.loadFromStorage()
    this.updateUI()
  }
  
  add(event) {
    const button = event.currentTarget
    const item = {
      id: button.dataset.productId,
      name: button.dataset.productName,
      price: parseFloat(button.dataset.productPrice),
      quantity: 1
    }
    
    // Update state
    const existing = this.itemsValue.find(i =&gt; i.id === item.id)
    
    if (existing) {
      existing.quantity++
    } else {
      this.itemsValue = [...this.itemsValue, item]
    }
    
    this.calculateTotal()
    this.saveToStorage()
    this.updateUI()
  }
  
  remove(event) {
    const itemId = event.currentTarget.dataset.itemId
    
    this.itemsValue = this.itemsValue.filter(i =&gt; i.id !== itemId)
    
    this.calculateTotal()
    this.saveToStorage()
    this.updateUI()
  }
  
  updateQuantity(event) {
    const itemId = event.currentTarget.dataset.itemId
    const quantity = parseInt(event.currentTarget.value)
    
    const item = this.itemsValue.find(i =&gt; i.id === itemId)
    if (item) {
      item.quantity = quantity
    }
    
    this.calculateTotal()
    this.saveToStorage()
    this.updateUI()
  }
  
  clear() {
    this.itemsValue = []
    this.totalValue = 0
    this.saveToStorage()
    this.updateUI()
  }
  
  // State calculations
  calculateTotal() {
    this.totalValue = this.itemsValue.reduce(
      (sum, item) =&gt; sum + (item.price * item.quantity),
      0
    )
  }
  
  // Persistence
  loadFromStorage() {
    const stored = localStorage.getItem(&#39;cart&#39;)
    if (stored) {
      const data = JSON.parse(stored)
      this.itemsValue = data.items || []
      this.totalValue = data.total || 0
    }
  }
  
  saveToStorage() {
    localStorage.setItem(&#39;cart&#39;, JSON.stringify({
      items: this.itemsValue,
      total: this.totalValue
    }))
  }
  
  // UI updates
  updateUI() {
    this.updateCount()
    this.updateTotal()
    this.updateEmpty()
  }
  
  updateCount() {
    const count = this.itemsValue.reduce((sum, item) =&gt; sum + item.quantity, 0)
    
    this.countTargets.forEach(target =&gt; {
      target.textContent = count
    })
  }
  
  updateTotal() {
    this.totalTargets.forEach(target =&gt; {
      target.textContent = `$${this.totalValue.toFixed(2)}`
    })
  }
  
  updateEmpty() {
    if (this.hasEmptyTarget) {
      if (this.itemsValue.length === 0) {
        this.emptyTarget.classList.remove(this.hiddenClass)
      } else {
        this.emptyTarget.classList.add(this.hiddenClass)
      }
    }
  }
  
  // Value changed callbacks
  itemsValueChanged() {
    this.calculateTotal()
  }
  
  totalValueChanged() {
    this.updateTotal()
  }
}
</code></pre>
<p><strong>HTML:</strong></p>
<pre><code class="language-html">&lt;!-- Product listing --&gt;
&lt;div data-controller=&quot;cart&quot; data-cart-hidden-class=&quot;hidden&quot;&gt;
  &lt;div class=&quot;products&quot;&gt;
    &lt;div class=&quot;product&quot;&gt;
      &lt;h3&gt;Product 1&lt;/h3&gt;
      &lt;p&gt;$29.99&lt;/p&gt;
      &lt;button data-action=&quot;click-&gt;cart#add&quot;
              data-product-id=&quot;1&quot;
              data-product-name=&quot;Product 1&quot;
              data-product-price=&quot;29.99&quot;&gt;
        Add to Cart
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  
  &lt;!-- Cart sidebar --&gt;
  &lt;div class=&quot;cart-sidebar&quot;&gt;
    &lt;h2&gt;Cart (&lt;span data-cart-target=&quot;count&quot;&gt;0&lt;/span&gt;)&lt;/h2&gt;
    
    &lt;div data-cart-target=&quot;empty&quot; class=&quot;empty-message&quot;&gt;
      Your cart is empty
    &lt;/div&gt;
    
    &lt;div data-cart-target=&quot;items&quot;&gt;
      &lt;!-- Cart items --&gt;
    &lt;/div&gt;
    
    &lt;div class=&quot;cart-total&quot;&gt;
      Total: &lt;span data-cart-target=&quot;total&quot;&gt;$0.00&lt;/span&gt;
    &lt;/div&gt;
    
    &lt;button data-action=&quot;click-&gt;cart#clear&quot;&gt;Clear Cart&lt;/button&gt;
    &lt;button&gt;Checkout&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Use values for state:</strong></p>
<pre><code class="language-javascript">// ✅ Good - values for state
static values = { 
  open: Boolean,
  count: Number 
}

this.openValue = true

// ❌ Bad - instance variables
this.open = true  // Lost on reconnect
</code></pre>
<p><strong>2. Persist when needed:</strong></p>
<pre><code class="language-javascript">connect() {
  this.loadState()
}

disconnect() {
  this.saveState()
}

loadState() {
  const state = localStorage.getItem(&#39;controller-state&#39;)
  if (state) {
    const data = JSON.parse(state)
    this.itemsValue = data.items
  }
}

saveState() {
  localStorage.setItem(&#39;controller-state&#39;, JSON.stringify({
    items: this.itemsValue
  }))
}
</code></pre>
<p><strong>3. React to value changes:</strong></p>
<pre><code class="language-javascript">static values = { count: Number }

countValueChanged(value, previousValue) {
  console.log(`Count changed from ${previousValue} to ${value}`)
  
  // Update UI
  this.element.textContent = value
  
  // Side effects
  if (value &gt; 10) {
    this.notify(&quot;High count!&quot;)
  }
}
</code></pre>
<p><strong>4. Use outlets for communication:</strong></p>
<pre><code class="language-javascript">// Parent controls child
this.resultsOutlet.update(data)

// Check outlet exists
if (this.hasResultsOutlet) {
  this.resultsOutlet.clear()
}

// Multiple outlets
this.resultsOutlets.forEach(outlet =&gt; {
  outlet.update(data)
})
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Values</strong> for state data</li>
<li><strong>Targets</strong> for DOM elements</li>
<li><strong>Classes</strong> for CSS management</li>
<li><strong>Outlets</strong> for communication</li>
<li><strong>valueChanged</strong> callbacks</li>
<li><strong>localStorage</strong> for persistence</li>
<li><strong>No complex</strong> state management</li>
<li><strong>Simple</strong> and effective</li>
<li><strong>Works with</strong> Turbo</li>
<li><strong>Progressive</strong> enhancement</li>
</ol>
<h1>Storage, Assets, and Error Handling Interview Questions</h1>
<h2>Question 149: Explain Active Storage in detail</h2>
<h3>Answer</h3>
<p><strong>Active Storage</strong> manages file uploads to cloud services (S3, GCS, Azure) or local disk. It handles attachments, variants (image processing), direct uploads, and provides a unified API across storage services.</p>
<hr>
<h3>Setup</h3>
<p><strong>Install Active Storage:</strong></p>
<pre><code class="language-bash">rails active_storage:install
rails db:migrate

# Creates tables:
# - active_storage_blobs (file metadata)
# - active_storage_attachments (polymorphic joins)
# - active_storage_variant_records (processed variants)
</code></pre>
<p><strong>Configure storage:</strong></p>
<pre><code class="language-yaml"># config/storage.yml
local:
  service: Disk
  root: &lt;%= Rails.root.join(&quot;storage&quot;) %&gt;

test:
  service: Disk
  root: &lt;%= Rails.root.join(&quot;tmp/storage&quot;) %&gt;

amazon:
  service: S3
  access_key_id: &lt;%= ENV[&#39;AWS_ACCESS_KEY_ID&#39;] %&gt;
  secret_access_key: &lt;%= ENV[&#39;AWS_SECRET_ACCESS_KEY&#39;] %&gt;
  region: us-east-1
  bucket: my-bucket

google:
  service: GCS
  project: my-project
  credentials: &lt;%= Rails.root.join(&quot;config/gcs.json&quot;) %&gt;
  bucket: my-bucket

microsoft:
  service: AzureStorage
  storage_account_name: &lt;%= ENV[&#39;AZURE_STORAGE_ACCOUNT&#39;] %&gt;
  storage_access_key: &lt;%= ENV[&#39;AZURE_STORAGE_ACCESS_KEY&#39;] %&gt;
  container: my-container
</code></pre>
<p><strong>Set active service:</strong></p>
<pre><code class="language-ruby"># config/environments/development.rb
config.active_storage.service = :local

# config/environments/production.rb
config.active_storage.service = :amazon
</code></pre>
<hr>
<h3>Attachments</h3>
<p><strong>has_one_attached:</strong></p>
<pre><code class="language-ruby"># Model
class User &lt; ApplicationRecord
  has_one_attached :avatar
end

# Usage
user = User.find(1)

# Attach file
user.avatar.attach(params[:avatar])
user.avatar.attach(
  io: File.open(&#39;/path/to/file.jpg&#39;),
  filename: &#39;avatar.jpg&#39;,
  content_type: &#39;image/jpeg&#39;
)

# Check attachment
user.avatar.attached?  # =&gt; true

# Access
user.avatar.filename   # =&gt; &quot;avatar.jpg&quot;
user.avatar.byte_size  # =&gt; 123456
user.avatar.content_type  # =&gt; &quot;image/jpeg&quot;

# URL
url_for(user.avatar)  # =&gt; &quot;/rails/active_storage/blobs/...&quot;

# Remove
user.avatar.purge       # Delete immediately
user.avatar.purge_later # Delete via background job
</code></pre>
<p><strong>has_many_attached:</strong></p>
<pre><code class="language-ruby"># Model
class Post &lt; ApplicationRecord
  has_many_attached :images
end

# Usage
post = Post.find(1)

# Attach multiple
post.images.attach(params[:images])
post.images.attach([file1, file2, file3])

# Access
post.images.each do |image|
  puts image.filename
end

# Remove
post.images.purge       # Delete all
post.images[0].purge    # Delete specific
</code></pre>
<hr>
<h3>Forms</h3>
<p><strong>Single file upload:</strong></p>
<pre><code class="language-erb">&lt;%= form_with model: @user do |f| %&gt;
  &lt;%= f.file_field :avatar, direct_upload: true %&gt;
  &lt;%= f.submit %&gt;
&lt;% end %&gt;

&lt;!-- Preview existing --&gt;
&lt;% if @user.avatar.attached? %&gt;
  &lt;%= image_tag @user.avatar, size: &quot;200x200&quot; %&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>Multiple files:</strong></p>
<pre><code class="language-erb">&lt;%= form_with model: @post do |f| %&gt;
  &lt;%= f.file_field :images, multiple: true, direct_upload: true %&gt;
  &lt;%= f.submit %&gt;
&lt;% end %&gt;

&lt;!-- Preview existing --&gt;
&lt;% @post.images.each do |image| %&gt;
  &lt;%= image_tag image, size: &quot;100x100&quot; %&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Image Processing</h3>
<p><strong>Variants (image transformations):</strong></p>
<pre><code class="language-ruby"># Model with variants
class User &lt; ApplicationRecord
  has_one_attached :avatar do |attachable|
    attachable.variant :thumb, resize_to_limit: [100, 100]
    attachable.variant :medium, resize_to_limit: [300, 300]
    attachable.variant :large, resize_to_limit: [800, 800]
  end
end

# View
&lt;%= image_tag user.avatar.variant(:thumb) %&gt;
&lt;%= image_tag user.avatar.variant(:medium) %&gt;

# On-the-fly transformation
&lt;%= image_tag user.avatar.variant(resize_to_limit: [200, 200]) %&gt;

# Multiple operations
&lt;%= image_tag user.avatar.variant(
  resize_to_limit: [800, 600],
  crop: &quot;800x600+0+0&quot;,
  quality: 80
) %&gt;
</code></pre>
<p><strong>Image processing libraries:</strong></p>
<pre><code class="language-ruby"># config/application.rb
# Choose processor: vips (default, faster) or mini_magick
config.active_storage.variant_processor = :vips

# Gemfile
gem &quot;image_processing&quot;, &quot;~&gt; 1.2&quot;  # Required for variants
</code></pre>
<p><strong>Available transformations:</strong></p>
<pre><code class="language-ruby"># Resize
resize_to_limit: [800, 600]  # Max dimensions
resize_to_fit: [800, 600]    # Fit within box
resize_to_fill: [800, 600]   # Fill box, crop excess
resize_and_pad: [800, 600, background: [255, 255, 255]]

# Crop
crop: &quot;800x600+100+50&quot;  # WIDTHxHEIGHT+X+Y

# Rotate
rotate: 90

# Quality (JPEG)
quality: 80

# Format conversion
format: :jpg
format: :png
format: :webp

# Multiple operations
user.avatar.variant(
  resize_to_limit: [800, 600],
  format: :webp,
  saver: { quality: 85 }
)
</code></pre>
<hr>
<h3>Direct Uploads</h3>
<p><strong>JavaScript direct upload:</strong></p>
<pre><code class="language-erb">&lt;!-- Form with direct upload --&gt;
&lt;%= form_with model: @post do |f| %&gt;
  &lt;%= f.file_field :images, 
      multiple: true,
      direct_upload: true,
      data: { 
        controller: &quot;upload&quot;,
        action: &quot;direct-upload:end-&gt;upload#complete&quot;
      } %&gt;
  &lt;%= f.submit %&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>Upload controller:</strong></p>
<pre><code class="language-javascript">// app/javascript/controllers/upload_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  complete(event) {
    const { id, file } = event.detail
    console.log(`Uploaded: ${file.name}`)
    
    // Show preview
    this.showPreview(file)
  }
  
  showPreview(file) {
    const reader = new FileReader()
    reader.onload = (e) =&gt; {
      const img = document.createElement(&#39;img&#39;)
      img.src = e.target.result
      document.body.appendChild(img)
    }
    reader.readAsDataURL(file)
  }
}
</code></pre>
<hr>
<h3>Validations</h3>
<p><strong>Content type and size:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  has_one_attached :avatar
  
  validates :avatar, 
    content_type: [&#39;image/png&#39;, &#39;image/jpeg&#39;, &#39;image/gif&#39;],
    size: { less_than: 5.megabytes }
end

# Using ActiveStorage::Validations gem
gem &#39;active_storage_validations&#39;

class User &lt; ApplicationRecord
  has_one_attached :avatar
  
  validates :avatar, 
    content_type: { in: %w[image/png image/jpeg], message: &#39;must be PNG or JPEG&#39; },
    size: { less_than: 2.megabytes, message: &#39;must be less than 2MB&#39; },
    dimension: { width: { min: 800, max: 2000 }, height: { min: 600, max: 2000 } }
end
</code></pre>
<hr>
<h3>Service Adapters</h3>
<p><strong>Amazon S3:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &quot;aws-sdk-s3&quot;, require: false

# config/storage.yml
amazon:
  service: S3
  access_key_id: &lt;%= ENV[&#39;AWS_ACCESS_KEY_ID&#39;] %&gt;
  secret_access_key: &lt;%= ENV[&#39;AWS_SECRET_ACCESS_KEY&#39;] %&gt;
  region: us-east-1
  bucket: my-bucket
  
# Public access
amazon_public:
  service: S3
  access_key_id: &lt;%= ENV[&#39;AWS_ACCESS_KEY_ID&#39;] %&gt;
  secret_access_key: &lt;%= ENV[&#39;AWS_SECRET_ACCESS_KEY&#39;] %&gt;
  region: us-east-1
  bucket: my-public-bucket
  public: true
</code></pre>
<p><strong>Google Cloud Storage:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &quot;google-cloud-storage&quot;, require: false

# config/storage.yml
google:
  service: GCS
  project: my-project-id
  credentials: &lt;%= Rails.root.join(&quot;config/gcs.json&quot;) %&gt;
  bucket: my-bucket
</code></pre>
<p><strong>Microsoft Azure:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &quot;azure-storage-blob&quot;, require: false

# config/storage.yml
microsoft:
  service: AzureStorage
  storage_account_name: &lt;%= ENV[&#39;AZURE_STORAGE_ACCOUNT&#39;] %&gt;
  storage_access_key: &lt;%= ENV[&#39;AZURE_STORAGE_ACCESS_KEY&#39;] %&gt;
  container: my-container
</code></pre>
<hr>
<h3>Advanced Usage</h3>
<p><strong>Metadata:</strong></p>
<pre><code class="language-ruby"># Store custom metadata
user.avatar.attach(
  io: File.open(&#39;avatar.jpg&#39;),
  filename: &#39;avatar.jpg&#39;,
  metadata: { 
    user_id: user.id,
    original_filename: &#39;photo.jpg&#39;
  }
)

# Access metadata
user.avatar.metadata  # =&gt; { identified: true, user_id: 1, ... }
</code></pre>
<p><strong>Analysis:</strong></p>
<pre><code class="language-ruby"># Analyze image (dimensions, etc.)
user.avatar.analyze

user.avatar.metadata[:width]   # =&gt; 1920
user.avatar.metadata[:height]  # =&gt; 1080

# Auto-analyze on upload
class User &lt; ApplicationRecord
  has_one_attached :avatar do |attachable|
    attachable.variant :thumb, resize_to_limit: [100, 100]
  end
  
  after_commit :analyze_avatar, on: [:create, :update]
  
  private
  
  def analyze_avatar
    avatar.analyze_later if avatar.attached?
  end
end
</code></pre>
<p><strong>Previews (for documents):</strong></p>
<pre><code class="language-ruby"># Generate preview for PDF, video, etc.
&lt;%= image_tag @document.file.preview(resize_to_limit: [300, 300]) %&gt;

# Check if previewable
@document.file.previewable?  # =&gt; true for PDF, video, etc.
</code></pre>
<hr>
<h3>Background Jobs</h3>
<p><strong>Purge files asynchronously:</strong></p>
<pre><code class="language-ruby"># Immediate deletion (blocks request)
user.avatar.purge

# Background deletion (job)
user.avatar.purge_later

# Custom job
class CleanupAvatarJob &lt; ApplicationJob
  def perform(user_id)
    user = User.find(user_id)
    user.avatar.purge if user.avatar.attached?
  end
end
</code></pre>
<hr>
<h3>Testing</h3>
<p><strong>RSpec:</strong></p>
<pre><code class="language-ruby">RSpec.describe User, type: :model do
  describe &#39;avatar attachment&#39; do
    it &#39;attaches avatar&#39; do
      user = create(:user)
      file = fixture_file_upload(&#39;avatar.jpg&#39;, &#39;image/jpeg&#39;)
      
      user.avatar.attach(file)
      
      expect(user.avatar).to be_attached
      expect(user.avatar.filename).to eq(&#39;avatar.jpg&#39;)
      expect(user.avatar.content_type).to eq(&#39;image/jpeg&#39;)
    end
    
    it &#39;validates content type&#39; do
      user = build(:user)
      file = fixture_file_upload(&#39;document.pdf&#39;, &#39;application/pdf&#39;)
      
      user.avatar.attach(file)
      
      expect(user).not_to be_valid
      expect(user.errors[:avatar]).to include(&#39;must be PNG or JPEG&#39;)
    end
  end
end
</code></pre>
<hr>
<h3>Performance Optimization</h3>
<p><strong>Eager loading:</strong></p>
<pre><code class="language-ruby"># N+1 query problem
users = User.all
users.each do |user|
  user.avatar.attached?  # Query per user
end

# Solution: eager load
users = User.with_attached_avatar
users.each do |user|
  user.avatar.attached?  # No additional queries
end

# Multiple attachments
posts = Post.with_attached_images
</code></pre>
<p><strong>CDN:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.active_storage.resolve_model_to_route = :rails_storage_proxy

# Use CDN in front of S3
# CloudFront, CloudFlare, etc.
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Active Storage</strong> manages uploads</li>
<li><strong>has_one_attached</strong> for single file</li>
<li><strong>has_many_attached</strong> for multiple</li>
<li><strong>Variants</strong> for image processing</li>
<li><strong>Direct uploads</strong> to cloud</li>
<li><strong>Multiple services</strong> (S3, GCS, Azure)</li>
<li><strong>Validations</strong> for content/size</li>
<li><strong>Background jobs</strong> for processing</li>
<li><strong>Eager loading</strong> prevents N+1</li>
<li><strong>Test</strong> with fixture files</li>
</ol>
<hr>
<h2>Question 150: What is Rails Asset Pipeline, and how does it work?</h2>
<h3>Answer</h3>
<p>The <strong>Asset Pipeline</strong> compiles and serves JavaScript, CSS, and images. It concatenates files, minifies code, fingerprints for caching, and processes preprocessors (Sass, CoffeeScript). Replaced by modern tools in Rails 7.</p>
<hr>
<h3>Asset Pipeline (Sprockets)</h3>
<p><strong>How it works:</strong></p>
<pre><code>Source Files               Asset Pipeline           Public Assets
─────────────             ──────────────           ─────────────
app/assets/               → Concatenate            public/assets/
  javascripts/            → Minify                   application-abc123.js
    application.js        → Compress                 application-abc123.css
    posts.js              → Fingerprint              logo-def456.png
  stylesheets/            → Cache
    application.css
    posts.scss
  images/
    logo.png

lib/assets/               → Include in pipeline

vendor/assets/            → Include in pipeline
</code></pre>
<hr>
<h3>Directory Structure</h3>
<pre><code class="language-ruby">app/assets/              # App-specific assets
├── images/              # Images
├── javascripts/         # JavaScript
│   ├── application.js   # Manifest file
│   └── posts.js
└── stylesheets/         # CSS/Sass
    ├── application.css  # Manifest file
    └── posts.scss

lib/assets/              # Library code

vendor/assets/           # Third-party code
</code></pre>
<hr>
<h3>Manifest Files</h3>
<p><strong>JavaScript manifest:</strong></p>
<pre><code class="language-javascript">// app/assets/javascripts/application.js

// Sprockets directives
//= require jquery
//= require jquery_ujs
//= require turbolinks
//= require_tree .

// Loads:
// 1. jquery.js
// 2. jquery_ujs.js
// 3. turbolinks.js
// 4. All files in same directory
</code></pre>
<p><strong>Directives:</strong></p>
<pre><code class="language-javascript">//= require file_name          // Include specific file
//= require_directory ./dir    // Include files in directory (non-recursive)
//= require_tree ./dir         // Include all files recursively
//= require_self               // Insert contents of current file
//= stub file_name             // Blacklist file
</code></pre>
<p><strong>CSS manifest:</strong></p>
<pre><code class="language-css">/* app/assets/stylesheets/application.css */

/*
 *= require_self
 *= require bootstrap
 *= require posts
 *= require_tree .
 */

/* Your CSS here */
</code></pre>
<hr>
<h3>Fingerprinting</h3>
<p><strong>Cache busting:</strong></p>
<pre><code class="language-ruby"># Development
application.js  → /assets/application.js

# Production
application.js  → /assets/application-abc123def456.js

# Fingerprint based on file contents
# Changes if file changes
# Perfect for CDN caching
</code></pre>
<hr>
<h3>Preprocessing</h3>
<p><strong>Sass/SCSS:</strong></p>
<pre><code class="language-scss">// app/assets/stylesheets/posts.scss
$primary-color: #3498db;

.post {
  color: $primary-color;
  
  .title {
    font-size: 24px;
  }
}

// Compiled to CSS
</code></pre>
<p><strong>CoffeeScript (deprecated):</strong></p>
<pre><code class="language-coffeescript"># app/assets/javascripts/posts.coffee
class Post
  constructor: (@title) -&gt;
  
  display: -&gt;
    alert @title

# Compiled to JavaScript
</code></pre>
<hr>
<h3>Using Assets in Views</h3>
<p><strong>JavaScript:</strong></p>
<pre><code class="language-erb">&lt;!-- Loads application.js --&gt;
&lt;%= javascript_include_tag &#39;application&#39; %&gt;

&lt;!-- Generated in production: --&gt;
&lt;script src=&quot;/assets/application-abc123.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><strong>CSS:</strong></p>
<pre><code class="language-erb">&lt;!-- Loads application.css --&gt;
&lt;%= stylesheet_link_tag &#39;application&#39; %&gt;

&lt;!-- Generated in production: --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/application-abc123.css&quot;&gt;
</code></pre>
<p><strong>Images:</strong></p>
<pre><code class="language-erb">&lt;!-- In views --&gt;
&lt;%= image_tag &#39;logo.png&#39; %&gt;

&lt;!-- In CSS --&gt;
background-image: url(asset-path(&#39;logo.png&#39;));

&lt;!-- Asset helpers --&gt;
&lt;%= asset_path(&#39;logo.png&#39;) %&gt;
&lt;%= asset_url(&#39;logo.png&#39;) %&gt;
</code></pre>
<hr>
<h3>Configuration</h3>
<pre><code class="language-ruby"># config/environments/development.rb
config.assets.debug = true           # Separate files
config.assets.digest = false         # No fingerprinting
config.assets.compile = true         # Compile on-the-fly

# config/environments/production.rb
config.assets.debug = false          # Concatenated
config.assets.digest = true          # Fingerprinting
config.assets.compile = false        # Don&#39;t compile on-the-fly
config.assets.js_compressor = :uglifier
config.assets.css_compressor = :sass
</code></pre>
<hr>
<h3>Precompilation</h3>
<p><strong>Precompile for production:</strong></p>
<pre><code class="language-bash"># Precompile assets
RAILS_ENV=production rails assets:precompile

# Creates:
# public/assets/application-abc123.js
# public/assets/application-abc123.css
# public/assets/manifest-xxx.json

# Clean old assets
RAILS_ENV=production rails assets:clean

# Clean all assets
RAILS_ENV=production rails assets:clobber
</code></pre>
<p><strong>Custom precompile list:</strong></p>
<pre><code class="language-ruby"># config/initializers/assets.rb
Rails.application.config.assets.precompile += %w[
  admin.js
  admin.css
  application.css
]
</code></pre>
<hr>
<h3>Problems with Asset Pipeline</h3>
<pre><code class="language-ruby">❌ Slow compilation
❌ Complex configuration
❌ Sprockets directives confusing
❌ Limited ES6+ support
❌ Not standard JavaScript tools
❌ Difficult debugging
❌ Outdated approach
</code></pre>
<hr>
<h3>Modern Alternatives (Rails 7)</h3>
<p><strong>Import Maps (default):</strong></p>
<pre><code class="language-ruby"># No asset pipeline
# Uses native ES modules
# See Question 146
</code></pre>
<p><strong>jsbundling-rails:</strong></p>
<pre><code class="language-ruby"># Modern bundlers
# esbuild, rollup, webpack
rails new myapp -j esbuild
</code></pre>
<p><strong>propshaft:</strong></p>
<pre><code class="language-ruby"># Simple asset serving
# No concatenation
# No preprocessing
# Fingerprinting only
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Asset Pipeline</strong> = Sprockets</li>
<li><strong>Concatenates</strong> and minifies</li>
<li><strong>Fingerprints</strong> for caching</li>
<li><strong>Manifest files</strong> with directives</li>
<li><strong>Precompile</strong> for production</li>
<li><strong>app/assets</strong> for app code</li>
<li><strong>Deprecated</strong> in Rails 7</li>
<li><strong>Import Maps</strong> new default</li>
<li><strong>jsbundling</strong> for complex apps</li>
<li><strong>propshaft</strong> for simple serving</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 151: How do you optimize Rails asset pipeline?</h2>
<h3>Answer</h3>
<p>Optimize Asset Pipeline through <strong>concatenation</strong>, <strong>minification</strong>, <strong>compression</strong>, <strong>CDN</strong>, <strong>caching</strong>, and <strong>selective precompilation</strong>. Modern Rails 7 uses simpler approaches (Import Maps, propshaft).</p>
<hr>
<h3>1. Concatenation and Minification</h3>
<p><strong>Combine files:</strong></p>
<pre><code class="language-javascript">// app/assets/javascripts/application.js
//= require jquery
//= require bootstrap
//= require_tree ./components
//= require_tree ./pages

// Production: All combined into one file
// Reduces HTTP requests
</code></pre>
<p><strong>Minify code:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.assets.js_compressor = :uglifier
config.assets.css_compressor = :sass

# Removes whitespace, comments, shortens variable names
# application.js (200KB) → application-abc123.js (50KB)
</code></pre>
<hr>
<h3>2. Compression</h3>
<p><strong>Gzip compression:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.middleware.insert_before ActionDispatch::Static, Rack::Deflater

# Compresses responses
# application.js (50KB) → application.js.gz (15KB)
# 70% size reduction
</code></pre>
<p><strong>Precompressed assets:</strong></p>
<pre><code class="language-bash"># Precompile with gzip
RAILS_ENV=production rails assets:precompile

# Creates both:
# public/assets/application-abc123.js
# public/assets/application-abc123.js.gz

# Server serves .gz if client accepts
</code></pre>
<hr>
<h3>3. CDN (Content Delivery Network)</h3>
<p><strong>Configure asset host:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.action_controller.asset_host = &#39;https://cdn.example.com&#39;

# Assets served from CDN:
# &lt;script src=&quot;https://cdn.example.com/assets/application-abc123.js&quot;&gt;
# &lt;link href=&quot;https://cdn.example.com/assets/application-abc123.css&quot;&gt;
</code></pre>
<p><strong>CloudFront example:</strong></p>
<pre><code class="language-ruby"># Create CloudFront distribution pointing to S3 bucket
# Store assets in S3
# Configure:
config.action_controller.asset_host = &#39;https://d123456.cloudfront.net&#39;

# Benefits:
# ✅ Geographically distributed
# ✅ Lower latency
# ✅ Reduced server load
# ✅ Better caching
</code></pre>
<hr>
<h3>4. Fingerprinting and Caching</h3>
<p><strong>Long-term caching:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.assets.digest = true

# Generates fingerprinted names
# application.js → application-abc123def456.js

# Far-future expires headers
config.public_file_server.headers = {
  &#39;Cache-Control&#39; =&gt; &#39;public, max-age=31536000&#39;  # 1 year
}

# File change → new fingerprint → cache bust
</code></pre>
<hr>
<h3>5. Selective Precompilation</h3>
<p><strong>Only precompile what&#39;s needed:</strong></p>
<pre><code class="language-ruby"># config/initializers/assets.rb

# Don&#39;t precompile everything
config.assets.precompile = [
  &#39;application.js&#39;,
  &#39;application.css&#39;,
  &#39;admin.js&#39;,
  &#39;admin.css&#39;
]

# Exclude test/development files
config.assets.precompile += Dir.glob(&quot;#{Rails.root}/app/assets/images/**/*&quot;)
</code></pre>
<hr>
<h3>6. Lazy Loading</h3>
<p><strong>Load scripts only when needed:</strong></p>
<pre><code class="language-erb">&lt;!-- Don&#39;t load on every page --&gt;
&lt;% if controller_name == &#39;posts&#39; %&gt;
  &lt;%= javascript_include_tag &#39;posts&#39; %&gt;
&lt;% end %&gt;

&lt;% if action_name == &#39;edit&#39; %&gt;
  &lt;%= javascript_include_tag &#39;editor&#39; %&gt;
&lt;% end %&gt;
</code></pre>
<p><strong>Code splitting:</strong></p>
<pre><code class="language-javascript">// Load heavy libraries conditionally
if (document.querySelector(&#39;.chart&#39;)) {
  import(&#39;./chart.js&#39;).then(module =&gt; {
    module.renderChart();
  });
}
</code></pre>
<hr>
<h3>7. Image Optimization</h3>
<p><strong>Optimize images:</strong></p>
<pre><code class="language-bash"># Install image optimization gems
gem &#39;image_optim&#39;
gem &#39;image_optim_pack&#39;

# Compress images
rake image_optim:optimize

# Or use external tools:
# ImageOptim, TinyPNG, JPEGmini
</code></pre>
<p><strong>Responsive images:</strong></p>
<pre><code class="language-erb">&lt;!-- Serve appropriate size --&gt;
&lt;%= image_tag &#39;photo.jpg&#39;, 
    srcset: {
      &#39;photo-small.jpg&#39; =&gt; &#39;320w&#39;,
      &#39;photo-medium.jpg&#39; =&gt; &#39;768w&#39;,
      &#39;photo-large.jpg&#39; =&gt; &#39;1024w&#39;
    },
    sizes: &#39;(max-width: 768px) 100vw, 50vw&#39; %&gt;
</code></pre>
<p><strong>Lazy load images:</strong></p>
<pre><code class="language-html">&lt;!-- Native lazy loading --&gt;
&lt;img src=&quot;image.jpg&quot; loading=&quot;lazy&quot;&gt;

&lt;!-- Or with JavaScript --&gt;
&lt;img data-src=&quot;image.jpg&quot; class=&quot;lazyload&quot;&gt;
&lt;script&gt;
  // Lazy load when visible
  const lazyImages = document.querySelectorAll(&#39;.lazyload&#39;);
  const imageObserver = new IntersectionObserver((entries) =&gt; {
    entries.forEach(entry =&gt; {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        imageObserver.unobserve(img);
      }
    });
  });
  
  lazyImages.forEach(img =&gt; imageObserver.observe(img));
&lt;/script&gt;
</code></pre>
<hr>
<h3>8. Remove Unused Assets</h3>
<p><strong>Audit and remove:</strong></p>
<pre><code class="language-bash"># Find unused assets
# Check which files are actually included

# Remove unused:
# - Old JavaScript libraries
# - Unused CSS files
# - Duplicate images
</code></pre>
<p><strong>Tree shaking (with Webpack):</strong></p>
<pre><code class="language-javascript">// Import only what you use
import { debounce } from &#39;lodash&#39;;  // Only debounce
// Not: import _ from &#39;lodash&#39;;     // Entire library
</code></pre>
<hr>
<h3>9. Async/Defer Loading</h3>
<p><strong>Non-blocking scripts:</strong></p>
<pre><code class="language-erb">&lt;!-- Async - download parallel, execute ASAP --&gt;
&lt;%= javascript_include_tag &#39;application&#39;, async: true %&gt;

&lt;!-- Defer - download parallel, execute after parse --&gt;
&lt;%= javascript_include_tag &#39;application&#39;, defer: true %&gt;

&lt;!-- Generated: --&gt;
&lt;script src=&quot;/assets/application.js&quot; async&gt;&lt;/script&gt;
&lt;script src=&quot;/assets/application.js&quot; defer&gt;&lt;/script&gt;
</code></pre>
<hr>
<h3>10. Monitor Performance</h3>
<p><strong>Tools:</strong></p>
<pre><code class="language-ruby"># Lighthouse (Chrome DevTools)
# PageSpeed Insights
# WebPageTest
# GTmetrix

# Metrics to monitor:
# - First Contentful Paint
# - Largest Contentful Paint
# - Time to Interactive
# - Total Blocking Time
# - Cumulative Layout Shift
</code></pre>
<p><strong>Rails production logs:</strong></p>
<pre><code class="language-bash"># Check asset serving times
tail -f log/production.log | grep &quot;assets&quot;

# Identify slow assets
# Optimize them
</code></pre>
<hr>
<h3>Rails 7 Optimization</h3>
<p><strong>Import Maps (simpler):</strong></p>
<pre><code class="language-ruby"># No bundling, minification handled by HTTP/2
# Smaller individual files
# Better caching (change one file, others cached)
# Native ES modules

# Pin from CDN (already optimized)
./bin/importmap pin lodash
</code></pre>
<p><strong>propshaft (simple asset serving):</strong></p>
<pre><code class="language-ruby"># gem &#39;propshaft&#39;

# Only fingerprinting, no preprocessing
# Fast, simple
# Good for CSS/images
</code></pre>
<hr>
<h3>Performance Checklist</h3>
<pre><code class="language-ruby"># ✅ Optimization Checklist

# 1. Concatenation
☐ Combine CSS files
☐ Combine JavaScript files

# 2. Minification
☐ Minify JavaScript (UglifyJS)
☐ Minify CSS (sass-rails)

# 3. Compression
☐ Enable Gzip (Rack::Deflater)
☐ Precompressed assets (.gz)

# 4. CDN
☐ Configure asset host
☐ Use CloudFront/CloudFlare

# 5. Caching
☐ Fingerprinting enabled
☐ Far-future expires headers
☐ Browser caching configured

# 6. Images
☐ Optimize images (ImageOptim)
☐ Responsive images (srcset)
☐ Lazy loading (loading=&quot;lazy&quot;)
☐ WebP format where supported

# 7. Loading
☐ Async/defer scripts
☐ Code splitting
☐ Lazy load heavy libraries

# 8. Cleanup
☐ Remove unused assets
☐ Tree shaking
☐ Audit dependencies

# 9. Monitoring
☐ Lighthouse score &gt;90
☐ PageSpeed insights
☐ Production logs monitored

# 10. Modern approach
☐ Consider Import Maps
☐ Consider propshaft
☐ HTTP/2 enabled
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Concatenate</strong> files</li>
<li><strong>Minify</strong> code</li>
<li><strong>Compress</strong> with Gzip</li>
<li><strong>CDN</strong> for distribution</li>
<li><strong>Fingerprint</strong> for caching</li>
<li><strong>Optimize</strong> images</li>
<li><strong>Lazy load</strong> when possible</li>
<li><strong>Async/defer</strong> scripts</li>
<li><strong>Monitor</strong> performance</li>
<li><strong>Rails 7</strong> = simpler approach</li>
</ol>
<hr>
<h2>Question 152: How do you optimize Webpack and Import Maps for Rails?</h2>
<h3>Answer</h3>
<p><strong>Webpack optimization</strong>: code splitting, tree shaking, minification, caching. <strong>Import Maps optimization</strong>: CDN, HTTP/2, preload, selective imports. Choose based on app complexity.</p>
<hr>
<h3>Webpack Optimization (jsbundling-rails)</h3>
<p><strong>1. Code splitting:</strong></p>
<pre><code class="language-javascript">// Separate vendor code
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: &#39;all&#39;,
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: &#39;vendors&#39;,
          priority: 10
        },
        common: {
          minChunks: 2,
          priority: 5,
          reuseExistingChunk: true
        }
      }
    }
  }
};

// Results in:
// - application.js (your code)
// - vendors.js (npm packages)
// Cache vendors separately
</code></pre>
<p><strong>2. Tree shaking:</strong></p>
<pre><code class="language-javascript">// Import only what you use
import { debounce, throttle } from &#39;lodash&#39;;  // Only these functions

// Not:
import _ from &#39;lodash&#39;;  // Entire library (100KB+)

// Webpack removes unused code
</code></pre>
<p><strong>3. Minification:</strong></p>
<pre><code class="language-javascript">// webpack.config.js
const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);

module.exports = {
  mode: &#39;production&#39;,
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true  // Remove console.logs
          }
        }
      })
    ]
  }
};
</code></pre>
<p><strong>4. Lazy loading:</strong></p>
<pre><code class="language-javascript">// Load modules on demand
button.addEventListener(&#39;click&#39;, async () =&gt; {
  const module = await import(&#39;./heavy-module.js&#39;);
  module.doSomething();
});

// heavy-module.js loaded only when clicked
</code></pre>
<p><strong>5. Caching:</strong></p>
<pre><code class="language-javascript">// webpack.config.js
module.exports = {
  output: {
    filename: &#39;[name].[contenthash].js&#39;,
    chunkFilename: &#39;[name].[contenthash].chunk.js&#39;
  },
  optimization: {
    moduleIds: &#39;deterministic&#39;,
    runtimeChunk: &#39;single&#39;
  }
};

// Stable hashes for long-term caching
</code></pre>
<hr>
<h3>Import Maps Optimization</h3>
<p><strong>1. Use CDN:</strong></p>
<pre><code class="language-ruby"># config/importmap.rb

# ✅ Good - use CDN
pin &quot;lodash&quot;, to: &quot;https://ga.jspm.io/npm:lodash@4.17.21/lodash.js&quot;

# ❌ Slower - download and vendor
pin &quot;lodash&quot;, to: &quot;lodash.js&quot;
</code></pre>
<p><strong>2. Preload critical modules:</strong></p>
<pre><code class="language-ruby"># config/importmap.rb
pin &quot;application&quot;, preload: true  # Load immediately
pin &quot;@hotwired/turbo-rails&quot;, preload: true
pin &quot;@hotwired/stimulus&quot;, preload: true

pin &quot;lodash&quot;  # Load on demand
</code></pre>
<p><strong>3. HTTP/2:</strong></p>
<pre><code class="language-ruby"># Import Maps benefit from HTTP/2 multiplexing
# Many small files loaded in parallel
# No bundling needed

# Ensure server uses HTTP/2:
# - Heroku (automatic)
# - Nginx (http2 enabled)
# - CloudFlare (automatic)
</code></pre>
<p><strong>4. Selective imports:</strong></p>
<pre><code class="language-javascript">// Import specific functions (if library supports)
import { debounce } from &quot;lodash/debounce&quot;

// Not entire library
import _ from &quot;lodash&quot;
</code></pre>
<p><strong>5. Cache headers:</strong></p>
<pre><code class="language-ruby"># config/environments/production.rb
config.public_file_server.headers = {
  &#39;Cache-Control&#39; =&gt; &#39;public, max-age=31536000, immutable&#39;
}

# Long-term caching with fingerprints
</code></pre>
<hr>
<h3>Comparison: Webpack vs Import Maps</h3>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Webpack</th>
<th>Import Maps</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bundling</strong></td>
<td>Yes (combined)</td>
<td>No (separate)</td>
</tr>
<tr>
<td><strong>Tree shaking</strong></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Code splitting</strong></td>
<td>Advanced</td>
<td>Basic</td>
</tr>
<tr>
<td><strong>Minification</strong></td>
<td>Yes</td>
<td>No (CDN)</td>
</tr>
<tr>
<td><strong>Lazy loading</strong></td>
<td>Dynamic import</td>
<td>Same</td>
</tr>
<tr>
<td><strong>HTTP requests</strong></td>
<td>Few large</td>
<td>Many small</td>
</tr>
<tr>
<td><strong>Build time</strong></td>
<td>Slow</td>
<td>None</td>
</tr>
<tr>
<td><strong>Complexity</strong></td>
<td>High</td>
<td>Low</td>
</tr>
<tr>
<td><strong>Best for</strong></td>
<td>Complex apps</td>
<td>Simple apps</td>
</tr>
</tbody></table>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use Webpack when:</strong></p>
<pre><code class="language-ruby">✅ Complex JavaScript app
✅ Need tree shaking
✅ Many dependencies
✅ Advanced optimizations
✅ Older browser support
✅ Custom transformations

Example: React/Vue SPA with Rails API
</code></pre>
<p><strong>Use Import Maps when:</strong></p>
<pre><code class="language-ruby">✅ Simple to moderate JS
✅ Modern browsers only
✅ Hotwire/Turbo/Stimulus
✅ Want simplicity
✅ Fast development
✅ Standard Rails app

Example: Traditional Rails CRUD with Hotwire
</code></pre>
<hr>
<h3>Hybrid Approach</h3>
<p><strong>Import Maps for app code, CDN for libraries:</strong></p>
<pre><code class="language-ruby"># config/importmap.rb

# App code (vendored)
pin &quot;application&quot;, preload: true
pin_all_from &quot;app/javascript/controllers&quot;, under: &quot;controllers&quot;

# Libraries (CDN)
pin &quot;lodash&quot;, to: &quot;https://cdn.skypack.dev/lodash@4.17.21&quot;
pin &quot;alpinejs&quot;, to: &quot;https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js&quot;

# Best of both worlds
</code></pre>
<hr>
<h3>Performance Monitoring</h3>
<p><strong>Tools:</strong></p>
<pre><code class="language-bash"># Webpack Bundle Analyzer
npm install --save-dev webpack-bundle-analyzer

# webpack.config.js
const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
};

# Shows bundle composition, size, duplicates
</code></pre>
<p><strong>Import Maps monitoring:</strong></p>
<pre><code class="language-javascript">// Track import times
performance.mark(&#39;imports-start&#39;);
import(&#39;./module.js&#39;).then(() =&gt; {
  performance.mark(&#39;imports-end&#39;);
  performance.measure(&#39;imports&#39;, &#39;imports-start&#39;, &#39;imports-end&#39;);
  const measure = performance.getEntriesByName(&#39;imports&#39;)[0];
  console.log(`Import took ${measure.duration}ms`);
});
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Webpack</strong> = build-time optimization</li>
<li><strong>Import Maps</strong> = runtime optimization</li>
<li><strong>Webpack</strong> for complex apps</li>
<li><strong>Import Maps</strong> for simple apps</li>
<li><strong>Code splitting</strong> reduces initial load</li>
<li><strong>Tree shaking</strong> removes unused code</li>
<li><strong>HTTP/2</strong> helps Import Maps</li>
<li><strong>CDN</strong> critical for Import Maps</li>
<li><strong>Monitor</strong> bundle sizes</li>
<li><strong>Choose</strong> based on needs</li>
</ol>
<hr>
<h2>Question 153: What is <code>try</code> vs <code>begin rescue</code>?</h2>
<h3>Answer</h3>
<p><strong><code>try</code></strong> safely calls methods that might not exist (returns nil). <strong><code>begin rescue</code></strong> handles exceptions with full control. try = convenience for nil/undefined, begin rescue = exception handling.</p>
<hr>
<h3>try Method</h3>
<p><strong>Safe method calls:</strong></p>
<pre><code class="language-ruby"># Without try
user = User.find_by(id: params[:id])
if user &amp;&amp; user.admin?
  # Do something
end

# With try
user = User.find_by(id: params[:id])
if user.try(:admin?)
  # Do something
end

# If user is nil, try returns nil (no error)
# If user exists, try calls admin?
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code class="language-ruby"># Safe navigation
nil.try(:upcase)           # =&gt; nil (no error)
&quot;hello&quot;.try(:upcase)       # =&gt; &quot;HELLO&quot;

# Method doesn&#39;t exist
user.try(:non_existent)    # =&gt; nil (no error)

# With arguments
user.try(:update, name: &quot;Alice&quot;)

# With block
user.try { |u| u.posts.count }

# try! raises if method doesn&#39;t exist
nil.try!(:upcase)          # =&gt; nil
user.try!(:non_existent)   # =&gt; NoMethodError
</code></pre>
<hr>
<h3>begin rescue</h3>
<p><strong>Exception handling:</strong></p>
<pre><code class="language-ruby">begin
  # Code that might raise exception
  result = 10 / 0
rescue ZeroDivisionError =&gt; e
  # Handle specific exception
  puts &quot;Cannot divide by zero: #{e.message}&quot;
rescue StandardError =&gt; e
  # Handle other exceptions
  puts &quot;Error: #{e.message}&quot;
ensure
  # Always runs (cleanup)
  puts &quot;Finished&quot;
end
</code></pre>
<p><strong>Multiple rescue blocks:</strong></p>
<pre><code class="language-ruby">begin
  User.find(params[:id])
rescue ActiveRecord::RecordNotFound
  redirect_to users_path, alert: &quot;User not found&quot;
rescue ActiveRecord::RecordInvalid =&gt; e
  render :new, alert: e.message
rescue StandardError =&gt; e
  Rails.logger.error e.message
  render :error
end
</code></pre>
<p><strong>Inline rescue:</strong></p>
<pre><code class="language-ruby"># Short form
result = 10 / 0 rescue &quot;Error&quot;  # =&gt; &quot;Error&quot;

value = params[:count].to_i rescue 0

# Use sparingly (hard to read)
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>try</th>
<th>begin rescue</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Purpose</strong></td>
<td>Safe method call</td>
<td>Exception handling</td>
</tr>
<tr>
<td><strong>Returns</strong></td>
<td>nil if no method</td>
<td>Rescue block result</td>
</tr>
<tr>
<td><strong>Exceptions</strong></td>
<td>NoMethodError only</td>
<td>Any exception</td>
</tr>
<tr>
<td><strong>Control</strong></td>
<td>Limited</td>
<td>Full control</td>
</tr>
<tr>
<td><strong>Use case</strong></td>
<td>Nil checking</td>
<td>Error handling</td>
</tr>
</tbody></table>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use try when:</strong></p>
<pre><code class="language-ruby"># Nil checking
@user.try(:name)
@post.try(:author).try(:email)

# Optional method calls
user.try(:notify_welcome) if user

# View helpers
&lt;%= @user.try(:formatted_name) || &quot;Guest&quot; %&gt;

# Short nil chains
@comment.try(:post).try(:user).try(:name)
</code></pre>
<p><strong>Use begin rescue when:</strong></p>
<pre><code class="language-ruby"># Exception handling
begin
  payment.process!
rescue PaymentError =&gt; e
  handle_payment_failure(e)
end

# Resource cleanup
begin
  file = File.open(&#39;data.txt&#39;)
  process(file)
ensure
  file.close if file
end

# Specific error handling
begin
  API.call
rescue Timeout::Error
  retry_later
rescue NetworkError
  use_cache
end

# Multiple exception types
begin
  operation
rescue TypeA, TypeB =&gt; e
  handle_both
end
</code></pre>
<hr>
<h3>Modern Alternative: Safe Navigation Operator</h3>
<p><strong>&amp;. operator (Ruby 2.3+):</strong></p>
<pre><code class="language-ruby"># Instead of try
user = User.find_by(id: 1)
name = user.try(:name)

# Use safe navigation
name = user&amp;.name

# Chaining
email = user&amp;.profile&amp;.email

# Works with any method
user&amp;.posts&amp;.first&amp;.title

# Returns nil if any part is nil
</code></pre>
<p><strong>Comparison:</strong></p>
<pre><code class="language-ruby"># try
user.try(:posts).try(:count)

# &amp;.
user&amp;.posts&amp;.count

# &amp; is shorter, cleaner, standard Ruby
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>try example:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    @author_name = @post.try(:author).try(:name) || &quot;Unknown&quot;
  end
end

# View
&lt;%= @post.try(:formatted_date) || Time.current %&gt;
</code></pre>
<p><strong>begin rescue example:</strong></p>
<pre><code class="language-ruby">class PaymentsController &lt; ApplicationController
  def create
    @payment = Payment.new(payment_params)
    
    begin
      @payment.process!
      redirect_to @payment, notice: &quot;Payment successful&quot;
    rescue PaymentGatewayError =&gt; e
      Rails.logger.error &quot;Payment failed: #{e.message}&quot;
      Sentry.capture_exception(e)
      
      flash.now[:alert] = &quot;Payment failed: #{e.message}&quot;
      render :new
    rescue NetworkError
      flash.now[:alert] = &quot;Network error. Please try again.&quot;
      render :new
    ensure
      @payment.log_attempt
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>try</strong> for safe method calls</li>
<li><strong>begin rescue</strong> for exceptions</li>
<li><strong>try</strong> returns nil</li>
<li><strong>begin rescue</strong> handles errors</li>
<li><strong>&amp;.</strong> preferred over try</li>
<li><strong>rescue</strong> for error recovery</li>
<li><strong>ensure</strong> for cleanup</li>
<li><strong>Multiple rescue</strong> blocks</li>
<li><strong>Inline rescue</strong> sparingly</li>
<li><strong>Choose</strong> based on need</li>
</ol>
<hr>
<h2>Question 154: How do you handle exceptions in Rails?</h2>
<h3>Answer</h3>
<p>Handle exceptions through <strong>rescue_from</strong>, <strong>custom error pages</strong>, <strong>exception notifications</strong>, <strong>logging</strong>, and <strong>user-friendly messages</strong>. Catch errors at application or controller level, log for debugging, show appropriate responses.</p>
<hr>
<h3>Application-Level Handling</h3>
<p><strong>ApplicationController rescue_from:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  rescue_from ActiveRecord::RecordNotFound, with: :not_found
  rescue_from ActionController::ParameterMissing, with: :bad_request
  rescue_from CanCan::AccessDenied, with: :forbidden
  rescue_from StandardError, with: :internal_error
  
  private
  
  def not_found
    respond_to do |format|
      format.html { render file: &quot;#{Rails.root}/public/404.html&quot;, status: :not_found }
      format.json { render json: { error: &#39;Not found&#39; }, status: :not_found }
    end
  end
  
  def bad_request
    respond_to do |format|
      format.html { render file: &quot;#{Rails.root}/public/400.html&quot;, status: :bad_request }
      format.json { render json: { error: &#39;Bad request&#39; }, status: :bad_request }
    end
  end
  
  def forbidden
    respond_to do |format|
      format.html { render file: &quot;#{Rails.root}/public/403.html&quot;, status: :forbidden }
      format.json { render json: { error: &#39;Forbidden&#39; }, status: :forbidden }
    end
  end
  
  def internal_error(exception)
    Rails.logger.error &quot;Internal Error: #{exception.message}&quot;
    Rails.logger.error exception.backtrace.join(&quot;\n&quot;)
    
    # Notify error tracking service
    Sentry.capture_exception(exception) if Rails.env.production?
    
    respond_to do |format|
      format.html { render file: &quot;#{Rails.root}/public/500.html&quot;, status: :internal_server_error }
      format.json { render json: { error: &#39;Internal server error&#39; }, status: :internal_server_error }
    end
  end
end
</code></pre>
<hr>
<h3>Controller-Level Handling</h3>
<p><strong>Specific controller rescue:</strong></p>
<pre><code class="language-ruby">class PostsController &lt; ApplicationController
  rescue_from Post::PublishError, with: :handle_publish_error
  
  def publish
    @post = Post.find(params[:id])
    @post.publish!
    redirect_to @post
  end
  
  private
  
  def handle_publish_error(exception)
    @post = Post.find(params[:id])
    flash.now[:alert] = &quot;Cannot publish: #{exception.message}&quot;
    render :show
  end
end
</code></pre>
<hr>
<h3>Custom Error Pages</h3>
<p><strong>Static error pages:</strong></p>
<pre><code class="language-html">&lt;!-- public/404.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Page Not Found (404)&lt;/title&gt;
  &lt;style&gt;
    body { text-align: center; padding: 50px; }
    h1 { font-size: 50px; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;404&lt;/h1&gt;
  &lt;h2&gt;Page Not Found&lt;/h2&gt;
  &lt;p&gt;The page you requested does not exist.&lt;/p&gt;
  &lt;a href=&quot;/&quot;&gt;Go Home&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Dynamic error pages:</strong></p>
<pre><code class="language-ruby"># config/routes.rb
match &#39;/404&#39;, to: &#39;errors#not_found&#39;, via: :all
match &#39;/500&#39;, to: &#39;errors#internal_error&#39;, via: :all

# app/controllers/errors_controller.rb
class ErrorsController &lt; ApplicationController
  def not_found
    render status: :not_found
  end
  
  def internal_error
    render status: :internal_server_error
  end
end

# config/application.rb
config.exceptions_app = self.routes
</code></pre>
<hr>
<h3>Exception Notification</h3>
<p><strong>Email notifications:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;exception_notification&#39;

# config/initializers/exception_notification.rb
Rails.application.config.middleware.use ExceptionNotification::Rack,
  email: {
    deliver_with: :deliver_later,
    email_prefix: &#39;[ERROR] &#39;,
    sender_address: %{&quot;Exception Notifier&quot; &lt;errors@myapp.com&gt;},
    exception_recipients: %w[admin@myapp.com]
  }
</code></pre>
<p><strong>Sentry (recommended):</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;sentry-ruby&#39;
gem &#39;sentry-rails&#39;

# config/initializers/sentry.rb
Sentry.init do |config|
  config.dsn = ENV[&#39;SENTRY_DSN&#39;]
  config.breadcrumbs_logger = [:active_support_logger, :http_logger]
  config.environment = Rails.env
  config.enabled_environments = %w[production staging]
  
  # Sample rate
  config.traces_sample_rate = 0.5  # 50% of transactions
  
  # Ignore certain errors
  config.excluded_exceptions += [&#39;ActionController::RoutingError&#39;]
end

# Usage:
begin
  risky_operation
rescue StandardError =&gt; e
  Sentry.capture_exception(e)
  raise
end
</code></pre>
<hr>
<h3>Logging</h3>
<p><strong>Rails logger:</strong></p>
<pre><code class="language-ruby">class ApplicationController &lt; ActionController::Base
  rescue_from StandardError do |exception|
    # Log error
    Rails.logger.error &quot;Error: #{exception.class} - #{exception.message}&quot;
    Rails.logger.error exception.backtrace.join(&quot;\n&quot;)
    
    # Log with context
    Rails.logger.error({
      exception: exception.class.name,
      message: exception.message,
      user_id: current_user&amp;.id,
      params: params.to_unsafe_h,
      url: request.url
    }.to_json)
    
    render :error, status: :internal_server_error
  end
end
</code></pre>
<p><strong>Custom logger:</strong></p>
<pre><code class="language-ruby"># config/initializers/error_logger.rb
class ErrorLogger
  def self.log(exception, context = {})
    Rails.logger.error({
      timestamp: Time.current.iso8601,
      exception: exception.class.name,
      message: exception.message,
      backtrace: exception.backtrace.first(10),
      context: context
    }.to_json)
  end
end

# Usage:
ErrorLogger.log(exception, {
  user_id: current_user.id,
  action: action_name,
  controller: controller_name
})
</code></pre>
<hr>
<h3>API Error Responses</h3>
<p><strong>Consistent error format:</strong></p>
<pre><code class="language-ruby"># app/controllers/api/base_controller.rb
class Api::BaseController &lt; ApplicationController
  rescue_from ActiveRecord::RecordNotFound, with: :not_found
  rescue_from ActiveRecord::RecordInvalid, with: :unprocessable_entity
  rescue_from ActionController::ParameterMissing, with: :bad_request
  
  private
  
  def not_found(exception)
    render json: {
      error: {
        code: &#39;not_found&#39;,
        message: exception.message
      }
    }, status: :not_found
  end
  
  def unprocessable_entity(exception)
    render json: {
      error: {
        code: &#39;validation_failed&#39;,
        message: exception.message,
        details: exception.record.errors.messages
      }
    }, status: :unprocessable_entity
  end
  
  def bad_request(exception)
    render json: {
      error: {
        code: &#39;bad_request&#39;,
        message: exception.message
      }
    }, status: :bad_request
  end
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Specific before general:</strong></p>
<pre><code class="language-ruby">rescue_from ActiveRecord::RecordNotFound, with: :not_found
rescue_from ActiveRecord::RecordInvalid, with: :invalid_record
rescue_from StandardError, with: :internal_error  # Catch-all last
</code></pre>
<p><strong>2. Don&#39;t swallow exceptions:</strong></p>
<pre><code class="language-ruby"># ❌ Bad - hides errors
begin
  risky_operation
rescue
  # Silent failure
end

# ✅ Good - log and handle
begin
  risky_operation
rescue StandardError =&gt; e
  Rails.logger.error e.message
  Sentry.capture_exception(e)
  render :error
end
</code></pre>
<p><strong>3. User-friendly messages:</strong></p>
<pre><code class="language-ruby"># ❌ Bad - technical message
&quot;ActiveRecord::RecordNotFound: Couldn&#39;t find User with &#39;id&#39;=123&quot;

# ✅ Good - user-friendly
&quot;User not found. They may have been deleted.&quot;
</code></pre>
<p><strong>4. Clean up resources:</strong></p>
<pre><code class="language-ruby">file = File.open(&#39;data.txt&#39;)
begin
  process(file)
ensure
  file.close  # Always close
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>rescue_from</strong> for common exceptions</li>
<li><strong>Application-level</strong> for global handling</li>
<li><strong>Controller-level</strong> for specific</li>
<li><strong>Custom error</strong> pages</li>
<li><strong>Log</strong> all exceptions</li>
<li><strong>Notify</strong> critical errors (Sentry)</li>
<li><strong>User-friendly</strong> messages</li>
<li><strong>API errors</strong> consistently</li>
<li><strong>Don&#39;t swallow</strong> exceptions</li>
<li><strong>Clean up</strong> resources</li>
</ol>
<h1>SQL and Database Interview Questions</h1>
<h2>SQL Joins</h2>
<h3>Question 155: What are the different types of SQL joins?</h3>
<h3>Answer</h3>
<p>SQL has <strong>six main join types</strong>: <strong>INNER JOIN</strong>, <strong>LEFT JOIN</strong> (LEFT OUTER), <strong>RIGHT JOIN</strong> (RIGHT OUTER), <strong>FULL JOIN</strong> (FULL OUTER), <strong>CROSS JOIN</strong>, and <strong>SELF JOIN</strong>. Each combines rows from two or more tables differently.</p>
<hr>
<h3>Join Types Overview</h3>
<pre><code class="language-sql">-- Sample Tables
Users (id, name)
1, Alice
2, Bob
3, Charlie

Posts (id, user_id, title)
1, 1, &#39;Post A&#39;
2, 1, &#39;Post B&#39;
3, 2, &#39;Post C&#39;
4, 99, &#39;Orphan Post&#39;  -- No matching user
</code></pre>
<p><strong>1. INNER JOIN</strong> - Only matching rows</p>
<pre><code class="language-sql">SELECT users.name, posts.title
FROM users
INNER JOIN posts ON users.id = posts.user_id;

-- Result:
Alice, Post A
Alice, Post B
Bob, Post C
-- Charlie excluded (no posts)
-- Orphan Post excluded (no user)
</code></pre>
<p><strong>2. LEFT JOIN</strong> - All left table + matching right</p>
<pre><code class="language-sql">SELECT users.name, posts.title
FROM users
LEFT JOIN posts ON users.id = posts.user_id;

-- Result:
Alice, Post A
Alice, Post B
Bob, Post C
Charlie, NULL  -- Charlie included with NULL
-- Orphan Post excluded
</code></pre>
<p><strong>3. RIGHT JOIN</strong> - All right table + matching left</p>
<pre><code class="language-sql">SELECT users.name, posts.title
FROM users
RIGHT JOIN posts ON users.id = posts.user_id;

-- Result:
Alice, Post A
Alice, Post B
Bob, Post C
NULL, Orphan Post  -- Orphan included with NULL
-- Charlie excluded
</code></pre>
<p><strong>4. FULL JOIN</strong> - All rows from both tables</p>
<pre><code class="language-sql">SELECT users.name, posts.title
FROM users
FULL OUTER JOIN posts ON users.id = posts.user_id;

-- Result:
Alice, Post A
Alice, Post B
Bob, Post C
Charlie, NULL       -- Charlie included
NULL, Orphan Post   -- Orphan included
</code></pre>
<p><strong>5. CROSS JOIN</strong> - Cartesian product</p>
<pre><code class="language-sql">SELECT users.name, posts.title
FROM users
CROSS JOIN posts;

-- Result: Every user with every post
-- 3 users × 4 posts = 12 rows
Alice, Post A
Alice, Post B
Alice, Post C
Alice, Orphan Post
Bob, Post A
Bob, Post B
... (12 total)
</code></pre>
<p><strong>6. SELF JOIN</strong> - Table joined with itself</p>
<pre><code class="language-sql">-- Employees table (id, name, manager_id)
SELECT e.name AS employee, m.name AS manager
FROM employees e
JOIN employees m ON e.manager_id = m.id;
</code></pre>
<hr>
<h3>Visual Representation</h3>
<pre><code>Tables:
┌────────────┐         ┌────────────┐
│   Users    │         │   Posts    │
├────────────┤         ├────────────┤
│ 1, Alice   │────┐    │ 1, 1, &#39;A&#39;  │
│ 2, Bob     │────┼───→│ 2, 1, &#39;B&#39;  │
│ 3, Charlie │    │    │ 3, 2, &#39;C&#39;  │
└────────────┘    │    │ 4, 99, &#39;D&#39; │
                  │    └────────────┘
                  │
            Matching on id = user_id

INNER JOIN:
┌─────────────────┐
│  Only Matches   │
│  Alice → A, B   │
│  Bob → C        │
└─────────────────┘

LEFT JOIN:
┌─────────────────┐
│  All Users      │
│  Alice → A, B   │
│  Bob → C        │
│  Charlie → NULL │
└─────────────────┘

RIGHT JOIN:
┌─────────────────┐
│  All Posts      │
│  Alice → A, B   │
│  Bob → C        │
│  NULL → D       │
└─────────────────┘

FULL JOIN:
┌─────────────────┐
│  Everything     │
│  Alice → A, B   │
│  Bob → C        │
│  Charlie → NULL │
│  NULL → D       │
└─────────────────┘
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>INNER JOIN</strong> - only matches</li>
<li><strong>LEFT JOIN</strong> - all left + matches</li>
<li><strong>RIGHT JOIN</strong> - all right + matches</li>
<li><strong>FULL JOIN</strong> - everything</li>
<li><strong>CROSS JOIN</strong> - all combinations</li>
<li><strong>SELF JOIN</strong> - table with itself</li>
<li><strong>INNER</strong> most restrictive</li>
<li><strong>FULL</strong> least restrictive</li>
<li><strong>Choose</strong> based on requirements</li>
<li><strong>Understand</strong> NULL handling</li>
</ol>
<hr>
<h2>Question 156: What is the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL JOIN?</h2>
<h3>Answer</h3>
<p><strong>INNER JOIN</strong> returns only matching rows. <strong>LEFT JOIN</strong> returns all left table rows + matches. <strong>RIGHT JOIN</strong> returns all right table rows + matches. <strong>FULL JOIN</strong> returns all rows from both tables.</p>
<hr>
<h3>Detailed Comparison</h3>
<p><strong>Sample Data:</strong></p>
<pre><code class="language-sql">-- customers table
id | name     | city
1  | Alice    | NYC
2  | Bob      | LA
3  | Charlie  | SF

-- orders table
id | customer_id | product
1  | 1           | Laptop
2  | 1           | Mouse
3  | 2           | Keyboard
4  | 99          | Orphan Order
</code></pre>
<hr>
<h3>INNER JOIN</h3>
<p><strong>Only rows with matches in both tables:</strong></p>
<pre><code class="language-sql">SELECT customers.name, orders.product
FROM customers
INNER JOIN orders ON customers.id = orders.customer_id;

-- Result (3 rows):
Alice, Laptop
Alice, Mouse
Bob, Keyboard

-- Excluded:
-- Charlie (no orders)
-- Orphan Order (no customer)
</code></pre>
<p><strong>Use when:</strong> You only want records that exist in both tables</p>
<p><strong>Rails ActiveRecord:</strong></p>
<pre><code class="language-ruby">Customer.joins(:orders)
# SELECT customers.* 
# FROM customers 
# INNER JOIN orders ON orders.customer_id = customers.id
</code></pre>
<hr>
<h3>LEFT JOIN (LEFT OUTER JOIN)</h3>
<p><strong>All rows from left table + matching right table:</strong></p>
<pre><code class="language-sql">SELECT customers.name, orders.product
FROM customers
LEFT JOIN orders ON customers.id = orders.customer_id;

-- Result (4 rows):
Alice, Laptop
Alice, Mouse
Bob, Keyboard
Charlie, NULL    -- Charlie kept, no orders

-- Excluded:
-- Orphan Order (not in customers)
</code></pre>
<p><strong>Use when:</strong> You want all records from the primary table, even if no matches</p>
<p><strong>Rails ActiveRecord:</strong></p>
<pre><code class="language-ruby">Customer.left_joins(:orders)
# SELECT customers.* 
# FROM customers 
# LEFT OUTER JOIN orders ON orders.customer_id = customers.id
</code></pre>
<hr>
<h3>RIGHT JOIN (RIGHT OUTER JOIN)</h3>
<p><strong>All rows from right table + matching left table:</strong></p>
<pre><code class="language-sql">SELECT customers.name, orders.product
FROM customers
RIGHT JOIN orders ON customers.id = orders.customer_id;

-- Result (4 rows):
Alice, Laptop
Alice, Mouse
Bob, Keyboard
NULL, Orphan Order    -- Orphan kept, no customer

-- Excluded:
-- Charlie (no orders)
</code></pre>
<p><strong>Use when:</strong> You want all records from the secondary table</p>
<p><strong>Note:</strong> Less common than LEFT JOIN. Usually restructured as LEFT JOIN</p>
<pre><code class="language-sql">-- RIGHT JOIN
SELECT customers.name, orders.product
FROM customers
RIGHT JOIN orders ON customers.id = orders.customer_id;

-- Equivalent LEFT JOIN (preferred)
SELECT customers.name, orders.product
FROM orders
LEFT JOIN customers ON customers.id = orders.customer_id;
</code></pre>
<hr>
<h3>FULL JOIN (FULL OUTER JOIN)</h3>
<p><strong>All rows from both tables:</strong></p>
<pre><code class="language-sql">SELECT customers.name, orders.product
FROM customers
FULL OUTER JOIN orders ON customers.id = orders.customer_id;

-- Result (5 rows):
Alice, Laptop
Alice, Mouse
Bob, Keyboard
Charlie, NULL        -- No orders
NULL, Orphan Order   -- No customer

-- Nothing excluded
</code></pre>
<p><strong>Use when:</strong> You want complete dataset, including unmatched records</p>
<p><strong>PostgreSQL only</strong> (not MySQL):</p>
<pre><code class="language-ruby"># Raw SQL
Customer.connection.execute(&lt;&lt;-SQL)
  SELECT customers.name, orders.product
  FROM customers
  FULL OUTER JOIN orders ON customers.id = orders.customer_id
SQL

# MySQL workaround: UNION of LEFT and RIGHT
SELECT customers.name, orders.product
FROM customers
LEFT JOIN orders ON customers.id = orders.customer_id
UNION
SELECT customers.name, orders.product
FROM customers
RIGHT JOIN orders ON customers.id = orders.customer_id;
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Join Type</th>
<th>Left Unmatched</th>
<th>Right Unmatched</th>
<th>Only Matches</th>
</tr>
</thead>
<tbody><tr>
<td><strong>INNER</strong></td>
<td>❌ Excluded</td>
<td>❌ Excluded</td>
<td>✅ Yes</td>
</tr>
<tr>
<td><strong>LEFT</strong></td>
<td>✅ Included</td>
<td>❌ Excluded</td>
<td>✅ Yes</td>
</tr>
<tr>
<td><strong>RIGHT</strong></td>
<td>❌ Excluded</td>
<td>✅ Included</td>
<td>✅ Yes</td>
</tr>
<tr>
<td><strong>FULL</strong></td>
<td>✅ Included</td>
<td>✅ Included</td>
<td>✅ Yes</td>
</tr>
</tbody></table>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Users and their posts:</strong></p>
<pre><code class="language-sql">-- INNER JOIN: Only users who have posts
SELECT users.name, COUNT(posts.id) as post_count
FROM users
INNER JOIN posts ON users.id = posts.user_id
GROUP BY users.name;

-- LEFT JOIN: All users, including those with no posts
SELECT users.name, COUNT(posts.id) as post_count
FROM users
LEFT JOIN posts ON users.id = posts.user_id
GROUP BY users.name;
-- Shows: Alice (5), Bob (0), Charlie (0)
</code></pre>
<p><strong>2. Products and orders:</strong></p>
<pre><code class="language-sql">-- Find all products and their order count (including unsold)
SELECT 
  products.name,
  COUNT(order_items.id) as times_ordered
FROM products
LEFT JOIN order_items ON products.id = order_items.product_id
GROUP BY products.name
ORDER BY times_ordered DESC;
</code></pre>
<p><strong>3. Missing relationships:</strong></p>
<pre><code class="language-sql">-- Find customers with no orders (LEFT JOIN with NULL check)
SELECT customers.name
FROM customers
LEFT JOIN orders ON customers.id = orders.customer_id
WHERE orders.id IS NULL;

-- Find orphaned orders (RIGHT JOIN with NULL check)
SELECT orders.id
FROM customers
RIGHT JOIN orders ON customers.id = orders.customer_id
WHERE customers.id IS NULL;
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-sql">-- INNER JOIN usually fastest (smallest result set)
-- LEFT/RIGHT JOIN slower (more rows)
-- FULL JOIN slowest (most rows, complex operation)

-- Index on join columns critical:
CREATE INDEX idx_orders_customer_id ON orders(customer_id);
CREATE INDEX idx_customers_id ON customers(id);
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>INNER</strong> - only matches, smallest result</li>
<li><strong>LEFT</strong> - all left + matches, most common</li>
<li><strong>RIGHT</strong> - all right + matches, rare</li>
<li><strong>FULL</strong> - everything, PostgreSQL only</li>
<li><strong>LEFT</strong> most useful in practice</li>
<li><strong>NULL</strong> for unmatched rows</li>
<li><strong>INNER</strong> fastest performance</li>
<li><strong>Index</strong> join columns</li>
<li><strong>FULL</strong> = LEFT UNION RIGHT</li>
<li><strong>Choose</strong> based on data needs</li>
</ol>
<hr>
<h2>Question 157: What is the difference between INNER JOIN and OUTER JOIN?</h2>
<h3>Answer</h3>
<p><strong>INNER JOIN</strong> returns only matching rows from both tables. <strong>OUTER JOIN</strong> (LEFT/RIGHT/FULL) returns matching rows plus unmatched rows from one or both tables, with NULLs for missing data.</p>
<hr>
<h3>Core Difference</h3>
<pre><code class="language-sql">-- Sample data:
users: 1-Alice, 2-Bob, 3-Charlie
orders: 1 (user_id: 1), 2 (user_id: 1), 3 (user_id: 99)

-- INNER JOIN - Only matches
SELECT users.name, orders.id
FROM users
INNER JOIN orders ON users.id = orders.user_id;

Result:
Alice, 1
Alice, 2
-- Charlie excluded (no orders)
-- Order 3 excluded (no user)

-- OUTER JOIN (LEFT) - All left + matches
SELECT users.name, orders.id
FROM users
LEFT OUTER JOIN orders ON users.id = orders.user_id;

Result:
Alice, 1
Alice, 2
Charlie, NULL  -- Charlie included with NULL
-- Order 3 still excluded (LEFT only)
</code></pre>
<hr>
<h3>INNER JOIN Characteristics</h3>
<pre><code class="language-sql">-- Only rows where join condition matches
-- No NULL values from join
-- Smallest result set
-- Fastest performance

SELECT *
FROM table_a
INNER JOIN table_b ON table_a.id = table_b.foreign_id;

-- Equivalent to:
SELECT *
FROM table_a, table_b
WHERE table_a.id = table_b.foreign_id;
</code></pre>
<hr>
<h3>OUTER JOIN Types</h3>
<p><strong>1. LEFT OUTER JOIN:</strong></p>
<pre><code class="language-sql">-- All rows from left table
-- Matching rows from right table
-- NULLs for unmatched right rows

SELECT users.name, posts.title
FROM users
LEFT OUTER JOIN posts ON users.id = posts.user_id;

-- Users without posts: name with NULL title
</code></pre>
<p><strong>2. RIGHT OUTER JOIN:</strong></p>
<pre><code class="language-sql">-- All rows from right table
-- Matching rows from left table
-- NULLs for unmatched left rows

SELECT users.name, posts.title
FROM users
RIGHT OUTER JOIN posts ON users.id = posts.user_id;

-- Posts without users: NULL name with title
</code></pre>
<p><strong>3. FULL OUTER JOIN:</strong></p>
<pre><code class="language-sql">-- All rows from both tables
-- NULLs where no match

SELECT users.name, posts.title
FROM users
FULL OUTER JOIN posts ON users.id = posts.user_id;

-- Both unmatched users and posts included
</code></pre>
<hr>
<h3>Visual Comparison</h3>
<pre><code>Dataset:
Left Table (A): 1, 2, 3
Right Table (B): 2, 3, 4
Join Condition: A.id = B.id

INNER JOIN (only matches):
┌───────┐
│   2   │
│   3   │
└───────┘
Result: 2, 3

LEFT OUTER JOIN (all left + matches):
┌───────┐
│   1   │ ← NULL for B
│   2   │ ← Matched
│   3   │ ← Matched
└───────┘
Result: 1 (NULL), 2, 3

RIGHT OUTER JOIN (all right + matches):
┌───────┐
│   2   │ ← Matched
│   3   │ ← Matched
│   4   │ ← NULL for A
└───────┘
Result: 2, 3, 4 (NULL)

FULL OUTER JOIN (everything):
┌───────┐
│   1   │ ← NULL for B
│   2   │ ← Matched
│   3   │ ← Matched
│   4   │ ← NULL for A
└───────┘
Result: 1 (NULL), 2, 3, 4 (NULL)
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use INNER JOIN when:</strong></p>
<pre><code class="language-sql">-- You only want confirmed relationships
-- Missing data should be excluded
-- Performance is critical

-- Example: Get users who have placed orders
SELECT users.name, COUNT(orders.id) as order_count
FROM users
INNER JOIN orders ON users.id = orders.customer_id
GROUP BY users.name;
-- Only users with orders appear
</code></pre>
<p><strong>Use OUTER JOIN when:</strong></p>
<pre><code class="language-sql">-- You want all records from primary table
-- Missing relationships should show as NULL
-- You need to find missing relationships

-- Example: Get all users, including those without orders
SELECT users.name, COUNT(orders.id) as order_count
FROM users
LEFT OUTER JOIN orders ON users.id = orders.customer_id
GROUP BY users.name;
-- All users appear: Alice (5), Bob (0), Charlie (0)
</code></pre>
<hr>
<h3>Finding Missing Relationships</h3>
<p><strong>Using OUTER JOIN:</strong></p>
<pre><code class="language-sql">-- Find users with no orders
SELECT users.name
FROM users
LEFT JOIN orders ON users.id = orders.customer_id
WHERE orders.id IS NULL;

-- Find orders without valid customers
SELECT orders.id
FROM orders
LEFT JOIN users ON orders.customer_id = users.id
WHERE users.id IS NULL;
</code></pre>
<hr>
<h3>Performance Impact</h3>
<pre><code class="language-sql">-- INNER JOIN
-- ✅ Usually fastest
-- ✅ Smaller result set
-- ✅ Simple execution plan

-- OUTER JOIN
-- ⚠️  Slower than INNER
-- ⚠️  Larger result set
-- ⚠️  More complex execution plan
-- ⚠️  Must handle NULLs

-- Optimization:
-- 1. Index join columns
-- 2. Filter early (WHERE before JOIN)
-- 3. Use INNER when possible
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># INNER JOIN
User.joins(:posts)
# Only users with posts

# LEFT OUTER JOIN
User.left_joins(:posts)
# All users, even without posts

# Find users without posts
User.left_joins(:posts).where(posts: { id: nil })

# Count posts per user (including zero)
User.left_joins(:posts)
    .group(:id)
    .select(&#39;users.*, COUNT(posts.id) as posts_count&#39;)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>INNER</strong> = only matches</li>
<li><strong>OUTER</strong> = matches + unmatched</li>
<li><strong>INNER</strong> excludes NULL</li>
<li><strong>OUTER</strong> includes NULL</li>
<li><strong>INNER</strong> faster</li>
<li><strong>OUTER</strong> more complete data</li>
<li><strong>LEFT OUTER</strong> most common</li>
<li><strong>Use OUTER</strong> to find missing</li>
<li><strong>Use INNER</strong> for relationships</li>
<li><strong>Index</strong> for performance</li>
</ol>
<hr>
<h2>Question 158: How does a SELF JOIN work?</h2>
<h3>Answer</h3>
<p>A <strong>SELF JOIN</strong> joins a table to itself, treating it as two separate tables with aliases. Used to compare rows within the same table or find hierarchical relationships.</p>
<hr>
<h3>Basic Concept</h3>
<pre><code class="language-sql">-- One table appears twice with different aliases
SELECT a.column, b.column
FROM table_name a
JOIN table_name b ON a.id = b.foreign_id;

-- &#39;a&#39; and &#39;b&#39; are aliases for the same table
-- Allows comparing rows within same table
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong>1. Hierarchical Data (Manager-Employee):</strong></p>
<pre><code class="language-sql">-- employees table
id | name    | manager_id
1  | Alice   | NULL        -- CEO
2  | Bob     | 1           -- Reports to Alice
3  | Charlie | 1           -- Reports to Alice
4  | David   | 2           -- Reports to Bob

-- Get employee with their manager
SELECT 
  e.name AS employee,
  m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;

-- Result:
employee | manager
Alice    | NULL
Bob      | Alice
Charlie  | Alice
David    | Bob
</code></pre>
<p><strong>2. Finding Pairs:</strong></p>
<pre><code class="language-sql">-- friends table (symmetric relationship)
user_id | friend_id
1       | 2
2       | 1
1       | 3
3       | 1

-- Get friend pairs (avoid duplicates)
SELECT DISTINCT
  u1.name AS user1,
  u2.name AS user2
FROM users u1
JOIN users u2 ON u1.id &lt; u2.id
JOIN friends f ON (f.user_id = u1.id AND f.friend_id = u2.id);
</code></pre>
<p><strong>3. Comparing Records:</strong></p>
<pre><code class="language-sql">-- Find employees with same salary
SELECT 
  e1.name AS employee1,
  e2.name AS employee2,
  e1.salary
FROM employees e1
JOIN employees e2 ON e1.salary = e2.salary
WHERE e1.id &lt; e2.id;  -- Avoid self-match and duplicates

-- Result:
employee1 | employee2 | salary
Bob       | Charlie   | 50000
</code></pre>
<hr>
<h3>Hierarchical Queries</h3>
<p><strong>Organization chart:</strong></p>
<pre><code class="language-sql">-- Get all reports under a manager
SELECT 
  e.name AS employee,
  m.name AS manager,
  m2.name AS grand_manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id
LEFT JOIN employees m2 ON m.manager_id = m2.id
ORDER BY m2.name, m.name, e.name;

-- Multiple levels of hierarchy
</code></pre>
<p><strong>Count direct reports:</strong></p>
<pre><code class="language-sql">SELECT 
  m.name AS manager,
  COUNT(e.id) AS direct_reports
FROM employees m
LEFT JOIN employees e ON m.id = e.manager_id
GROUP BY m.id, m.name
HAVING COUNT(e.id) &gt; 0
ORDER BY direct_reports DESC;

-- Shows managers with their team sizes
</code></pre>
<hr>
<h3>Finding Relationships</h3>
<p><strong>1. Sequences/Consecutive Rows:</strong></p>
<pre><code class="language-sql">-- Find consecutive seat bookings
-- seats table: id, seat_number, is_booked
SELECT 
  s1.seat_number AS seat,
  s2.seat_number AS next_seat
FROM seats s1
JOIN seats s2 ON s1.seat_number + 1 = s2.seat_number
WHERE s1.is_booked = true 
  AND s2.is_booked = true;

-- Finds pairs of consecutive booked seats
</code></pre>
<p><strong>2. Time-based Comparisons:</strong></p>
<pre><code class="language-sql">-- Find sales growth (compare to previous period)
SELECT 
  current.month,
  current.sales AS current_sales,
  previous.sales AS previous_sales,
  (current.sales - previous.sales) AS growth
FROM monthly_sales current
LEFT JOIN monthly_sales previous 
  ON current.month = previous.month + INTERVAL &#39;1 month&#39;;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<p><strong>Model setup:</strong></p>
<pre><code class="language-ruby"># app/models/employee.rb
class Employee &lt; ApplicationRecord
  belongs_to :manager, class_name: &#39;Employee&#39;, optional: true
  has_many :subordinates, class_name: &#39;Employee&#39;, foreign_key: &#39;manager_id&#39;
end

# Usage:
employee = Employee.find(1)
employee.manager           # Manager object
employee.subordinates      # Array of direct reports

# Get employee with manager name
Employee.joins(&quot;LEFT JOIN employees managers ON employees.manager_id = managers.id&quot;)
        .select(&quot;employees.*, managers.name as manager_name&quot;)
</code></pre>
<p><strong>Custom query:</strong></p>
<pre><code class="language-ruby"># Find employees with same salary
Employee.joins(&lt;&lt;-SQL)
  INNER JOIN employees e2 
  ON employees.salary = e2.salary 
  AND employees.id &lt; e2.id
SQL

# Organization hierarchy
class Employee &lt; ApplicationRecord
  def all_subordinates
    subordinates + subordinates.flat_map(&amp;:all_subordinates)
  end
  
  def hierarchy_level
    manager ? manager.hierarchy_level + 1 : 0
  end
end
</code></pre>
<hr>
<h3>Complex Hierarchies</h3>
<p><strong>Recursive CTE (Common Table Expression):</strong></p>
<pre><code class="language-sql">-- Get entire hierarchy under CEO
WITH RECURSIVE employee_hierarchy AS (
  -- Base case: CEO
  SELECT id, name, manager_id, 0 AS level
  FROM employees
  WHERE manager_id IS NULL
  
  UNION ALL
  
  -- Recursive case: employees reporting to previous level
  SELECT e.id, e.name, e.manager_id, eh.level + 1
  FROM employees e
  JOIN employee_hierarchy eh ON e.manager_id = eh.id
)
SELECT 
  REPEAT(&#39;  &#39;, level) || name AS org_chart,
  level
FROM employee_hierarchy
ORDER BY level, name;

-- Output:
Alice             (level 0)
  Bob             (level 1)
    David         (level 2)
  Charlie         (level 1)
</code></pre>
<hr>
<h3>Best Practices</h3>
<p><strong>1. Always use aliases:</strong></p>
<pre><code class="language-sql">-- ❌ Confusing
SELECT employees.name, employees.name
FROM employees
JOIN employees ON employees.id = employees.manager_id;

-- ✅ Clear
SELECT e.name AS employee, m.name AS manager
FROM employees e
JOIN employees m ON e.manager_id = m.id;
</code></pre>
<p><strong>2. Avoid duplicate results:</strong></p>
<pre><code class="language-sql">-- Use WHERE to prevent matching same row
WHERE e1.id &lt; e2.id  -- Or e1.id != e2.id

-- Or use DISTINCT
SELECT DISTINCT e1.name, e2.name
</code></pre>
<p><strong>3. Handle NULL properly:</strong></p>
<pre><code class="language-sql">-- Use LEFT JOIN for optional relationships
LEFT JOIN employees m ON e.manager_id = m.id

-- Top-level employees have NULL manager
</code></pre>
<p><strong>4. Index foreign keys:</strong></p>
<pre><code class="language-sql">CREATE INDEX idx_employees_manager_id ON employees(manager_id);

-- Critical for SELF JOIN performance
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>SELF JOIN</strong> = table joins itself</li>
<li><strong>Aliases required</strong> (e1, e2)</li>
<li><strong>Hierarchical</strong> relationships</li>
<li><strong>Compare rows</strong> in same table</li>
<li><strong>Manager-employee</strong> common use</li>
<li><strong>Avoid duplicates</strong> with WHERE</li>
<li><strong>NULL handling</strong> important</li>
<li><strong>Recursive CTE</strong> for deep hierarchies</li>
<li><strong>Index</strong> foreign keys</li>
<li><strong>Rails</strong> supports with associations</li>
</ol>
<hr>
<h2>Question 159: What is a CROSS JOIN, and when would you use it?</h2>
<h3>Answer</h3>
<p>A <strong>CROSS JOIN</strong> returns the Cartesian product of two tables - every row from the first table combined with every row from the second table. Use for generating all possible combinations.</p>
<hr>
<h3>Basic Syntax</h3>
<pre><code class="language-sql">-- Explicit CROSS JOIN
SELECT *
FROM table1
CROSS JOIN table2;

-- Implicit CROSS JOIN (comma syntax)
SELECT *
FROM table1, table2;

-- Both produce same result
</code></pre>
<hr>
<h3>How It Works</h3>
<pre><code class="language-sql">-- Table A
id | name
1  | Alice
2  | Bob

-- Table B
id | color
1  | Red
2  | Blue

-- CROSS JOIN
SELECT a.name, b.color
FROM table_a a
CROSS JOIN table_b b;

-- Result (2 × 2 = 4 rows):
name  | color
Alice | Red
Alice | Blue
Bob   | Red
Bob   | Blue

-- Every combination
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong>1. Generate all combinations:</strong></p>
<pre><code class="language-sql">-- Sizes and colors for products
-- sizes: S, M, L
-- colors: Red, Blue, Green

SELECT 
  s.size,
  c.color,
  CONCAT(c.color, &#39; - &#39;, s.size) AS variant
FROM sizes s
CROSS JOIN colors c;

-- Result (3 × 3 = 9 variants):
S, Red, Red - S
S, Blue, Blue - S
S, Green, Green - S
M, Red, Red - M
M, Blue, Blue - M
M, Green, Green - M
L, Red, Red - L
L, Blue, Blue - L
L, Green, Green - L
</code></pre>
<p><strong>2. Create date ranges:</strong></p>
<pre><code class="language-sql">-- Generate all dates in a month
SELECT 
  dates.day,
  CONCAT(&#39;2024-01-&#39;, LPAD(dates.day::text, 2, &#39;0&#39;)) AS full_date
FROM generate_series(1, 31) AS dates(day);

-- Cross join with data for reports
SELECT 
  d.date,
  COALESCE(SUM(o.amount), 0) AS daily_total
FROM (
  SELECT generate_series(
    &#39;2024-01-01&#39;::date,
    &#39;2024-01-31&#39;::date,
    &#39;1 day&#39;
  )::date AS date
) d
CROSS JOIN LATERAL (
  SELECT amount FROM orders WHERE DATE(created_at) = d.date
) o
GROUP BY d.date;
</code></pre>
<p><strong>3. Schedule generation:</strong></p>
<pre><code class="language-sql">-- All possible time slots for appointments
SELECT 
  d.day_name,
  t.time_slot,
  r.room_name
FROM days d
CROSS JOIN time_slots t
CROSS JOIN rooms r
WHERE d.is_working_day = true;

-- Creates full schedule matrix
</code></pre>
<p><strong>4. Testing permutations:</strong></p>
<pre><code class="language-sql">-- Test all parameter combinations
SELECT 
  p.param_a,
  q.param_b,
  r.param_c
FROM param_set_a p
CROSS JOIN param_set_b q
CROSS JOIN param_set_c r;

-- Generate test cases
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<p><strong>Warning: Exponential growth</strong></p>
<pre><code class="language-sql">-- Table A: 1000 rows
-- Table B: 1000 rows
-- CROSS JOIN = 1,000,000 rows!

-- Table A: 100 rows
-- Table B: 100 rows  
-- Table C: 100 rows
-- CROSS JOIN ALL = 1,000,000 rows!

-- Always consider result size
</code></pre>
<p><strong>Optimization:</strong></p>
<pre><code class="language-sql">-- ❌ Bad: Unfiltered cross join
SELECT *
FROM large_table1
CROSS JOIN large_table2;
-- Millions of rows, very slow

-- ✅ Good: Filter after cross join
SELECT *
FROM small_table1
CROSS JOIN small_table2
WHERE some_condition;
-- Only small tables, filtered result

-- ✅ Better: Use INNER JOIN when possible
SELECT *
FROM table1
INNER JOIN table2 ON table1.id = table2.foreign_id;
-- Much faster with proper join condition
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Product variants:</strong></p>
<pre><code class="language-ruby"># Rails - Generate all product variants
class Product &lt; ApplicationRecord
  def generate_variants
    sizes = [&#39;XS&#39;, &#39;S&#39;, &#39;M&#39;, &#39;L&#39;, &#39;XL&#39;]
    colors = [&#39;Red&#39;, &#39;Blue&#39;, &#39;Green&#39;, &#39;Black&#39;]
    
    # CROSS JOIN equivalent in Ruby
    sizes.product(colors).each do |size, color|
      variants.create!(
        size: size,
        color: color,
        sku: &quot;#{code}-#{size}-#{color}&quot;
      )
    end
  end
end

# SQL equivalent:
INSERT INTO variants (product_id, size, color, sku)
SELECT 
  p.id,
  s.name,
  c.name,
  CONCAT(p.code, &#39;-&#39;, s.name, &#39;-&#39;, c.name)
FROM products p
CROSS JOIN sizes s
CROSS JOIN colors c
WHERE p.id = 123;
</code></pre>
<p><strong>2. Report with all dates:</strong></p>
<pre><code class="language-sql">-- Sales report showing every day (even zero sales)
WITH date_range AS (
  SELECT generate_series(
    &#39;2024-01-01&#39;::date,
    &#39;2024-01-31&#39;::date,
    &#39;1 day&#39;
  )::date AS date
)
SELECT 
  dr.date,
  COALESCE(SUM(o.amount), 0) AS total_sales,
  COUNT(o.id) AS order_count
FROM date_range dr
LEFT JOIN orders o ON DATE(o.created_at) = dr.date
GROUP BY dr.date
ORDER BY dr.date;

-- Shows all dates with zero for days without sales
</code></pre>
<p><strong>3. Seating chart:</strong></p>
<pre><code class="language-sql">-- Generate all seat positions
SELECT 
  r.row_letter,
  s.seat_number,
  CONCAT(r.row_letter, s.seat_number) AS seat_code
FROM (
  SELECT chr(ascii(&#39;A&#39;) + n) AS row_letter
  FROM generate_series(0, 25) n
) r
CROSS JOIN (
  SELECT generate_series(1, 50) AS seat_number
) s;

-- Creates: A1, A2, ..., Z50
</code></pre>
<hr>
<h3>CROSS JOIN vs Other Joins</h3>
<pre><code class="language-sql">-- CROSS JOIN (Cartesian product)
SELECT * FROM a CROSS JOIN b;
-- Every a with every b

-- INNER JOIN (Only matches)
SELECT * FROM a INNER JOIN b ON a.id = b.foreign_id;
-- Only where condition matches

-- LEFT JOIN (All left + matches)
SELECT * FROM a LEFT JOIN b ON a.id = b.foreign_id;
-- All a, matched b or NULL

-- CROSS JOIN = INNER JOIN without condition
-- Results in Cartesian product
</code></pre>
<hr>
<h3>When NOT to Use</h3>
<pre><code class="language-sql">-- ❌ Don&#39;t use for regular joins
SELECT *
FROM users
CROSS JOIN posts
WHERE users.id = posts.user_id;

-- ✅ Use proper join instead
SELECT *
FROM users
INNER JOIN posts ON users.id = posts.user_id;

-- CROSS JOIN then filter = inefficient
-- Generates huge intermediate result
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>CROSS JOIN</strong> = all combinations</li>
<li><strong>Cartesian product</strong> of tables</li>
<li><strong>No ON condition</strong> needed</li>
<li><strong>Result size</strong> = rows1 × rows2</li>
<li><strong>Use for</strong> combinations/permutations</li>
<li><strong>Dangerous</strong> with large tables</li>
<li><strong>Product variants</strong> common use</li>
<li><strong>Date ranges</strong> with series</li>
<li><strong>Filter after</strong> if needed</li>
<li><strong>Prefer INNER JOIN</strong> when possible</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 160: What is a NATURAL JOIN?</h2>
<h3>Answer</h3>
<p>A <strong>NATURAL JOIN</strong> automatically joins tables on all columns with the same name, without explicitly specifying the join condition. <strong>Rarely used</strong> in practice due to implicit behavior and potential issues.</p>
<hr>
<h3>Basic Syntax</h3>
<pre><code class="language-sql">-- NATURAL JOIN
SELECT *
FROM table1
NATURAL JOIN table2;

-- Automatically joins on columns with same name
-- No ON clause needed
</code></pre>
<hr>
<h3>How It Works</h3>
<pre><code class="language-sql">-- Table: users
id | name  | email
1  | Alice | alice@example.com
2  | Bob   | bob@example.com

-- Table: orders
id | user_id | product
1  | 1       | Laptop
2  | 1       | Mouse
3  | 2       | Keyboard

-- NATURAL JOIN attempts to join on &#39;id&#39; (common column)
SELECT *
FROM users
NATURAL JOIN orders;

-- Problem: joins users.id = orders.id (wrong!)
-- Result: Only user 1 matches order 1

-- Correct approach:
SELECT *
FROM users
INNER JOIN orders ON users.id = orders.user_id;
</code></pre>
<hr>
<h3>When It Works</h3>
<pre><code class="language-sql">-- Tables designed for natural join
-- employees
employee_id | name
1          | Alice
2          | Bob

-- salaries
employee_id | amount
1          | 50000
2          | 60000

-- NATURAL JOIN (works because only one common column)
SELECT *
FROM employees
NATURAL JOIN salaries;

-- Result: joins on employee_id
employee_id | name  | amount
1          | Alice | 50000
2          | Bob   | 60000
</code></pre>
<hr>
<h3>Why Avoid NATURAL JOIN</h3>
<p><strong>1. Ambiguous join conditions:</strong></p>
<pre><code class="language-sql">-- What if tables have multiple common columns?
-- users: id, name, created_at
-- posts: id, user_id, name, created_at

SELECT *
FROM users
NATURAL JOIN posts;

-- Joins on ALL common columns: name AND created_at
-- Probably not what you want!
</code></pre>
<p><strong>2. Schema changes break queries:</strong></p>
<pre><code class="language-sql">-- Original tables:
-- users: id, name
-- posts: id, user_id

NATURAL JOIN works fine

-- New column added to both:
-- users: id, name, status
-- posts: id, user_id, status

NATURAL JOIN now joins on status too - breaks query!
</code></pre>
<p><strong>3. Less readable:</strong></p>
<pre><code class="language-sql">-- ❌ Unclear what&#39;s being joined
SELECT *
FROM users
NATURAL JOIN posts;
-- What column? Must check schema

-- ✅ Clear and explicit
SELECT *
FROM users
INNER JOIN posts ON users.id = posts.user_id;
-- Obvious join condition
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>NATURAL JOIN</strong> auto-joins on same-named columns</li>
<li><strong>No ON clause</strong> specified</li>
<li><strong>Implicit</strong> and potentially dangerous</li>
<li><strong>Schema changes</strong> break queries</li>
<li><strong>Avoid in production</strong> code</li>
<li><strong>Use explicit</strong> INNER/LEFT JOIN</li>
<li><strong>Less readable</strong> than explicit</li>
<li><strong>Rare</strong> in modern SQL</li>
<li><strong>Better alternatives</strong> exist</li>
<li><strong>Explicit is better</strong> than implicit</li>
</ol>
<hr>
<h2>SQL Queries and Operations</h2>
<h2>Question 162: What is the difference between WHERE and HAVING?</h2>
<h3>Answer</h3>
<p><strong>WHERE</strong> filters rows before grouping. <strong>HAVING</strong> filters groups after GROUP BY. WHERE = row filter, HAVING = group filter.</p>
<hr>
<h3>WHERE Clause</h3>
<p><strong>Filters individual rows:</strong></p>
<pre><code class="language-sql">-- Filter before aggregation
SELECT *
FROM orders
WHERE status = &#39;completed&#39;
  AND amount &gt; 100;

-- Runs before any grouping
-- Filters individual orders
</code></pre>
<hr>
<h3>HAVING Clause</h3>
<p><strong>Filters groups after GROUP BY:</strong></p>
<pre><code class="language-sql">-- Filter after aggregation
SELECT 
  user_id,
  COUNT(*) as order_count
FROM orders
GROUP BY user_id
HAVING COUNT(*) &gt; 5;

-- Runs after grouping
-- Filters groups (users) based on aggregate
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>WHERE</th>
<th>HAVING</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Filters</strong></td>
<td>Individual rows</td>
<td>Groups</td>
</tr>
<tr>
<td><strong>When</strong></td>
<td>Before GROUP BY</td>
<td>After GROUP BY</td>
</tr>
<tr>
<td><strong>Can use</strong></td>
<td>Column values</td>
<td>Aggregate functions</td>
</tr>
<tr>
<td><strong>Cannot use</strong></td>
<td>Aggregate functions</td>
<td>N/A</td>
</tr>
</tbody></table>
<hr>
<h3>Examples</h3>
<p><strong>WHERE only:</strong></p>
<pre><code class="language-sql">-- Get expensive orders
SELECT order_id, amount
FROM orders
WHERE amount &gt; 1000;

-- No grouping, filters rows directly
</code></pre>
<p><strong>GROUP BY with WHERE:</strong></p>
<pre><code class="language-sql">-- Count completed orders per user
SELECT 
  user_id,
  COUNT(*) as completed_orders
FROM orders
WHERE status = &#39;completed&#39;  -- Filter rows first
GROUP BY user_id;

-- WHERE filters BEFORE counting
-- Only completed orders counted
</code></pre>
<p><strong>GROUP BY with HAVING:</strong></p>
<pre><code class="language-sql">-- Find users with more than 10 orders
SELECT 
  user_id,
  COUNT(*) as order_count
FROM orders
GROUP BY user_id
HAVING COUNT(*) &gt; 10;  -- Filter groups after counting

-- HAVING filters AFTER grouping
-- Only users with 10+ orders shown
</code></pre>
<p><strong>Both WHERE and HAVING:</strong></p>
<pre><code class="language-sql">-- Users who spent over $5000 on completed orders
SELECT 
  user_id,
  SUM(amount) as total_spent
FROM orders
WHERE status = &#39;completed&#39;    -- Filter rows first
GROUP BY user_id
HAVING SUM(amount) &gt; 5000;    -- Filter groups after

-- WHERE: Only completed orders
-- GROUP BY: Sum per user
-- HAVING: Only users with total &gt; 5000
</code></pre>
<hr>
<h3>Aggregate Functions</h3>
<p><strong>WHERE cannot use aggregates:</strong></p>
<pre><code class="language-sql">-- ❌ WRONG - WHERE can&#39;t use COUNT
SELECT user_id, COUNT(*) as orders
FROM orders
WHERE COUNT(*) &gt; 5  -- ERROR!
GROUP BY user_id;

-- ✅ CORRECT - HAVING uses COUNT
SELECT user_id, COUNT(*) as orders
FROM orders
GROUP BY user_id
HAVING COUNT(*) &gt; 5;
</code></pre>
<p><strong>HAVING can use aggregates:</strong></p>
<pre><code class="language-sql">-- All aggregate functions work
HAVING COUNT(*) &gt; 10
HAVING SUM(amount) &gt; 1000
HAVING AVG(rating) &gt;= 4.5
HAVING MAX(price) &lt; 100
HAVING MIN(quantity) &gt; 0
</code></pre>
<hr>
<h3>Execution Order</h3>
<pre><code class="language-sql">SELECT user_id, SUM(amount) as total
FROM orders
WHERE status = &#39;completed&#39;   -- 1. Filter rows
GROUP BY user_id             -- 2. Group
HAVING SUM(amount) &gt; 1000    -- 3. Filter groups
ORDER BY total DESC          -- 4. Sort
LIMIT 10;                    -- 5. Limit

-- Logical execution order:
-- FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT
</code></pre>
<hr>
<h3>Performance</h3>
<pre><code class="language-sql">-- ✅ Better - WHERE filters early
SELECT category, AVG(price)
FROM products
WHERE active = true  -- Filters 10000 → 5000 rows
GROUP BY category
HAVING AVG(price) &gt; 50;

-- ❌ Worse - All rows grouped first
SELECT category, AVG(price)
FROM products
GROUP BY category    -- Groups 10000 rows
HAVING AVG(price) &gt; 50 AND category IN (&#39;A&#39;, &#39;B&#39;);
-- Use WHERE for category filter instead!

-- ✅ Best - Filter early with WHERE
SELECT category, AVG(price)
FROM products
WHERE active = true 
  AND category IN (&#39;A&#39;, &#39;B&#39;)  -- Filter here
GROUP BY category
HAVING AVG(price) &gt; 50;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># WHERE (before grouping)
Order.where(status: &#39;completed&#39;)
     .group(:user_id)
     .count

# HAVING (after grouping)
Order.group(:user_id)
     .having(&#39;COUNT(*) &gt; ?&#39;, 5)
     .count

# Both
Order.where(status: &#39;completed&#39;)
     .group(:user_id)
     .having(&#39;SUM(amount) &gt; ?&#39;, 1000)
     .select(&#39;user_id, SUM(amount) as total&#39;)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>WHERE</strong> filters rows</li>
<li><strong>HAVING</strong> filters groups</li>
<li><strong>WHERE</strong> before GROUP BY</li>
<li><strong>HAVING</strong> after GROUP BY</li>
<li><strong>WHERE</strong> cannot use aggregates</li>
<li><strong>HAVING</strong> can use aggregates</li>
<li><strong>WHERE</strong> faster (early filter)</li>
<li><strong>Use both</strong> when needed</li>
<li><strong>Execution order</strong> matters</li>
<li><strong>Filter early</strong> for performance</li>
</ol>
<hr>
<h2>Question 163: What is the purpose of GROUP BY?</h2>
<h3>Answer</h3>
<p><strong>GROUP BY</strong> groups rows with the same values into summary rows, enabling aggregate calculations (COUNT, SUM, AVG, etc.) for each group. Essential for data analysis and reporting.</p>
<hr>
<h3>Basic Concept</h3>
<pre><code class="language-sql">-- Without GROUP BY
SELECT * FROM orders;
-- Result: All individual orders

-- With GROUP BY
SELECT 
  user_id,
  COUNT(*) as order_count,
  SUM(amount) as total_spent
FROM orders
GROUP BY user_id;

-- Result: One row per user with aggregates
user_id | order_count | total_spent
1       | 5           | 500
2       | 3           | 300
3       | 8           | 1200
</code></pre>
<hr>
<h3>How It Works</h3>
<pre><code class="language-sql">-- Original data:
order_id | user_id | amount
1        | 1       | 100
2        | 1       | 200
3        | 2       | 150
4        | 1       | 200
5        | 2       | 150

-- GROUP BY user_id
SELECT user_id, COUNT(*), SUM(amount)
FROM orders
GROUP BY user_id;

-- Groups:
-- Group 1 (user_id = 1): orders 1, 2, 4
-- Group 2 (user_id = 2): orders 3, 5

-- Result:
user_id | count | sum
1       | 3     | 500
2       | 2     | 300
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong>1. Count per category:</strong></p>
<pre><code class="language-sql">SELECT 
  category,
  COUNT(*) as product_count
FROM products
GROUP BY category;

-- Result:
category | product_count
Electronics | 50
Clothing    | 100
Books       | 75
</code></pre>
<p><strong>2. Sum per user:</strong></p>
<pre><code class="language-sql">SELECT 
  user_id,
  SUM(amount) as total_revenue
FROM orders
GROUP BY user_id
ORDER BY total_revenue DESC;

-- Top spending users
</code></pre>
<p><strong>3. Average per group:</strong></p>
<pre><code class="language-sql">SELECT 
  department,
  AVG(salary) as avg_salary,
  COUNT(*) as employee_count
FROM employees
GROUP BY department;

-- Department statistics
</code></pre>
<p><strong>4. Multiple grouping columns:</strong></p>
<pre><code class="language-sql">SELECT 
  category,
  brand,
  COUNT(*) as products,
  AVG(price) as avg_price
FROM products
GROUP BY category, brand
ORDER BY category, brand;

-- Groups by combination of category AND brand
-- Result: One row per category-brand pair
</code></pre>
<hr>
<h3>Rules and Restrictions</h3>
<p><strong>1. Selected columns must be in GROUP BY or aggregates:</strong></p>
<pre><code class="language-sql">-- ❌ WRONG
SELECT user_id, status, COUNT(*)
FROM orders
GROUP BY user_id;
-- ERROR: status not in GROUP BY

-- ✅ CORRECT - Option 1: Add to GROUP BY
SELECT user_id, status, COUNT(*)
FROM orders
GROUP BY user_id, status;

-- ✅ CORRECT - Option 2: Use aggregate
SELECT user_id, MAX(status), COUNT(*)
FROM orders
GROUP BY user_id;
</code></pre>
<p><strong>2. Cannot use column aliases in GROUP BY (most databases):</strong></p>
<pre><code class="language-sql">-- ❌ WRONG (most databases)
SELECT 
  YEAR(created_at) as year,
  COUNT(*) as orders
FROM orders
GROUP BY year;  -- ERROR

-- ✅ CORRECT
SELECT 
  YEAR(created_at) as year,
  COUNT(*) as orders
FROM orders
GROUP BY YEAR(created_at);

-- PostgreSQL allows:
GROUP BY year  -- Works in PostgreSQL only
</code></pre>
<hr>
<h3>Aggregate Functions with GROUP BY</h3>
<pre><code class="language-sql">SELECT 
  category,
  COUNT(*) as total_products,
  COUNT(DISTINCT brand) as brand_count,
  SUM(stock) as total_stock,
  AVG(price) as avg_price,
  MIN(price) as cheapest,
  MAX(price) as most_expensive,
  STDDEV(price) as price_variance
FROM products
GROUP BY category;

-- All standard aggregates work
</code></pre>
<hr>
<h3>GROUP BY with HAVING</h3>
<pre><code class="language-sql">-- Filter groups (not individual rows)
SELECT 
  user_id,
  COUNT(*) as orders,
  SUM(amount) as total
FROM orders
GROUP BY user_id
HAVING COUNT(*) &gt;= 5          -- At least 5 orders
  AND SUM(amount) &gt; 1000;     -- Spent over $1000

-- Only users meeting both conditions
</code></pre>
<hr>
<h3>GROUP BY with WHERE</h3>
<pre><code class="language-sql">-- Filter rows BEFORE grouping
SELECT 
  category,
  COUNT(*) as active_products
FROM products
WHERE active = true           -- Filter first
GROUP BY category
HAVING COUNT(*) &gt; 10;         -- Then filter groups

-- More efficient: filters early
</code></pre>
<hr>
<h3>Multiple Column Grouping</h3>
<pre><code class="language-sql">-- Group by year and month
SELECT 
  YEAR(created_at) as year,
  MONTH(created_at) as month,
  COUNT(*) as orders,
  SUM(amount) as revenue
FROM orders
GROUP BY YEAR(created_at), MONTH(created_at)
ORDER BY year, month;

-- One row per year-month combination
</code></pre>
<hr>
<h3>GROUP BY with Expressions</h3>
<pre><code class="language-sql">-- Group by calculation
SELECT 
  CASE 
    WHEN age &lt; 18 THEN &#39;Minor&#39;
    WHEN age &lt; 65 THEN &#39;Adult&#39;
    ELSE &#39;Senior&#39;
  END as age_group,
  COUNT(*) as count
FROM users
GROUP BY CASE 
  WHEN age &lt; 18 THEN &#39;Minor&#39;
  WHEN age &lt; 65 THEN &#39;Adult&#39;
  ELSE &#39;Senior&#39;
END;

-- Groups by age category
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># Basic GROUP BY
Order.group(:user_id).count
# =&gt; { 1 =&gt; 5, 2 =&gt; 3, 3 =&gt; 8 }

# With aggregate
Order.group(:user_id).sum(:amount)
# =&gt; { 1 =&gt; 500, 2 =&gt; 300, 3 =&gt; 1200 }

# Multiple columns
Product.group(:category, :brand).count

# With calculations
Order.group(:user_id)
     .select(&#39;user_id, COUNT(*) as orders, SUM(amount) as total&#39;)

# With HAVING
Order.group(:user_id)
     .having(&#39;COUNT(*) &gt; ?&#39;, 5)
     .count
</code></pre>
<hr>
<h3>Advanced: GROUP BY ALL (PostgreSQL 13+)</h3>
<pre><code class="language-sql">-- Automatically groups by all non-aggregate columns
SELECT 
  category,
  brand,
  COUNT(*) as products
FROM products
GROUP BY ALL;  -- Groups by category and brand automatically

-- Equivalent to:
GROUP BY category, brand
</code></pre>
<hr>
<h3>Performance Tips</h3>
<pre><code class="language-sql">-- ✅ Index grouped columns
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- ✅ Filter before grouping
WHERE status = &#39;completed&#39;  -- Filter first
GROUP BY user_id            -- Then group

-- ✅ Use covering indexes
CREATE INDEX idx_orders_covering 
ON orders(user_id, status, amount);

-- ⚠️ Large GROUP BY can be slow
-- Consider materialized views for frequent queries
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>GROUP BY</strong> aggregates rows</li>
<li><strong>One row</strong> per group</li>
<li><strong>Requires aggregates</strong> (COUNT, SUM, etc.)</li>
<li><strong>Selected columns</strong> must be grouped or aggregated</li>
<li><strong>Multiple columns</strong> allowed</li>
<li><strong>HAVING</strong> filters groups</li>
<li><strong>WHERE</strong> filters before grouping</li>
<li><strong>Performance</strong> improved with indexes</li>
<li><strong>Essential</strong> for reports</li>
<li><strong>Rails</strong> has convenient helpers</li>
</ol>
<hr>
<h2>Question 164: What is ORDER BY, and how do you sort results?</h2>
<h3>Answer</h3>
<p><strong>ORDER BY</strong> sorts query results by one or more columns in ascending (ASC) or descending (DESC) order. Executed after filtering and grouping, before LIMIT.</p>
<hr>
<h3>Basic Syntax</h3>
<pre><code class="language-sql">-- Ascending (default)
SELECT * FROM users
ORDER BY name;

SELECT * FROM users
ORDER BY name ASC;  -- Explicit

-- Descending
SELECT * FROM users
ORDER BY age DESC;

-- Multiple columns
SELECT * FROM users
ORDER BY age DESC, name ASC;
-- First by age (descending), then by name (ascending)
</code></pre>
<hr>
<h3>Sort Order</h3>
<pre><code class="language-sql">-- Numbers
SELECT * FROM products
ORDER BY price ASC;
-- Result: 9.99, 19.99, 29.99, 49.99

SELECT * FROM products
ORDER BY price DESC;
-- Result: 49.99, 29.99, 19.99, 9.99

-- Strings (alphabetical)
SELECT * FROM users
ORDER BY name ASC;
-- Result: Alice, Bob, Charlie, David

-- Dates (chronological)
SELECT * FROM orders
ORDER BY created_at DESC;
-- Result: Newest first
</code></pre>
<hr>
<h3>NULL Handling</h3>
<pre><code class="language-sql">-- NULLs first (default in PostgreSQL)
SELECT * FROM users
ORDER BY last_login ASC;
-- Result: NULL, NULL, 2024-01-01, 2024-01-15

-- NULLs last
SELECT * FROM users
ORDER BY last_login ASC NULLS LAST;
-- Result: 2024-01-01, 2024-01-15, NULL, NULL

-- NULLs first (explicit)
SELECT * FROM users
ORDER BY last_login DESC NULLS FIRST;
-- Result: NULL, NULL, 2024-01-15, 2024-01-01
</code></pre>
<hr>
<h3>Multiple Columns</h3>
<pre><code class="language-sql">-- Sort by multiple columns
SELECT name, age, city
FROM users
ORDER BY city ASC, age DESC, name ASC;

-- Execution:
-- 1. Sort by city (alphabetically)
-- 2. Within same city, sort by age (oldest first)
-- 3. Within same city and age, sort by name

-- Example result:
name    | age | city
Charlie | 35  | LA
Alice   | 30  | LA
Bob     | 25  | LA
David   | 40  | NYC
Eve     | 28  | NYC
</code></pre>
<hr>
<h3>Sort by Position</h3>
<pre><code class="language-sql">-- Sort by column position (not recommended)
SELECT name, age, city
FROM users
ORDER BY 2 DESC, 3 ASC;
-- 2 = age column, 3 = city column

-- ❌ Hard to read, breaks if column order changes
-- ✅ Use column names instead
</code></pre>
<hr>
<h3>Sort by Expressions</h3>
<pre><code class="language-sql">-- Sort by calculation
SELECT 
  name,
  price,
  quantity,
  price * quantity AS total
FROM products
ORDER BY price * quantity DESC;

-- Sort by CASE expression
SELECT name, status
FROM orders
ORDER BY 
  CASE status
    WHEN &#39;urgent&#39; THEN 1
    WHEN &#39;high&#39; THEN 2
    WHEN &#39;normal&#39; THEN 3
    WHEN &#39;low&#39; THEN 4
  END;
-- Custom priority order

-- Sort by string function
SELECT name, email
FROM users
ORDER BY LOWER(name);
-- Case-insensitive sort
</code></pre>
<hr>
<h3>Sort by Aggregate</h3>
<pre><code class="language-sql">-- Sort grouped results
SELECT 
  category,
  COUNT(*) as product_count
FROM products
GROUP BY category
ORDER BY COUNT(*) DESC;

-- Sort by aggregate alias
SELECT 
  category,
  COUNT(*) as product_count
FROM products
GROUP BY category
ORDER BY product_count DESC;  -- Works in most databases
</code></pre>
<hr>
<h3>Advanced Sorting</h3>
<p><strong>1. Custom sort order:</strong></p>
<pre><code class="language-sql">-- Sort by specific values
SELECT *
FROM products
ORDER BY 
  CASE category
    WHEN &#39;Featured&#39; THEN 1
    WHEN &#39;New&#39; THEN 2
    WHEN &#39;Sale&#39; THEN 3
    ELSE 4
  END,
  price ASC;
</code></pre>
<p><strong>2. Random order:</strong></p>
<pre><code class="language-sql">-- PostgreSQL
SELECT * FROM products
ORDER BY RANDOM()
LIMIT 10;

-- MySQL
SELECT * FROM products
ORDER BY RAND()
LIMIT 10;

-- Get 10 random products
</code></pre>
<p><strong>3. Natural sort (alphanumeric):</strong></p>
<pre><code class="language-sql">-- Sort: Product1, Product2, Product10, Product20
-- Not: Product1, Product10, Product2, Product20

-- PostgreSQL with regex
SELECT name
FROM products
ORDER BY 
  REGEXP_REPLACE(name, &#39;[^0-9]&#39;, &#39;&#39;, &#39;g&#39;)::INTEGER,
  name;
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-sql">-- ✅ Index helps ORDER BY
CREATE INDEX idx_users_created_at ON users(created_at);

SELECT * FROM users
ORDER BY created_at DESC;
-- Uses index, very fast

-- ❌ No index = full table sort (slow)
SELECT * FROM users
ORDER BY random_column;
-- Must sort entire result set

-- ✅ Covering index (best)
CREATE INDEX idx_users_covering ON users(age, name);

SELECT name, age
FROM users
ORDER BY age DESC, name ASC;
-- All data in index, no table access needed

-- ⚠️ ORDER BY with LIMIT is efficient
SELECT * FROM users
ORDER BY created_at DESC
LIMIT 10;
-- Database can stop after finding 10

-- ❌ ORDER BY on large result sets (slow)
SELECT *
FROM huge_table
ORDER BY some_column;
-- Must sort millions of rows
</code></pre>
<hr>
<h3>Execution Order</h3>
<pre><code class="language-sql">SELECT name, COUNT(*) as orders
FROM users
JOIN orders ON users.id = orders.user_id
WHERE status = &#39;completed&#39;
GROUP BY name
HAVING COUNT(*) &gt; 5
ORDER BY COUNT(*) DESC
LIMIT 10;

-- Logical execution order:
-- 1. FROM users
-- 2. JOIN orders
-- 3. WHERE status = &#39;completed&#39;
-- 4. GROUP BY name
-- 5. HAVING COUNT(*) &gt; 5
-- 6. SELECT name, COUNT(*)
-- 7. ORDER BY COUNT(*) DESC
-- 8. LIMIT 10
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># Basic ORDER BY
User.order(:name)
User.order(name: :asc)

# Descending
User.order(created_at: :desc)

# Multiple columns
User.order(age: :desc, name: :asc)

# String syntax
User.order(&#39;age DESC, name ASC&#39;)

# Expression
User.order(&#39;LOWER(name)&#39;)

# Multiple order calls (chained)
User.where(active: true)
    .order(created_at: :desc)
    .order(:name)
# Result: ORDER BY created_at DESC, name ASC

# Reorder (replaces previous ORDER BY)
User.order(:name).reorder(created_at: :desc)
# Result: ORDER BY created_at DESC (name removed)

# Random
User.order(&#39;RANDOM()&#39;).limit(10)  # PostgreSQL
User.order(&#39;RAND()&#39;).limit(10)    # MySQL
</code></pre>
<hr>
<h3>Common Patterns</h3>
<p><strong>1. Pagination:</strong></p>
<pre><code class="language-sql">-- Page 1
SELECT * FROM products
ORDER BY id
LIMIT 20 OFFSET 0;

-- Page 2
SELECT * FROM products
ORDER BY id
LIMIT 20 OFFSET 20;

-- Consistent ORDER BY required for pagination
</code></pre>
<p><strong>2. Top N:</strong></p>
<pre><code class="language-sql">-- Top 10 earners
SELECT name, salary
FROM employees
ORDER BY salary DESC
LIMIT 10;

-- Bottom 10
SELECT name, salary
FROM employees
ORDER BY salary ASC
LIMIT 10;
</code></pre>
<p><strong>3. Recent items:</strong></p>
<pre><code class="language-sql">-- Latest posts
SELECT * FROM posts
ORDER BY published_at DESC
LIMIT 20;

-- Oldest unprocessed
SELECT * FROM queue
WHERE status = &#39;pending&#39;
ORDER BY created_at ASC
LIMIT 100;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>ORDER BY</strong> sorts results</li>
<li><strong>ASC</strong> ascending (default)</li>
<li><strong>DESC</strong> descending</li>
<li><strong>Multiple columns</strong> supported</li>
<li><strong>NULLs</strong> first or last</li>
<li><strong>Expressions</strong> allowed</li>
<li><strong>Index</strong> improves performance</li>
<li><strong>After</strong> filtering/grouping</li>
<li><strong>Before</strong> LIMIT</li>
<li><strong>Required</strong> for pagination</li>
</ol>
<hr>
<h2>Question 165: What is the difference between DISTINCT and GROUP BY?</h2>
<h3>Answer</h3>
<p><strong>DISTINCT</strong> removes duplicate rows from results. <strong>GROUP BY</strong> groups rows and allows aggregate functions. DISTINCT = unique rows, GROUP BY = aggregation.</p>
<hr>
<h3>DISTINCT</h3>
<p><strong>Remove duplicate rows:</strong></p>
<pre><code class="language-sql">-- All columns must match for duplicates
SELECT DISTINCT city
FROM users;

-- Result (unique cities):
NYC
LA
Chicago

-- Without DISTINCT:
NYC
NYC
LA
Chicago
LA
LA
</code></pre>
<p><strong>Multiple columns:</strong></p>
<pre><code class="language-sql">-- Unique combinations
SELECT DISTINCT city, state
FROM users;

-- Result (unique city-state pairs):
NYC, NY
LA, CA
Chicago, IL
</code></pre>
<hr>
<h3>GROUP BY</h3>
<p><strong>Group and aggregate:</strong></p>
<pre><code class="language-sql">-- Count per city
SELECT city, COUNT(*) as user_count
FROM users
GROUP BY city;

-- Result:
city    | user_count
NYC     | 15
LA      | 22
Chicago | 8
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>DISTINCT</th>
<th>GROUP BY</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Purpose</strong></td>
<td>Remove duplicates</td>
<td>Aggregate data</td>
</tr>
<tr>
<td><strong>Aggregates</strong></td>
<td>No</td>
<td>Yes (COUNT, SUM, etc.)</td>
</tr>
<tr>
<td><strong>Result</strong></td>
<td>Unique rows</td>
<td>One row per group</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Usually faster</td>
<td>Slower (grouping)</td>
</tr>
<tr>
<td><strong>Flexibility</strong></td>
<td>Limited</td>
<td>High</td>
</tr>
</tbody></table>
<hr>
<h3>When They&#39;re Similar</h3>
<pre><code class="language-sql">-- Count unique cities (same result)

-- Using DISTINCT
SELECT COUNT(DISTINCT city) FROM users;
-- Result: 3

-- Using GROUP BY
SELECT COUNT(*) FROM (
  SELECT city FROM users GROUP BY city
) AS subquery;
-- Result: 3

-- Get unique cities (similar result)

-- DISTINCT
SELECT DISTINCT city FROM users;

-- GROUP BY
SELECT city FROM users GROUP BY city;

-- Both return unique cities, but:
-- - DISTINCT is simpler
-- - GROUP BY allows aggregates
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use DISTINCT when:</strong></p>
<pre><code class="language-sql">-- ✅ Simple unique values
SELECT DISTINCT category FROM products;

-- ✅ Unique combinations
SELECT DISTINCT user_id, product_id FROM views;

-- ✅ Count unique
SELECT COUNT(DISTINCT user_id) FROM orders;

-- Simple, no aggregation needed
</code></pre>
<p><strong>Use GROUP BY when:</strong></p>
<pre><code class="language-sql">-- ✅ Need aggregates
SELECT category, COUNT(*) as products
FROM products
GROUP BY category;

-- ✅ Multiple aggregates
SELECT 
  user_id,
  COUNT(*) as orders,
  SUM(amount) as total_spent
FROM orders
GROUP BY user_id;

-- ✅ Filter groups (HAVING)
SELECT category, COUNT(*)
FROM products
GROUP BY category
HAVING COUNT(*) &gt; 10;

-- Complex aggregation needed
</code></pre>
<hr>
<h3>DISTINCT with Aggregates</h3>
<pre><code class="language-sql">-- Count unique users who ordered
SELECT COUNT(DISTINCT user_id)
FROM orders;

-- Count unique products per user
SELECT 
  user_id,
  COUNT(DISTINCT product_id) as unique_products
FROM order_items
GROUP BY user_id;

-- Average unique daily visitors
SELECT 
  DATE(visited_at) as date,
  COUNT(DISTINCT user_id) as unique_visitors
FROM page_views
GROUP BY DATE(visited_at);
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-sql">-- DISTINCT (usually faster)
SELECT DISTINCT city
FROM users;
-- Simple deduplication

-- GROUP BY (slower if no aggregates needed)
SELECT city
FROM users
GROUP BY city;
-- More complex operation

-- But with aggregates, GROUP BY is necessary
SELECT city, COUNT(*)
FROM users
GROUP BY city;
-- Cannot use DISTINCT here
</code></pre>
<hr>
<h3>DISTINCT ON (PostgreSQL)</h3>
<pre><code class="language-sql">-- Get first order per user
SELECT DISTINCT ON (user_id)
  user_id,
  order_id,
  created_at
FROM orders
ORDER BY user_id, created_at DESC;

-- Result: One order per user (most recent)
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Unique customers:</strong></p>
<pre><code class="language-sql">-- DISTINCT - just list
SELECT DISTINCT customer_id
FROM orders;

-- GROUP BY - with stats
SELECT 
  customer_id,
  COUNT(*) as order_count,
  SUM(total) as lifetime_value
FROM orders
GROUP BY customer_id;
</code></pre>
<p><strong>2. Product categories:</strong></p>
<pre><code class="language-sql">-- DISTINCT - simple list
SELECT DISTINCT category
FROM products
ORDER BY category;

-- GROUP BY - with counts
SELECT 
  category,
  COUNT(*) as product_count,
  AVG(price) as avg_price
FROM products
GROUP BY category
ORDER BY product_count DESC;
</code></pre>
<p><strong>3. Active users:</strong></p>
<pre><code class="language-sql">-- DISTINCT - count unique
SELECT COUNT(DISTINCT user_id)
FROM logins
WHERE DATE(created_at) = CURRENT_DATE;

-- GROUP BY - detailed breakdown
SELECT 
  DATE(created_at) as date,
  COUNT(DISTINCT user_id) as daily_active_users
FROM logins
WHERE created_at &gt;= CURRENT_DATE - INTERVAL &#39;30 days&#39;
GROUP BY DATE(created_at)
ORDER BY date;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># DISTINCT
User.select(:city).distinct
# SELECT DISTINCT city FROM users

User.distinct.count(:city)
# SELECT COUNT(DISTINCT city) FROM users

# GROUP BY
User.group(:city).count
# SELECT city, COUNT(*) FROM users GROUP BY city
# Result: { &quot;NYC&quot; =&gt; 15, &quot;LA&quot; =&gt; 22 }

User.group(:city)
    .select(&#39;city, COUNT(*) as user_count&#39;)
# SELECT city, COUNT(*) as user_count FROM users GROUP BY city

# DISTINCT with GROUP BY
Order.group(:user_id)
     .select(&#39;user_id, COUNT(DISTINCT product_id) as unique_products&#39;)
</code></pre>
<hr>
<h3>Common Mistakes</h3>
<pre><code class="language-sql">-- ❌ DISTINCT with aggregate (incorrect)
SELECT DISTINCT city, COUNT(*)
FROM users;
-- Doesn&#39;t make sense, use GROUP BY

-- ✅ Correct
SELECT city, COUNT(*)
FROM users
GROUP BY city;

-- ❌ GROUP BY without aggregate
SELECT city, name
FROM users
GROUP BY city;
-- ERROR: name not in GROUP BY

-- ✅ Use DISTINCT instead
SELECT DISTINCT city, name
FROM users;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>DISTINCT</strong> removes duplicates</li>
<li><strong>GROUP BY</strong> aggregates data</li>
<li><strong>DISTINCT</strong> simpler, faster</li>
<li><strong>GROUP BY</strong> more flexible</li>
<li><strong>DISTINCT</strong> no aggregates</li>
<li><strong>GROUP BY</strong> with aggregates</li>
<li><strong>COUNT(DISTINCT)</strong> common</li>
<li><strong>Use DISTINCT</strong> for unique values</li>
<li><strong>Use GROUP BY</strong> for stats</li>
<li><strong>Choose</strong> based on needs</li>
</ol>
<hr>
<h2>Question 166: Explain UNION and UNION ALL</h2>
<h3>Answer</h3>
<p><strong>UNION</strong> combines results from multiple queries, removing duplicates. <strong>UNION ALL</strong> combines results keeping all rows including duplicates. UNION = unique rows, UNION ALL = all rows.</p>
<hr>
<h3>UNION</h3>
<p><strong>Combines with deduplication:</strong></p>
<pre><code class="language-sql">-- Query 1 results
SELECT name FROM customers
-- Result: Alice, Bob, Charlie

-- Query 2 results
SELECT name FROM suppliers
-- Result: Bob, David, Eve

-- UNION (removes duplicate &#39;Bob&#39;)
SELECT name FROM customers
UNION
SELECT name FROM suppliers;

-- Result:
Alice
Bob      -- Only once
Charlie
David
Eve
</code></pre>
<hr>
<h3>UNION ALL</h3>
<p><strong>Combines keeping duplicates:</strong></p>
<pre><code class="language-sql">-- Same queries
SELECT name FROM customers
UNION ALL
SELECT name FROM suppliers;

-- Result:
Alice
Bob      -- From customers
Charlie
Bob      -- From suppliers (duplicate kept)
David
Eve
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>UNION</th>
<th>UNION ALL</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Duplicates</strong></td>
<td>Removed</td>
<td>Kept</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Slower (dedup)</td>
<td>Faster</td>
</tr>
<tr>
<td><strong>Use when</strong></td>
<td>Need unique</td>
<td>Duplicates OK</td>
</tr>
<tr>
<td><strong>Sort</strong></td>
<td>Implicit</td>
<td>None</td>
</tr>
</tbody></table>
<hr>
<h3>Requirements</h3>
<pre><code class="language-sql">-- Must have:
-- 1. Same number of columns
-- 2. Compatible data types
-- 3. Same column order

-- ✅ Valid
SELECT id, name FROM users
UNION
SELECT id, title FROM posts;

-- ❌ Invalid - different column count
SELECT id, name FROM users
UNION
SELECT id FROM posts;  -- ERROR

-- ❌ Invalid - incompatible types
SELECT id, name FROM users
UNION
SELECT name, id FROM posts;  -- Type mismatch
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong>1. Combine similar tables:</strong></p>
<pre><code class="language-sql">-- Active and archived orders
SELECT id, user_id, amount, &#39;active&#39; as source
FROM orders
UNION ALL
SELECT id, user_id, amount, &#39;archived&#39; as source
FROM archived_orders
ORDER BY id;

-- View all orders together
</code></pre>
<p><strong>2. Multiple categories:</strong></p>
<pre><code class="language-sql">-- Premium and regular users
SELECT id, name, email, &#39;premium&#39; as tier
FROM premium_users
UNION ALL
SELECT id, name, email, &#39;regular&#39; as tier
FROM regular_users;
</code></pre>
<p><strong>3. Search across tables:</strong></p>
<pre><code class="language-sql">-- Search in posts and comments
SELECT 
  id,
  title as text,
  &#39;post&#39; as type,
  created_at
FROM posts
WHERE title ILIKE &#39;%search term%&#39;

UNION ALL

SELECT 
  id,
  body as text,
  &#39;comment&#39; as type,
  created_at
FROM comments
WHERE body ILIKE &#39;%search term%&#39;;
</code></pre>
<p><strong>4. Aggregate from multiple sources:</strong></p>
<pre><code class="language-sql">-- Total revenue from multiple sources
SELECT SUM(revenue) FROM (
  SELECT amount as revenue FROM sales
  UNION ALL
  SELECT subscription_fee as revenue FROM subscriptions
  UNION ALL
  SELECT fee as revenue FROM services
) AS all_revenue;
</code></pre>
<hr>
<h3>UNION with ORDER BY</h3>
<pre><code class="language-sql">-- ORDER BY applies to final result
SELECT name, created_at FROM users
UNION
SELECT title, published_at FROM posts
ORDER BY created_at DESC
LIMIT 10;

-- Cannot order individual queries before UNION
-- (except in subqueries)

SELECT * FROM (
  SELECT name, created_at FROM users
  ORDER BY created_at DESC
  LIMIT 5
) u
UNION ALL
SELECT * FROM (
  SELECT title, published_at FROM posts
  ORDER BY published_at DESC
  LIMIT 5
) p
ORDER BY created_at DESC;
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-sql">-- UNION (slower)
SELECT id FROM table1  -- 10,000 rows
UNION
SELECT id FROM table2; -- 10,000 rows
-- Must remove duplicates
-- Temporary hash table
-- ~500ms

-- UNION ALL (faster)
SELECT id FROM table1  -- 10,000 rows
UNION ALL
SELECT id FROM table2; -- 10,000 rows
-- No deduplication
-- Direct append
-- ~50ms

-- ✅ Use UNION ALL when:
-- - Know there are no duplicates
-- - Duplicates are acceptable
-- - Performance is critical
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. User activity feed:</strong></p>
<pre><code class="language-ruby"># Rails - Activity feed combining different event types
class User &lt; ApplicationRecord
  def activity_feed
    posts_activity = Post
      .where(user_id: id)
      .select(&quot;id, &#39;post&#39; as type, title as content, created_at&quot;)
    
    comments_activity = Comment
      .where(user_id: id)
      .select(&quot;id, &#39;comment&#39; as type, body as content, created_at&quot;)
    
    posts_activity
      .union_all(comments_activity)
      .order(created_at: :desc)
      .limit(20)
  end
end
</code></pre>
<p><strong>2. Search results:</strong></p>
<pre><code class="language-sql">-- Search products and blog posts
(
  SELECT 
    id,
    name as title,
    &#39;product&#39; as type,
    price as score
  FROM products
  WHERE name ILIKE &#39;%laptop%&#39;
  LIMIT 5
)
UNION ALL
(
  SELECT 
    id,
    title,
    &#39;blog&#39; as type,
    views as score
  FROM blog_posts
  WHERE title ILIKE &#39;%laptop%&#39;
  LIMIT 5
)
ORDER BY score DESC;
</code></pre>
<p><strong>3. Dashboard metrics:</strong></p>
<pre><code class="language-sql">-- Combine different metric types
SELECT &#39;Revenue&#39; as metric, SUM(amount) as value
FROM orders
WHERE created_at &gt;= CURRENT_DATE

UNION ALL

SELECT &#39;New Users&#39;, COUNT(*)
FROM users
WHERE created_at &gt;= CURRENT_DATE

UNION ALL

SELECT &#39;Page Views&#39;, COUNT(*)
FROM analytics
WHERE date = CURRENT_DATE;

-- Result:
metric      | value
Revenue     | 15000
New Users   | 145
Page Views  | 8234
</code></pre>
<hr>
<h3>UNION with NULL</h3>
<pre><code class="language-sql">-- Different NULL handling
SELECT id, name, email FROM users
UNION
SELECT id, name, NULL FROM external_users;

-- NULLs are treated as equal for UNION
-- But kept distinct in UNION ALL
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># UNION
User.select(:email)
    .union(Customer.select(:email))

# UNION ALL
User.select(:email)
    .union_all(Customer.select(:email))

# Complex example
active_users = User.where(active: true)
                  .select(:id, :name, &quot;&#39;active&#39; as status&quot;)

inactive_users = User.where(active: false)
                    .select(:id, :name, &quot;&#39;inactive&#39; as status&quot;)

all_users = active_users.union_all(inactive_users)
                       .order(:name)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>UNION</strong> removes duplicates</li>
<li><strong>UNION ALL</strong> keeps duplicates</li>
<li><strong>UNION ALL</strong> faster</li>
<li><strong>Same column count</strong> required</li>
<li><strong>Compatible types</strong> required</li>
<li><strong>ORDER BY</strong> on final result</li>
<li><strong>Use UNION ALL</strong> when possible</li>
<li><strong>Combine</strong> similar data sources</li>
<li><strong>Add identifier</strong> column helpful</li>
<li><strong>Performance</strong> matters at scale</li>
</ol>
<hr>
<h2>Question 167: What is the difference between UNION, UNION ALL, INTERSECT, and EXCEPT?</h2>
<h3>Answer</h3>
<p>Set operations combine query results differently: <strong>UNION</strong> = all unique rows, <strong>UNION ALL</strong> = all rows with duplicates, <strong>INTERSECT</strong> = common rows only, <strong>EXCEPT</strong> = rows in first but not second.</p>
<hr>
<h3>Visual Representation</h3>
<pre><code>Query A: {1, 2, 3, 4}
Query B: {3, 4, 5, 6}

UNION:
{1, 2, 3, 4, 5, 6}  -- All unique

UNION ALL:
{1, 2, 3, 4, 3, 4, 5, 6}  -- All rows

INTERSECT:
{3, 4}  -- Common only

EXCEPT (A - B):
{1, 2}  -- In A, not in B
</code></pre>
<hr>
<h3>UNION</h3>
<p><strong>All unique rows from both queries:</strong></p>
<pre><code class="language-sql">SELECT id FROM customers  -- {1, 2, 3}
UNION
SELECT id FROM suppliers; -- {2, 3, 4}

-- Result: {1, 2, 3, 4}
-- Duplicates removed
</code></pre>
<hr>
<h3>UNION ALL</h3>
<p><strong>All rows including duplicates:</strong></p>
<pre><code class="language-sql">SELECT id FROM customers  -- {1, 2, 3}
UNION ALL
SELECT id FROM suppliers; -- {2, 3, 4}

-- Result: {1, 2, 3, 2, 3, 4}
-- Duplicates kept
</code></pre>
<hr>
<h3>INTERSECT</h3>
<p><strong>Only rows in BOTH queries:</strong></p>
<pre><code class="language-sql">SELECT id FROM customers  -- {1, 2, 3}
INTERSECT
SELECT id FROM suppliers; -- {2, 3, 4}

-- Result: {2, 3}
-- Common rows only
</code></pre>
<hr>
<h3>EXCEPT (or MINUS)</h3>
<p><strong>Rows in first query but NOT in second:</strong></p>
<pre><code class="language-sql">SELECT id FROM customers  -- {1, 2, 3}
EXCEPT
SELECT id FROM suppliers; -- {2, 3, 4}

-- Result: {1}
-- In customers but not suppliers

-- Note: Oracle uses MINUS instead of EXCEPT
-- SELECT id FROM customers
-- MINUS
-- SELECT id FROM suppliers;
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Result</th>
<th>Duplicates</th>
<th>Use Case</th>
</tr>
</thead>
<tbody><tr>
<td><strong>UNION</strong></td>
<td>A ∪ B (unique)</td>
<td>Removed</td>
<td>Combine unique</td>
</tr>
<tr>
<td><strong>UNION ALL</strong></td>
<td>A + B (all)</td>
<td>Kept</td>
<td>Combine all</td>
</tr>
<tr>
<td><strong>INTERSECT</strong></td>
<td>A ∩ B</td>
<td>Removed</td>
<td>Common only</td>
</tr>
<tr>
<td><strong>EXCEPT</strong></td>
<td>A - B</td>
<td>Removed</td>
<td>Difference</td>
</tr>
</tbody></table>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. UNION - Combine user sources:</strong></p>
<pre><code class="language-sql">-- All unique users from different systems
SELECT email FROM app_users
UNION
SELECT email FROM legacy_users
UNION
SELECT email FROM imported_users;

-- Result: All unique emails
</code></pre>
<p><strong>2. UNION ALL - Activity log:</strong></p>
<pre><code class="language-sql">-- All activities (duplicates OK)
SELECT user_id, &#39;login&#39; as action, created_at
FROM logins
UNION ALL
SELECT user_id, &#39;purchase&#39;, created_at
FROM purchases
UNION ALL
SELECT user_id, &#39;comment&#39;, created_at
FROM comments
ORDER BY created_at DESC;

-- Chronological activity feed
</code></pre>
<p><strong>3. INTERSECT - Users in both groups:</strong></p>
<pre><code class="language-sql">-- Users who are both customers AND suppliers
SELECT user_id FROM customers
INTERSECT
SELECT user_id FROM suppliers;

-- Find dual-role users
</code></pre>
<p><strong>4. EXCEPT - Missing records:</strong></p>
<pre><code class="language-sql">-- Products not yet ordered
SELECT product_id FROM products
EXCEPT
SELECT DISTINCT product_id FROM order_items;

-- Products never sold

-- Users who haven&#39;t logged in
SELECT id FROM users
EXCEPT
SELECT DISTINCT user_id FROM login_history;

-- Inactive users
</code></pre>
<hr>
<h3>Complex Examples</h3>
<p><strong>1. Find exclusive customers:</strong></p>
<pre><code class="language-sql">-- Customers who buy from us but not competitors
SELECT customer_id FROM our_customers
EXCEPT
SELECT customer_id FROM competitor_customers;
</code></pre>
<p><strong>2. Email lists:</strong></p>
<pre><code class="language-sql">-- Subscribed but not unsubscribed
SELECT email FROM subscriptions
EXCEPT
SELECT email FROM unsubscribes;

-- Active subscriber list
</code></pre>
<p><strong>3. Data validation:</strong></p>
<pre><code class="language-sql">-- Records in source but missing in target (data sync check)
SELECT id FROM source_table
EXCEPT
SELECT id FROM target_table;

-- Missing records that need syncing
</code></pre>
<p><strong>4. A/B testing:</strong></p>
<pre><code class="language-sql">-- Users in test group A who are NOT in test group B
SELECT user_id FROM test_group_a
EXCEPT
SELECT user_id FROM test_group_b;

-- Exclusive to group A
</code></pre>
<hr>
<h3>INTERSECT ALL and EXCEPT ALL</h3>
<pre><code class="language-sql">-- PostgreSQL supports ALL variants

-- INTERSECT ALL (keeps duplicate counts)
SELECT id FROM table1  -- {1, 1, 2}
INTERSECT ALL
SELECT id FROM table2; -- {1, 2, 2}
-- Result: {1, 2}  -- One &#39;1&#39; and one &#39;2&#39;

-- EXCEPT ALL (keeps duplicates in difference)
SELECT id FROM table1  -- {1, 1, 2}
EXCEPT ALL
SELECT id FROM table2; -- {1, 2, 2}
-- Result: {1}  -- One extra &#39;1&#39; from table1
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-sql">-- Fastest to slowest:
1. UNION ALL     -- No deduplication
2. UNION         -- Must deduplicate
3. INTERSECT     -- Must find common
4. EXCEPT        -- Must find difference

-- Always prefer UNION ALL when:
-- - No duplicates exist
-- - Duplicates acceptable
-- - Performance critical
</code></pre>
<hr>
<h3>Requirements (All Operations)</h3>
<pre><code class="language-sql">-- Same rules apply to all:
-- 1. Same number of columns
-- 2. Compatible data types
-- 3. Same column order

-- ✅ Valid
SELECT id, name FROM table1
UNION
SELECT id, title FROM table2;

-- ❌ Invalid
SELECT id, name, email FROM table1
UNION
SELECT id, name FROM table2;  -- Different column count
</code></pre>
<hr>
<h3>INTERSECT Alternative</h3>
<pre><code class="language-sql">-- INTERSECT not supported in MySQL
-- Use INNER JOIN instead:

-- PostgreSQL:
SELECT id FROM customers
INTERSECT
SELECT id FROM suppliers;

-- MySQL equivalent:
SELECT DISTINCT c.id
FROM customers c
INNER JOIN suppliers s ON c.id = s.id;
</code></pre>
<hr>
<h3>EXCEPT Alternative</h3>
<pre><code class="language-sql">-- EXCEPT not supported in MySQL
-- Use LEFT JOIN with NULL check:

-- PostgreSQL:
SELECT id FROM customers
EXCEPT
SELECT id FROM suppliers;

-- MySQL equivalent:
SELECT c.id
FROM customers c
LEFT JOIN suppliers s ON c.id = s.id
WHERE s.id IS NULL;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># UNION
User.where(active: true)
    .union(User.where(premium: true))

# UNION ALL
User.where(active: true)
    .union_all(User.where(premium: true))

# INTERSECT (gem: active_record_union)
User.where(active: true)
    .intersect(User.where(premium: true))

# EXCEPT
User.where(active: true)
    .except(User.where(banned: true))
</code></pre>
<hr>
<h3>Practical Use Cases</h3>
<p><strong>1. Marketing campaigns:</strong></p>
<pre><code class="language-sql">-- Email everyone except unsubscribed
SELECT email FROM customers
EXCEPT
SELECT email FROM unsubscribed;
</code></pre>
<p><strong>2. User segmentation:</strong></p>
<pre><code class="language-sql">-- Premium users who are also active
SELECT user_id FROM premium_subscriptions
INTERSECT
SELECT user_id FROM active_users;
</code></pre>
<p><strong>3. Inventory:</strong></p>
<pre><code class="language-sql">-- Products in catalog but out of stock
SELECT product_id FROM catalog
EXCEPT
SELECT product_id FROM inventory WHERE quantity &gt; 0;
</code></pre>
<p><strong>4. Access control:</strong></p>
<pre><code class="language-sql">-- Users with permission but not banned
SELECT user_id FROM permissions
EXCEPT
SELECT user_id FROM banned_users;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>UNION</strong> = all unique rows</li>
<li><strong>UNION ALL</strong> = all rows (fastest)</li>
<li><strong>INTERSECT</strong> = common rows only</li>
<li><strong>EXCEPT</strong> = difference (A - B)</li>
<li><strong>Same requirements</strong> for all</li>
<li><strong>UNION ALL</strong> most performant</li>
<li><strong>INTERSECT</strong> = overlap</li>
<li><strong>EXCEPT</strong> = exclusion</li>
<li><strong>Use JOINs</strong> for MySQL alternatives</li>
<li><strong>Choose</strong> based on logic needed</li>
</ol>
<hr>
<h2>Question 168: What is LIMIT and OFFSET?</h2>
<h3>Answer</h3>
<p><strong>LIMIT</strong> restricts the number of rows returned. <strong>OFFSET</strong> skips rows before returning results. Used together for pagination. LIMIT = row count, OFFSET = skip count.</p>
<hr>
<h3>Basic Syntax</h3>
<pre><code class="language-sql">-- Get first 10 rows
SELECT * FROM users
LIMIT 10;

-- Skip first 20, get next 10
SELECT * FROM users
LIMIT 10 OFFSET 20;

-- Alternative syntax (some databases)
SELECT * FROM users
OFFSET 20 ROWS
FETCH NEXT 10 ROWS ONLY;
</code></pre>
<hr>
<h3>LIMIT</h3>
<p><strong>Restrict result count:</strong></p>
<pre><code class="language-sql">-- Top 5 products
SELECT * FROM products
ORDER BY price DESC
LIMIT 5;

-- First user
SELECT * FROM users
ORDER BY created_at
LIMIT 1;

-- Latest 100 orders
SELECT * FROM orders
ORDER BY created_at DESC
LIMIT 100;
</code></pre>
<hr>
<h3>OFFSET</h3>
<p><strong>Skip rows:</strong></p>
<pre><code class="language-sql">-- Skip first 10 rows
SELECT * FROM users
OFFSET 10;

-- Get all except first 5
SELECT * FROM products
ORDER BY price
OFFSET 5;
</code></pre>
<hr>
<h3>LIMIT with OFFSET (Pagination)</h3>
<p><strong>Standard pagination pattern:</strong></p>
<pre><code class="language-sql">-- Page 1 (rows 1-10)
SELECT * FROM products
ORDER BY id
LIMIT 10 OFFSET 0;

-- Page 2 (rows 11-20)
SELECT * FROM products
ORDER BY id
LIMIT 10 OFFSET 10;

-- Page 3 (rows 21-30)
SELECT * FROM products
ORDER BY id
LIMIT 10 OFFSET 20;

-- Formula: OFFSET = (page - 1) * page_size
-- Page 5, size 20: OFFSET = (5-1) * 20 = 80
</code></pre>
<hr>
<h3>Pagination Example</h3>
<pre><code class="language-sql">-- Function to calculate offset
-- page_number: 1, 2, 3, ...
-- page_size: 10, 20, 50, ...

OFFSET = (page_number - 1) * page_size

-- Page 1, size 10
LIMIT 10 OFFSET 0   -- rows 1-10

-- Page 2, size 10
LIMIT 10 OFFSET 10  -- rows 11-20

-- Page 3, size 10
LIMIT 10 OFFSET 20  -- rows 21-30

-- Page 10, size 25
LIMIT 25 OFFSET 225 -- rows 226-250
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<p><strong>Problem with large OFFSET:</strong></p>
<pre><code class="language-sql">-- ❌ Slow for large offsets
SELECT * FROM users
LIMIT 10 OFFSET 1000000;

-- Database must:
-- 1. Process all 1,000,000 rows
-- 2. Skip them
-- 3. Return next 10
-- Very inefficient!

-- ✅ Better: Keyset pagination
SELECT * FROM users
WHERE id &gt; 1000000
ORDER BY id
LIMIT 10;

-- Uses index, much faster
</code></pre>
<p><strong>Keyset (Cursor) Pagination:</strong></p>
<pre><code class="language-sql">-- Page 1
SELECT * FROM users
ORDER BY id
LIMIT 10;
-- Returns: ids 1-10, last_id = 10

-- Page 2 (use last_id from page 1)
SELECT * FROM users
WHERE id &gt; 10
ORDER BY id
LIMIT 10;
-- Returns: ids 11-20, last_id = 20

-- Page 3
SELECT * FROM users
WHERE id &gt; 20
ORDER BY id
LIMIT 10;

-- Benefits:
-- ✅ No OFFSET needed
-- ✅ Consistent performance
-- ✅ Works with real-time data
</code></pre>
<hr>
<h3>Database-Specific Syntax</h3>
<p><strong>PostgreSQL:</strong></p>
<pre><code class="language-sql">SELECT * FROM users
LIMIT 10 OFFSET 20;

-- Or
SELECT * FROM users
OFFSET 20
FETCH FIRST 10 ROWS ONLY;
</code></pre>
<p><strong>MySQL:</strong></p>
<pre><code class="language-sql">SELECT * FROM users
LIMIT 10 OFFSET 20;

-- Or short form
SELECT * FROM users
LIMIT 20, 10;  -- LIMIT offset, count
</code></pre>
<p><strong>SQL Server:</strong></p>
<pre><code class="language-sql">-- SQL Server 2012+
SELECT * FROM users
ORDER BY id
OFFSET 20 ROWS
FETCH NEXT 10 ROWS ONLY;

-- Older SQL Server (TOP)
SELECT TOP 10 * FROM users
WHERE id NOT IN (
  SELECT TOP 20 id FROM users ORDER BY id
)
ORDER BY id;
</code></pre>
<p><strong>Oracle:</strong></p>
<pre><code class="language-sql">-- Oracle 12c+
SELECT * FROM users
ORDER BY id
OFFSET 20 ROWS
FETCH NEXT 10 ROWS ONLY;

-- Older Oracle (ROWNUM)
SELECT * FROM (
  SELECT a.*, ROWNUM rnum FROM (
    SELECT * FROM users ORDER BY id
  ) a
  WHERE ROWNUM &lt;= 30
)
WHERE rnum &gt; 20;
</code></pre>
<hr>
<h3>Common Patterns</h3>
<p><strong>1. Top N:</strong></p>
<pre><code class="language-sql">-- Top 10 sellers
SELECT * FROM products
ORDER BY sales DESC
LIMIT 10;

-- Top 5 rated
SELECT * FROM movies
ORDER BY rating DESC
LIMIT 5;
</code></pre>
<p><strong>2. Random sample:</strong></p>
<pre><code class="language-sql">-- 100 random users
SELECT * FROM users
ORDER BY RANDOM()
LIMIT 100;
</code></pre>
<p><strong>3. Skip first, get next:</strong></p>
<pre><code class="language-sql">-- Skip winner (1st), get runners-up (2nd-4th)
SELECT * FROM race_results
ORDER BY finish_time
LIMIT 3 OFFSET 1;
</code></pre>
<p><strong>4. Preview with &quot;load more&quot;:</strong></p>
<pre><code class="language-sql">-- Initial load: 20 items
SELECT * FROM posts
ORDER BY created_at DESC
LIMIT 20;

-- Load more: next 20
SELECT * FROM posts
ORDER BY created_at DESC
LIMIT 20 OFFSET 20;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># LIMIT
User.limit(10)
# SELECT * FROM users LIMIT 10

# OFFSET
User.offset(20)
# SELECT * FROM users OFFSET 20

# Both (pagination)
User.limit(10).offset(20)
# SELECT * FROM users LIMIT 10 OFFSET 20

# Page helper
User.page(3).per(10)
# SELECT * FROM users LIMIT 10 OFFSET 20

# Using Kaminari gem
@users = User.page(params[:page]).per(25)

# Keyset pagination
User.where(&#39;id &gt; ?&#39;, last_seen_id).limit(10)
</code></pre>
<hr>
<h3>Pagination Helpers</h3>
<p><strong>Calculate total pages:</strong></p>
<pre><code class="language-sql">-- Total records
SELECT COUNT(*) FROM users;  -- 1,543

-- Page size: 25
-- Total pages: CEIL(1543 / 25) = 62 pages

-- Page 1: OFFSET 0
-- Page 2: OFFSET 25
-- ...
-- Page 62: OFFSET 1525
</code></pre>
<p><strong>Ruby example:</strong></p>
<pre><code class="language-ruby"># Pagination calculation
total_records = User.count         # 1543
page_size = 25
page_number = params[:page].to_i   # 3

offset = (page_number - 1) * page_size  # 50
total_pages = (total_records.to_f / page_size).ceil  # 62

@users = User.limit(page_size).offset(offset)
</code></pre>
<hr>
<h3>Pitfalls</h3>
<p><strong>1. Missing ORDER BY:</strong></p>
<pre><code class="language-sql">-- ❌ Unpredictable results
SELECT * FROM users
LIMIT 10;

-- May return different rows each time
-- Database chooses arbitrary order

-- ✅ Always use ORDER BY
SELECT * FROM users
ORDER BY id
LIMIT 10;
</code></pre>
<p><strong>2. Data changes between pages:</strong></p>
<pre><code class="language-sql">-- User views page 1
SELECT * FROM posts
ORDER BY created_at DESC
LIMIT 10 OFFSET 0;

-- New post added

-- User views page 2
SELECT * FROM posts
ORDER BY created_at DESC
LIMIT 10 OFFSET 10;

-- May miss or duplicate a post!
-- Solution: Keyset pagination or snapshot
</code></pre>
<p><strong>3. Large OFFSET performance:</strong></p>
<pre><code class="language-sql">-- ❌ Very slow
SELECT * FROM logs
LIMIT 100 OFFSET 10000000;

-- Must scan 10 million rows

-- ✅ Use keyset instead
SELECT * FROM logs
WHERE id &gt; last_seen_id
ORDER BY id
LIMIT 100;
</code></pre>
<hr>
<h3>Best Practices</h3>
<pre><code class="language-sql">-- ✅ Always include ORDER BY
SELECT * FROM users
ORDER BY created_at DESC
LIMIT 10;

-- ✅ Use indexes on ORDER BY columns
CREATE INDEX idx_users_created_at ON users(created_at);

-- ✅ Consider keyset pagination for large datasets
SELECT * FROM users
WHERE id &gt; ?
ORDER BY id
LIMIT 10;

-- ✅ Validate page numbers
-- Prevent: OFFSET -10 or OFFSET 999999999

-- ✅ Cache total count for large tables
-- Don&#39;t COUNT(*) on every request
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>LIMIT</strong> restricts row count</li>
<li><strong>OFFSET</strong> skips rows</li>
<li><strong>Together</strong> for pagination</li>
<li><strong>Always</strong> use ORDER BY</li>
<li><strong>Large OFFSET</strong> slow</li>
<li><strong>Keyset pagination</strong> better for scale</li>
<li><strong>Formula</strong>: OFFSET = (page-1) × size</li>
<li><strong>Index</strong> ORDER BY columns</li>
<li><strong>Syntax varies</strong> by database</li>
<li><strong>Rails</strong> has pagination gems</li>
</ol>
<hr>
<h2>Question 169: How do you remove duplicate records from a table?</h2>
<h3>Answer</h3>
<p>Remove duplicates using <strong>DELETE with self-join</strong>, <strong>ROW_NUMBER window function</strong>, <strong>DISTINCT with INSERT</strong>, or <strong>CREATE TABLE AS</strong>. Method depends on database and whether to keep one copy or delete all.</p>
<hr>
<h3>Method 1: DELETE with Self-Join (Keep One)</h3>
<pre><code class="language-sql">-- Users table with duplicates
id | email              | name
1  | alice@example.com  | Alice
2  | bob@example.com    | Bob
3  | alice@example.com  | Alice (duplicate)
4  | charlie@example.com| Charlie
5  | bob@example.com    | Bob (duplicate)

-- Delete duplicates, keep lowest id
DELETE FROM users u1
USING users u2
WHERE u1.id &gt; u2.id
  AND u1.email = u2.email;

-- Result: Keeps ids 1, 2, 4
-- Deletes ids 3, 5

-- PostgreSQL/MySQL syntax varies
</code></pre>
<hr>
<h3>Method 2: Window Function (ROW_NUMBER)</h3>
<pre><code class="language-sql">-- PostgreSQL - Delete all but first occurrence
WITH cte AS (
  SELECT 
    id,
    ROW_NUMBER() OVER (
      PARTITION BY email 
      ORDER BY id
    ) AS row_num
  FROM users
)
DELETE FROM users
WHERE id IN (
  SELECT id 
  FROM cte 
  WHERE row_num &gt; 1
);

-- Keeps first occurrence (lowest id) per email
-- Deletes all others
</code></pre>
<hr>
<h3>Method 3: DISTINCT INTO New Table</h3>
<pre><code class="language-sql">-- Create new table with unique records
CREATE TABLE users_unique AS
SELECT DISTINCT ON (email)
  id, email, name, created_at
FROM users
ORDER BY email, id;

-- Drop old table, rename new
DROP TABLE users;
ALTER TABLE users_unique RENAME TO users;

-- Or INSERT approach:
CREATE TABLE users_temp LIKE users;

INSERT INTO users_temp
SELECT DISTINCT email, name, created_at
FROM users;

DROP TABLE users;
ALTER TABLE users_temp RENAME TO users;
</code></pre>
<hr>
<h3>Method 4: GROUP BY with MIN/MAX</h3>
<pre><code class="language-sql">-- Keep oldest record (MIN id)
DELETE FROM users
WHERE id NOT IN (
  SELECT MIN(id)
  FROM users
  GROUP BY email
);

-- Or keep newest (MAX id)
DELETE FROM users
WHERE id NOT IN (
  SELECT MAX(id)
  FROM users
  GROUP BY email
);
</code></pre>
<hr>
<h3>Database-Specific Solutions</h3>
<p><strong>PostgreSQL:</strong></p>
<pre><code class="language-sql">-- Using DISTINCT ON
DELETE FROM users
WHERE id NOT IN (
  SELECT DISTINCT ON (email) id
  FROM users
  ORDER BY email, id
);

-- Or WITH CTE
WITH duplicates AS (
  SELECT id,
    ROW_NUMBER() OVER (
      PARTITION BY email 
      ORDER BY id
    ) AS rn
  FROM users
)
DELETE FROM users
WHERE id IN (
  SELECT id FROM duplicates WHERE rn &gt; 1
);
</code></pre>
<p><strong>MySQL:</strong></p>
<pre><code class="language-sql">-- Cannot delete from same table in subquery
-- Use temporary table:
DELETE u1 FROM users u1
INNER JOIN users u2
WHERE u1.id &gt; u2.id
  AND u1.email = u2.email;

-- Or:
DELETE FROM users
WHERE id NOT IN (
  SELECT id FROM (
    SELECT MIN(id) AS id
    FROM users
    GROUP BY email
  ) AS keep
);
</code></pre>
<p><strong>SQL Server:</strong></p>
<pre><code class="language-sql">-- Using CTE and ROW_NUMBER
WITH DuplicateCTE AS (
  SELECT *,
    ROW_NUMBER() OVER (
      PARTITION BY email 
      ORDER BY id
    ) AS RowNum
  FROM users
)
DELETE FROM DuplicateCTE
WHERE RowNum &gt; 1;
</code></pre>
<hr>
<h3>Multiple Column Duplicates</h3>
<pre><code class="language-sql">-- Duplicates based on multiple columns
DELETE FROM contacts c1
USING contacts c2
WHERE c1.id &gt; c2.id
  AND c1.email = c2.email
  AND c1.phone = c2.phone;

-- Or with ROW_NUMBER:
WITH dups AS (
  SELECT id,
    ROW_NUMBER() OVER (
      PARTITION BY email, phone 
      ORDER BY id
    ) AS rn
  FROM contacts
)
DELETE FROM contacts
WHERE id IN (
  SELECT id FROM dups WHERE rn &gt; 1
);
</code></pre>
<hr>
<h3>Prevention Strategies</h3>
<p><strong>1. Add UNIQUE constraint:</strong></p>
<pre><code class="language-sql">-- Prevent future duplicates
ALTER TABLE users
ADD CONSTRAINT unique_email UNIQUE (email);

-- Composite unique constraint
ALTER TABLE contacts
ADD CONSTRAINT unique_email_phone 
UNIQUE (email, phone);
</code></pre>
<p><strong>2. Partial unique index:</strong></p>
<pre><code class="language-sql">-- PostgreSQL - unique only for active records
CREATE UNIQUE INDEX unique_active_email
ON users (email)
WHERE active = true;
</code></pre>
<p><strong>3. Before insert check:</strong></p>
<pre><code class="language-sql">-- Application level
INSERT INTO users (email, name)
SELECT &#39;new@example.com&#39;, &#39;New User&#39;
WHERE NOT EXISTS (
  SELECT 1 FROM users WHERE email = &#39;new@example.com&#39;
);
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># Method 1: Find and delete duplicates
User.select(:email)
    .group(:email)
    .having(&#39;COUNT(*) &gt; 1&#39;)
    .each do |duplicate|
      # Keep first, delete rest
      users = User.where(email: duplicate.email)
      users.offset(1).destroy_all
    end

# Method 2: Raw SQL
ActiveRecord::Base.connection.execute(&lt;&lt;-SQL)
  DELETE FROM users u1
  USING users u2
  WHERE u1.id &gt; u2.id
    AND u1.email = u2.email;
SQL

# Method 3: Recreate table
User.connection.execute(&lt;&lt;-SQL)
  CREATE TABLE users_unique AS
  SELECT DISTINCT ON (email) *
  FROM users
  ORDER BY email, id;
SQL

# Prevention: Validation
class User &lt; ApplicationRecord
  validates :email, uniqueness: true
end

# Migration: Add unique index
add_index :users, :email, unique: true
</code></pre>
<hr>
<h3>Identify Duplicates Before Deleting</h3>
<pre><code class="language-sql">-- Find duplicate emails
SELECT email, COUNT(*) as count
FROM users
GROUP BY email
HAVING COUNT(*) &gt; 1
ORDER BY count DESC;

-- Show all duplicate records
SELECT *
FROM users
WHERE email IN (
  SELECT email
  FROM users
  GROUP BY email
  HAVING COUNT(*) &gt; 1
)
ORDER BY email, id;

-- Count total duplicates
SELECT COUNT(*) - COUNT(DISTINCT email) as duplicate_count
FROM users;
</code></pre>
<hr>
<h3>Keep Specific Record</h3>
<pre><code class="language-sql">-- Keep most recent (by created_at)
DELETE FROM users
WHERE id NOT IN (
  SELECT id FROM (
    SELECT DISTINCT ON (email) id
    FROM users
    ORDER BY email, created_at DESC
  ) AS keep
);

-- Keep record with most data (non-null columns)
WITH ranked AS (
  SELECT *,
    ROW_NUMBER() OVER (
      PARTITION BY email
      ORDER BY 
        CASE WHEN phone IS NULL THEN 1 ELSE 0 END,
        CASE WHEN address IS NULL THEN 1 ELSE 0 END,
        id
    ) AS rn
  FROM users
)
DELETE FROM users
WHERE id IN (
  SELECT id FROM ranked WHERE rn &gt; 1
);
</code></pre>
<hr>
<h3>Backup Before Deleting</h3>
<pre><code class="language-sql">-- Create backup table
CREATE TABLE users_backup AS
SELECT * FROM users;

-- Or export to file
COPY users TO &#39;/tmp/users_backup.csv&#39; CSV HEADER;

-- Then delete duplicates
DELETE FROM users u1
USING users u2
WHERE u1.id &gt; u2.id
  AND u1.email = u2.email;

-- Verify
SELECT COUNT(*) FROM users;
SELECT COUNT(DISTINCT email) FROM users;
-- Counts should match

-- If something wrong, restore
DROP TABLE users;
ALTER TABLE users_backup RENAME TO users;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Multiple methods</strong> available</li>
<li><strong>Backup first</strong> always</li>
<li><strong>ROW_NUMBER</strong> most flexible</li>
<li><strong>Self-join</strong> simple</li>
<li><strong>Keep criteria</strong> matters</li>
<li><strong>UNIQUE constraint</strong> prevents</li>
<li><strong>Test on copy</strong> first</li>
<li><strong>Database-specific</strong> syntax</li>
<li><strong>Verify results</strong> after</li>
<li><strong>Prevention</strong> better than cure</li>
</ol>
<hr>
<h2>Aggregate Functions</h2>
<h2>Question 170: What is the difference between COUNT(*) and COUNT(column_name)?</h2>
<h3>Answer</h3>
<p><strong>COUNT(*)</strong> counts all rows including NULLs. <strong>COUNT(column_name)</strong> counts only non-NULL values in that column. COUNT(*) = total rows, COUNT(column) = non-NULL values.</p>
<hr>
<h3>COUNT(*)</h3>
<p><strong>Counts all rows:</strong></p>
<pre><code class="language-sql">-- users table
id | name    | email
1  | Alice   | alice@example.com
2  | Bob     | NULL
3  | Charlie | charlie@example.com
4  | David   | NULL

-- Count all rows
SELECT COUNT(*) FROM users;
-- Result: 4 (includes rows with NULL email)
</code></pre>
<hr>
<h3>COUNT(column_name)</h3>
<p><strong>Counts non-NULL values:</strong></p>
<pre><code class="language-sql">-- Count non-NULL emails
SELECT COUNT(email) FROM users;
-- Result: 2 (only Alice and Charlie)

-- Count non-NULL names
SELECT COUNT(name) FROM users;
-- Result: 4 (all have names)
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>COUNT(*)</th>
<th>COUNT(column)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NULL values</strong></td>
<td>Counted</td>
<td>Ignored</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Slightly faster</td>
<td>Checks for NULL</td>
</tr>
<tr>
<td><strong>Use when</strong></td>
<td>Total rows</td>
<td>Non-NULL count</td>
</tr>
<tr>
<td><strong>Result</strong></td>
<td>Total row count</td>
<td>Non-NULL count</td>
</tr>
</tbody></table>
<hr>
<h3>Examples</h3>
<p><strong>1. Total vs present:</strong></p>
<pre><code class="language-sql">-- Total users
SELECT COUNT(*) as total_users
FROM users;
-- Result: 1000

-- Users with email
SELECT COUNT(email) as users_with_email
FROM users;
-- Result: 850

-- Users missing email
SELECT 
  COUNT(*) - COUNT(email) as users_without_email
FROM users;
-- Result: 150
</code></pre>
<p><strong>2. Multiple columns:</strong></p>
<pre><code class="language-sql">SELECT 
  COUNT(*) as total,
  COUNT(email) as with_email,
  COUNT(phone) as with_phone,
  COUNT(address) as with_address
FROM users;

-- Result:
total | with_email | with_phone | with_address
1000  | 850        | 650        | 400
</code></pre>
<p><strong>3. Percentage calculation:</strong></p>
<pre><code class="language-sql">SELECT 
  COUNT(*) as total,
  COUNT(email) as with_email,
  ROUND(COUNT(email) * 100.0 / COUNT(*), 2) as email_percentage
FROM users;

-- Result:
total | with_email | email_percentage
1000  | 850        | 85.00
</code></pre>
<hr>
<h3>COUNT(DISTINCT column)</h3>
<p><strong>Count unique non-NULL values:</strong></p>
<pre><code class="language-sql">-- orders table
id | user_id | product
1  | 1       | Laptop
2  | 1       | Mouse
3  | 2       | Laptop
4  | 2       | Keyboard
5  | 3       | Laptop

-- Total orders
SELECT COUNT(*) FROM orders;
-- Result: 5

-- Total users who ordered
SELECT COUNT(DISTINCT user_id) FROM orders;
-- Result: 3

-- Total unique products ordered
SELECT COUNT(DISTINCT product) FROM orders;
-- Result: 3 (Laptop, Mouse, Keyboard)
</code></pre>
<hr>
<h3>COUNT with WHERE</h3>
<pre><code class="language-sql">-- Count specific rows
SELECT COUNT(*) as active_users
FROM users
WHERE status = &#39;active&#39;;

SELECT COUNT(*) as premium_users
FROM users
WHERE subscription = &#39;premium&#39;;

-- Count with conditions
SELECT 
  COUNT(*) as total,
  COUNT(CASE WHEN status = &#39;active&#39; THEN 1 END) as active,
  COUNT(CASE WHEN subscription = &#39;premium&#39; THEN 1 END) as premium
FROM users;
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-sql">-- COUNT(*) optimized by databases
SELECT COUNT(*) FROM large_table;
-- Usually uses index or metadata
-- Very fast even for millions of rows

-- COUNT(column) may be slower
SELECT COUNT(nullable_column) FROM large_table;
-- Must check each value for NULL
-- Still fast with index

-- Avoid SELECT COUNT(*) with complex conditions
-- ❌ Slow
SELECT COUNT(*) FROM large_table
WHERE complex_calculation &gt; threshold;

-- ✅ Better with index
CREATE INDEX idx_calc ON large_table(complex_calculation);
</code></pre>
<hr>
<h3>NULL Handling Examples</h3>
<pre><code class="language-sql">-- All return same result
SELECT COUNT(*) FROM users WHERE email IS NOT NULL;
SELECT COUNT(email) FROM users;

-- Both count non-NULL emails

-- Find NULL counts
SELECT 
  COUNT(*) - COUNT(email) as null_count
FROM users;

-- Or explicitly
SELECT COUNT(*) as null_emails
FROM users
WHERE email IS NULL;
</code></pre>
<hr>
<h3>GROUP BY with COUNT</h3>
<pre><code class="language-sql">-- Count per group
SELECT 
  category,
  COUNT(*) as total_products,
  COUNT(description) as with_description
FROM products
GROUP BY category;

-- Result:
category    | total_products | with_description
Electronics | 100            | 85
Clothing    | 200            | 200
Books       | 150            | 140
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># COUNT(*)
User.count
# SELECT COUNT(*) FROM users

# COUNT(column)
User.count(:email)
# SELECT COUNT(email) FROM users

# COUNT(DISTINCT column)
Order.distinct.count(:user_id)
# SELECT COUNT(DISTINCT user_id) FROM orders

# With conditions
User.where(status: &#39;active&#39;).count

# Multiple counts
User.select(&#39;
  COUNT(*) as total,
  COUNT(email) as with_email
&#39;).first

# Grouped count
Order.group(:user_id).count
# =&gt; { 1 =&gt; 5, 2 =&gt; 3, 3 =&gt; 8 }
</code></pre>
<hr>
<h3>Common Pitfalls</h3>
<p><strong>1. Assuming COUNT(*) ignores NULLs:</strong></p>
<pre><code class="language-sql">-- ❌ Wrong assumption
SELECT COUNT(*) FROM users WHERE email IS NOT NULL;
-- Unnecessarily complex

-- ✅ Simpler
SELECT COUNT(email) FROM users;
-- Same result
</code></pre>
<p><strong>2. Using COUNT(1) vs COUNT(*):</strong></p>
<pre><code class="language-sql">-- Both identical in modern databases
SELECT COUNT(1) FROM users;
SELECT COUNT(*) FROM users;

-- COUNT(1) not faster
-- Use COUNT(*) for clarity
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>COUNT(*)</strong> counts all rows</li>
<li><strong>COUNT(column)</strong> counts non-NULL</li>
<li><strong>COUNT(*)</strong> includes NULLs</li>
<li><strong>COUNT(column)</strong> excludes NULLs</li>
<li><strong>COUNT(DISTINCT)</strong> for unique</li>
<li><strong>COUNT(*)</strong> usually faster</li>
<li><strong>Use COUNT(column)</strong> when NULLs matter</li>
<li><strong>Use COUNT(*)</strong> for totals</li>
<li><strong>Performance</strong> generally good</li>
<li><strong>INDEX</strong> helps both</li>
</ol>
<hr>
<h2>Question 171: What is the difference between SUM and COUNT?</h2>
<h3>Answer</h3>
<p><strong>SUM</strong> adds up numeric values. <strong>COUNT</strong> counts rows or non-NULL values. SUM = total value, COUNT = row count.</p>
<hr>
<h3>SUM</h3>
<p><strong>Adds numeric values:</strong></p>
<pre><code class="language-sql">-- orders table
id | user_id | amount
1  | 1       | 100
2  | 1       | 200
3  | 2       | 150
4  | 2       | NULL
5  | 3       | 300

-- Total revenue
SELECT SUM(amount) FROM orders;
-- Result: 750 (100+200+150+300, NULL ignored)
</code></pre>
<hr>
<h3>COUNT</h3>
<p><strong>Counts rows:</strong></p>
<pre><code class="language-sql">-- Count all orders
SELECT COUNT(*) FROM orders;
-- Result: 5

-- Count orders with amount
SELECT COUNT(amount) FROM orders;
-- Result: 4 (NULL excluded)
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>SUM</th>
<th>COUNT</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Operation</strong></td>
<td>Addition</td>
<td>Counting</td>
</tr>
<tr>
<td><strong>Input</strong></td>
<td>Numeric values</td>
<td>Rows/Values</td>
</tr>
<tr>
<td><strong>NULL</strong></td>
<td>Ignored in sum</td>
<td>Excluded from count</td>
</tr>
<tr>
<td><strong>Result type</strong></td>
<td>Number (sum)</td>
<td>Integer (count)</td>
</tr>
<tr>
<td><strong>Use for</strong></td>
<td>Totals, revenue</td>
<td>Quantities, frequency</td>
</tr>
</tbody></table>
<hr>
<h3>Common Use Cases</h3>
<p><strong>SUM:</strong></p>
<pre><code class="language-sql">-- Total revenue
SELECT SUM(amount) as total_revenue FROM orders;

-- Revenue per user
SELECT user_id, SUM(amount) as user_total
FROM orders
GROUP BY user_id;

-- Total inventory value
SELECT SUM(price * quantity) as inventory_value
FROM products;
</code></pre>
<p><strong>COUNT:</strong></p>
<pre><code class="language-sql">-- Total orders
SELECT COUNT(*) as order_count FROM orders;

-- Orders per user
SELECT user_id, COUNT(*) as order_count
FROM orders
GROUP BY user_id;

-- Active products
SELECT COUNT(*) as active_products
FROM products
WHERE status = &#39;active&#39;;
</code></pre>
<hr>
<h3>Together</h3>
<pre><code class="language-sql">-- Order statistics per user
SELECT 
  user_id,
  COUNT(*) as order_count,
  SUM(amount) as total_spent,
  AVG(amount) as avg_order_value
FROM orders
GROUP BY user_id;

-- Result:
user_id | order_count | total_spent | avg_order_value
1       | 2           | 300         | 150.00
2       | 2           | 150         | 150.00  -- NULL ignored
3       | 1           | 300         | 300.00
</code></pre>
<hr>
<h3>NULL Handling</h3>
<pre><code class="language-sql">-- Both ignore NULL
SELECT 
  SUM(amount) as sum,        -- 750 (ignores NULL)
  COUNT(amount) as count,    -- 4 (ignores NULL)
  AVG(amount) as avg         -- 187.5 (750/4)
FROM orders;

-- SUM(NULL) = NULL (if all NULL)
SELECT SUM(amount) FROM orders WHERE amount IS NULL;
-- Result: NULL

-- COUNT(*) includes NULL rows
-- COUNT(column) excludes NULL values
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>SUM</strong> adds values</li>
<li><strong>COUNT</strong> counts rows</li>
<li><strong>SUM</strong> requires numbers</li>
<li><strong>COUNT</strong> works on any type</li>
<li><strong>Both</strong> ignore NULL (in calculation)</li>
<li><strong>Use together</strong> for stats</li>
<li><strong>SUM</strong> for totals</li>
<li><strong>COUNT</strong> for quantities</li>
<li><strong>GROUP BY</strong> for breakdowns</li>
<li><strong>Different purposes</strong></li>
</ol>
<hr>
<h2>Question 172: How do you perform aggregate queries (SUM, COUNT, AVG, MAX, MIN)?</h2>
<h3>Answer</h3>
<p><strong>Aggregate functions</strong> perform calculations across multiple rows: <strong>SUM</strong> (total), <strong>COUNT</strong> (count), <strong>AVG</strong> (average), <strong>MAX</strong> (maximum), <strong>MIN</strong> (minimum). Used with or without GROUP BY.</p>
<hr>
<h3>Basic Aggregate Functions</h3>
<p><strong>1. COUNT - Count rows:</strong></p>
<pre><code class="language-sql">-- Total orders
SELECT COUNT(*) as total FROM orders;
-- Result: 100

-- Non-NULL values
SELECT COUNT(email) as with_email FROM users;

-- Distinct values
SELECT COUNT(DISTINCT user_id) as unique_users FROM orders;
</code></pre>
<p><strong>2. SUM - Add values:</strong></p>
<pre><code class="language-sql">-- Total revenue
SELECT SUM(amount) as revenue FROM orders;
-- Result: 15000.00

-- Total quantity
SELECT SUM(quantity) as total_items FROM order_items;
</code></pre>
<p><strong>3. AVG - Average:</strong></p>
<pre><code class="language-sql">-- Average order value
SELECT AVG(amount) as avg_order FROM orders;
-- Result: 150.00

-- Average rating
SELECT AVG(rating) as avg_rating FROM reviews;
-- Result: 4.2
</code></pre>
<p><strong>4. MAX - Maximum:</strong></p>
<pre><code class="language-sql">-- Highest price
SELECT MAX(price) as max_price FROM products;
-- Result: 999.99

-- Latest order
SELECT MAX(created_at) as latest_order FROM orders;
</code></pre>
<p><strong>5. MIN - Minimum:</strong></p>
<pre><code class="language-sql">-- Lowest price
SELECT MIN(price) as min_price FROM products;
-- Result: 9.99

-- Earliest order
SELECT MIN(created_at) as first_order FROM orders;
</code></pre>
<hr>
<h3>Multiple Aggregates</h3>
<pre><code class="language-sql">-- Order statistics
SELECT 
  COUNT(*) as total_orders,
  SUM(amount) as total_revenue,
  AVG(amount) as avg_order_value,
  MAX(amount) as largest_order,
  MIN(amount) as smallest_order
FROM orders;

-- Result:
total_orders | total_revenue | avg_order_value | largest_order | smallest_order
100          | 15000.00      | 150.00          | 500.00        | 10.00
</code></pre>
<hr>
<h3>GROUP BY with Aggregates</h3>
<pre><code class="language-sql">-- Revenue per user
SELECT 
  user_id,
  COUNT(*) as orders,
  SUM(amount) as revenue,
  AVG(amount) as avg_order,
  MAX(amount) as largest,
  MIN(amount) as smallest
FROM orders
GROUP BY user_id
ORDER BY revenue DESC;

-- Result:
user_id | orders | revenue | avg_order | largest | smallest
5       | 20     | 5000    | 250.00    | 500     | 100
3       | 15     | 3000    | 200.00    | 400     | 50
1       | 10     | 2000    | 200.00    | 300     | 100
</code></pre>
<hr>
<h3>Aggregates with WHERE</h3>
<pre><code class="language-sql">-- Filter BEFORE aggregation
SELECT 
  COUNT(*) as completed_orders,
  SUM(amount) as completed_revenue
FROM orders
WHERE status = &#39;completed&#39;;

-- Revenue per category for active products
SELECT 
  category,
  COUNT(*) as product_count,
  AVG(price) as avg_price
FROM products
WHERE active = true
GROUP BY category;
</code></pre>
<hr>
<h3>Aggregates with HAVING</h3>
<pre><code class="language-sql">-- Filter AFTER aggregation
SELECT 
  user_id,
  COUNT(*) as orders,
  SUM(amount) as revenue
FROM orders
GROUP BY user_id
HAVING SUM(amount) &gt; 1000
ORDER BY revenue DESC;

-- Only users with revenue &gt; $1000
</code></pre>
<hr>
<h3>Conditional Aggregates</h3>
<pre><code class="language-sql">-- Count by condition
SELECT 
  COUNT(*) as total,
  COUNT(CASE WHEN status = &#39;completed&#39; THEN 1 END) as completed,
  COUNT(CASE WHEN status = &#39;pending&#39; THEN 1 END) as pending,
  COUNT(CASE WHEN status = &#39;cancelled&#39; THEN 1 END) as cancelled
FROM orders;

-- Sum by condition
SELECT 
  user_id,
  SUM(CASE WHEN status = &#39;completed&#39; THEN amount ELSE 0 END) as completed_revenue,
  SUM(CASE WHEN status = &#39;refunded&#39; THEN amount ELSE 0 END) as refunded_amount
FROM orders
GROUP BY user_id;
</code></pre>
<hr>
<h3>Advanced Aggregates</h3>
<p><strong>1. STDDEV - Standard deviation:</strong></p>
<pre><code class="language-sql">-- Price variance
SELECT 
  category,
  AVG(price) as avg_price,
  STDDEV(price) as price_stddev
FROM products
GROUP BY category;
</code></pre>
<p><strong>2. VARIANCE:</strong></p>
<pre><code class="language-sql">-- Statistical variance
SELECT 
  VARIANCE(price) as price_variance
FROM products;
</code></pre>
<p><strong>3. String aggregation (PostgreSQL):</strong></p>
<pre><code class="language-sql">-- Concatenate values
SELECT 
  user_id,
  STRING_AGG(product_name, &#39;, &#39;) as products
FROM purchases
GROUP BY user_id;

-- Result:
user_id | products
1       | Laptop, Mouse, Keyboard
2       | Phone, Charger
</code></pre>
<p><strong>4. Array aggregation (PostgreSQL):</strong></p>
<pre><code class="language-sql">-- Collect into array
SELECT 
  user_id,
  ARRAY_AGG(product_id) as product_ids
FROM purchases
GROUP BY user_id;
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Sales dashboard:</strong></p>
<pre><code class="language-sql">SELECT 
  DATE(created_at) as date,
  COUNT(*) as orders,
  SUM(amount) as revenue,
  AVG(amount) as avg_order,
  COUNT(DISTINCT user_id) as unique_customers
FROM orders
WHERE created_at &gt;= CURRENT_DATE - INTERVAL &#39;30 days&#39;
GROUP BY DATE(created_at)
ORDER BY date DESC;
</code></pre>
<p><strong>2. Product performance:</strong></p>
<pre><code class="language-sql">SELECT 
  p.name,
  p.category,
  COUNT(oi.id) as times_sold,
  SUM(oi.quantity) as total_quantity,
  SUM(oi.price * oi.quantity) as revenue,
  AVG(r.rating) as avg_rating
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN reviews r ON p.id = r.product_id
GROUP BY p.id, p.name, p.category
HAVING COUNT(oi.id) &gt; 0
ORDER BY revenue DESC
LIMIT 10;
</code></pre>
<p><strong>3. User segmentation:</strong></p>
<pre><code class="language-sql">SELECT 
  CASE 
    WHEN total_spent &gt;= 10000 THEN &#39;VIP&#39;
    WHEN total_spent &gt;= 1000 THEN &#39;Premium&#39;
    WHEN total_spent &gt;= 100 THEN &#39;Regular&#39;
    ELSE &#39;New&#39;
  END as segment,
  COUNT(*) as users,
  AVG(total_spent) as avg_spent
FROM (
  SELECT 
    user_id,
    SUM(amount) as total_spent
  FROM orders
  GROUP BY user_id
) user_totals
GROUP BY segment;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># COUNT
Order.count
Order.where(status: &#39;completed&#39;).count

# SUM
Order.sum(:amount)
Order.where(status: &#39;completed&#39;).sum(:amount)

# AVG
Product.average(:price)

# MAX/MIN
Product.maximum(:price)
Product.minimum(:price)

# Multiple aggregates
Order.select(&#39;
  COUNT(*) as order_count,
  SUM(amount) as revenue,
  AVG(amount) as avg_order
&#39;).first

# GROUP BY
Order.group(:user_id).sum(:amount)
# =&gt; { 1 =&gt; 500, 2 =&gt; 300, 3 =&gt; 1200 }

# Complex aggregation
User.joins(:orders)
    .group(&#39;users.id&#39;)
    .select(&#39;
      users.*,
      COUNT(orders.id) as order_count,
      SUM(orders.amount) as total_spent
    &#39;)
</code></pre>
<hr>
<h3>Performance Tips</h3>
<pre><code class="language-sql">-- ✅ Index aggregated columns
CREATE INDEX idx_orders_amount ON orders(amount);
CREATE INDEX idx_orders_created_at ON orders(created_at);

-- ✅ Filter early with WHERE
SELECT AVG(price)
FROM products
WHERE active = true;  -- Filter first

-- ✅ Covering index
CREATE INDEX idx_orders_covering 
ON orders(user_id, status, amount);

-- ❌ Avoid aggregating huge tables without filter
SELECT SUM(amount) FROM huge_orders;  -- Slow

-- ✅ Add WHERE clause
SELECT SUM(amount) 
FROM huge_orders 
WHERE created_at &gt;= &#39;2024-01-01&#39;;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>COUNT</strong> counts rows</li>
<li><strong>SUM</strong> adds values</li>
<li><strong>AVG</strong> calculates average</li>
<li><strong>MAX/MIN</strong> find extremes</li>
<li><strong>GROUP BY</strong> for breakdowns</li>
<li><strong>HAVING</strong> filters groups</li>
<li><strong>WHERE</strong> filters rows first</li>
<li><strong>Conditional</strong> aggregates with CASE</li>
<li><strong>Multiple</strong> aggregates together</li>
<li><strong>Index</strong> for performance</li>
</ol>
<hr>
<h2>Question 173: How do you use ROLLUP and CUBE for advanced grouping?</h2>
<h3>Answer</h3>
<p><strong>ROLLUP</strong> creates subtotals and grand totals in a hierarchy. <strong>CUBE</strong> creates all possible grouping combinations. Both generate summary rows beyond basic GROUP BY.</p>
<hr>
<h3>ROLLUP</h3>
<p><strong>Hierarchical aggregation:</strong></p>
<pre><code class="language-sql">-- Sales data
region | country | city    | sales
NA     | USA     | NYC     | 1000
NA     | USA     | LA      | 800
NA     | Canada  | Toronto | 500
EU     | UK      | London  | 1200
EU     | France  | Paris   | 900

-- ROLLUP creates hierarchy: region &gt; country &gt; city &gt; total
SELECT 
  region,
  country,
  city,
  SUM(sales) as total_sales
FROM sales
GROUP BY ROLLUP (region, country, city);

-- Result:
region | country | city    | total_sales
NA     | USA     | NYC     | 1000        -- City level
NA     | USA     | LA      | 800
NA     | USA     | NULL    | 1800        -- Country subtotal
NA     | Canada  | Toronto | 500
NA     | Canada  | NULL    | 500         -- Country subtotal
NA     | NULL    | NULL    | 2300        -- Region subtotal
EU     | UK      | London  | 1200
EU     | UK      | NULL    | 1200
EU     | France  | Paris   | 900
EU     | France  | NULL    | 900
EU     | NULL    | NULL    | 2100        -- Region subtotal
NULL   | NULL    | NULL    | 4400        -- Grand total
</code></pre>
<hr>
<h3>CUBE</h3>
<p><strong>All possible combinations:</strong></p>
<pre><code class="language-sql">-- CUBE creates all grouping combinations
SELECT 
  region,
  product,
  SUM(sales) as total_sales
FROM sales
GROUP BY CUBE (region, product);

-- Generates:
-- 1. (region, product) - both grouped
-- 2. (region, NULL) - by region only
-- 3. (NULL, product) - by product only
-- 4. (NULL, NULL) - grand total

-- Example result:
region | product  | total_sales
NA     | Laptop   | 5000       -- Region + Product
NA     | Phone    | 3000
NA     | NULL     | 8000       -- Region total
EU     | Laptop   | 4000
EU     | Phone    | 2500
EU     | NULL     | 6500       -- Region total
NULL   | Laptop   | 9000       -- Product total
NULL   | Phone    | 5500       -- Product total
NULL   | NULL     | 14500      -- Grand total
</code></pre>
<hr>
<h3>Difference: ROLLUP vs CUBE</h3>
<pre><code class="language-sql">-- ROLLUP (n columns) = n+1 grouping levels
GROUP BY ROLLUP (A, B, C)
-- Generates: (A,B,C), (A,B), (A), ()

-- CUBE (n columns) = 2^n grouping combinations
GROUP BY CUBE (A, B, C)
-- Generates: (A,B,C), (A,B), (A,C), (B,C), (A), (B), (C), ()

-- Example with 2 columns:
GROUP BY ROLLUP (region, product)
-- 3 levels: (region, product), (region), ()

GROUP BY CUBE (region, product)
-- 4 combinations: (region, product), (region), (product), ()
</code></pre>
<hr>
<h3>Identifying Grouping Levels</h3>
<p><strong>GROUPING function:</strong></p>
<pre><code class="language-sql">-- Identify which columns are aggregated (1 = aggregated, 0 = grouped)
SELECT 
  region,
  product,
  SUM(sales) as total_sales,
  GROUPING(region) as region_grouping,
  GROUPING(product) as product_grouping
FROM sales
GROUP BY CUBE (region, product);

-- Result:
region | product | total_sales | region_grouping | product_grouping
NA     | Laptop  | 5000        | 0               | 0      -- Both grouped
NA     | NULL    | 8000        | 0               | 1      -- Product aggregated
NULL   | Laptop  | 9000        | 1               | 0      -- Region aggregated
NULL   | NULL    | 14500       | 1               | 1      -- Both aggregated
</code></pre>
<p><strong>GROUPING_ID (multiple columns):</strong></p>
<pre><code class="language-sql">-- Binary combination of GROUPING values
SELECT 
  region,
  product,
  category,
  SUM(sales) as total,
  GROUPING_ID(region, product, category) as group_id
FROM sales
GROUP BY CUBE (region, product, category);

-- group_id = binary representation
-- 0 = 000 = (region, product, category)
-- 1 = 001 = (region, product, NULL)
-- 2 = 010 = (region, NULL, category)
-- ...
-- 7 = 111 = (NULL, NULL, NULL) grand total
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Sales report with subtotals:</strong></p>
<pre><code class="language-sql">-- Monthly sales with year totals
SELECT 
  YEAR(order_date) as year,
  MONTH(order_date) as month,
  SUM(amount) as revenue,
  CASE 
    WHEN GROUPING(YEAR(order_date)) = 1 THEN &#39;Grand Total&#39;
    WHEN GROUPING(MONTH(order_date)) = 1 THEN &#39;Year Total&#39;
    ELSE &#39;Month&#39;
  END as level
FROM orders
WHERE order_date &gt;= &#39;2024-01-01&#39;
GROUP BY ROLLUP (YEAR(order_date), MONTH(order_date))
ORDER BY year, month;

-- Result:
year | month | revenue  | level
2024 | 1     | 50000    | Month
2024 | 2     | 55000    | Month
2024 | NULL  | 105000   | Year Total
NULL | NULL  | 105000   | Grand Total
</code></pre>
<p><strong>2. Multi-dimensional analysis:</strong></p>
<pre><code class="language-sql">-- Product sales by region and quarter
SELECT 
  COALESCE(region, &#39;All Regions&#39;) as region,
  COALESCE(quarter, &#39;All Quarters&#39;) as quarter,
  COALESCE(product_category, &#39;All Categories&#39;) as category,
  SUM(sales) as total_sales
FROM sales_data
GROUP BY CUBE (region, quarter, product_category)
ORDER BY 
  GROUPING_ID(region, quarter, product_category),
  region,
  quarter,
  product_category;

-- Shows all possible breakdowns:
-- - By region, quarter, category
-- - By region and quarter
-- - By region and category
-- - By quarter and category
-- - By region only
-- - By quarter only
-- - By category only
-- - Grand total
</code></pre>
<p><strong>3. Employee hierarchy totals:</strong></p>
<pre><code class="language-sql">-- Department &gt; Team &gt; Employee hierarchy
SELECT 
  department,
  team,
  employee,
  SUM(sales) as total,
  CASE GROUPING_ID(department, team, employee)
    WHEN 0 THEN &#39;Employee&#39;
    WHEN 1 THEN &#39;Team Total&#39;
    WHEN 3 THEN &#39;Department Total&#39;
    WHEN 7 THEN &#39;Company Total&#39;
  END as level_name
FROM employee_sales
GROUP BY ROLLUP (department, team, employee);
</code></pre>
<hr>
<h3>GROUPING SETS</h3>
<p><strong>Custom grouping combinations:</strong></p>
<pre><code class="language-sql">-- Specify exact groupings wanted
SELECT 
  region,
  product,
  SUM(sales) as total
FROM sales
GROUP BY GROUPING SETS (
  (region, product),  -- By region and product
  (region),          -- By region only
  ()                 -- Grand total
);

-- More control than ROLLUP or CUBE
-- Only generates specified combinations

-- Example: Multiple independent groupings
SELECT 
  year,
  quarter,
  month,
  SUM(revenue) as total
FROM orders
GROUP BY GROUPING SETS (
  (year),           -- Yearly totals
  (year, quarter),  -- Quarterly totals
  (year, month),    -- Monthly totals
  ()                -- Grand total
);
</code></pre>
<hr>
<h3>Filtering Rollup/Cube Results</h3>
<pre><code class="language-sql">-- Filter specific grouping levels
SELECT 
  region,
  product,
  SUM(sales) as total
FROM sales
GROUP BY ROLLUP (region, product)
HAVING GROUPING(region) = 0;  -- Only detail and region subtotals

-- Or use WHERE on GROUPING_ID
SELECT *
FROM (
  SELECT 
    region,
    product,
    SUM(sales) as total,
    GROUPING_ID(region, product) as gid
  FROM sales
  GROUP BY CUBE (region, product)
) cube_results
WHERE gid IN (0, 3);  -- Only detail rows and grand total
</code></pre>
<hr>
<h3>Database Support</h3>
<pre><code class="language-sql">-- PostgreSQL: Full support
GROUP BY ROLLUP (...)
GROUP BY CUBE (...)
GROUP BY GROUPING SETS (...)

-- MySQL 8.0+: Full support
GROUP BY ROLLUP (...)
-- CUBE and GROUPING SETS added in MySQL 8.0.1

-- SQL Server: Full support
GROUP BY ROLLUP (...)
GROUP BY CUBE (...)
GROUP BY GROUPING SETS (...)

-- Oracle: Full support (uses ROLLUP/CUBE differently)
GROUP BY ROLLUP (...)
GROUP BY CUBE (...)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>ROLLUP</strong> creates hierarchy</li>
<li><strong>CUBE</strong> creates all combinations</li>
<li><strong>ROLLUP</strong> for subtotals</li>
<li><strong>CUBE</strong> for multi-dimensional</li>
<li><strong>GROUPING</strong> identifies level</li>
<li><strong>GROUPING_ID</strong> for multiple columns</li>
<li><strong>GROUPING SETS</strong> for custom</li>
<li><strong>NULL</strong> represents aggregation</li>
<li><strong>Powerful</strong> for reports</li>
<li><strong>Modern SQL</strong> feature</li>
</ol>
<hr>
<h2>Question 174: How do you perform conditional aggregation using CASE statements?</h2>
<h3>Answer</h3>
<p><strong>Conditional aggregation</strong> uses <strong>CASE</strong> statements inside aggregate functions to calculate different metrics based on conditions, creating pivot-like results or multi-condition summaries in a single query.</p>
<hr>
<h3>Basic Pattern</h3>
<pre><code class="language-sql">-- Template
SELECT 
  group_column,
  SUM(CASE WHEN condition THEN value ELSE 0 END) as conditional_sum,
  COUNT(CASE WHEN condition THEN 1 END) as conditional_count
FROM table
GROUP BY group_column;
</code></pre>
<hr>
<h3>Count by Condition</h3>
<pre><code class="language-sql">-- Count orders by status
SELECT 
  user_id,
  COUNT(*) as total_orders,
  COUNT(CASE WHEN status = &#39;completed&#39; THEN 1 END) as completed,
  COUNT(CASE WHEN status = &#39;pending&#39; THEN 1 END) as pending,
  COUNT(CASE WHEN status = &#39;cancelled&#39; THEN 1 END) as cancelled
FROM orders
GROUP BY user_id;

-- Result:
user_id | total_orders | completed | pending | cancelled
1       | 10           | 7         | 2       | 1
2       | 5            | 4         | 0       | 1
3       | 8            | 6         | 2       | 0
</code></pre>
<hr>
<h3>Sum by Condition</h3>
<pre><code class="language-sql">-- Revenue by order status
SELECT 
  user_id,
  SUM(amount) as total_revenue,
  SUM(CASE WHEN status = &#39;completed&#39; THEN amount ELSE 0 END) as completed_revenue,
  SUM(CASE WHEN status = &#39;refunded&#39; THEN amount ELSE 0 END) as refunded_revenue,
  SUM(CASE WHEN status = &#39;pending&#39; THEN amount ELSE 0 END) as pending_revenue
FROM orders
GROUP BY user_id;

-- Result:
user_id | total_revenue | completed_revenue | refunded_revenue | pending_revenue
1       | 5000          | 4500              | 300              | 200
2       | 3000          | 2800              | 0                | 200
</code></pre>
<hr>
<h3>Pivot Table Effect</h3>
<pre><code class="language-sql">-- Monthly revenue by category (pivot)
SELECT 
  YEAR(order_date) as year,
  SUM(CASE WHEN MONTH(order_date) = 1 THEN amount ELSE 0 END) as jan,
  SUM(CASE WHEN MONTH(order_date) = 2 THEN amount ELSE 0 END) as feb,
  SUM(CASE WHEN MONTH(order_date) = 3 THEN amount ELSE 0 END) as mar,
  SUM(CASE WHEN MONTH(order_date) = 4 THEN amount ELSE 0 END) as apr,
  SUM(CASE WHEN MONTH(order_date) = 5 THEN amount ELSE 0 END) as may,
  SUM(CASE WHEN MONTH(order_date) = 6 THEN amount ELSE 0 END) as jun
FROM orders
WHERE YEAR(order_date) = 2024
GROUP BY YEAR(order_date);

-- Result:
year | jan   | feb   | mar   | apr   | may   | jun
2024 | 50000 | 55000 | 48000 | 62000 | 71000 | 68000
</code></pre>
<hr>
<h3>Multiple Conditions</h3>
<pre><code class="language-sql">-- Sales by product and region
SELECT 
  product_id,
  SUM(CASE WHEN region = &#39;NA&#39; THEN quantity ELSE 0 END) as na_sales,
  SUM(CASE WHEN region = &#39;EU&#39; THEN quantity ELSE 0 END) as eu_sales,
  SUM(CASE WHEN region = &#39;ASIA&#39; THEN quantity ELSE 0 END) as asia_sales,
  SUM(quantity) as total_sales
FROM sales
GROUP BY product_id;
</code></pre>
<hr>
<h3>Complex Conditions</h3>
<pre><code class="language-sql">-- Customer segmentation
SELECT 
  COUNT(*) as total_customers,
  COUNT(CASE 
    WHEN total_spent &gt;= 10000 THEN 1 
  END) as vip_customers,
  COUNT(CASE 
    WHEN total_spent &gt;= 1000 AND total_spent &lt; 10000 THEN 1 
  END) as premium_customers,
  COUNT(CASE 
    WHEN total_spent &gt;= 100 AND total_spent &lt; 1000 THEN 1 
  END) as regular_customers,
  COUNT(CASE 
    WHEN total_spent &lt; 100 THEN 1 
  END) as new_customers
FROM (
  SELECT user_id, SUM(amount) as total_spent
  FROM orders
  GROUP BY user_id
) user_totals;
</code></pre>
<hr>
<h3>Average by Condition</h3>
<pre><code class="language-sql">-- Average order value by day of week
SELECT 
  user_id,
  AVG(CASE WHEN EXTRACT(DOW FROM created_at) IN (0, 6) 
      THEN amount END) as weekend_avg,
  AVG(CASE WHEN EXTRACT(DOW FROM created_at) BETWEEN 1 AND 5 
      THEN amount END) as weekday_avg
FROM orders
GROUP BY user_id;
</code></pre>
<hr>
<h3>Percentage Calculations</h3>
<pre><code class="language-sql">-- Completion rate per user
SELECT 
  user_id,
  COUNT(*) as total_orders,
  COUNT(CASE WHEN status = &#39;completed&#39; THEN 1 END) as completed,
  ROUND(
    COUNT(CASE WHEN status = &#39;completed&#39; THEN 1 END) * 100.0 / 
    COUNT(*), 
    2
  ) as completion_rate
FROM orders
GROUP BY user_id;

-- Result:
user_id | total_orders | completed | completion_rate
1       | 10           | 7         | 70.00
2       | 5            | 5         | 100.00
3       | 8            | 6         | 75.00
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. E-commerce dashboard:</strong></p>
<pre><code class="language-sql">SELECT 
  DATE(created_at) as date,
  COUNT(*) as total_orders,
  SUM(amount) as total_revenue,
  SUM(CASE WHEN status = &#39;completed&#39; THEN amount ELSE 0 END) as completed_revenue,
  COUNT(CASE WHEN status = &#39;completed&#39; THEN 1 END) as completed_count,
  SUM(CASE WHEN is_first_purchase THEN amount ELSE 0 END) as new_customer_revenue,
  SUM(CASE WHEN discount &gt; 0 THEN amount ELSE 0 END) as discounted_revenue,
  AVG(CASE WHEN status = &#39;completed&#39; THEN amount END) as avg_order_value
FROM orders
WHERE created_at &gt;= CURRENT_DATE - INTERVAL &#39;30 days&#39;
GROUP BY DATE(created_at)
ORDER BY date DESC;
</code></pre>
<p><strong>2. Product performance:</strong></p>
<pre><code class="language-sql">SELECT 
  product_id,
  product_name,
  SUM(CASE WHEN rating = 5 THEN 1 ELSE 0 END) as five_star,
  SUM(CASE WHEN rating = 4 THEN 1 ELSE 0 END) as four_star,
  SUM(CASE WHEN rating = 3 THEN 1 ELSE 0 END) as three_star,
  SUM(CASE WHEN rating &lt;= 2 THEN 1 ELSE 0 END) as low_rating,
  AVG(rating) as avg_rating,
  COUNT(*) as total_reviews
FROM reviews
GROUP BY product_id, product_name
HAVING COUNT(*) &gt;= 10
ORDER BY avg_rating DESC;
</code></pre>
<p><strong>3. User activity tracking:</strong></p>
<pre><code class="language-sql">SELECT 
  user_id,
  COUNT(CASE WHEN action = &#39;login&#39; THEN 1 END) as logins,
  COUNT(CASE WHEN action = &#39;view_product&#39; THEN 1 END) as product_views,
  COUNT(CASE WHEN action = &#39;add_to_cart&#39; THEN 1 END) as cart_adds,
  COUNT(CASE WHEN action = &#39;purchase&#39; THEN 1 END) as purchases,
  ROUND(
    COUNT(CASE WHEN action = &#39;purchase&#39; THEN 1 END) * 100.0 / 
    NULLIF(COUNT(CASE WHEN action = &#39;add_to_cart&#39; THEN 1 END), 0),
    2
  ) as conversion_rate
FROM user_actions
WHERE created_at &gt;= CURRENT_DATE - INTERVAL &#39;7 days&#39;
GROUP BY user_id;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># Conditional aggregation
Order.group(:user_id)
     .select(&quot;
       user_id,
       COUNT(*) as total,
       COUNT(CASE WHEN status = &#39;completed&#39; THEN 1 END) as completed,
       SUM(CASE WHEN status = &#39;completed&#39; THEN amount ELSE 0 END) as revenue
     &quot;)

# Using pluck
Order.group(:user_id)
     .pluck(
       :user_id,
       Arel.sql(&quot;COUNT(*)&quot;),
       Arel.sql(&quot;COUNT(CASE WHEN status = &#39;completed&#39; THEN 1 END)&quot;),
       Arel.sql(&quot;SUM(CASE WHEN status = &#39;completed&#39; THEN amount ELSE 0 END)&quot;)
     )
</code></pre>
<hr>
<h3>Advanced Techniques</h3>
<p><strong>1. Multiple metrics in one query:</strong></p>
<pre><code class="language-sql">SELECT 
  category,
  -- Count metrics
  COUNT(*) as total_products,
  COUNT(CASE WHEN active THEN 1 END) as active_count,
  COUNT(CASE WHEN on_sale THEN 1 END) as on_sale_count,
  -- Sum metrics
  SUM(CASE WHEN active THEN stock ELSE 0 END) as active_stock,
  SUM(CASE WHEN on_sale THEN stock ELSE 0 END) as sale_stock,
  -- Average metrics
  AVG(CASE WHEN active THEN price END) as avg_active_price,
  AVG(CASE WHEN on_sale THEN price END) as avg_sale_price,
  -- Min/Max metrics
  MIN(CASE WHEN active THEN price END) as min_active_price,
  MAX(CASE WHEN active THEN price END) as max_active_price
FROM products
GROUP BY category;
</code></pre>
<p><strong>2. Time-based conditionals:</strong></p>
<pre><code class="language-sql">-- Compare time periods
SELECT 
  product_id,
  SUM(CASE 
    WHEN created_at &gt;= CURRENT_DATE - INTERVAL &#39;7 days&#39; 
    THEN quantity 
    ELSE 0 
  END) as last_7_days,
  SUM(CASE 
    WHEN created_at &gt;= CURRENT_DATE - INTERVAL &#39;30 days&#39; 
    THEN quantity 
    ELSE 0 
  END) as last_30_days,
  SUM(CASE 
    WHEN created_at &gt;= CURRENT_DATE - INTERVAL &#39;90 days&#39; 
    THEN quantity 
    ELSE 0 
  END) as last_90_days
FROM sales
GROUP BY product_id;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>CASE</strong> inside aggregates</li>
<li><strong>Pivot-like</strong> results</li>
<li><strong>Multiple conditions</strong> in one query</li>
<li><strong>Count, Sum, Avg</strong> all work</li>
<li><strong>NULL</strong> in ELSE vs 0</li>
<li><strong>Percentage</strong> calculations</li>
<li><strong>Complex conditions</strong> supported</li>
<li><strong>Performance</strong> efficient</li>
<li><strong>Replaces</strong> multiple queries</li>
<li><strong>Powerful</strong> for analytics</li>
</ol>
<h1>Window Functions, Advanced SQL, and Database Design Interview Questions</h1>
<h2>Window Functions</h2>
<h2>Question 175: What is a window function, and how is it different from GROUP BY?</h2>
<h3>Answer</h3>
<p><strong>Window functions</strong> perform calculations across a set of rows (a &quot;window&quot;) related to the current row, while keeping all rows in the result. <strong>GROUP BY</strong> collapses rows into groups. Window functions = keep all rows + add calculations, GROUP BY = collapse to one row per group.</p>
<hr>
<h3>Core Difference</h3>
<pre><code class="language-sql">-- Sample data: employees
id | name    | department | salary
1  | Alice   | Sales      | 50000
2  | Bob     | Sales      | 60000
3  | Charlie | Sales      | 55000
4  | David   | IT         | 70000
5  | Eve     | IT         | 75000

-- GROUP BY (collapses to one row per department)
SELECT 
  department,
  AVG(salary) as avg_salary
FROM employees
GROUP BY department;

-- Result (2 rows):
department | avg_salary
Sales      | 55000
IT         | 72500

-- Window Function (keeps all rows)
SELECT 
  name,
  department,
  salary,
  AVG(salary) OVER (PARTITION BY department) as dept_avg
FROM employees;

-- Result (5 rows):
name    | department | salary | dept_avg
Alice   | Sales      | 50000  | 55000
Bob     | Sales      | 60000  | 55000
Charlie | Sales      | 55000  | 55000
David   | IT         | 70000  | 72500
Eve     | IT         | 75000  | 72500
</code></pre>
<hr>
<h3>Window Function Syntax</h3>
<pre><code class="language-sql">function_name() OVER (
  [PARTITION BY column]
  [ORDER BY column]
  [ROWS/RANGE frame_clause]
)

-- Components:
-- PARTITION BY: Defines groups (like GROUP BY)
-- ORDER BY: Defines order within partition
-- Frame: Defines which rows to include in calculation
</code></pre>
<hr>
<h3>Key Differences</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>GROUP BY</th>
<th>Window Function</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Rows returned</strong></td>
<td>One per group</td>
<td>All rows</td>
</tr>
<tr>
<td><strong>Aggregation</strong></td>
<td>Required</td>
<td>Optional</td>
</tr>
<tr>
<td><strong>Detail preserved</strong></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Ranking</strong></td>
<td>Cannot do</td>
<td>Can do</td>
</tr>
<tr>
<td><strong>Running totals</strong></td>
<td>Cannot do</td>
<td>Can do</td>
</tr>
<tr>
<td><strong>Use with</strong></td>
<td>Aggregates only</td>
<td>Aggregates + analytic</td>
</tr>
</tbody></table>
<hr>
<h3>Common Window Functions</h3>
<p><strong>1. Aggregate functions:</strong></p>
<pre><code class="language-sql">-- Same aggregates as GROUP BY, but keep all rows
SELECT 
  name,
  salary,
  SUM(salary) OVER () as total_salary,
  AVG(salary) OVER () as avg_salary,
  COUNT(*) OVER () as total_employees
FROM employees;

-- All rows see same aggregates
</code></pre>
<p><strong>2. Ranking functions:</strong></p>
<pre><code class="language-sql">-- Assign ranks to rows
SELECT 
  name,
  salary,
  ROW_NUMBER() OVER (ORDER BY salary DESC) as row_num,
  RANK() OVER (ORDER BY salary DESC) as rank,
  DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank
FROM employees;
</code></pre>
<p><strong>3. Analytic functions:</strong></p>
<pre><code class="language-sql">-- Access other rows&#39; data
SELECT 
  name,
  salary,
  LAG(salary) OVER (ORDER BY salary) as prev_salary,
  LEAD(salary) OVER (ORDER BY salary) as next_salary
FROM employees;
</code></pre>
<hr>
<h3>PARTITION BY (Window&#39;s GROUP BY)</h3>
<pre><code class="language-sql">-- Calculate department-specific metrics
SELECT 
  name,
  department,
  salary,
  AVG(salary) OVER (PARTITION BY department) as dept_avg,
  MAX(salary) OVER (PARTITION BY department) as dept_max,
  MIN(salary) OVER (PARTITION BY department) as dept_min,
  COUNT(*) OVER (PARTITION BY department) as dept_count
FROM employees;

-- Each row shows its own data + department aggregates
</code></pre>
<hr>
<h3>ORDER BY in Window</h3>
<pre><code class="language-sql">-- Running totals
SELECT 
  date,
  amount,
  SUM(amount) OVER (ORDER BY date) as running_total
FROM sales
ORDER BY date;

-- Result:
date       | amount | running_total
2024-01-01 | 100    | 100
2024-01-02 | 150    | 250
2024-01-03 | 200    | 450
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use GROUP BY when:</strong></p>
<pre><code class="language-sql">-- ✅ Need summary only
SELECT department, AVG(salary)
FROM employees
GROUP BY department;

-- ✅ Don&#39;t need individual rows
SELECT category, COUNT(*)
FROM products
GROUP BY category;
</code></pre>
<p><strong>Use Window Functions when:</strong></p>
<pre><code class="language-sql">-- ✅ Need detail + aggregates
SELECT 
  name,
  salary,
  salary - AVG(salary) OVER () as diff_from_avg
FROM employees;

-- ✅ Need rankings
SELECT 
  name,
  ROW_NUMBER() OVER (ORDER BY salary DESC) as rank
FROM employees;

-- ✅ Need running calculations
SELECT 
  date,
  SUM(amount) OVER (ORDER BY date) as running_total
FROM sales;
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Salary comparison:</strong></p>
<pre><code class="language-sql">-- Each employee with department average
SELECT 
  name,
  department,
  salary,
  AVG(salary) OVER (PARTITION BY department) as dept_avg,
  salary - AVG(salary) OVER (PARTITION BY department) as diff,
  ROUND(
    salary * 100.0 / AVG(salary) OVER (PARTITION BY department),
    2
  ) as pct_of_avg
FROM employees;
</code></pre>
<p><strong>2. Top N per category:</strong></p>
<pre><code class="language-sql">-- Top 3 products per category
SELECT *
FROM (
  SELECT 
    name,
    category,
    sales,
    ROW_NUMBER() OVER (
      PARTITION BY category 
      ORDER BY sales DESC
    ) as rank
  FROM products
) ranked
WHERE rank &lt;= 3;
</code></pre>
<p><strong>3. Previous/next comparison:</strong></p>
<pre><code class="language-sql">-- Compare with previous month
SELECT 
  month,
  revenue,
  LAG(revenue) OVER (ORDER BY month) as prev_month,
  revenue - LAG(revenue) OVER (ORDER BY month) as growth
FROM monthly_revenue;
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-sql">-- Window functions can be expensive
-- Optimize with:

-- 1. Index on PARTITION BY and ORDER BY columns
CREATE INDEX idx_emp_dept_salary 
ON employees(department, salary);

-- 2. Filter before window function
SELECT *
FROM (
  SELECT 
    name,
    salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) as rank
  FROM employees
  WHERE active = true  -- Filter first
) ranked
WHERE rank &lt;= 10;

-- 3. Reuse window definitions
SELECT 
  name,
  AVG(salary) OVER w as avg,
  MAX(salary) OVER w as max,
  MIN(salary) OVER w as min
FROM employees
WINDOW w AS (PARTITION BY department);
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Window functions</strong> keep all rows</li>
<li><strong>GROUP BY</strong> collapses rows</li>
<li><strong>PARTITION BY</strong> = window grouping</li>
<li><strong>ORDER BY</strong> defines sequence</li>
<li><strong>Aggregates</strong> + analytic functions</li>
<li><strong>Rankings</strong> and running totals</li>
<li><strong>Detail</strong> + summary together</li>
<li><strong>More flexible</strong> than GROUP BY</li>
<li><strong>Performance</strong> needs indexing</li>
<li><strong>Modern SQL</strong> essential feature</li>
</ol>
<hr>
<h2>Question 176: How do you use window functions (ROW_NUMBER, RANK, DENSE_RANK)?</h2>
<h3>Answer</h3>
<p><strong>ROW_NUMBER</strong> assigns unique sequential numbers. <strong>RANK</strong> assigns ranks with gaps for ties. <strong>DENSE_RANK</strong> assigns ranks without gaps. All three number rows within a partition, differing in how they handle ties.</p>
<hr>
<h3>ROW_NUMBER()</h3>
<p><strong>Unique sequential numbers:</strong></p>
<pre><code class="language-sql">-- Assign unique numbers
SELECT 
  name,
  salary,
  ROW_NUMBER() OVER (ORDER BY salary DESC) as row_num
FROM employees;

-- Result:
name    | salary | row_num
Eve     | 75000  | 1
David   | 70000  | 2
Bob     | 60000  | 3
Charlie | 55000  | 4
Alice   | 50000  | 5

-- Even with ties, each row gets unique number
</code></pre>
<p><strong>With PARTITION BY:</strong></p>
<pre><code class="language-sql">-- Number within each department
SELECT 
  name,
  department,
  salary,
  ROW_NUMBER() OVER (
    PARTITION BY department 
    ORDER BY salary DESC
  ) as dept_row_num
FROM employees;

-- Result:
name    | department | salary | dept_row_num
Bob     | Sales      | 60000  | 1
Charlie | Sales      | 55000  | 2
Alice   | Sales      | 50000  | 3
Eve     | IT         | 75000  | 1
David   | IT         | 70000  | 2
</code></pre>
<hr>
<h3>RANK()</h3>
<p><strong>Ranks with gaps for ties:</strong></p>
<pre><code class="language-sql">-- Test scores with ties
id | name    | score
1  | Alice   | 95
2  | Bob     | 90
3  | Charlie | 90  -- Tie
4  | David   | 85
5  | Eve     | 80

SELECT 
  name,
  score,
  RANK() OVER (ORDER BY score DESC) as rank
FROM students;

-- Result:
name    | score | rank
Alice   | 95    | 1
Bob     | 90    | 2
Charlie | 90    | 2  -- Same rank as Bob
David   | 85    | 4  -- Skips 3 (gap!)
Eve     | 80    | 5
</code></pre>
<hr>
<h3>DENSE_RANK()</h3>
<p><strong>Ranks without gaps:</strong></p>
<pre><code class="language-sql">-- Same data
SELECT 
  name,
  score,
  DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank
FROM students;

-- Result:
name    | score | dense_rank
Alice   | 95    | 1
Bob     | 90    | 2
Charlie | 90    | 2  -- Same rank as Bob
David   | 85    | 3  -- No gap! (not 4)
Eve     | 80    | 4
</code></pre>
<hr>
<h3>Side-by-Side Comparison</h3>
<pre><code class="language-sql">SELECT 
  name,
  score,
  ROW_NUMBER() OVER (ORDER BY score DESC) as row_num,
  RANK() OVER (ORDER BY score DESC) as rank,
  DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank
FROM students;

-- Result:
name    | score | row_num | rank | dense_rank
Alice   | 95    | 1       | 1    | 1
Bob     | 90    | 2       | 2    | 2
Charlie | 90    | 3       | 2    | 2      -- ROW_NUMBER unique
David   | 85    | 4       | 4    | 3      -- RANK has gap
Eve     | 80    | 5       | 5    | 4
</code></pre>
<hr>
<h3>Visual Comparison</h3>
<pre><code>Score: 95, 90, 90, 85, 80

ROW_NUMBER:  1  2  3  4  5  (always unique)
RANK:        1  2  2  4  5  (gaps after ties)
DENSE_RANK:  1  2  2  3  4  (no gaps)
</code></pre>
<hr>
<h3>Common Use Cases</h3>
<p><strong>1. Pagination with ROW_NUMBER:</strong></p>
<pre><code class="language-sql">-- Deterministic pagination
SELECT *
FROM (
  SELECT 
    *,
    ROW_NUMBER() OVER (ORDER BY id) as row_num
  FROM products
) numbered
WHERE row_num BETWEEN 21 AND 30;  -- Page 3
</code></pre>
<p><strong>2. Top N per category with ROW_NUMBER:</strong></p>
<pre><code class="language-sql">-- Top 3 products per category
SELECT name, category, sales
FROM (
  SELECT 
    name,
    category,
    sales,
    ROW_NUMBER() OVER (
      PARTITION BY category 
      ORDER BY sales DESC
    ) as rn
  FROM products
) ranked
WHERE rn &lt;= 3;
</code></pre>
<p><strong>3. Leaderboard with RANK:</strong></p>
<pre><code class="language-sql">-- Game leaderboard with tied positions
SELECT 
  player_name,
  score,
  RANK() OVER (ORDER BY score DESC) as position
FROM game_scores
ORDER BY position
LIMIT 10;

-- Ties get same position (fair ranking)
</code></pre>
<p><strong>4. Prize distribution with DENSE_RANK:</strong></p>
<pre><code class="language-sql">-- Award prizes for top 3 distinct score levels
SELECT 
  name,
  score,
  DENSE_RANK() OVER (ORDER BY score DESC) as prize_tier,
  CASE DENSE_RANK() OVER (ORDER BY score DESC)
    WHEN 1 THEN &#39;Gold&#39;
    WHEN 2 THEN &#39;Silver&#39;
    WHEN 3 THEN &#39;Bronze&#39;
    ELSE NULL
  END as medal
FROM contestants;

-- All winners at same score get same medal
</code></pre>
<p><strong>5. Deduplication with ROW_NUMBER:</strong></p>
<pre><code class="language-sql">-- Remove duplicates, keep first occurrence
DELETE FROM users
WHERE id IN (
  SELECT id
  FROM (
    SELECT 
      id,
      ROW_NUMBER() OVER (
        PARTITION BY email 
        ORDER BY created_at
      ) as rn
    FROM users
  ) ranked
  WHERE rn &gt; 1
);
</code></pre>
<hr>
<h3>With Multiple Partitions</h3>
<pre><code class="language-sql">-- Rank within each department and year
SELECT 
  name,
  department,
  year,
  sales,
  ROW_NUMBER() OVER (
    PARTITION BY department, year 
    ORDER BY sales DESC
  ) as dept_year_rank
FROM employee_sales
ORDER BY department, year, dept_year_rank;
</code></pre>
<hr>
<h3>Filtering Ranked Results</h3>
<pre><code class="language-sql">-- Get 2nd highest salary per department
SELECT department, name, salary
FROM (
  SELECT 
    department,
    name,
    salary,
    ROW_NUMBER() OVER (
      PARTITION BY department 
      ORDER BY salary DESC
    ) as rn
  FROM employees
) ranked
WHERE rn = 2;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># ROW_NUMBER - Remove duplicates
User.select(&#39;DISTINCT ON (email) *&#39;)
    .order(:email, :created_at)

# Or with window function
User.from(
  User.select(
    &#39;*&#39;,
    &#39;ROW_NUMBER() OVER (PARTITION BY email ORDER BY created_at) as rn&#39;
  ),
  :users
).where(&#39;rn = 1&#39;)

# RANK - Leaderboard
User.select(
  &#39;*&#39;,
  &#39;RANK() OVER (ORDER BY score DESC) as rank&#39;
).order(:rank)

# Top N per group
Product.from(
  Product.select(
    &#39;*&#39;,
    &#39;ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY sales DESC) as rn&#39;
  ),
  :products
).where(&#39;rn &lt;= 3&#39;)
</code></pre>
<hr>
<h3>Performance Tips</h3>
<pre><code class="language-sql">-- ✅ Index helps ORDER BY
CREATE INDEX idx_employees_salary 
ON employees(salary DESC);

-- ✅ Index helps PARTITION BY + ORDER BY
CREATE INDEX idx_products_category_sales 
ON products(category_id, sales DESC);

-- ✅ Filter before ranking when possible
SELECT *
FROM (
  SELECT 
    *,
    ROW_NUMBER() OVER (ORDER BY score DESC) as rn
  FROM players
  WHERE active = true  -- Filter first
) ranked
WHERE rn &lt;= 10;

-- ❌ Avoid ranking large result sets
-- without filtering
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>ROW_NUMBER</strong> always unique</li>
<li><strong>RANK</strong> has gaps for ties</li>
<li><strong>DENSE_RANK</strong> no gaps</li>
<li><strong>Use ROW_NUMBER</strong> for dedup</li>
<li><strong>Use RANK</strong> for competitions</li>
<li><strong>Use DENSE_RANK</strong> for tiers</li>
<li><strong>PARTITION BY</strong> for grouping</li>
<li><strong>ORDER BY</strong> defines sequence</li>
<li><strong>Filter</strong> after ranking</li>
<li><strong>Index</strong> improves performance</li>
</ol>
<hr>
<h2>Question 177: What is the difference between RANK() and DENSE_RANK()?</h2>
<h3>Answer</h3>
<p><strong>RANK()</strong> skips numbers after ties (has gaps). <strong>DENSE_RANK()</strong> continues sequentially (no gaps). Both assign same rank to ties, but RANK leaves gaps while DENSE_RANK doesn&#39;t.</p>
<hr>
<h3>Core Difference</h3>
<pre><code class="language-sql">-- Sample data: test scores with ties
name    | score
Alice   | 95
Bob     | 90
Charlie | 90  -- Tie with Bob
David   | 90  -- Also tied
Eve     | 85
Frank   | 80

-- RANK() - with gaps
SELECT 
  name,
  score,
  RANK() OVER (ORDER BY score DESC) as rank
FROM scores;

-- Result:
name    | score | rank
Alice   | 95    | 1
Bob     | 90    | 2
Charlie | 90    | 2    -- Same as Bob
David   | 90    | 2    -- Same as Bob
Eve     | 85    | 5    -- Skips 3 and 4 (GAP)
Frank   | 80    | 6

-- DENSE_RANK() - no gaps
SELECT 
  name,
  score,
  DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank
FROM scores;

-- Result:
name    | score | dense_rank
Alice   | 95    | 1
Bob     | 90    | 2
Charlie | 90    | 2
David   | 90    | 2
Eve     | 85    | 3    -- Continues from 2 (NO GAP)
Frank   | 80    | 4
</code></pre>
<hr>
<h3>Visual Comparison</h3>
<pre><code>Scores: 95, 90, 90, 90, 85, 80

RANK():
Position: 1   2   2   2   5   6
          ↑   ↑   ↑   ↑   ↑   ↑
          └───┴───┴───┘   │   │
          3 tied at #2    │   │
                    Skips 3,4 │
                              │
                         Next rank

DENSE_RANK():
Position: 1   2   2   2   3   4
          ↑   ↑   ↑   ↑   ↑   ↑
          └───┴───┴───┘   │   │
          3 tied at #2    │   │
                    No skip   │
                         Continues
</code></pre>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use RANK() when:</strong></p>
<pre><code class="language-sql">-- ✅ Traditional competition ranking
-- (Olympic medals, sports tournaments)
SELECT 
  athlete,
  time,
  RANK() OVER (ORDER BY time) as position
FROM race_results;
-- 1st, 2nd (tie), 2nd (tie), 4th (not 3rd)

-- ✅ When gaps represent tied positions
-- ✅ When you want final rank = row count
-- (If 100 students, worst rank is 100)
</code></pre>
<p><strong>Use DENSE_RANK() when:</strong></p>
<pre><code class="language-sql">-- ✅ Prize tiers or levels
SELECT 
  player,
  score,
  DENSE_RANK() OVER (ORDER BY score DESC) as tier,
  CASE DENSE_RANK() OVER (ORDER BY score DESC)
    WHEN 1 THEN &#39;Platinum&#39;
    WHEN 2 THEN &#39;Gold&#39;
    WHEN 3 THEN &#39;Silver&#39;
    WHEN 4 THEN &#39;Bronze&#39;
  END as level
FROM players;
-- Everyone at same score gets same level

-- ✅ Grade distribution
-- A+ = rank 1, A = rank 2, B+ = rank 3, etc.

-- ✅ When counting distinct values
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Sports tournament (RANK):</strong></p>
<pre><code class="language-sql">-- Golf tournament
SELECT 
  player_name,
  total_score,
  RANK() OVER (ORDER BY total_score) as position
FROM tournament_results;

-- Result:
player_name | total_score | position
Tiger       | 280         | 1
Phil        | 285         | 2
Rory        | 285         | 2  (Tied)
Jordan      | 287         | 4  (Not 3!)

-- Prize money based on position:
-- 1st: $1M
-- 2nd: $500K (split between Phil and Rory)
-- 4th: $250K (Jordan)
</code></pre>
<p><strong>2. Product categories (DENSE_RANK):</strong></p>
<pre><code class="language-sql">-- Price tiers for products
SELECT 
  product_name,
  price,
  DENSE_RANK() OVER (ORDER BY price DESC) as price_tier,
  CASE DENSE_RANK() OVER (ORDER BY price DESC)
    WHEN 1 THEN &#39;Premium&#39;
    WHEN 2 THEN &#39;Mid-Range&#39;
    WHEN 3 THEN &#39;Budget&#39;
    ELSE &#39;Economy&#39;
  END as category
FROM products;

-- All $999 products are Premium
-- All $599 products are Mid-Range
-- No gaps in tiers
</code></pre>
<p><strong>3. Student grades (DENSE_RANK):</strong></p>
<pre><code class="language-sql">-- Grade assignment
SELECT 
  student,
  score,
  DENSE_RANK() OVER (ORDER BY score DESC) as rank,
  CASE DENSE_RANK() OVER (ORDER BY score DESC)
    WHEN 1 THEN &#39;A+&#39;
    WHEN 2 THEN &#39;A&#39;
    WHEN 3 THEN &#39;A-&#39;
    WHEN 4 THEN &#39;B+&#39;
  END as grade
FROM exam_results;

-- All students with same score get same grade
</code></pre>
<hr>
<h3>Calculating Count Differences</h3>
<pre><code class="language-sql">-- RANK: Final rank equals row count
SELECT 
  MAX(RANK() OVER (ORDER BY score DESC)) as max_rank,
  COUNT(*) as total_rows
FROM scores;
-- max_rank = total_rows (always)

-- DENSE_RANK: Final rank equals distinct value count
SELECT 
  MAX(DENSE_RANK() OVER (ORDER BY score DESC)) as max_rank,
  COUNT(DISTINCT score) as distinct_scores
FROM scores;
-- max_rank = distinct_scores (always)
</code></pre>
<hr>
<h3>Performance</h3>
<pre><code class="language-sql">-- Both have similar performance
-- DENSE_RANK slightly more expensive
-- (needs to track distinct values)

-- Both benefit from same index:
CREATE INDEX idx_scores 
ON scores(score DESC);

-- No significant difference in speed
</code></pre>
<hr>
<h3>Combined Usage</h3>
<pre><code class="language-sql">-- Show both for comparison
SELECT 
  name,
  score,
  RANK() OVER (ORDER BY score DESC) as standard_rank,
  DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank,
  COUNT(*) OVER () as total_rows,
  COUNT(DISTINCT score) OVER () as distinct_scores
FROM scores;

-- Verify:
-- MAX(standard_rank) = total_rows
-- MAX(dense_rank) = distinct_scores
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>RANK</strong> has gaps</li>
<li><strong>DENSE_RANK</strong> no gaps</li>
<li><strong>RANK</strong> for competitions</li>
<li><strong>DENSE_RANK</strong> for tiers</li>
<li><strong>Both</strong> handle ties same</li>
<li><strong>RANK</strong> final = row count</li>
<li><strong>DENSE_RANK</strong> final = distinct count</li>
<li><strong>Similar</strong> performance</li>
<li><strong>Same</strong> syntax</li>
<li><strong>Choose</strong> based on context</li>
</ol>
<hr>
<h2>Question 178: How do you use LEAD() and LAG() functions?</h2>
<h3>Answer</h3>
<p><strong>LAG()</strong> accesses previous row&#39;s value. <strong>LEAD()</strong> accesses next row&#39;s value. Both allow comparing current row with adjacent rows. LAG = look back, LEAD = look ahead.</p>
<hr>
<h3>LAG() Function</h3>
<p><strong>Access previous row:</strong></p>
<pre><code class="language-sql">-- Sales data
date       | amount
2024-01-01 | 1000
2024-01-02 | 1200
2024-01-03 | 900
2024-01-04 | 1500

-- Get previous day&#39;s sales
SELECT 
  date,
  amount,
  LAG(amount) OVER (ORDER BY date) as prev_day_amount
FROM sales;

-- Result:
date       | amount | prev_day_amount
2024-01-01 | 1000   | NULL           -- No previous
2024-01-02 | 1200   | 1000
2024-01-03 | 900    | 1200
2024-01-04 | 1500   | 900
</code></pre>
<hr>
<h3>LEAD() Function</h3>
<p><strong>Access next row:</strong></p>
<pre><code class="language-sql">-- Get next day&#39;s sales
SELECT 
  date,
  amount,
  LEAD(amount) OVER (ORDER BY date) as next_day_amount
FROM sales;

-- Result:
date       | amount | next_day_amount
2024-01-01 | 1000   | 1200
2024-01-02 | 1200   | 900
2024-01-03 | 900    | 1500
2024-01-04 | 1500   | NULL           -- No next
</code></pre>
<hr>
<h3>Syntax</h3>
<pre><code class="language-sql">LAG(column, offset, default) OVER (
  [PARTITION BY partition_column]
  ORDER BY order_column
)

LEAD(column, offset, default) OVER (
  [PARTITION BY partition_column]
  ORDER BY order_column
)

-- Parameters:
-- column: Column to access
-- offset: How many rows back/ahead (default: 1)
-- default: Value when no row exists (default: NULL)
</code></pre>
<hr>
<h3>With Offset</h3>
<pre><code class="language-sql">-- Look back 2 rows
SELECT 
  date,
  amount,
  LAG(amount, 1) OVER (ORDER BY date) as prev_1_day,
  LAG(amount, 2) OVER (ORDER BY date) as prev_2_days,
  LAG(amount, 3) OVER (ORDER BY date) as prev_3_days
FROM sales;

-- Result:
date       | amount | prev_1_day | prev_2_days | prev_3_days
2024-01-01 | 1000   | NULL       | NULL        | NULL
2024-01-02 | 1200   | 1000       | NULL        | NULL
2024-01-03 | 900    | 1200       | 1000        | NULL
2024-01-04 | 1500   | 900        | 1200        | 1000
</code></pre>
<hr>
<h3>With Default Value</h3>
<pre><code class="language-sql">-- Use 0 instead of NULL
SELECT 
  date,
  amount,
  LAG(amount, 1, 0) OVER (ORDER BY date) as prev_amount
FROM sales;

-- Result:
date       | amount | prev_amount
2024-01-01 | 1000   | 0          -- Default instead of NULL
2024-01-02 | 1200   | 1000
2024-01-03 | 900    | 1200
2024-01-04 | 1500   | 900
</code></pre>
<hr>
<h3>Calculate Changes</h3>
<pre><code class="language-sql">-- Day-over-day change
SELECT 
  date,
  amount,
  LAG(amount) OVER (ORDER BY date) as prev_amount,
  amount - LAG(amount) OVER (ORDER BY date) as daily_change,
  ROUND(
    (amount - LAG(amount) OVER (ORDER BY date)) * 100.0 / 
    LAG(amount) OVER (ORDER BY date),
    2
  ) as pct_change
FROM sales;

-- Result:
date       | amount | prev_amount | daily_change | pct_change
2024-01-01 | 1000   | NULL        | NULL         | NULL
2024-01-02 | 1200   | 1000        | 200          | 20.00
2024-01-03 | 900    | 1200        | -300         | -25.00
2024-01-04 | 1500   | 900         | 600          | 66.67
</code></pre>
<hr>
<h3>With PARTITION BY</h3>
<pre><code class="language-sql">-- Previous sale per product
SELECT 
  product_id,
  date,
  amount,
  LAG(amount) OVER (
    PARTITION BY product_id 
    ORDER BY date
  ) as prev_sale
FROM sales
ORDER BY product_id, date;

-- Result (separate sequences per product):
product_id | date       | amount | prev_sale
1          | 2024-01-01 | 100    | NULL      -- First for product 1
1          | 2024-01-02 | 120    | 100
1          | 2024-01-03 | 110    | 120
2          | 2024-01-01 | 200    | NULL      -- First for product 2
2          | 2024-01-02 | 190    | 200
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Stock price changes:</strong></p>
<pre><code class="language-sql">-- Daily stock movement
SELECT 
  date,
  close_price,
  LAG(close_price) OVER (ORDER BY date) as prev_close,
  close_price - LAG(close_price) OVER (ORDER BY date) as change,
  CASE 
    WHEN close_price &gt; LAG(close_price) OVER (ORDER BY date) 
      THEN &#39;▲&#39;
    WHEN close_price &lt; LAG(close_price) OVER (ORDER BY date) 
      THEN &#39;▼&#39;
    ELSE &#39;─&#39;
  END as trend
FROM stock_prices
ORDER BY date DESC
LIMIT 30;
</code></pre>
<p><strong>2. Customer order frequency:</strong></p>
<pre><code class="language-sql">-- Days between orders per customer
SELECT 
  customer_id,
  order_date,
  order_date - LAG(order_date) OVER (
    PARTITION BY customer_id 
    ORDER BY order_date
  ) as days_since_last_order
FROM orders;

-- Find customers ordering more frequently
WHERE order_date - LAG(order_date) OVER (...) &lt; 7;
</code></pre>
<p><strong>3. Website session analysis:</strong></p>
<pre><code class="language-sql">-- Time between page views
SELECT 
  user_id,
  page,
  viewed_at,
  viewed_at - LAG(viewed_at) OVER (
    PARTITION BY user_id 
    ORDER BY viewed_at
  ) as time_on_prev_page
FROM page_views;
</code></pre>
<p><strong>4. Consecutive events:</strong></p>
<pre><code class="language-sql">-- Find users who logged in on consecutive days
SELECT DISTINCT user_id
FROM (
  SELECT 
    user_id,
    DATE(login_at) as login_date,
    DATE(LAG(login_at) OVER (
      PARTITION BY user_id 
      ORDER BY login_at
    )) as prev_login_date
  FROM logins
) daily_logins
WHERE login_date = prev_login_date + INTERVAL &#39;1 day&#39;;
</code></pre>
<p><strong>5. Gap detection:</strong></p>
<pre><code class="language-sql">-- Find gaps in sequence
SELECT 
  id,
  id - LAG(id) OVER (ORDER BY id) as gap
FROM records
WHERE id - LAG(id) OVER (ORDER BY id) &gt; 1;

-- Shows missing IDs
</code></pre>
<hr>
<h3>Compare Current, Previous, and Next</h3>
<pre><code class="language-sql">-- Three-day window
SELECT 
  date,
  amount,
  LAG(amount) OVER (ORDER BY date) as yesterday,
  LEAD(amount) OVER (ORDER BY date) as tomorrow,
  amount - LAG(amount) OVER (ORDER BY date) as change_from_yesterday,
  LEAD(amount) OVER (ORDER BY date) - amount as change_to_tomorrow
FROM sales;
</code></pre>
<hr>
<h3>Moving Average Context</h3>
<pre><code class="language-sql">-- Compare to moving average
SELECT 
  date,
  amount,
  AVG(amount) OVER (
    ORDER BY date 
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
  ) as ma_3_day,
  amount - LAG(amount) OVER (ORDER BY date) as vs_prev_day
FROM sales;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># LAG/LEAD in raw SQL
Sale.select(&quot;
  date,
  amount,
  LAG(amount) OVER (ORDER BY date) as prev_amount,
  LEAD(amount) OVER (ORDER BY date) as next_amount
&quot;).order(:date)

# Calculate changes
Sale.select(&quot;
  date,
  amount,
  amount - LAG(amount) OVER (ORDER BY date) as daily_change
&quot;).where(&quot;date &gt;= ?&quot;, 30.days.ago)

# Per product
Sale.select(&quot;
  product_id,
  date,
  amount,
  LAG(amount) OVER (
    PARTITION BY product_id 
    ORDER BY date
  ) as prev_amount
&quot;).order(:product_id, :date)
</code></pre>
<hr>
<h3>Performance Tips</h3>
<pre><code class="language-sql">-- ✅ Index on ORDER BY column
CREATE INDEX idx_sales_date ON sales(date);

-- ✅ Index on PARTITION BY + ORDER BY
CREATE INDEX idx_sales_product_date 
ON sales(product_id, date);

-- ✅ Filter before LAG/LEAD
SELECT *
FROM (
  SELECT 
    date,
    amount,
    LAG(amount) OVER (ORDER BY date) as prev
  FROM sales
  WHERE date &gt;= &#39;2024-01-01&#39;  -- Filter first
) with_lag
WHERE prev IS NOT NULL;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>LAG</strong> looks backward</li>
<li><strong>LEAD</strong> looks forward</li>
<li><strong>Offset</strong> parameter for distance</li>
<li><strong>Default</strong> for missing rows</li>
<li><strong>PARTITION BY</strong> for groups</li>
<li><strong>ORDER BY</strong> required</li>
<li><strong>Compare</strong> adjacent rows</li>
<li><strong>Calculate</strong> changes</li>
<li><strong>NULL</strong> when no row</li>
<li><strong>Index</strong> improves performance</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 179: How do you calculate running totals in SQL?</h2>
<h3>Answer</h3>
<p><strong>Running totals</strong> (cumulative sums) use <strong>window functions</strong> with SUM() OVER (ORDER BY ...). Each row shows the sum of all previous rows plus current row.</p>
<hr>
<h3>Basic Running Total</h3>
<pre><code class="language-sql">-- Sales data
date       | amount
2024-01-01 | 100
2024-01-02 | 150
2024-01-03 | 200
2024-01-04 | 120

-- Calculate running total
SELECT 
  date,
  amount,
  SUM(amount) OVER (ORDER BY date) as running_total
FROM sales
ORDER BY date;

-- Result:
date       | amount | running_total
2024-01-01 | 100    | 100         -- 100
2024-01-02 | 150    | 250         -- 100 + 150
2024-01-03 | 200    | 450         -- 100 + 150 + 200
2024-01-04 | 120    | 570         -- 100 + 150 + 200 + 120
</code></pre>
<hr>
<h3>Window Frame Specification</h3>
<pre><code class="language-sql">-- Explicit frame (same as default for ORDER BY)
SELECT 
  date,
  amount,
  SUM(amount) OVER (
    ORDER BY date
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) as running_total
FROM sales;

-- Frame components:
-- UNBOUNDED PRECEDING: Start from first row
-- CURRENT ROW: End at current row
-- Result: Sum from beginning to current
</code></pre>
<hr>
<h3>Running Total Per Group</h3>
<pre><code class="language-sql">-- Running total per product
SELECT 
  product_id,
  date,
  quantity,
  SUM(quantity) OVER (
    PARTITION BY product_id 
    ORDER BY date
  ) as running_quantity
FROM sales
ORDER BY product_id, date;

-- Result:
product_id | date       | quantity | running_quantity
1          | 2024-01-01 | 10       | 10
1          | 2024-01-02 | 15       | 25      -- 10 + 15
1          | 2024-01-03 | 12       | 37      -- 10 + 15 + 12
2          | 2024-01-01 | 20       | 20      -- Reset for product 2
2          | 2024-01-02 | 25       | 45      -- 20 + 25
</code></pre>
<hr>
<h3>Multiple Running Totals</h3>
<pre><code class="language-sql">-- Track multiple metrics
SELECT 
  date,
  revenue,
  cost,
  SUM(revenue) OVER (ORDER BY date) as cumulative_revenue,
  SUM(cost) OVER (ORDER BY date) as cumulative_cost,
  SUM(revenue - cost) OVER (ORDER BY date) as cumulative_profit
FROM daily_finances
ORDER BY date;
</code></pre>
<hr>
<h3>Running Total with Reset</h3>
<pre><code class="language-sql">-- Reset running total each month
SELECT 
  date,
  amount,
  SUM(amount) OVER (
    PARTITION BY DATE_TRUNC(&#39;month&#39;, date)
    ORDER BY date
  ) as monthly_running_total
FROM sales;

-- Result:
date       | amount | monthly_running_total
2024-01-15 | 100    | 100
2024-01-20 | 150    | 250
2024-01-25 | 200    | 450
2024-02-01 | 120    | 120     -- Resets for new month
2024-02-05 | 180    | 300     -- 120 + 180
</code></pre>
<hr>
<h3>Running Total with Percentage</h3>
<pre><code class="language-sql">-- Show percentage of total
SELECT 
  date,
  amount,
  SUM(amount) OVER (ORDER BY date) as running_total,
  SUM(amount) OVER () as grand_total,
  ROUND(
    SUM(amount) OVER (ORDER BY date) * 100.0 / 
    SUM(amount) OVER (),
    2
  ) as pct_of_total
FROM sales
ORDER BY date;

-- Result:
date       | amount | running_total | grand_total | pct_of_total
2024-01-01 | 100    | 100           | 570         | 17.54
2024-01-02 | 150    | 250           | 570         | 43.86
2024-01-03 | 200    | 450           | 570         | 78.95
2024-01-04 | 120    | 570           | 570         | 100.00
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Account balance:</strong></p>
<pre><code class="language-sql">-- Bank account running balance
SELECT 
  transaction_date,
  transaction_type,
  amount,
  SUM(
    CASE 
      WHEN transaction_type = &#39;credit&#39; THEN amount
      WHEN transaction_type = &#39;debit&#39; THEN -amount
    END
  ) OVER (ORDER BY transaction_date, transaction_id) as balance
FROM transactions
WHERE account_id = 12345
ORDER BY transaction_date;

-- Result:
date       | type   | amount | balance
2024-01-01 | credit | 1000   | 1000
2024-01-02 | debit  | 200    | 800
2024-01-03 | credit | 500    | 1300
2024-01-04 | debit  | 300    | 1000
</code></pre>
<p><strong>2. Inventory tracking:</strong></p>
<pre><code class="language-sql">-- Running inventory count
SELECT 
  date,
  product_id,
  CASE 
    WHEN type = &#39;purchase&#39; THEN quantity
    WHEN type = &#39;sale&#39; THEN -quantity
  END as change,
  SUM(
    CASE 
      WHEN type = &#39;purchase&#39; THEN quantity
      WHEN type = &#39;sale&#39; THEN -quantity
    END
  ) OVER (
    PARTITION BY product_id 
    ORDER BY date
  ) as current_stock
FROM inventory_changes
ORDER BY product_id, date;
</code></pre>
<p><strong>3. Customer lifetime value:</strong></p>
<pre><code class="language-sql">-- Cumulative spending per customer
SELECT 
  customer_id,
  order_date,
  order_amount,
  SUM(order_amount) OVER (
    PARTITION BY customer_id 
    ORDER BY order_date
  ) as lifetime_value,
  ROW_NUMBER() OVER (
    PARTITION BY customer_id 
    ORDER BY order_date
  ) as order_number
FROM orders
ORDER BY customer_id, order_date;
</code></pre>
<p><strong>4. Project budget tracking:</strong></p>
<pre><code class="language-sql">-- Budget vs actual spend
SELECT 
  week,
  actual_spend,
  budgeted_amount,
  SUM(actual_spend) OVER (ORDER BY week) as cumulative_spend,
  SUM(budgeted_amount) OVER (ORDER BY week) as cumulative_budget,
  SUM(budgeted_amount) OVER (ORDER BY week) - 
  SUM(actual_spend) OVER (ORDER BY week) as remaining_budget
FROM project_expenses
ORDER BY week;
</code></pre>
<p><strong>5. Sales target progress:</strong></p>
<pre><code class="language-sql">-- Track progress toward annual goal
SELECT 
  month,
  sales,
  12000000 as annual_target,
  SUM(sales) OVER (ORDER BY month) as year_to_date,
  ROUND(
    SUM(sales) OVER (ORDER BY month) * 100.0 / 12000000,
    2
  ) as pct_of_target
FROM monthly_sales
WHERE EXTRACT(YEAR FROM month) = 2024
ORDER BY month;
</code></pre>
<hr>
<h3>Running Count</h3>
<pre><code class="language-sql">-- Cumulative customer count
SELECT 
  signup_date,
  COUNT(*) OVER (ORDER BY signup_date) as total_customers
FROM users
ORDER BY signup_date;
</code></pre>
<hr>
<h3>Running Average</h3>
<pre><code class="language-sql">-- Cumulative average
SELECT 
  date,
  value,
  AVG(value) OVER (ORDER BY date) as running_avg
FROM measurements
ORDER BY date;
</code></pre>
<hr>
<h3>With Conditional Logic</h3>
<pre><code class="language-sql">-- Running total only for completed orders
SELECT 
  date,
  amount,
  status,
  SUM(
    CASE WHEN status = &#39;completed&#39; THEN amount ELSE 0 END
  ) OVER (ORDER BY date) as completed_revenue_running_total
FROM orders
ORDER BY date;
</code></pre>
<hr>
<h3>Performance Optimization</h3>
<pre><code class="language-sql">-- ✅ Index on ORDER BY column
CREATE INDEX idx_sales_date ON sales(date);

-- ✅ Index on PARTITION BY + ORDER BY
CREATE INDEX idx_sales_product_date 
ON sales(product_id, date);

-- ✅ Materialized view for expensive calculations
CREATE MATERIALIZED VIEW daily_running_totals AS
SELECT 
  date,
  SUM(amount) OVER (ORDER BY date) as running_total
FROM sales;

-- Refresh periodically
REFRESH MATERIALIZED VIEW daily_running_totals;

-- ❌ Avoid on very large tables without filtering
-- Filter first, then calculate:
SELECT *
FROM (
  SELECT 
    date,
    amount,
    SUM(amount) OVER (ORDER BY date) as running_total
  FROM sales
  WHERE date &gt;= &#39;2024-01-01&#39;  -- Filter first
) filtered
WHERE running_total &gt; 10000;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># Basic running total
Sale.select(&quot;
  date,
  amount,
  SUM(amount) OVER (ORDER BY date) as running_total
&quot;).order(:date)

# Per product
Sale.select(&quot;
  product_id,
  date,
  amount,
  SUM(amount) OVER (
    PARTITION BY product_id 
    ORDER BY date
  ) as running_total
&quot;).order(:product_id, :date)

# With percentage
Sale.select(&quot;
  date,
  amount,
  SUM(amount) OVER (ORDER BY date) as running_total,
  ROUND(
    SUM(amount) OVER (ORDER BY date) * 100.0 / 
    SUM(amount) OVER (),
    2
  ) as pct_of_total
&quot;).order(:date)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>SUM() OVER</strong> for running totals</li>
<li><strong>ORDER BY</strong> determines sequence</li>
<li><strong>PARTITION BY</strong> for groups</li>
<li><strong>Cumulative</strong> sum calculation</li>
<li><strong>Each row</strong> sees previous sum</li>
<li><strong>Reset</strong> with PARTITION BY</li>
<li><strong>Percentage</strong> of total</li>
<li><strong>Multiple metrics</strong> together</li>
<li><strong>Index</strong> improves performance</li>
<li><strong>Essential</strong> for financial reporting</li>
</ol>
<hr>
<h2>Question 180: How do you calculate moving averages in SQL?</h2>
<h3>Answer</h3>
<p><strong>Moving averages</strong> use window functions with frame specifications to calculate averages over a sliding window of rows. Common for smoothing time-series data and trend analysis.</p>
<hr>
<h3>Basic Moving Average</h3>
<pre><code class="language-sql">-- 3-day moving average
SELECT 
  date,
  value,
  AVG(value) OVER (
    ORDER BY date
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
  ) as ma_3
FROM measurements
ORDER BY date;

-- Result:
date       | value | ma_3
2024-01-01 | 100   | 100.00    -- (100) / 1
2024-01-02 | 120   | 110.00    -- (100+120) / 2
2024-01-03 | 90    | 103.33    -- (100+120+90) / 3
2024-01-04 | 110   | 106.67    -- (120+90+110) / 3
2024-01-05 | 130   | 110.00    -- (90+110+130) / 3
</code></pre>
<hr>
<h3>Frame Specifications</h3>
<pre><code class="language-sql">-- Different window sizes
SELECT 
  date,
  value,
  AVG(value) OVER (
    ORDER BY date
    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
  ) as ma_3,
  AVG(value) OVER (
    ORDER BY date
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
  ) as ma_7,
  AVG(value) OVER (
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) as ma_30
FROM daily_data
ORDER BY date;
</code></pre>
<hr>
<h3>Centered Moving Average</h3>
<pre><code class="language-sql">-- Centered 5-day moving average
-- (2 before + current + 2 after)
SELECT 
  date,
  value,
  AVG(value) OVER (
    ORDER BY date
    ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING
  ) as centered_ma_5
FROM measurements
ORDER BY date;

-- Result:
date       | value | centered_ma_5
2024-01-01 | 100   | 108.00    -- Avg of 1st 3 days
2024-01-02 | 120   | 108.00    -- Avg of 1st 4 days
2024-01-03 | 90    | 110.00    -- Avg of all 5 days
2024-01-04 | 110   | 112.00    -- Avg of last 4 days
2024-01-05 | 130   | 120.00    -- Avg of last 3 days
</code></pre>
<hr>
<h3>Multiple Moving Averages</h3>
<pre><code class="language-sql">-- Short-term and long-term MA
SELECT 
  date,
  price,
  AVG(price) OVER (
    ORDER BY date
    ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
  ) as ma_5,
  AVG(price) OVER (
    ORDER BY date
    ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
  ) as ma_20,
  AVG(price) OVER (
    ORDER BY date
    ROWS BETWEEN 49 PRECEDING AND CURRENT ROW
  ) as ma_50
FROM stock_prices
ORDER BY date;

-- Trading signal: MA_5 crosses above MA_20
</code></pre>
<hr>
<h3>Moving Average Per Group</h3>
<pre><code class="language-sql">-- MA per product
SELECT 
  product_id,
  date,
  sales,
  AVG(sales) OVER (
    PARTITION BY product_id
    ORDER BY date
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
  ) as weekly_ma
FROM product_sales
ORDER BY product_id, date;
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Stock price smoothing:</strong></p>
<pre><code class="language-sql">-- Technical analysis moving averages
SELECT 
  date,
  close_price,
  AVG(close_price) OVER (
    ORDER BY date
    ROWS BETWEEN 4 PRECEDING AND CURRENT ROW
  ) as ma_5,
  AVG(close_price) OVER (
    ORDER BY date
    ROWS BETWEEN 19 PRECEDING AND CURRENT ROW
  ) as ma_20,
  AVG(close_price) OVER (
    ORDER BY date
    ROWS BETWEEN 49 PRECEDING AND CURRENT ROW
  ) as ma_50,
  -- Golden cross signal
  CASE 
    WHEN AVG(close_price) OVER (
      ORDER BY date
      ROWS BETWEEN 49 PRECEDING AND CURRENT ROW
    ) &lt; close_price THEN &#39;Bullish&#39;
    ELSE &#39;Bearish&#39;
  END as trend
FROM stock_prices
WHERE symbol = &#39;AAPL&#39;
ORDER BY date DESC
LIMIT 100;
</code></pre>
<p><strong>2. Website traffic trending:</strong></p>
<pre><code class="language-sql">-- 7-day moving average of visitors
SELECT 
  date,
  visitors,
  AVG(visitors) OVER (
    ORDER BY date
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
  ) as ma_7,
  visitors - AVG(visitors) OVER (
    ORDER BY date
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
  ) as deviation_from_ma
FROM daily_traffic
WHERE date &gt;= CURRENT_DATE - INTERVAL &#39;90 days&#39;
ORDER BY date;
</code></pre>
<p><strong>3. Sales forecasting:</strong></p>
<pre><code class="language-sql">-- Compare actual vs moving average
SELECT 
  date,
  actual_sales,
  AVG(actual_sales) OVER (
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND 1 PRECEDING
  ) as forecast_30_day,
  actual_sales - AVG(actual_sales) OVER (
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND 1 PRECEDING
  ) as variance
FROM daily_sales
ORDER BY date DESC
LIMIT 30;
</code></pre>
<p><strong>4. Temperature smoothing:</strong></p>
<pre><code class="language-sql">-- Smooth noisy sensor data
SELECT 
  measured_at,
  temperature,
  AVG(temperature) OVER (
    ORDER BY measured_at
    ROWS BETWEEN 5 PRECEDING AND 5 FOLLOWING
  ) as smoothed_temp,
  temperature - AVG(temperature) OVER (
    ORDER BY measured_at
    ROWS BETWEEN 5 PRECEDING AND 5 FOLLOWING
  ) as noise
FROM sensor_readings
WHERE sensor_id = &#39;TEMP_01&#39;
ORDER BY measured_at;
</code></pre>
<p><strong>5. Customer engagement metrics:</strong></p>
<pre><code class="language-sql">-- 30-day moving average active users
SELECT 
  date,
  daily_active_users,
  AVG(daily_active_users) OVER (
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) as mau_30,
  ROUND(
    daily_active_users * 100.0 / 
    AVG(daily_active_users) OVER (
      ORDER BY date
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ),
    2
  ) as pct_of_average
FROM user_activity
ORDER BY date;
</code></pre>
<hr>
<h3>Weighted Moving Average</h3>
<pre><code class="language-sql">-- Exponentially weighted moving average (simplified)
SELECT 
  date,
  price,
  -- More weight to recent values
  (
    price * 0.5 + 
    LAG(price, 1) OVER (ORDER BY date) * 0.3 +
    LAG(price, 2) OVER (ORDER BY date) * 0.2
  ) as weighted_ma_3
FROM prices
ORDER BY date;
</code></pre>
<hr>
<h3>Moving Sum (Not Average)</h3>
<pre><code class="language-sql">-- 7-day rolling sum
SELECT 
  date,
  sales,
  SUM(sales) OVER (
    ORDER BY date
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
  ) as rolling_7_day_sum
FROM daily_sales
ORDER BY date;
</code></pre>
<hr>
<h3>Range-Based Frame (Time Windows)</h3>
<pre><code class="language-sql">-- PostgreSQL: Moving average using date range
SELECT 
  date,
  amount,
  AVG(amount) OVER (
    ORDER BY date
    RANGE BETWEEN INTERVAL &#39;7 days&#39; PRECEDING 
              AND CURRENT ROW
  ) as ma_7_days
FROM sales
ORDER BY date;

-- Handles missing dates correctly
</code></pre>
<hr>
<h3>Compare Multiple Periods</h3>
<pre><code class="language-sql">-- Current vs MA vs previous period
SELECT 
  date,
  sales,
  AVG(sales) OVER (
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) as ma_30,
  LAG(sales, 7) OVER (ORDER BY date) as week_ago,
  sales - AVG(sales) OVER (
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) as vs_ma,
  sales - LAG(sales, 7) OVER (ORDER BY date) as vs_week_ago
FROM daily_sales
ORDER BY date DESC;
</code></pre>
<hr>
<h3>Performance Tips</h3>
<pre><code class="language-sql">-- ✅ Index on ORDER BY column
CREATE INDEX idx_data_date ON data(date);

-- ✅ Materialized view for expensive MA
CREATE MATERIALIZED VIEW daily_ma AS
SELECT 
  date,
  value,
  AVG(value) OVER (
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) as ma_30
FROM measurements;

REFRESH MATERIALIZED VIEW daily_ma;

-- ✅ Filter date range first
SELECT *
FROM (
  SELECT 
    date,
    value,
    AVG(value) OVER (ORDER BY date ROWS 6 PRECEDING) as ma
  FROM data
  WHERE date &gt;= &#39;2024-01-01&#39;  -- Filter first
) with_ma
WHERE date &gt;= &#39;2024-01-07&#39;;  -- Ensure full window
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># 7-day moving average
Metric.select(&quot;
  date,
  value,
  AVG(value) OVER (
    ORDER BY date
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
  ) as ma_7
&quot;).where(&quot;date &gt;= ?&quot;, 90.days.ago)
  .order(:date)

# Multiple MAs
StockPrice.select(&quot;
  date,
  close_price,
  AVG(close_price) OVER (
    ORDER BY date ROWS 4 PRECEDING
  ) as ma_5,
  AVG(close_price) OVER (
    ORDER BY date ROWS 19 PRECEDING
  ) as ma_20
&quot;).where(symbol: &#39;AAPL&#39;)
  .order(date: :desc)
  .limit(100)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>AVG() OVER</strong> with frame</li>
<li><strong>ROWS BETWEEN</strong> defines window</li>
<li><strong>Sliding window</strong> calculation</li>
<li><strong>Smooths</strong> time-series data</li>
<li><strong>Multiple MAs</strong> for comparison</li>
<li><strong>PARTITION BY</strong> for groups</li>
<li><strong>Centered</strong> or trailing</li>
<li><strong>Trading signals</strong> (MA crossovers)</li>
<li><strong>Index</strong> improves performance</li>
<li><strong>Essential</strong> for trend analysis</li>
</ol>
<hr>
<h2>Advanced SQL Concepts</h2>
<h2>Question 181: How do you use Common Table Expressions (CTEs)?</h2>
<h3>Answer</h3>
<p><strong>CTEs (WITH clauses)</strong> create temporary named result sets that exist only for a single query. Improve readability, enable recursion, and allow referencing same subquery multiple times.</p>
<hr>
<h3>Basic CTE Syntax</h3>
<pre><code class="language-sql">WITH cte_name AS (
  SELECT ...
  FROM ...
  WHERE ...
)
SELECT *
FROM cte_name;
</code></pre>
<hr>
<h3>Simple Example</h3>
<pre><code class="language-sql">-- Without CTE (nested subquery)
SELECT *
FROM (
  SELECT 
    user_id,
    SUM(amount) as total_spent
  FROM orders
  GROUP BY user_id
) user_totals
WHERE total_spent &gt; 1000;

-- With CTE (more readable)
WITH user_totals AS (
  SELECT 
    user_id,
    SUM(amount) as total_spent
  FROM orders
  GROUP BY user_id
)
SELECT *
FROM user_totals
WHERE total_spent &gt; 1000;
</code></pre>
<hr>
<h3>Multiple CTEs</h3>
<pre><code class="language-sql">-- Chain multiple CTEs
WITH 
active_users AS (
  SELECT id, name, email
  FROM users
  WHERE status = &#39;active&#39;
),
premium_users AS (
  SELECT id
  FROM subscriptions
  WHERE plan = &#39;premium&#39;
),
active_premium AS (
  SELECT au.*
  FROM active_users au
  INNER JOIN premium_users pu ON au.id = pu.id
)
SELECT *
FROM active_premium
ORDER BY name;
</code></pre>
<hr>
<h3>Reusing CTE Multiple Times</h3>
<pre><code class="language-sql">-- Reference CTE multiple times
WITH monthly_sales AS (
  SELECT 
    DATE_TRUNC(&#39;month&#39;, order_date) as month,
    SUM(amount) as total
  FROM orders
  GROUP BY DATE_TRUNC(&#39;month&#39;, order_date)
)
SELECT 
  current.month,
  current.total as current_month,
  previous.total as previous_month,
  current.total - previous.total as growth
FROM monthly_sales current
LEFT JOIN monthly_sales previous 
  ON current.month = previous.month + INTERVAL &#39;1 month&#39;
ORDER BY current.month;
</code></pre>
<hr>
<h3>Recursive CTE</h3>
<p><strong>Hierarchical data:</strong></p>
<pre><code class="language-sql">-- Employee hierarchy (manager-subordinate)
WITH RECURSIVE employee_hierarchy AS (
  -- Base case: top-level employees (no manager)
  SELECT 
    id,
    name,
    manager_id,
    0 as level
  FROM employees
  WHERE manager_id IS NULL
  
  UNION ALL
  
  -- Recursive case: employees with managers
  SELECT 
    e.id,
    e.name,
    e.manager_id,
    eh.level + 1
  FROM employees e
  INNER JOIN employee_hierarchy eh ON e.manager_id = eh.id
)
SELECT 
  REPEAT(&#39;  &#39;, level) || name as org_chart,
  level
FROM employee_hierarchy
ORDER BY level, name;

-- Result:
Alice              (level 0 - CEO)
  Bob              (level 1)
    David          (level 2)
    Eve            (level 2)
  Charlie          (level 1)
    Frank          (level 2)
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Sales funnel analysis:</strong></p>
<pre><code class="language-sql">WITH 
visitors AS (
  SELECT DATE(visited_at) as date, COUNT(DISTINCT user_id) as count
  FROM page_views
  WHERE visited_at &gt;= CURRENT_DATE - INTERVAL &#39;30 days&#39;
  GROUP BY DATE(visited_at)
),
signups AS (
  SELECT DATE(created_at) as date, COUNT(*) as count
  FROM users
  WHERE created_at &gt;= CURRENT_DATE - INTERVAL &#39;30 days&#39;
  GROUP BY DATE(created_at)
),
purchases AS (
  SELECT DATE(created_at) as date, COUNT(*) as count
  FROM orders
  WHERE created_at &gt;= CURRENT_DATE - INTERVAL &#39;30 days&#39;
  GROUP BY DATE(created_at)
)
SELECT 
  v.date,
  v.count as visitors,
  COALESCE(s.count, 0) as signups,
  COALESCE(p.count, 0) as purchases,
  ROUND(COALESCE(s.count, 0) * 100.0 / v.count, 2) as signup_rate,
  ROUND(COALESCE(p.count, 0) * 100.0 / COALESCE(s.count, 1), 2) as purchase_rate
FROM visitors v
LEFT JOIN signups s ON v.date = s.date
LEFT JOIN purchases p ON v.date = p.date
ORDER BY v.date;
</code></pre>
<p><strong>2. Product recommendations:</strong></p>
<pre><code class="language-sql">-- Products bought together
WITH user_products AS (
  SELECT 
    user_id,
    product_id
  FROM order_items
  WHERE created_at &gt;= CURRENT_DATE - INTERVAL &#39;90 days&#39;
),
product_pairs AS (
  SELECT 
    up1.product_id as product_a,
    up2.product_id as product_b,
    COUNT(DISTINCT up1.user_id) as times_bought_together
  FROM user_products up1
  JOIN user_products up2 
    ON up1.user_id = up2.user_id 
    AND up1.product_id &lt; up2.product_id
  GROUP BY up1.product_id, up2.product_id
)
SELECT 
  p1.name as product,
  p2.name as recommended,
  pp.times_bought_together
FROM product_pairs pp
JOIN products p1 ON pp.product_a = p1.id
JOIN products p2 ON pp.product_b = p2.id
WHERE pp.product_a = 123
ORDER BY pp.times_bought_together DESC
LIMIT 5;
</code></pre>
<p><strong>3. Running calculations:</strong></p>
<pre><code class="language-sql">-- Year-over-year growth
WITH monthly_revenue AS (
  SELECT 
    DATE_TRUNC(&#39;month&#39;, order_date) as month,
    SUM(amount) as revenue
  FROM orders
  GROUP BY DATE_TRUNC(&#39;month&#39;, order_date)
)
SELECT 
  current.month,
  current.revenue as current_revenue,
  previous.revenue as previous_year_revenue,
  ROUND(
    (current.revenue - previous.revenue) * 100.0 / previous.revenue,
    2
  ) as yoy_growth_pct
FROM monthly_revenue current
LEFT JOIN monthly_revenue previous 
  ON current.month = previous.month + INTERVAL &#39;1 year&#39;
ORDER BY current.month;
</code></pre>
<p><strong>4. Recursive category tree:</strong></p>
<pre><code class="language-sql">-- Category hierarchy with products
WITH RECURSIVE category_tree AS (
  -- Root categories
  SELECT 
    id,
    name,
    parent_id,
    0 as depth,
    name as path
  FROM categories
  WHERE parent_id IS NULL
  
  UNION ALL
  
  -- Child categories
  SELECT 
    c.id,
    c.name,
    c.parent_id,
    ct.depth + 1,
    ct.path || &#39; &gt; &#39; || c.name
  FROM categories c
  JOIN category_tree ct ON c.parent_id = ct.id
)
SELECT 
  ct.path,
  COUNT(p.id) as product_count
FROM category_tree ct
LEFT JOIN products p ON ct.id = p.category_id
GROUP BY ct.path
ORDER BY ct.path;
</code></pre>
<hr>
<h3>CTE vs Subquery</h3>
<p><strong>When to use CTE:</strong></p>
<pre><code class="language-sql">✅ Complex queries (better readability)
✅ Multiple references to same subquery
✅ Recursive queries (only way)
✅ Logical query structure
✅ Team collaboration (maintainability)
</code></pre>
<p><strong>When to use Subquery:</strong></p>
<pre><code class="language-sql">✅ Simple one-time reference
✅ Single use case
✅ Performance critical (some databases)
</code></pre>
<hr>
<h3>CTE vs Temporary Table</h3>
<pre><code class="language-sql">-- CTE: Query-scoped, automatic cleanup
WITH temp_data AS (...)
SELECT * FROM temp_data;

-- Temp table: Session-scoped, manual cleanup
CREATE TEMPORARY TABLE temp_data AS ...;
SELECT * FROM temp_data;
DROP TABLE temp_data;

-- CTE advantages:
-- ✅ No cleanup needed
-- ✅ Query-scoped
-- ✅ No permissions required
-- ✅ Easier to read

-- Temp table advantages:
-- ✅ Can be indexed
-- ✅ Can be referenced in multiple queries
-- ✅ Better for large datasets
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-sql">-- CTEs are optimization fences in some databases
-- (PostgreSQL materializes CTEs)

-- Force inline (PostgreSQL 12+)
WITH cte AS NOT MATERIALIZED (
  SELECT * FROM large_table WHERE condition
)
SELECT * FROM cte LIMIT 10;

-- Force materialization
WITH cte AS MATERIALIZED (
  SELECT expensive_calculation() as result
  FROM data
)
SELECT * FROM cte  -- Calculated once
UNION ALL
SELECT * FROM cte; -- Reused

-- Index base tables, not CTEs
CREATE INDEX idx_orders_date ON orders(order_date);
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># Basic CTE
high_spenders = User.select(&#39;id&#39;).where(&#39;total_spent &gt; 1000&#39;)
User.with(high_spenders: high_spenders)
    .from(&#39;high_spenders&#39;)
    .joins(&#39;JOIN users ON users.id = high_spenders.id&#39;)

# Multiple CTEs
active = User.where(status: &#39;active&#39;)
premium = User.where(plan: &#39;premium&#39;)

User.with(active_users: active, premium_users: premium)
    .from(&#39;active_users&#39;)
    .joins(&#39;JOIN premium_users ON active_users.id = premium_users.id&#39;)

# Raw SQL for complex CTEs
ActiveRecord::Base.connection.execute(&lt;&lt;-SQL)
  WITH RECURSIVE hierarchy AS (...)
  SELECT * FROM hierarchy
SQL
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>WITH</strong> creates temporary result</li>
<li><strong>Better readability</strong> than subqueries</li>
<li><strong>Multiple CTEs</strong> with comma</li>
<li><strong>Reference multiple times</strong></li>
<li><strong>RECURSIVE</strong> for hierarchies</li>
<li><strong>Query-scoped</strong> (automatic cleanup)</li>
<li><strong>Logical structure</strong> for complex queries</li>
<li><strong>Performance</strong> varies by database</li>
<li><strong>No indexes</strong> on CTE results</li>
<li><strong>Maintainable</strong> code</li>
</ol>
<hr>
<h2>Question 182: What is the difference between <code>LIKE</code> and <code>ILIKE</code>?</h2>
<h3>Answer</h3>
<p><strong>LIKE</strong> is case-sensitive pattern matching. <strong>ILIKE</strong> is case-insensitive (PostgreSQL specific). LIKE = exact case, ILIKE = any case.</p>
<hr>
<h3>LIKE (Case-Sensitive)</h3>
<pre><code class="language-sql">-- Exact case match required
SELECT * FROM users
WHERE name LIKE &#39;Alice%&#39;;

-- Matches:
-- Alice, Alice Smith, ALICE ❌

-- Only matches:
-- Alice, Alice Smith (lowercase &#39;lice&#39;)
</code></pre>
<hr>
<h3>ILIKE (Case-Insensitive)</h3>
<pre><code class="language-sql">-- PostgreSQL only
SELECT * FROM users
WHERE name ILIKE &#39;alice%&#39;;

-- Matches:
-- Alice, alice, ALICE, AliCe, Alice Smith, etc.
</code></pre>
<hr>
<h3>Pattern Wildcards</h3>
<pre><code class="language-sql">-- % = any sequence of characters
-- _ = single character

-- Starts with
LIKE &#39;A%&#39;    -- Alice, Andrew
ILIKE &#39;a%&#39;   -- alice, ALICE, Andrew

-- Ends with
LIKE &#39;%son&#39;  -- Johnson, Wilson
ILIKE &#39;%son&#39; -- johnson, JOHNSON

-- Contains
LIKE &#39;%test%&#39;  -- testing, Test123
ILIKE &#39;%test%&#39; -- Testing, TEST, test

-- Exact length
LIKE &#39;A___&#39;  -- 4 characters starting with A
ILIKE &#39;a___&#39; -- Case-insensitive
</code></pre>
<hr>
<h3>Database Support</h3>
<pre><code class="language-sql">-- PostgreSQL: Both LIKE and ILIKE
SELECT * FROM users WHERE name ILIKE &#39;alice%&#39;;

-- MySQL: Only LIKE (case-insensitive by default!)
SELECT * FROM users WHERE name LIKE &#39;alice%&#39;;
-- Matches Alice, ALICE, alice

-- MySQL case-sensitive:
SELECT * FROM users WHERE name LIKE BINARY &#39;Alice%&#39;;

-- SQL Server: Both LIKE and COLLATE
SELECT * FROM users 
WHERE name LIKE &#39;alice%&#39; COLLATE Latin1_General_CI_AS;  -- Case-insensitive

-- Oracle: Only LIKE (case-sensitive)
SELECT * FROM users WHERE UPPER(name) LIKE &#39;ALICE%&#39;;
</code></pre>
<hr>
<h3>Case-Insensitive Alternatives</h3>
<p><strong>PostgreSQL:</strong></p>
<pre><code class="language-sql">-- Method 1: ILIKE
WHERE name ILIKE &#39;alice%&#39;

-- Method 2: LOWER()
WHERE LOWER(name) LIKE &#39;alice%&#39;

-- Method 3: UPPER()
WHERE UPPER(name) LIKE &#39;ALICE%&#39;
</code></pre>
<p><strong>MySQL:</strong></p>
<pre><code class="language-sql">-- Default: case-insensitive
WHERE name LIKE &#39;alice%&#39;

-- Case-sensitive:
WHERE name LIKE BINARY &#39;Alice%&#39;
</code></pre>
<hr>
<h3>Performance</h3>
<pre><code class="language-sql">-- LIKE with leading wildcard: SLOW (no index)
WHERE name LIKE &#39;%alice%&#39;  -- Full table scan

-- LIKE without leading wildcard: FAST (uses index)
WHERE name LIKE &#39;alice%&#39;   -- Index scan

-- ILIKE: SLOWER than LIKE
WHERE name ILIKE &#39;alice%&#39;  -- Case conversion

-- Best: Index with expression
CREATE INDEX idx_users_name_lower ON users(LOWER(name));
WHERE LOWER(name) LIKE &#39;alice%&#39;;  -- Uses index
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Search functionality:</strong></p>
<pre><code class="language-sql">-- Case-insensitive search
SELECT * FROM products
WHERE name ILIKE &#39;%laptop%&#39;
   OR description ILIKE &#39;%laptop%&#39;;

-- Matches: Laptop, LAPTOP, laptop, Gaming Laptop
</code></pre>
<p><strong>2. Email validation:</strong></p>
<pre><code class="language-sql">-- Case-insensitive email check
SELECT * FROM users
WHERE email ILIKE &#39;%@gmail.com&#39;;

-- Matches: user@gmail.com, User@Gmail.Com
</code></pre>
<p><strong>3. Prefix search:</strong></p>
<pre><code class="language-sql">-- Name autocomplete
SELECT name FROM users
WHERE name ILIKE &#39;joh%&#39;
ORDER BY name
LIMIT 10;

-- Matches: John, john, JOHN, Johnny, Johnson
</code></pre>
<hr>
<h3>Special Characters</h3>
<pre><code class="language-sql">-- Escape special characters
-- % and _ are wildcards

-- Match literal %
WHERE text LIKE &#39;50\%&#39; ESCAPE &#39;\&#39;

-- Match literal _
WHERE code LIKE &#39;ABC\_123&#39; ESCAPE &#39;\&#39;

-- PostgreSQL also supports:
WHERE text LIKE &#39;50%&#39; ESCAPE &#39;|&#39;
WHERE text LIKE &#39;50|%&#39; -- | is escape
</code></pre>
<hr>
<h3>Regular Expressions (Better Alternative)</h3>
<pre><code class="language-sql">-- PostgreSQL: SIMILAR TO (SQL standard)
WHERE name SIMILAR TO &#39;A(lice|ndrew)%&#39;

-- PostgreSQL: ~ (regex)
WHERE name ~ &#39;^[Aa]lice&#39;  -- Case-sensitive regex
WHERE name ~* &#39;^alice&#39;     -- Case-insensitive regex

-- More powerful than LIKE:
WHERE email ~* &#39;^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$&#39;
</code></pre>
<hr>
<h3>Rails ActiveRecord</h3>
<pre><code class="language-ruby"># PostgreSQL: ILIKE
User.where(&quot;name ILIKE ?&quot;, &quot;%alice%&quot;)

# MySQL: LIKE (case-insensitive by default)
User.where(&quot;name LIKE ?&quot;, &quot;%alice%&quot;)

# Cross-database: LOWER
User.where(&quot;LOWER(name) LIKE LOWER(?)&quot;, &quot;%alice%&quot;)

# Arel (more complex)
users = User.arel_table
User.where(users[:name].matches(&quot;%alice%&quot;))  # LIKE
User.where(users[:name].matches(&quot;%alice%&quot;, nil, true))  # ILIKE

# Scopes
class User &lt; ApplicationRecord
  scope :search_name, -&gt;(query) {
    where(&quot;name ILIKE ?&quot;, &quot;%#{sanitize_sql_like(query)}%&quot;)
  }
end

User.search_name(&quot;alice&quot;)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>LIKE</strong> case-sensitive</li>
<li><strong>ILIKE</strong> case-insensitive (PostgreSQL)</li>
<li><strong>%</strong> any characters</li>
<li><strong>_</strong> single character</li>
<li><strong>Leading %</strong> slow (no index)</li>
<li><strong>LOWER() + index</strong> for performance</li>
<li><strong>MySQL LIKE</strong> case-insensitive default</li>
<li><strong>ESCAPE</strong> for literal wildcards</li>
<li><strong>Regex</strong> more powerful</li>
<li><strong>Database-specific</strong> behavior</li>
</ol>
<hr>
<h2>Question 183-186 Summary</h2>
<p>Due to space constraints, here are concise answers:</p>
<p><strong>Q183: Insert multiple records efficiently</strong></p>
<pre><code class="language-sql">-- Bulk INSERT
INSERT INTO users (name, email) VALUES
  (&#39;Alice&#39;, &#39;alice@example.com&#39;),
  (&#39;Bob&#39;, &#39;bob@example.com&#39;),
  (&#39;Charlie&#39;, &#39;charlie@example.com&#39;);

-- INSERT from SELECT
INSERT INTO archive_orders
SELECT * FROM orders WHERE created_at &lt; &#39;2023-01-01&#39;;

-- Rails: insert_all (Rails 6+)
User.insert_all([
  {name: &#39;Alice&#39;, email: &#39;alice@example.com&#39;},
  {name: &#39;Bob&#39;, email: &#39;bob@example.com&#39;}
])
</code></pre>
<p><strong>Q184: Bulk update without slowing database</strong></p>
<pre><code class="language-sql">-- Batch updates
UPDATE products SET price = price * 1.1
WHERE category = &#39;Electronics&#39;
AND id BETWEEN 1 AND 1000;
-- Run in batches

-- Use CASE for different updates
UPDATE products
SET price = CASE 
  WHEN category = &#39;Electronics&#39; THEN price * 1.1
  WHEN category = &#39;Clothing&#39; THEN price * 1.05
  ELSE price
END;

-- Rails: update_all
Product.where(category: &#39;Electronics&#39;).update_all(&quot;price = price * 1.1&quot;)
</code></pre>
<p><strong>Q185: Find duplicates</strong> (covered in Q169)</p>
<pre><code class="language-sql">-- Find duplicate emails
SELECT email, COUNT(*) as count
FROM users
GROUP BY email
HAVING COUNT(*) &gt; 1;
</code></pre>
<p><strong>Q186: Find unmatched records</strong></p>
<pre><code class="language-sql">-- LEFT JOIN with NULL
SELECT u.*
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.id IS NULL;

-- EXCEPT (PostgreSQL)
SELECT id FROM users
EXCEPT
SELECT DISTINCT user_id FROM orders;
</code></pre>
<hr>
<h2>Database Design</h2>
<h2>Question 187: What is a foreign key, and why is it important?</h2>
<h3>Answer</h3>
<p>A <strong>foreign key</strong> is a column (or set of columns) that references the primary key of another table, establishing a relationship between tables. Ensures referential integrity and maintains data consistency.</p>
<hr>
<h3>Basic Concept</h3>
<pre><code class="language-sql">-- Parent table
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100)
);

-- Child table with foreign key
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,
  amount DECIMAL(10,2),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Relationship: orders.user_id → users.id
</code></pre>
<hr>
<h3>Why Important</h3>
<p><strong>1. Referential Integrity:</strong></p>
<pre><code class="language-sql">-- ✅ Valid insert (user exists)
INSERT INTO orders (user_id, amount) 
VALUES (1, 100.00);

-- ❌ Rejected (user doesn&#39;t exist)
INSERT INTO orders (user_id, amount) 
VALUES (999, 100.00);
-- ERROR: violates foreign key constraint

-- Ensures every order belongs to valid user
</code></pre>
<p><strong>2. Prevents orphaned records:</strong></p>
<pre><code class="language-sql">-- ❌ Cannot delete user with orders
DELETE FROM users WHERE id = 1;
-- ERROR: violates foreign key constraint

-- Must delete orders first, or use CASCADE
</code></pre>
<p><strong>3. Database-level validation:</strong></p>
<pre><code class="language-sql">-- No application code needed
-- Database enforces relationships
-- Catches bugs at data layer
</code></pre>
<hr>
<h3>ON DELETE Actions</h3>
<pre><code class="language-sql">-- NO ACTION (default): Reject delete
FOREIGN KEY (user_id) REFERENCES users(id) 
ON DELETE NO ACTION;

-- CASCADE: Delete related records
FOREIGN KEY (user_id) REFERENCES users(id) 
ON DELETE CASCADE;
-- Deleting user deletes all their orders

-- SET NULL: Set FK to NULL
FOREIGN KEY (user_id) REFERENCES users(id) 
ON DELETE SET NULL;
-- Deleting user sets orders.user_id to NULL

-- SET DEFAULT: Set FK to default value
FOREIGN KEY (user_id) REFERENCES users(id) 
ON DELETE SET DEFAULT DEFAULT 0;

-- RESTRICT: Same as NO ACTION
FOREIGN KEY (user_id) REFERENCES users(id) 
ON DELETE RESTRICT;
</code></pre>
<hr>
<h3>ON UPDATE Actions</h3>
<pre><code class="language-sql">-- CASCADE: Update related records
FOREIGN KEY (user_id) REFERENCES users(id) 
ON UPDATE CASCADE;
-- Updating user.id updates all orders.user_id

-- Generally use CASCADE for updates
</code></pre>
<hr>
<h3>Composite Foreign Keys</h3>
<pre><code class="language-sql">-- Multiple columns reference multiple columns
CREATE TABLE order_items (
  order_id INTEGER,
  product_id INTEGER,
  store_id INTEGER,
  quantity INTEGER,
  FOREIGN KEY (order_id) REFERENCES orders(id),
  FOREIGN KEY (product_id, store_id) 
    REFERENCES store_products(product_id, store_id)
);
</code></pre>
<hr>
<h3>Rails Migrations</h3>
<pre><code class="language-ruby"># Create table with foreign key
create_table :orders do |t|
  t.references :user, foreign_key: true
  t.decimal :amount
  t.timestamps
end

# Add foreign key to existing table
add_foreign_key :orders, :users

# With ON DELETE
add_foreign_key :orders, :users, on_delete: :cascade

# Remove foreign key
remove_foreign_key :orders, :users
</code></pre>
<hr>
<h3>Benefits</h3>
<pre><code>✅ Data integrity
✅ Prevents orphans
✅ Enforces relationships
✅ Database-level validation
✅ Self-documenting schema
✅ Query optimization hints
✅ CASCADE operations
✅ Prevents data corruption
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>References</strong> another table&#39;s PK</li>
<li><strong>Ensures</strong> referential integrity</li>
<li><strong>Prevents</strong> invalid data</li>
<li><strong>ON DELETE</strong> defines behavior</li>
<li><strong>CASCADE</strong> deletes children</li>
<li><strong>SET NULL</strong> allows orphans</li>
<li><strong>Database enforces</strong> relationships</li>
<li><strong>Performance</strong> with indexes</li>
<li><strong>Required</strong> for good design</li>
<li><strong>Rails</strong> handles automatically</li>
</ol>
<hr>
<h2>Question 188: What is a composite primary key?</h2>
<h3>Answer</h3>
<p>A <strong>composite primary key</strong> uses multiple columns together as the unique identifier for a row. Each column alone may not be unique, but the combination is.</p>
<hr>
<h3>Basic Example</h3>
<pre><code class="language-sql">-- Composite PK: (user_id, product_id)
CREATE TABLE cart_items (
  user_id INTEGER,
  product_id INTEGER,
  quantity INTEGER,
  PRIMARY KEY (user_id, product_id)
);

-- Each user can have each product only once
-- But same user_id can appear multiple times
-- And same product_id can appear multiple times
</code></pre>
<hr>
<h3>When to Use</h3>
<pre><code class="language-sql">-- Many-to-many join tables
CREATE TABLE enrollments (
  student_id INTEGER,
  course_id INTEGER,
  grade VARCHAR(2),
  PRIMARY KEY (student_id, course_id)
);

-- Time-series data
CREATE TABLE sensor_readings (
  sensor_id INTEGER,
  timestamp TIMESTAMP,
  value DECIMAL,
  PRIMARY KEY (sensor_id, timestamp)
);

-- Multi-tenant data
CREATE TABLE tenant_products (
  tenant_id INTEGER,
  product_id INTEGER,
  price DECIMAL,
  PRIMARY KEY (tenant_id, product_id)
);
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Multiple columns</strong> as PK</li>
<li><strong>Combination</strong> is unique</li>
<li><strong>Join tables</strong> common use</li>
<li><strong>No auto-increment</strong> needed</li>
<li><strong>Both columns</strong> required</li>
<li><strong>Foreign keys</strong> reference all</li>
<li><strong>Rails</strong> prefers single PK</li>
<li><strong>Good</strong> for relationships</li>
<li><strong>Natural keys</strong> sometimes</li>
<li><strong>Consider</strong> surrogate key</li>
</ol>
<hr>
<h2>Question 189: What is the difference between one-to-one, one-to-many, and many-to-many relationships?</h2>
<h3>Answer</h3>
<p><strong>One-to-one</strong>: Each record in Table A relates to exactly one record in Table B. <strong>One-to-many</strong>: Each record in Table A relates to multiple records in Table B. <strong>Many-to-many</strong>: Records in both tables can relate to multiple records in the other, requiring a join table.</p>
<hr>
<h3>One-to-One</h3>
<pre><code class="language-sql">-- User has one profile
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR
);

CREATE TABLE profiles (
  id SERIAL PRIMARY KEY,
  user_id INTEGER UNIQUE NOT NULL,  -- UNIQUE = one-to-one
  bio TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Rails
class User &lt; ApplicationRecord
  has_one :profile
end

class Profile &lt; ApplicationRecord
  belongs_to :user
end
</code></pre>
<hr>
<h3>One-to-Many</h3>
<pre><code class="language-sql">-- User has many orders
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR
);

CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,  -- No UNIQUE = one-to-many
  amount DECIMAL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Rails
class User &lt; ApplicationRecord
  has_many :orders
end

class Order &lt; ApplicationRecord
  belongs_to :user
end
</code></pre>
<hr>
<h3>Many-to-Many</h3>
<pre><code class="language-sql">-- Students enroll in many courses
-- Courses have many students

CREATE TABLE students (id SERIAL PRIMARY KEY, name VARCHAR);
CREATE TABLE courses (id SERIAL PRIMARY KEY, name VARCHAR);

-- Join table
CREATE TABLE enrollments (
  student_id INTEGER,
  course_id INTEGER,
  PRIMARY KEY (student_id, course_id),
  FOREIGN KEY (student_id) REFERENCES students(id),
  FOREIGN KEY (course_id) REFERENCES courses(id)
);

-- Rails
class Student &lt; ApplicationRecord
  has_many :enrollments
  has_many :courses, through: :enrollments
end

class Course &lt; ApplicationRecord
  has_many :enrollments
  has_many :students, through: :enrollments
end

class Enrollment &lt; ApplicationRecord
  belongs_to :student
  belongs_to :course
end
</code></pre>
<hr>
<h3>Summary Table</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
<th>Foreign Key</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1:1</strong></td>
<td>One record to one</td>
<td>UNIQUE FK</td>
<td>User → Profile</td>
</tr>
<tr>
<td><strong>1:N</strong></td>
<td>One to many</td>
<td>FK (no unique)</td>
<td>User → Orders</td>
</tr>
<tr>
<td><strong>N:M</strong></td>
<td>Many to many</td>
<td>Join table</td>
<td>Students ↔ Courses</td>
</tr>
</tbody></table>
<h1>Performance, Optimization, Transactions and ACID Interview Questions</h1>
<h2>Performance and Optimization</h2>
<h2>Question 190: How do you find slow queries in a Rails application?</h2>
<h3>Answer</h3>
<p>Find slow queries using <strong>Rails logs</strong>, <strong>database logs</strong>, <strong>query analyzers</strong>, <strong>APM tools</strong>, and <strong>custom middleware</strong>. Monitor query execution time, N+1 queries, and database load.</p>
<hr>
<h3>1. Rails Development Logs</h3>
<p><strong>Check log/development.log:</strong></p>
<pre><code class="language-ruby"># Automatic query logging
User.where(active: true).to_a

# Log output:
User Load (23.4ms)  SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;active&quot; = $1
# Shows execution time: 23.4ms
</code></pre>
<p><strong>Configure logging level:</strong></p>
<pre><code class="language-ruby"># config/environments/development.rb
config.log_level = :debug  # Shows all SQL queries

# config/environments/production.rb
config.log_level = :info   # Less verbose
</code></pre>
<hr>
<h3>2. Query Log Tagging</h3>
<p><strong>Tag queries with context:</strong></p>
<pre><code class="language-ruby"># config/application.rb
config.active_record.query_log_tags_enabled = true
config.active_record.query_log_tags = [
  :application,
  :controller,
  :action,
  :job
]

# Log output:
# /*application:MyApp,controller:posts,action:index*/ 
# SELECT &quot;posts&quot;.* FROM &quot;posts&quot;
</code></pre>
<hr>
<h3>3. PostgreSQL Slow Query Log</h3>
<p><strong>Enable slow query logging:</strong></p>
<pre><code class="language-sql">-- postgresql.conf
log_min_duration_statement = 100  -- Log queries &gt; 100ms

-- Or set at runtime:
ALTER DATABASE myapp_production 
SET log_min_duration_statement = 100;

-- Check logs:
tail -f /var/log/postgresql/postgresql-*.log

# Output:
# LOG: duration: 523.456 ms  statement: SELECT ...
</code></pre>
<hr>
<h3>4. pg_stat_statements Extension</h3>
<p><strong>Track query statistics:</strong></p>
<pre><code class="language-sql">-- Enable extension
CREATE EXTENSION pg_stat_statements;

-- View slow queries
SELECT 
  calls,
  total_exec_time,
  mean_exec_time,
  max_exec_time,
  query
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 20;

-- Result:
calls | total_time | mean_time | max_time  | query
1000  | 45000.0    | 45.0      | 250.0     | SELECT * FROM orders WHERE...
500   | 20000.0    | 40.0      | 180.0     | SELECT * FROM users WHERE...

-- Reset statistics:
SELECT pg_stat_statements_reset();
</code></pre>
<hr>
<h3>5. Bullet Gem (N+1 Detection)</h3>
<p><strong>Detect N+1 queries:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;bullet&#39;, group: :development

# config/environments/development.rb
config.after_initialize do
  Bullet.enable = true
  Bullet.alert = true           # JavaScript alert
  Bullet.bullet_logger = true   # Log to bullet.log
  Bullet.console = true         # Console output
  Bullet.rails_logger = true    # Rails log
  Bullet.add_footer = true      # Add footer to page
end

# Detects:
# N+1 Query: User =&gt; Posts
# USE: User.includes(:posts)
</code></pre>
<hr>
<h3>6. Rack Mini Profiler</h3>
<p><strong>Real-time performance profiling:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;rack-mini-profiler&#39;, group: :development

# Shows in top-left corner:
# - Total page load time
# - SQL queries count
# - SQL time
# - Click to see detailed breakdown

# Example output:
# 245ms total
# 18 queries (234ms)
# Click for details:
#   User Load (23ms)
#   Post Load (45ms) ← N+1 detected!
</code></pre>
<hr>
<h3>7. New Relic / Datadog / Skylight</h3>
<p><strong>Application Performance Monitoring (APM):</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;newrelic_rpm&#39;  # or &#39;skylight&#39; or &#39;ddtrace&#39;

# Provides:
# - Slow transaction tracking
# - Database query analysis
# - Real-time alerting
# - Historical trends
# - Query breakdown by endpoint

# Dashboard shows:
# /posts/index: 456ms (234ms in DB)
#   ↳ SELECT * FROM posts: 89ms (executed 50 times) ← N+1!
#   ↳ SELECT * FROM users: 145ms
</code></pre>
<hr>
<h3>8. Custom Query Logging</h3>
<p><strong>Log slow queries programmatically:</strong></p>
<pre><code class="language-ruby"># config/initializers/query_logger.rb
ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  
  if event.duration &gt; 100  # &gt; 100ms
    Rails.logger.warn &quot;[SLOW QUERY] #{event.duration.round(2)}ms: #{event.payload[:sql]}&quot;
    
    # Send to external service
    SlowQueryTracker.track(
      duration: event.duration,
      sql: event.payload[:sql],
      backtrace: Rails.backtrace_cleaner.clean(caller)
    )
  end
end
</code></pre>
<hr>
<h3>9. Database Monitoring Tools</h3>
<p><strong>PostgreSQL specific:</strong></p>
<pre><code class="language-sql">-- Current running queries
SELECT 
  pid,
  now() - query_start AS duration,
  query,
  state
FROM pg_stat_activity
WHERE state != &#39;idle&#39;
  AND query NOT LIKE &#39;%pg_stat_activity%&#39;
ORDER BY duration DESC;

-- Kill long-running query
SELECT pg_cancel_backend(12345);  -- pid
SELECT pg_terminate_backend(12345);  -- force kill

-- Lock monitoring
SELECT 
  blocked_locks.pid AS blocked_pid,
  blocked_activity.query AS blocked_query,
  blocking_locks.pid AS blocking_pid,
  blocking_activity.query AS blocking_query
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
  ON blocking_locks.locktype = blocked_locks.locktype
  AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
  AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
  AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
</code></pre>
<hr>
<h3>10. Query Performance Checklist</h3>
<pre><code class="language-ruby"># ✅ Check these issues:

# 1. N+1 Queries
# ❌ Bad
posts = Post.all
posts.each { |p| p.author.name }  # N queries

# ✅ Good
posts = Post.includes(:author)
posts.each { |p| p.author.name }  # 2 queries

# 2. SELECT *
# ❌ Bad
User.all

# ✅ Good
User.select(:id, :name, :email)

# 3. Missing indexes
# ❌ Bad
User.where(email: &#39;test@example.com&#39;)  # No index

# ✅ Good
add_index :users, :email  # Add index

# 4. Large OFFSET
# ❌ Bad
User.limit(10).offset(100000)  # Slow

# ✅ Good
User.where(&#39;id &gt; ?&#39;, last_id).limit(10)  # Keyset

# 5. Unoptimized joins
# ❌ Bad
User.joins(:posts).where(posts: { published: true })

# ✅ Good
User.joins(:posts).where(posts: { published: true }).distinct

# 6. Loading too much data
# ❌ Bad
Post.all.map(&amp;:id)  # Loads all columns

# ✅ Good
Post.pluck(:id)  # Only IDs
</code></pre>
<hr>
<h3>Real-World Monitoring Setup</h3>
<pre><code class="language-ruby"># config/initializers/performance_monitoring.rb
if Rails.env.production?
  # 1. Track slow queries
  ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do |*args|
    event = ActiveSupport::Notifications::Event.new(*args)
    
    if event.duration &gt; 500  # &gt; 500ms
      SlackNotifier.notify(
        channel: &#39;#slow-queries&#39;,
        message: &quot;Slow query: #{event.duration}ms\n```#{event.payload[:sql]}```&quot;
      )
    end
  end
  
  # 2. Track query counts per request
  ActiveSupport::Notifications.subscribe(&#39;process_action.action_controller&#39;) do |*args|
    event = ActiveSupport::Notifications::Event.new(*args)
    
    query_count = event.payload[:db_runtime]
    if query_count &amp;&amp; query_count &gt; 100
      Rails.logger.warn &quot;[HIGH QUERY COUNT] #{event.payload[:controller]}##{event.payload[:action]}: #{query_count} queries&quot;
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Rails logs</strong> show query times</li>
<li><strong>pg_stat_statements</strong> tracks stats</li>
<li><strong>Bullet</strong> detects N+1 queries</li>
<li><strong>Rack Mini Profiler</strong> real-time</li>
<li><strong>APM tools</strong> for production</li>
<li><strong>Slow query log</strong> in PostgreSQL</li>
<li><strong>Custom logging</strong> for alerts</li>
<li><strong>Monitor</strong> query counts</li>
<li><strong>Check indexes</strong> regularly</li>
<li><strong>Profile</strong> before optimizing</li>
</ol>
<hr>
<h2>Question 191: What is EXPLAIN ANALYZE, and how do you use it?</h2>
<h3>Answer</h3>
<p><strong>EXPLAIN ANALYZE</strong> shows the query execution plan AND actually runs the query, providing real performance metrics. EXPLAIN = plan only, EXPLAIN ANALYZE = plan + actual execution + timing.</p>
<hr>
<h3>EXPLAIN vs EXPLAIN ANALYZE</h3>
<pre><code class="language-sql">-- EXPLAIN: Shows planned execution (doesn&#39;t run query)
EXPLAIN SELECT * FROM users WHERE email = &#39;test@example.com&#39;;

-- Output:
Seq Scan on users  (cost=0.00..15.50 rows=1 width=100)
  Filter: (email = &#39;test@example.com&#39;::text)

-- EXPLAIN ANALYZE: Shows plan + runs query + actual metrics
EXPLAIN ANALYZE SELECT * FROM users WHERE email = &#39;test@example.com&#39;;

-- Output:
Seq Scan on users  (cost=0.00..15.50 rows=1 width=100)
                   (actual time=0.023..0.456 rows=1 loops=1)
  Filter: (email = &#39;test@example.com&#39;::text)
  Rows Removed by Filter: 999
Planning Time: 0.123 ms
Execution Time: 0.489 ms
</code></pre>
<hr>
<h3>Basic Usage</h3>
<pre><code class="language-sql">-- Format options
EXPLAIN (FORMAT TEXT) SELECT ...;      -- Default, human-readable
EXPLAIN (FORMAT JSON) SELECT ...;      -- JSON output
EXPLAIN (FORMAT YAML) SELECT ...;      -- YAML output
EXPLAIN (FORMAT XML) SELECT ...;       -- XML output

-- With ANALYZE
EXPLAIN (ANALYZE) SELECT ...;
EXPLAIN (ANALYZE, BUFFERS) SELECT ...; -- + buffer usage
EXPLAIN (ANALYZE, TIMING) SELECT ...;  -- + timing per node
EXPLAIN (ANALYZE, VERBOSE) SELECT ...; -- + detailed info
</code></pre>
<hr>
<h3>Reading EXPLAIN Output</h3>
<pre><code class="language-sql">EXPLAIN ANALYZE
SELECT users.name, posts.title
FROM users
JOIN posts ON users.id = posts.user_id
WHERE users.active = true;

-- Output:
Hash Join  (cost=5.50..25.75 rows=100 width=64) 
           (actual time=0.234..1.567 rows=87 loops=1)
  Hash Cond: (posts.user_id = users.id)
  -&gt;  Seq Scan on posts  (cost=0.00..18.50 rows=850 width=36)
                         (actual time=0.012..0.456 rows=850 loops=1)
  -&gt;  Hash  (cost=5.25..5.25 rows=20 width=36)
            (actual time=0.189..0.189 rows=15 loops=1)
        Buckets: 1024  Batches: 1  Memory Usage: 9kB
        -&gt;  Seq Scan on users  (cost=0.00..5.25 rows=20 width=36)
                              (actual time=0.008..0.156 rows=15 loops=1)
              Filter: (active = true)
              Rows Removed by Filter: 85
Planning Time: 0.234 ms
Execution Time: 1.678 ms

-- Key components:
-- cost=start..total: Estimated cost
-- rows=N: Estimated row count
-- width=N: Average row size in bytes
-- actual time=start..end: Real execution time (ms)
-- rows=N: Actual rows returned
-- loops=N: Number of times node executed
</code></pre>
<hr>
<h3>Common Operations</h3>
<p><strong>1. Sequential Scan:</strong></p>
<pre><code class="language-sql">Seq Scan on users  (cost=0.00..1543.00 rows=100 width=100)
                   (actual time=0.012..23.456 rows=100 loops=1)
  Filter: (email LIKE &#39;%@gmail.com%&#39;)
  Rows Removed by Filter: 99900

-- ❌ Slow: Reads entire table
-- ✅ Fix: Add index if possible
</code></pre>
<p><strong>2. Index Scan:</strong></p>
<pre><code class="language-sql">Index Scan using users_email_idx on users
  (cost=0.29..8.31 rows=1 width=100)
  (actual time=0.023..0.024 rows=1 loops=1)
  Index Cond: (email = &#39;test@example.com&#39;::text)

-- ✅ Fast: Uses index
</code></pre>
<p><strong>3. Bitmap Index Scan:</strong></p>
<pre><code class="language-sql">Bitmap Heap Scan on posts
  (cost=10.50..234.75 rows=1000 width=50)
  (actual time=1.234..5.678 rows=987 loops=1)
  Recheck Cond: (category = &#39;Tech&#39;::text)
  -&gt;  Bitmap Index Scan on posts_category_idx
        (cost=0.00..10.25 rows=1000 width=0)
        (actual time=1.123..1.123 rows=987 loops=1)
        Index Cond: (category = &#39;Tech&#39;::text)

-- Efficient for moderate result sets
</code></pre>
<p><strong>4. Nested Loop:</strong></p>
<pre><code class="language-sql">Nested Loop  (cost=0.29..876.45 rows=100 width=100)
             (actual time=0.045..12.345 rows=87 loops=1)
  -&gt;  Seq Scan on users  (cost=0.00..5.25 rows=20 width=50)
  -&gt;  Index Scan using posts_user_id_idx on posts
        (cost=0.29..43.56 rows=5 width=50)
        Index Cond: (user_id = users.id)

-- Good for small datasets
-- Executes inner scan once per outer row
</code></pre>
<p><strong>5. Hash Join:</strong></p>
<pre><code class="language-sql">Hash Join  (cost=5.50..234.75 rows=1000 width=100)
           (actual time=1.234..5.678 rows=987 loops=1)
  Hash Cond: (posts.user_id = users.id)
  -&gt;  Seq Scan on posts
  -&gt;  Hash  (cost=5.25..5.25 rows=20 width=50)
        -&gt;  Seq Scan on users

-- Good for larger datasets
-- Builds hash table in memory
</code></pre>
<p><strong>6. Merge Join:</strong></p>
<pre><code class="language-sql">Merge Join  (cost=234.56..567.89 rows=1000 width=100)
            (actual time=2.345..8.901 rows=987 loops=1)
  Merge Cond: (posts.user_id = users.id)
  -&gt;  Index Scan using posts_user_id_idx on posts
  -&gt;  Index Scan using users_pkey on users

-- Efficient when both inputs sorted
</code></pre>
<hr>
<h3>Rails Integration</h3>
<pre><code class="language-ruby"># Get EXPLAIN output
User.where(active: true).explain

# Output:
# EXPLAIN for: SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;active&quot; = $1
# Seq Scan on users  (cost=0.00..15.50 rows=50 width=100)
#   Filter: (active = true)

# With ANALYZE
query = User.where(active: true).to_sql
result = ActiveRecord::Base.connection.execute(&quot;EXPLAIN ANALYZE #{query}&quot;)
puts result.to_a

# Custom method
class ApplicationRecord &lt; ActiveRecord::Base
  def self.explain_analyze
    sql = to_sql
    connection.execute(&quot;EXPLAIN (ANALYZE, BUFFERS) #{sql}&quot;).to_a
  end
end

User.where(active: true).explain_analyze
</code></pre>
<hr>
<h3>Analyzing Slow Queries</h3>
<pre><code class="language-sql">-- Example: Slow query
EXPLAIN (ANALYZE, BUFFERS)
SELECT 
  users.name,
  COUNT(posts.id) as post_count
FROM users
LEFT JOIN posts ON users.id = posts.user_id
WHERE users.created_at &gt; &#39;2024-01-01&#39;
GROUP BY users.id, users.name
HAVING COUNT(posts.id) &gt; 10
ORDER BY post_count DESC;

-- Look for:
-- 1. Seq Scan instead of Index Scan
-- 2. High actual time
-- 3. Rows removed by filter
-- 4. Nested loops with high loop count
-- 5. Shared Buffers Read (disk I/O)
</code></pre>
<hr>
<h3>Optimization Based on EXPLAIN</h3>
<pre><code class="language-sql">-- ❌ Problem: Sequential scan
Seq Scan on users  (cost=0.00..1543.00 rows=100 width=100)
                   (actual time=0.012..45.678 rows=100 loops=1)
  Filter: (email = &#39;test@example.com&#39;::text)
  Rows Removed by Filter: 99900

-- ✅ Solution: Add index
CREATE INDEX idx_users_email ON users(email);

-- After index:
Index Scan using idx_users_email on users
  (cost=0.29..8.31 rows=1 width=100)
  (actual time=0.023..0.024 rows=1 loops=1)
  Index Cond: (email = &#39;test@example.com&#39;::text)

-- Performance: 45.678ms → 0.024ms (1900x faster!)
</code></pre>
<hr>
<h3>Key Metrics to Watch</h3>
<pre><code class="language-sql">1. actual time: Real execution time
   - High values = slow operation
   
2. rows (estimated vs actual): Accuracy of planner
   - Large difference = need ANALYZE or better stats
   
3. Rows Removed by Filter: Wasted work
   - High values = missing index
   
4. loops: Executions of node
   - High loops in nested loop = performance issue
   
5. Buffers (with BUFFERS option):
   - Shared Buffers Read: Disk I/O (slow)
   - Shared Buffers Hit: Cache hit (fast)
   
6. Planning Time vs Execution Time:
   - High planning = complex query
   - High execution = need optimization
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>EXPLAIN</strong> shows plan only</li>
<li><strong>ANALYZE</strong> runs query + metrics</li>
<li><strong>actual time</strong> = real performance</li>
<li><strong>Seq Scan</strong> often slow</li>
<li><strong>Index Scan</strong> usually fast</li>
<li><strong>rows</strong> estimate accuracy</li>
<li><strong>Buffers</strong> show I/O</li>
<li><strong>Compare</strong> estimated vs actual</li>
<li><strong>Use Rails</strong> .explain method</li>
<li><strong>Optimize</strong> based on output</li>
</ol>
<hr>
<h2>Question 192: How do you analyze query performance using EXPLAIN ANALYZE?</h2>
<h3>Answer</h3>
<p>Analyze query performance by examining <strong>execution time</strong>, <strong>scan types</strong>, <strong>row estimates</strong>, <strong>join methods</strong>, <strong>buffer usage</strong>, and <strong>planning accuracy</strong>. Identify bottlenecks and optimize accordingly.</p>
<hr>
<h3>Step-by-Step Analysis Process</h3>
<p><strong>Step 1: Run EXPLAIN ANALYZE</strong></p>
<pre><code class="language-sql">EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT 
  u.name,
  COUNT(o.id) as order_count,
  SUM(o.amount) as total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.created_at &gt; &#39;2024-01-01&#39;
GROUP BY u.id, u.name
HAVING COUNT(o.id) &gt; 5
ORDER BY total_spent DESC
LIMIT 10;
</code></pre>
<hr>
<h3>Step 2: Identify Expensive Operations</h3>
<pre><code class="language-sql">-- Look for high actual time:
Hash Join  (cost=234.56..5678.90 rows=1000 width=100)
           (actual time=123.45..4567.89 rows=987 loops=1)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
           4567ms - EXPENSIVE!

-- Check the slowest node in tree
</code></pre>
<hr>
<h3>Step 3: Analyze Scan Types</h3>
<pre><code class="language-sql">-- ❌ Sequential Scan (SLOW)
Seq Scan on orders  (cost=0.00..15000.00 rows=100000 width=50)
                    (actual time=0.123..456.789 rows=100000 loops=1)
-- Reading entire table

-- ✅ Index Scan (FAST)
Index Scan using orders_user_id_idx on orders
  (cost=0.42..8.45 rows=100 width=50)
  (actual time=0.023..0.234 rows=87 loops=1)
  Index Cond: (user_id = 123)
-- Using index

-- ⚠️ Bitmap Heap Scan (MODERATE)
Bitmap Heap Scan on posts
  (cost=10.50..234.75 rows=1000 width=50)
  (actual time=1.234..5.678 rows=987 loops=1)
-- Good for moderate result sets
</code></pre>
<hr>
<h3>Step 4: Check Row Estimates</h3>
<pre><code class="language-sql">-- Estimated vs Actual
Hash Join  (cost=5.50..25.75 rows=100 width=64)
           (actual time=0.234..1.567 rows=87 loops=1)
                                      ^^^^^^^^^^^^^
                                      Estimate: 100
                                      Actual: 87
                                      ✅ Close enough

-- Large difference is bad:
Hash Join  (cost=5.50..25.75 rows=10 width=64)
           (actual time=0.234..45.678 rows=100000 loops=1)
                                       ^^^^^^^^
                                       ❌ Way off!
                                       Need ANALYZE or better stats
</code></pre>
<hr>
<h3>Step 5: Examine Join Methods</h3>
<pre><code class="language-sql">-- Nested Loop (good for small datasets)
Nested Loop  (cost=0.29..876.45 rows=100 width=100)
             (actual time=0.045..2.345 rows=87 loops=1)
  -- Inner scan executed once per outer row
  -- Expensive if outer has many rows

-- Hash Join (good for large datasets)
Hash Join  (cost=5.50..234.75 rows=1000 width=100)
           (actual time=1.234..5.678 rows=987 loops=1)
  -- Builds hash table in memory
  -- One-time cost, then fast lookups

-- Merge Join (good for sorted data)
Merge Join  (cost=234.56..567.89 rows=1000 width=100)
            (actual time=2.345..8.901 rows=987 loops=1)
  -- Both inputs must be sorted
  -- Efficient when indexes exist
</code></pre>
<hr>
<h3>Step 6: Analyze Filters</h3>
<pre><code class="language-sql">Seq Scan on users  (cost=0.00..1543.00 rows=100 width=100)
                   (actual time=0.012..45.678 rows=100 loops=1)
  Filter: (email LIKE &#39;%@gmail.com%&#39;)
  Rows Removed by Filter: 99900
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  ❌ 99,900 rows scanned but discarded!
  
-- Problem: No index for pattern matching
-- Solution: 
--   1. Add index if possible
--   2. Use full-text search
--   3. Denormalize data
</code></pre>
<hr>
<h3>Step 7: Check Buffer Usage</h3>
<pre><code class="language-sql">-- With BUFFERS option
Seq Scan on large_table
  (cost=0.00..15000.00 rows=100000 width=100)
  (actual time=0.123..456.789 rows=100000 loops=1)
  Buffers: shared hit=5000 read=10000
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
           hit=5000: From cache (fast)
           read=10000: From disk (slow!)
           
-- High &quot;read&quot; = disk I/O = slow
-- Solution: More RAM, better indexes, smaller result set
</code></pre>
<hr>
<h3>Step 8: Look for Nested Loops with High Iterations</h3>
<pre><code class="language-sql">-- ❌ BAD: Nested loop with high iterations
Nested Loop  (cost=0.29..876.45 rows=100 width=100)
             (actual time=0.045..2345.678 rows=87 loops=50000)
                                                        ^^^^^^
                                                        Executed 50,000 times!
  -&gt;  Seq Scan on users  (cost=0.00..5.25 rows=50000 width=50)
  -&gt;  Index Scan using posts_user_id_idx on posts
        (cost=0.29..0.35 rows=1 width=50)
        (actual time=0.023..0.034 rows=2 loops=50000)
        ^^^^^^^^^^^^
        2 * 50,000 = 100,000 lookups!
        
-- Solution: Use Hash Join instead
-- Or add better filtering
</code></pre>
<hr>
<h3>Real-World Example: Before Optimization</h3>
<pre><code class="language-sql">EXPLAIN (ANALYZE, BUFFERS)
SELECT 
  users.name,
  COUNT(orders.id) as order_count
FROM users
JOIN orders ON users.id = orders.user_id
WHERE users.created_at &gt; &#39;2023-01-01&#39;
GROUP BY users.id, users.name
HAVING COUNT(orders.id) &gt; 10;

-- Output:
GroupAggregate  (cost=15234.56..18456.78 rows=500 width=100)
                (actual time=4567.89..5678.90 rows=234 loops=1)
  Filter: (count(orders.id) &gt; 10)
  Rows Removed by Filter: 8766
  -&gt;  Sort  (cost=15234.56..15456.78 rows=10000 width=100)
            (actual time=4123.45..4234.56 rows=9000 loops=1)
        Sort Key: users.id
        Sort Method: external merge  Disk: 12345kB
        -&gt;  Hash Join  (cost=234.56..12345.67 rows=10000 width=100)
                      (actual time=123.45..3456.78 rows=9000 loops=1)
              Hash Cond: (orders.user_id = users.id)
              -&gt;  Seq Scan on orders  (cost=0.00..10000.00 rows=500000 width=50)
                                     (actual time=0.012..2345.67 rows=500000 loops=1)
              -&gt;  Hash  (cost=200.00..200.00 rows=1000 width=50)
                        (actual time=120.34..120.34 rows=1000 loops=1)
                    Buckets: 1024  Batches: 1  Memory Usage: 50kB
                    -&gt;  Seq Scan on users  (cost=0.00..200.00 rows=1000 width=50)
                                          (actual time=0.023..100.23 rows=1000 loops=1)
                          Filter: (created_at &gt; &#39;2023-01-01&#39;::date)
                          Rows Removed by Filter: 9000
  Buffers: shared hit=12000 read=25000
Planning Time: 1.234 ms
Execution Time: 5679.12 ms

-- Problems identified:
-- 1. Seq Scan on orders (2345ms)
-- 2. Seq Scan on users with filter removing 9000 rows (100ms)
-- 3. External merge sort to disk (slow)
-- 4. High disk I/O (read=25000)
</code></pre>
<hr>
<h3>After Optimization</h3>
<pre><code class="language-sql">-- 1. Add indexes
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- 2. Materialize frequent aggregations
CREATE MATERIALIZED VIEW user_order_counts AS
SELECT 
  user_id,
  COUNT(*) as order_count
FROM orders
GROUP BY user_id;

CREATE INDEX idx_uoc_user_id ON user_order_counts(user_id);

-- 3. Optimized query
EXPLAIN (ANALYZE, BUFFERS)
SELECT 
  users.name,
  uoc.order_count
FROM users
JOIN user_order_counts uoc ON users.id = uoc.user_id
WHERE users.created_at &gt; &#39;2023-01-01&#39;
  AND uoc.order_count &gt; 10;

-- Output:
Nested Loop  (cost=0.85..45.67 rows=234 width=100)
             (actual time=0.234..12.345 rows=234 loops=1)
  -&gt;  Index Scan using idx_users_created_at on users
        (cost=0.42..25.34 rows=1000 width=50)
        (actual time=0.023..5.678 rows=1000 loops=1)
        Index Cond: (created_at &gt; &#39;2023-01-01&#39;::date)
  -&gt;  Index Scan using idx_uoc_user_id on user_order_counts uoc
        (cost=0.42..0.45 rows=1 width=50)
        (actual time=0.005..0.006 rows=1 loops=1000)
        Index Cond: (user_id = users.id)
        Filter: (order_count &gt; 10)
        Rows Removed by Filter: 0
  Buffers: shared hit=2345
Planning Time: 0.567 ms
Execution Time: 12.567 ms

-- Improvements:
-- 1. No Seq Scans - using indexes ✅
-- 2. No disk I/O - all in cache ✅
-- 3. No external sort - small result set ✅
-- 4. 5679ms → 12ms (473x faster!) ✅
</code></pre>
<hr>
<h3>Optimization Checklist</h3>
<pre><code class="language-sql">-- ✅ Actions to take based on EXPLAIN ANALYZE:

-- 1. Sequential Scans
Problem: Seq Scan with high actual time
Solution: Add index on filter/join columns

-- 2. High Rows Removed by Filter
Problem: Scanning many rows, discarding most
Solution: Better index, rewrite query, denormalize

-- 3. Inaccurate Row Estimates
Problem: estimated rows != actual rows
Solution: ANALYZE table, update statistics

-- 4. Nested Loop with Many Iterations
Problem: Inner scan executed thousands of times
Solution: Add index, use hash join, reduce outer rows

-- 5. External Sort to Disk
Problem: Sort Method: external merge Disk: XkB
Solution: Increase work_mem, reduce result set, add index

-- 6. High Disk I/O
Problem: Buffers: shared read=large_number
Solution: More RAM, better indexes, query optimization

-- 7. Slow Hash Building
Problem: Hash takes long time
Solution: Reduce hash table size, add filters earlier

-- 8. Multiple Scans of Same Table
Problem: Same table appears multiple times
Solution: Use CTE or temp table
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Check actual time</strong> first</li>
<li><strong>Seq Scan</strong> often needs index</li>
<li><strong>Row estimates</strong> accuracy important</li>
<li><strong>Buffers</strong> show I/O patterns</li>
<li><strong>Nested loops</strong> with high iterations bad</li>
<li><strong>External sorts</strong> slow</li>
<li><strong>Filter efficiency</strong> critical</li>
<li><strong>Join methods</strong> matter</li>
<li><strong>Before/after</strong> comparison</li>
<li><strong>Iterate</strong> on improvements</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 193: How do you optimize queries involving large datasets?</h2>
<h3>Answer</h3>
<p>Optimize large dataset queries using <strong>pagination</strong>, <strong>indexes</strong>, <strong>partitioning</strong>, <strong>denormalization</strong>, <strong>caching</strong>, <strong>limiting columns</strong>, and <strong>batch processing</strong>. Avoid loading entire dataset into memory.</p>
<hr>
<h3>1. Use Pagination</h3>
<pre><code class="language-ruby"># ❌ BAD: Load all records
users = User.all  # 1,000,000 records → OOM

# ✅ GOOD: Paginate
users = User.page(1).per(100)  # 100 records

# ✅ BETTER: Keyset pagination
users = User.where(&#39;id &gt; ?&#39;, last_id).limit(100)
# No OFFSET, uses index
</code></pre>
<hr>
<h3>2. Select Only Needed Columns</h3>
<pre><code class="language-ruby"># ❌ BAD: SELECT *
User.all  # All columns

# ✅ GOOD: SELECT specific columns
User.select(:id, :name, :email)  # Only 3 columns

# Even better: Use pluck for simple data
User.pluck(:id, :email)  # Array of arrays, no AR objects
</code></pre>
<hr>
<h3>3. Use find_each for Batching</h3>
<pre><code class="language-ruby"># ❌ BAD: Load all into memory
User.all.each do |user|
  user.send_email
end

# ✅ GOOD: Batch processing
User.find_each(batch_size: 1000) do |user|
  user.send_email
end
# Loads 1000 at a time

# find_in_batches for batch operations
User.find_in_batches(batch_size: 1000) do |users|
  UserMailer.bulk_send(users).deliver_later
end
</code></pre>
<hr>
<h3>4. Add Appropriate Indexes</h3>
<pre><code class="language-sql">-- Identify missing indexes
EXPLAIN ANALYZE SELECT * FROM users WHERE email = &#39;test@example.com&#39;;
-- Seq Scan → Need index

-- Add index
CREATE INDEX idx_users_email ON users(email);

-- Multi-column index for common queries
CREATE INDEX idx_orders_user_status 
ON orders(user_id, status, created_at);

-- Partial index
CREATE INDEX idx_active_users_email 
ON users(email) WHERE active = true;
</code></pre>
<hr>
<h3>5. Use COUNT Alternatives</h3>
<pre><code class="language-ruby"># ❌ SLOW: Count all records
User.count  # Full table scan

# ✅ FAST: Approximate count
User.connection.execute(
  &quot;SELECT reltuples::bigint AS estimate FROM pg_class WHERE relname = &#39;users&#39;&quot;
).first[&#39;estimate&#39;]

# Or use cached counter
class Post &lt; ApplicationRecord
  belongs_to :user, counter_cache: true
end
user.posts_count  # No query!
</code></pre>
<hr>
<h3>6. Partition Large Tables</h3>
<pre><code class="language-sql">-- Range partitioning by date
CREATE TABLE orders (
  id BIGSERIAL,
  user_id INTEGER,
  created_at TIMESTAMP,
  amount DECIMAL
) PARTITION BY RANGE (created_at);

-- Create partitions
CREATE TABLE orders_2024_01 PARTITION OF orders
  FOR VALUES FROM (&#39;2024-01-01&#39;) TO (&#39;2024-02-01&#39;);

CREATE TABLE orders_2024_02 PARTITION OF orders
  FOR VALUES FROM (&#39;2024-02-01&#39;) TO (&#39;2024-03-01&#39;);

-- Query only relevant partition
SELECT * FROM orders WHERE created_at &gt;= &#39;2024-01-15&#39;;
-- Only scans orders_2024_01
</code></pre>
<hr>
<h3>7. Denormalize for Read Performance</h3>
<pre><code class="language-ruby"># Store aggregated data
class User &lt; ApplicationRecord
  # Columns: orders_count, total_spent, last_order_at
  
  after_commit :update_stats, on: [:create, :update]
  
  def update_stats
    update_columns(
      orders_count: orders.count,
      total_spent: orders.sum(:amount),
      last_order_at: orders.maximum(:created_at)
    )
  end
end

# Fast queries without joins
User.where(&#39;total_spent &gt; ?&#39;, 10000)  # No aggregation needed
</code></pre>
<hr>
<h3>8. Use Materialized Views</h3>
<pre><code class="language-sql">-- Create materialized view
CREATE MATERIALIZED VIEW user_stats AS
SELECT 
  user_id,
  COUNT(*) as order_count,
  SUM(amount) as total_spent,
  AVG(amount) as avg_order
FROM orders
GROUP BY user_id;

-- Add index
CREATE INDEX idx_user_stats_user_id ON user_stats(user_id);

-- Refresh periodically
REFRESH MATERIALIZED VIEW CONCURRENTLY user_stats;

-- Query is fast
SELECT * FROM user_stats WHERE total_spent &gt; 10000;
</code></pre>
<hr>
<h3>9. Limit JOIN Result Sets</h3>
<pre><code class="language-ruby"># ❌ BAD: Join large tables
User.joins(:orders).where(orders: { status: &#39;completed&#39; })

# ✅ GOOD: Filter before join
completed_order_user_ids = Order.where(status: &#39;completed&#39;).pluck(:user_id).uniq
User.where(id: completed_order_user_ids)

# Or use subquery
User.where(id: Order.where(status: &#39;completed&#39;).select(:user_id))
</code></pre>
<hr>
<h3>10. Use Database Views for Complex Queries</h3>
<pre><code class="language-sql">-- Create view for frequently used query
CREATE VIEW high_value_customers AS
SELECT 
  u.id,
  u.name,
  u.email,
  COUNT(o.id) as order_count,
  SUM(o.amount) as total_spent
FROM users u
JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name, u.email
HAVING SUM(o.amount) &gt; 10000;

-- Query view instead of joining every time
SELECT * FROM high_value_customers;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Paginate</strong> don&#39;t load all</li>
<li><strong>Select</strong> only needed columns</li>
<li><strong>find_each</strong> for batches</li>
<li><strong>Index</strong> filter columns</li>
<li><strong>Partition</strong> huge tables</li>
<li><strong>Denormalize</strong> for reads</li>
<li><strong>Materialized views</strong> for aggregates</li>
<li><strong>Cache</strong> expensive queries</li>
<li><strong>Approximate</strong> when exact not needed</li>
<li><strong>Monitor</strong> and iterate</li>
</ol>
<hr>
<h2>Question 194: What are the different types of indexes (B-Tree, Hash, GIN, GiST) in PostgreSQL?</h2>
<h3>Answer</h3>
<p>PostgreSQL supports multiple index types: <strong>B-Tree</strong> (default, general purpose), <strong>Hash</strong> (equality only), <strong>GIN</strong> (full-text, arrays, JSON), <strong>GiST</strong> (geometric, text search), <strong>BRIN</strong> (very large tables), <strong>SP-GiST</strong> (partitioned data).</p>
<hr>
<h3>1. B-Tree (Default)</h3>
<p><strong>Best for:</strong> Sorting, range queries, equality</p>
<pre><code class="language-sql">-- Default index type
CREATE INDEX idx_users_email ON users(email);

-- Explicit B-Tree
CREATE INDEX idx_users_email ON users USING btree(email);

-- Use cases:
-- = (equality)
SELECT * FROM users WHERE email = &#39;test@example.com&#39;;

-- &lt;, &gt;, &lt;=, &gt;= (range)
SELECT * FROM users WHERE age &gt; 21;

-- BETWEEN
SELECT * FROM orders WHERE created_at BETWEEN &#39;2024-01-01&#39; AND &#39;2024-12-31&#39;;

-- ORDER BY
SELECT * FROM users ORDER BY created_at DESC;

-- LIKE with prefix
SELECT * FROM users WHERE name LIKE &#39;John%&#39;;  -- Uses index
SELECT * FROM users WHERE name LIKE &#39;%John%&#39;; -- Doesn&#39;t use index

-- Characteristics:
-- ✅ General purpose
-- ✅ Most common
-- ✅ Supports all data types
-- ✅ Balanced tree structure
-- ✅ O(log n) lookups
</code></pre>
<hr>
<h3>2. Hash Index</h3>
<p><strong>Best for:</strong> Exact equality only</p>
<pre><code class="language-sql">-- Create hash index
CREATE INDEX idx_users_email_hash ON users USING hash(email);

-- Use cases:
-- = (equality only)
SELECT * FROM users WHERE email = &#39;test@example.com&#39;;  -- Uses hash

-- Does NOT support:
-- &lt;, &gt;, &lt;=, &gt;=, BETWEEN, ORDER BY, LIKE

-- Characteristics:
-- ⚡ Faster for equality than B-Tree
-- ❌ No range queries
-- ❌ No sorting
-- ⚠️ Rarely needed (B-Tree usually better)
-- ✅ O(1) lookups in best case
</code></pre>
<hr>
<h3>3. GIN (Generalized Inverted Index)</h3>
<p><strong>Best for:</strong> Full-text search, arrays, JSONB</p>
<pre><code class="language-sql">-- Full-text search
CREATE INDEX idx_posts_content_fts 
ON posts USING gin(to_tsvector(&#39;english&#39;, content));

SELECT * FROM posts 
WHERE to_tsvector(&#39;english&#39;, content) @@ to_tsquery(&#39;search &amp; term&#39;);

-- Array contains
CREATE INDEX idx_tags ON posts USING gin(tags);

SELECT * FROM posts WHERE tags @&gt; ARRAY[&#39;ruby&#39;, &#39;rails&#39;];
SELECT * FROM posts WHERE tags &amp;&amp; ARRAY[&#39;ruby&#39;];  -- Overlaps

-- JSONB
CREATE INDEX idx_metadata ON products USING gin(metadata);

SELECT * FROM products WHERE metadata @&gt; &#39;{&quot;color&quot;: &quot;red&quot;}&#39;;
SELECT * FROM products WHERE metadata ? &#39;color&#39;;  -- Has key

-- Characteristics:
-- ✅ Multi-value columns (arrays, jsonb)
-- ✅ Full-text search
-- ✅ Fast for containment (@&gt;, @?, @@)
-- ❌ Larger index size
-- ❌ Slower to build and update
-- ⚠️ Good for read-heavy workloads
</code></pre>
<hr>
<h3>4. GiST (Generalized Search Tree)</h3>
<p><strong>Best for:</strong> Geometric data, full-text, range types</p>
<pre><code class="language-sql">-- Geometric data
CREATE INDEX idx_locations ON stores USING gist(location);

SELECT * FROM stores 
WHERE location &lt;-&gt; point(40.7128, -74.0060) &lt; 10;  -- Within 10 units

-- Range types
CREATE INDEX idx_reservations_period 
ON reservations USING gist(period);

SELECT * FROM reservations 
WHERE period &amp;&amp; daterange(&#39;2024-01-01&#39;, &#39;2024-01-31&#39;);  -- Overlaps

-- Full-text (alternative to GIN)
CREATE INDEX idx_posts_content_gist 
ON posts USING gist(to_tsvector(&#39;english&#39;, content));

-- Characteristics:
-- ✅ Geometric queries
-- ✅ Nearest neighbor searches
-- ✅ Range overlaps
-- ✅ Smaller than GIN
-- ⚠️ Slower searches than GIN
-- ✅ Faster updates than GIN
</code></pre>
<hr>
<h3>5. BRIN (Block Range Index)</h3>
<p><strong>Best for:</strong> Very large tables with natural ordering</p>
<pre><code class="language-sql">-- Time-series data
CREATE INDEX idx_logs_created_at 
ON logs USING brin(created_at);

-- Characteristics:
-- ✅ Extremely small index size
-- ✅ Fast to build
-- ✅ Good for huge tables (TB+)
-- ⚠️ Only for naturally ordered data
-- ⚠️ Less accurate than B-Tree
-- ✅ Perfect for append-only tables

-- Example: 1TB table
-- B-Tree index: 20GB
-- BRIN index: 100MB (200x smaller!)

-- Use for:
-- - Log tables ordered by timestamp
-- - Sensor data ordered by reading_time
-- - Sequential data
</code></pre>
<hr>
<h3>6. SP-GiST (Space-Partitioned GiST)</h3>
<p><strong>Best for:</strong> Non-balanced data structures</p>
<pre><code class="language-sql">-- IP addresses (inet type)
CREATE INDEX idx_ip_addresses 
ON connections USING spgist(ip_address);

-- Phone numbers
CREATE INDEX idx_phone 
ON users USING spgist(phone_number);

-- Characteristics:
-- ✅ Partitioned search trees
-- ✅ Good for clustered data
-- ⚠️ Specialized use cases
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Best For</th>
<th>Operators</th>
<th>Size</th>
<th>Speed</th>
</tr>
</thead>
<tbody><tr>
<td><strong>B-Tree</strong></td>
<td>General queries</td>
<td>=, &lt;, &gt;, &lt;=, &gt;=, BETWEEN</td>
<td>Medium</td>
<td>Fast</td>
</tr>
<tr>
<td><strong>Hash</strong></td>
<td>Exact equality</td>
<td>= only</td>
<td>Small</td>
<td>Very Fast</td>
</tr>
<tr>
<td><strong>GIN</strong></td>
<td>Arrays, JSONB, FTS</td>
<td>@&gt;, ?, @@</td>
<td>Large</td>
<td>Fast read</td>
</tr>
<tr>
<td><strong>GiST</strong></td>
<td>Geometric, Ranges</td>
<td>&amp;&amp;, &lt;-&gt;</td>
<td>Medium</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>BRIN</strong></td>
<td>Huge ordered tables</td>
<td>=, &lt;, &gt;</td>
<td>Tiny</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>SP-GiST</strong></td>
<td>Partitioned data</td>
<td>Varies</td>
<td>Medium</td>
<td>Medium</td>
</tr>
</tbody></table>
<hr>
<h3>Choosing the Right Index</h3>
<pre><code class="language-sql">-- Equality on single column → B-Tree
CREATE INDEX ON users(email);

-- Full-text search → GIN
CREATE INDEX ON posts USING gin(to_tsvector(&#39;english&#39;, content));

-- JSONB queries → GIN
CREATE INDEX ON products USING gin(metadata);

-- Array contains → GIN
CREATE INDEX ON posts USING gin(tags);

-- Geographic queries → GiST
CREATE INDEX ON locations USING gist(coordinates);

-- Time-series (huge table) → BRIN
CREATE INDEX ON logs USING brin(created_at);

-- Range overlaps → GiST
CREATE INDEX ON reservations USING gist(period);
</code></pre>
<hr>
<h3>Rails Migrations</h3>
<pre><code class="language-ruby"># B-Tree (default)
add_index :users, :email

# GIN for array
add_index :posts, :tags, using: :gin

# GIN for JSONB
add_index :products, :metadata, using: :gin

# GiST for geometric
add_index :stores, :location, using: :gist

# BRIN for large time-series
add_index :logs, :created_at, using: :brin

# Expression index with GIN
execute &lt;&lt;-SQL
  CREATE INDEX idx_posts_search 
  ON posts USING gin(to_tsvector(&#39;english&#39;, title || &#39; &#39; || body))
SQL
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>B-Tree</strong> default and most common</li>
<li><strong>Hash</strong> for exact equality only</li>
<li><strong>GIN</strong> for arrays/JSONB/full-text</li>
<li><strong>GiST</strong> for geometric/ranges</li>
<li><strong>BRIN</strong> for huge ordered tables</li>
<li><strong>Choose</strong> based on query patterns</li>
<li><strong>GIN</strong> large but fast reads</li>
<li><strong>BRIN</strong> tiny but approximate</li>
<li><strong>Test</strong> with real data</li>
<li><strong>Monitor</strong> index usage</li>
</ol>
<hr>
<h2>Question 195-196 Summary</h2>
<p><strong>Q195: Multi-column indexes</strong></p>
<pre><code class="language-sql">-- Composite index
CREATE INDEX idx_orders_user_status_date 
ON orders(user_id, status, created_at);

-- Column order matters!
-- Good for:
WHERE user_id = 1
WHERE user_id = 1 AND status = &#39;completed&#39;
WHERE user_id = 1 AND status = &#39;completed&#39; AND created_at &gt; &#39;2024-01-01&#39;

-- NOT good for:
WHERE status = &#39;completed&#39;  -- Doesn&#39;t use index (user_id not specified)
WHERE created_at &gt; &#39;2024-01-01&#39;  -- Doesn&#39;t use index

-- Rule: Leftmost prefix must be specified
</code></pre>
<p><strong>Q196: Temporary tables</strong></p>
<pre><code class="language-sql">-- Create temp table for complex query
CREATE TEMPORARY TABLE active_users AS
SELECT id, name, email
FROM users
WHERE active = true
AND created_at &gt; &#39;2024-01-01&#39;;

-- Add index
CREATE INDEX idx_temp_users_id ON active_users(id);

-- Use in complex query
SELECT 
  au.name,
  COUNT(o.id) as order_count
FROM active_users au
JOIN orders o ON au.id = o.user_id
GROUP BY au.name;

-- Temp table dropped at session end
</code></pre>
<hr>
<h2>Transactions and ACID</h2>
<h2>Question 197: What are ACID properties in a database?</h2>
<h3>Answer</h3>
<p><strong>ACID</strong> ensures reliable database transactions: <strong>Atomicity</strong> (all or nothing), <strong>Consistency</strong> (valid state), <strong>Isolation</strong> (concurrent safety), <strong>Durability</strong> (permanent once committed).</p>
<hr>
<h3>Atomicity</h3>
<p><strong>All operations succeed or all fail:</strong></p>
<pre><code class="language-ruby"># Example: Money transfer
ActiveRecord::Base.transaction do
  account_a.update!(balance: account_a.balance - 100)
  account_b.update!(balance: account_b.balance + 100)
end

# Either both succeed or both rollback
# No partial updates

# If error occurs:
begin
  ActiveRecord::Base.transaction do
    account_a.update!(balance: account_a.balance - 100)
    raise &quot;Network error&quot;  # Simulated error
    account_b.update!(balance: account_b.balance + 100)  # Never executes
  end
rescue =&gt; e
  # Both updates rolled back
  # account_a.balance unchanged
  # account_b.balance unchanged
end
</code></pre>
<hr>
<h3>Consistency</h3>
<p><strong>Database always in valid state:</strong></p>
<pre><code class="language-ruby"># Constraints enforced
class Account &lt; ApplicationRecord
  validates :balance, numericality: { greater_than_or_equal_to: 0 }
end

# Transaction maintains consistency
begin
  ActiveRecord::Base.transaction do
    account.update!(balance: account.balance - 1000)
    # If balance goes negative, validation fails
    # Transaction rolls back
    # Database remains consistent
  end
rescue ActiveRecord::RecordInvalid
  # Handle error
end

# Foreign key constraints
class Order &lt; ApplicationRecord
  belongs_to :user
end

# Can&#39;t create order for non-existent user
Order.create!(user_id: 99999)  # Raises error
# Database integrity maintained
</code></pre>
<hr>
<h3>Isolation</h3>
<p><strong>Concurrent transactions don&#39;t interfere:</strong></p>
<pre><code class="language-ruby"># Two users booking same seat simultaneously
# User 1:
ActiveRecord::Base.transaction do
  seat = Seat.find(123)
  sleep(1)  # Simulate processing
  seat.update!(booked: true) if !seat.booked?
end

# User 2 (concurrent):
ActiveRecord::Base.transaction do
  seat = Seat.find(123)
  sleep(1)  # Simulate processing
  seat.update!(booked: true) if !seat.booked?
end

# Without isolation: Both might book same seat!
# With isolation: Only one succeeds

# Use pessimistic locking:
ActiveRecord::Base.transaction do
  seat = Seat.lock.find(123)  # Locks row
  seat.update!(booked: true) if !seat.booked?
end
# Second user waits for lock
</code></pre>
<hr>
<h3>Durability</h3>
<p><strong>Committed data persists:</strong></p>
<pre><code class="language-ruby"># After commit, data survives:
order = Order.create!(user: user, amount: 100)
# Even if server crashes immediately after,
# order persists in database

# WAL (Write-Ahead Logging) ensures durability
# Changes written to disk before commit returns

# PostgreSQL settings:
# synchronous_commit = on (default)
# fsync = on (default)
# wal_level = replica (or higher)
</code></pre>
<hr>
<h3>ACID in Action</h3>
<pre><code class="language-ruby"># Complete example: Order processing
class OrderProcessingService
  def process(order)
    ActiveRecord::Base.transaction do
      # Atomicity: All or nothing
      order.update!(status: &#39;processing&#39;)
      
      # Deduct inventory
      order.line_items.each do |item|
        product = Product.lock.find(item.product_id)  # Isolation: Lock
        
        if product.stock &lt; item.quantity
          raise InsufficientStockError  # Rollback everything
        end
        
        product.update!(stock: product.stock - item.quantity)
      end
      
      # Charge payment
      payment = PaymentGateway.charge(order)
      raise PaymentError unless payment.success?
      
      order.update!(status: &#39;completed&#39;, payment_id: payment.id)
      
      # Consistency: All constraints validated
      # Durability: Committed to disk
    end
    
    # If any step fails, entire transaction rolls back
    # Database remains consistent
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Atomicity</strong> = all or nothing</li>
<li><strong>Consistency</strong> = valid state always</li>
<li><strong>Isolation</strong> = concurrent safety</li>
<li><strong>Durability</strong> = persists after commit</li>
<li><strong>Transactions</strong> ensure ACID</li>
<li><strong>Rollback</strong> on any failure</li>
<li><strong>Constraints</strong> enforce consistency</li>
<li><strong>Locks</strong> provide isolation</li>
<li><strong>WAL</strong> ensures durability</li>
<li><strong>Critical</strong> for reliability</li>
</ol>
<hr>
<h2>Question 198-202 Summary</h2>
<p><strong>Q198: Isolation levels</strong></p>
<pre><code class="language-sql">-- Read Uncommitted (lowest)
-- Can see uncommitted changes (dirty reads)
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- Read Committed (PostgreSQL default)
-- Only see committed data
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- Repeatable Read
-- Same SELECT returns same results
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- Serializable (highest)
-- Full isolation, as if serial
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
</code></pre>
<p><strong>Q199: ACID compliance</strong></p>
<pre><code class="language-ruby"># Use transactions
ActiveRecord::Base.transaction do
  # Multiple operations
end

# Add constraints
add_foreign_key :orders, :users
add_check_constraint :accounts, &quot;balance &gt;= 0&quot;

# Use locking
Model.lock.find(id)
</code></pre>
<p><strong>Q200: Explicit transactions</strong></p>
<pre><code class="language-ruby"># Basic transaction
ActiveRecord::Base.transaction do
  user.update!(name: &#39;New Name&#39;)
  order.create!(user: user)
end

# Nested transactions (savepoints)
User.transaction do
  user.save!
  
  Order.transaction do
    order.save!
  end
end

# Rollback
User.transaction do
  user.save!
  raise ActiveRecord::Rollback  # Rollback only
end
</code></pre>
<p><strong>Q201: SAVEPOINT</strong></p>
<pre><code class="language-sql">BEGIN;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1;
  SAVEPOINT my_savepoint;
  
  UPDATE accounts SET balance = balance + 100 WHERE id = 2;
  -- Error occurs
  
  ROLLBACK TO SAVEPOINT my_savepoint;  -- Undo last UPDATE only
  -- First UPDATE still active
COMMIT;  -- First UPDATE commits
</code></pre>
<p><strong>Q202: Partial rollback</strong></p>
<pre><code class="language-ruby"># Using savepoints
User.transaction do
  user.update!(name: &#39;New Name&#39;)  # Will commit
  
  User.transaction(requires_new: true) do
    user.update!(email: &#39;invalid&#39;)  # Will rollback
    raise ActiveRecord::Rollback
  end
  
  # First update persists
end
</code></pre>
<h1>PostgreSQL Specific and Data Warehousing Interview Questions</h1>
<h2>PostgreSQL Specific</h2>
<h2>Question 203: How do you store and query JSON data in PostgreSQL?</h2>
<h3>Answer</h3>
<p>PostgreSQL supports <strong>JSON</strong> and <strong>JSONB</strong> (binary JSON) types. JSONB is preferred for most use cases due to better performance and indexing support. Store with <code>jsonb</code> column, query with operators and functions.</p>
<hr>
<h3>JSON vs JSONB</h3>
<pre><code class="language-sql">-- JSON: Stores exact text representation
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  data JSON
);

-- JSONB: Stores decomposed binary format (RECOMMENDED)
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  data JSONB
);

-- Comparison:
-- JSON: Faster to input, preserves formatting, slower queries
-- JSONB: Slower to input, no formatting, faster queries, supports indexing
</code></pre>
<hr>
<h3>Storing JSON Data</h3>
<pre><code class="language-ruby"># Rails migration
class AddMetadataToProducts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :products, :metadata, :jsonb, default: {}
    add_index :products, :metadata, using: :gin
  end
end

# Insert data
product = Product.create(
  name: &#39;Laptop&#39;,
  metadata: {
    brand: &#39;Apple&#39;,
    specs: {
      cpu: &#39;M2&#39;,
      ram: &#39;16GB&#39;,
      storage: &#39;512GB&#39;
    },
    features: [&#39;Touch ID&#39;, &#39;Retina Display&#39;],
    price_history: [
      { date: &#39;2024-01-01&#39;, price: 1299 },
      { date: &#39;2024-06-01&#39;, price: 1199 }
    ]
  }
)

# SQL insert
INSERT INTO products (name, metadata)
VALUES (
  &#39;Laptop&#39;,
  &#39;{&quot;brand&quot;: &quot;Apple&quot;, &quot;specs&quot;: {&quot;cpu&quot;: &quot;M2&quot;, &quot;ram&quot;: &quot;16GB&quot;}}&#39;::jsonb
);
</code></pre>
<hr>
<h3>Querying JSON Data</h3>
<p><strong>1. Access operators:</strong></p>
<pre><code class="language-sql">-- -&gt; returns JSON
SELECT metadata-&gt;&#39;brand&#39; FROM products;
-- Result: &quot;Apple&quot; (with quotes)

-- -&gt;&gt; returns text
SELECT metadata-&gt;&gt;&#39;brand&#39; FROM products;
-- Result: Apple (without quotes)

-- Nested access
SELECT metadata-&gt;&#39;specs&#39;-&gt;&#39;cpu&#39; FROM products;
SELECT metadata-&gt;&#39;specs&#39;-&gt;&gt;&#39;cpu&#39; FROM products;
-- Result: &quot;M2&quot; or M2

-- Array access
SELECT metadata-&gt;&#39;features&#39;-&gt;0 FROM products;
-- Result: &quot;Touch ID&quot;

-- Deep path access (#&gt; for JSON, #&gt;&gt; for text)
SELECT metadata#&gt;&#39;{specs,cpu}&#39; FROM products;
SELECT metadata#&gt;&gt;&#39;{specs,cpu}&#39; FROM products;
-- Path as array
</code></pre>
<hr>
<p><strong>2. Containment operators:</strong></p>
<pre><code class="language-sql">-- @&gt; : Contains (left contains right)
SELECT * FROM products
WHERE metadata @&gt; &#39;{&quot;brand&quot;: &quot;Apple&quot;}&#39;;

-- More complex containment
SELECT * FROM products
WHERE metadata @&gt; &#39;{&quot;specs&quot;: {&quot;cpu&quot;: &quot;M2&quot;}}&#39;;

-- &lt;@ : Contained by (left contained in right)
SELECT * FROM products
WHERE &#39;{&quot;brand&quot;: &quot;Apple&quot;}&#39; &lt;@ metadata;

-- ? : Has key
SELECT * FROM products
WHERE metadata ? &#39;brand&#39;;

-- ?| : Has any key
SELECT * FROM products
WHERE metadata ?| ARRAY[&#39;brand&#39;, &#39;model&#39;];

-- ?&amp; : Has all keys
SELECT * FROM products
WHERE metadata ?&amp; ARRAY[&#39;brand&#39;, &#39;specs&#39;];
</code></pre>
<hr>
<p><strong>3. Existence checks:</strong></p>
<pre><code class="language-sql">-- Key exists
SELECT * FROM products
WHERE metadata ? &#39;warranty&#39;;

-- Nested key exists
SELECT * FROM products
WHERE metadata-&gt;&#39;specs&#39; ? &#39;cpu&#39;;

-- Path exists
SELECT * FROM products
WHERE metadata @? &#39;$.specs.cpu&#39;;
</code></pre>
<hr>
<p><strong>4. JSON functions:</strong></p>
<pre><code class="language-sql">-- jsonb_extract_path
SELECT jsonb_extract_path(metadata, &#39;specs&#39;, &#39;cpu&#39;) FROM products;

-- jsonb_extract_path_text
SELECT jsonb_extract_path_text(metadata, &#39;specs&#39;, &#39;cpu&#39;) FROM products;

-- jsonb_array_elements (expand array)
SELECT jsonb_array_elements(metadata-&gt;&#39;features&#39;) as feature
FROM products;

-- Result:
&quot;Touch ID&quot;
&quot;Retina Display&quot;

-- jsonb_array_elements_text
SELECT jsonb_array_elements_text(metadata-&gt;&#39;features&#39;) as feature
FROM products;

-- Result:
Touch ID
Retina Display

-- jsonb_object_keys
SELECT jsonb_object_keys(metadata) FROM products;

-- Result:
brand
specs
features
</code></pre>
<hr>
<p><strong>5. Aggregation:</strong></p>
<pre><code class="language-sql">-- Collect JSON objects
SELECT jsonb_agg(metadata) FROM products;

-- Collect specific field
SELECT jsonb_agg(metadata-&gt;&gt;&#39;brand&#39;) FROM products;

-- Build object
SELECT jsonb_build_object(
  &#39;name&#39;, name,
  &#39;brand&#39;, metadata-&gt;&gt;&#39;brand&#39;
) FROM products;
</code></pre>
<hr>
<p><strong>6. Modification functions:</strong></p>
<pre><code class="language-sql">-- Set value
UPDATE products
SET metadata = jsonb_set(
  metadata,
  &#39;{specs,ram}&#39;,
  &#39;&quot;32GB&quot;&#39;
);

-- Insert value
UPDATE products
SET metadata = jsonb_insert(
  metadata,
  &#39;{specs,gpu}&#39;,
  &#39;&quot;M2 Pro&quot;&#39;
);

-- Delete key
UPDATE products
SET metadata = metadata - &#39;warranty&#39;;

-- Delete nested key
UPDATE products
SET metadata = metadata #- &#39;{specs,storage}&#39;;

-- Concatenate
UPDATE products
SET metadata = metadata || &#39;{&quot;color&quot;: &quot;Silver&quot;}&#39;::jsonb;
</code></pre>
<hr>
<h3>Rails Integration</h3>
<pre><code class="language-ruby"># Model
class Product &lt; ApplicationRecord
  # Store accessors for easy access
  store_accessor :metadata, :brand, :warranty
  
  # Scopes
  scope :by_brand, -&gt;(brand) {
    where(&quot;metadata-&gt;&gt;&#39;brand&#39; = ?&quot;, brand)
  }
  
  scope :with_feature, -&gt;(feature) {
    where(&quot;metadata-&gt;&#39;features&#39; ? :feature&quot;, feature: feature)
  }
  
  scope :cpu_type, -&gt;(cpu) {
    where(&quot;metadata#&gt;&gt;&#39;{specs,cpu}&#39; = ?&quot;, cpu)
  }
end

# Usage
Product.by_brand(&#39;Apple&#39;)
Product.with_feature(&#39;Touch ID&#39;)
Product.cpu_type(&#39;M2&#39;)

# Access data
product = Product.first
product.metadata[&#39;brand&#39;]              # &quot;Apple&quot;
product.brand                          # &quot;Apple&quot; (via store_accessor)
product.metadata[&#39;specs&#39;][&#39;cpu&#39;]       # &quot;M2&quot;
product.metadata[&#39;features&#39;][0]        # &quot;Touch ID&quot;

# Modify data
product.metadata[&#39;warranty&#39;] = &#39;3 years&#39;
product.save

# Query
Product.where(&quot;metadata @&gt; ?&quot;, { brand: &#39;Apple&#39; }.to_json)
Product.where(&quot;metadata-&gt;&gt;&#39;brand&#39; = ?&quot;, &#39;Apple&#39;)
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<p><strong>1. Product catalog:</strong></p>
<pre><code class="language-ruby"># Schema
create_table :products do |t|
  t.string :name
  t.jsonb :specs, default: {}
  t.jsonb :pricing, default: {}
  t.timestamps
end

add_index :products, :specs, using: :gin
add_index :products, :pricing, using: :gin

# Query by specs
Product.where(&quot;specs @&gt; ?&quot;, { screen_size: &#39;15.6&quot;&#39; }.to_json)

# Query by price range
Product.where(&quot;(pricing-&gt;&gt;&#39;current_price&#39;)::numeric BETWEEN ? AND ?&quot;, 500, 1000)
</code></pre>
<p><strong>2. User settings:</strong></p>
<pre><code class="language-ruby">class User &lt; ApplicationRecord
  store_accessor :settings,
    :theme,
    :notifications_enabled,
    :language
  
  # Default settings
  after_initialize do
    self.settings ||= {
      theme: &#39;light&#39;,
      notifications_enabled: true,
      language: &#39;en&#39;
    }
  end
end

# Usage
user.theme = &#39;dark&#39;
user.save

# Query
User.where(&quot;settings-&gt;&gt;&#39;theme&#39; = ?&quot;, &#39;dark&#39;)
</code></pre>
<p><strong>3. Event logging:</strong></p>
<pre><code class="language-ruby">create_table :events do |t|
  t.string :event_type
  t.jsonb :payload
  t.timestamp :created_at
end

add_index :events, :payload, using: :gin
add_index :events, :created_at

# Store events
Event.create(
  event_type: &#39;user_login&#39;,
  payload: {
    user_id: 123,
    ip_address: &#39;192.168.1.1&#39;,
    user_agent: &#39;Chrome/120.0&#39;,
    location: { city: &#39;NYC&#39;, country: &#39;US&#39; }
  }
)

# Query
Event.where(&quot;payload-&gt;&gt;&#39;user_id&#39; = ?&quot;, &#39;123&#39;)
Event.where(&quot;payload @&gt; ?&quot;, { location: { city: &#39;NYC&#39; } }.to_json)
</code></pre>
<hr>
<h3>Performance Tips</h3>
<pre><code class="language-sql">-- ✅ Use JSONB, not JSON
-- JSONB supports indexing and faster queries

-- ✅ Add GIN index
CREATE INDEX idx_products_metadata ON products USING gin(metadata);

-- ✅ Index specific paths
CREATE INDEX idx_products_brand ON products ((metadata-&gt;&gt;&#39;brand&#39;));

-- ✅ Use containment (@&gt;) instead of equality when possible
-- Fast (uses GIN index):
WHERE metadata @&gt; &#39;{&quot;brand&quot;: &quot;Apple&quot;}&#39;

-- Slower:
WHERE metadata-&gt;&gt;&#39;brand&#39; = &#39;Apple&#39;

-- ✅ Extract frequently queried fields to columns
-- If always querying brand, consider:
ALTER TABLE products ADD COLUMN brand TEXT 
  GENERATED ALWAYS AS (metadata-&gt;&gt;&#39;brand&#39;) STORED;
CREATE INDEX idx_products_brand ON products(brand);
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>JSONB</strong> preferred over JSON</li>
<li><strong>-&gt;</strong> returns JSON, <strong>-&gt;&gt;</strong> returns text</li>
<li><strong>@&gt;</strong> for containment queries</li>
<li><strong>?</strong> for key existence</li>
<li><strong>GIN index</strong> essential</li>
<li><strong>store_accessor</strong> in Rails</li>
<li><strong>Flexible schema</strong> for dynamic data</li>
<li><strong>Path syntax</strong> for nested access</li>
<li><strong>Functions</strong> for complex operations</li>
<li><strong>Performance</strong> needs indexes</li>
</ol>
<hr>
<h2>Question 204: How do you perform full-text search on JSON fields?</h2>
<h3>Answer</h3>
<p>Perform full-text search on JSON fields using <strong>GIN indexes</strong> on <code>to_tsvector()</code> applied to JSON values. Combine JSONB operators with full-text search functions for powerful querying.</p>
<hr>
<h3>Basic Full-Text Search on JSON</h3>
<pre><code class="language-sql">-- Sample data
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  data JSONB
);

INSERT INTO products (data) VALUES
  (&#39;{&quot;name&quot;: &quot;MacBook Pro&quot;, &quot;description&quot;: &quot;Powerful laptop for developers&quot;}&#39;),
  (&#39;{&quot;name&quot;: &quot;iPhone&quot;, &quot;description&quot;: &quot;Smartphone with advanced camera&quot;}&#39;),
  (&#39;{&quot;name&quot;: &quot;iPad&quot;, &quot;description&quot;: &quot;Tablet for creative professionals&quot;}&#39;);

-- Search in single field
SELECT * FROM products
WHERE to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;description&#39;) 
  @@ to_tsquery(&#39;english&#39;, &#39;developer&#39;);

-- Result: MacBook Pro row
</code></pre>
<hr>
<h3>Create Searchable Index</h3>
<pre><code class="language-sql">-- Generate tsvector from JSON field
CREATE INDEX idx_products_description_search 
ON products 
USING gin(to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;description&#39;));

-- Search (uses index)
SELECT * FROM products
WHERE to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;description&#39;) 
  @@ to_tsquery(&#39;english&#39;, &#39;laptop | smartphone&#39;);

-- Search multiple fields
CREATE INDEX idx_products_fulltext 
ON products 
USING gin(
  to_tsvector(&#39;english&#39;, 
    COALESCE(data-&gt;&gt;&#39;name&#39;, &#39;&#39;) || &#39; &#39; || 
    COALESCE(data-&gt;&gt;&#39;description&#39;, &#39;&#39;)
  )
);
</code></pre>
<hr>
<h3>Generated Column for Search</h3>
<pre><code class="language-sql">-- Add generated column (PostgreSQL 12+)
ALTER TABLE products 
ADD COLUMN searchable tsvector
GENERATED ALWAYS AS (
  to_tsvector(&#39;english&#39;,
    COALESCE(data-&gt;&gt;&#39;name&#39;, &#39;&#39;) || &#39; &#39; ||
    COALESCE(data-&gt;&gt;&#39;description&#39;, &#39;&#39;) || &#39; &#39; ||
    COALESCE(data-&gt;&gt;&#39;brand&#39;, &#39;&#39;)
  )
) STORED;

-- Index the generated column
CREATE INDEX idx_products_searchable 
ON products USING gin(searchable);

-- Search (very fast)
SELECT * FROM products
WHERE searchable @@ to_tsquery(&#39;english&#39;, &#39;laptop &amp; powerful&#39;);
</code></pre>
<hr>
<h3>Search with Ranking</h3>
<pre><code class="language-sql">-- Rank search results
SELECT 
  id,
  data-&gt;&gt;&#39;name&#39; as name,
  ts_rank(
    to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;description&#39;),
    to_tsquery(&#39;english&#39;, &#39;laptop&#39;)
  ) as rank
FROM products
WHERE to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;description&#39;) 
  @@ to_tsquery(&#39;english&#39;, &#39;laptop&#39;)
ORDER BY rank DESC;

-- Weighted ranking (different weights for fields)
SELECT 
  id,
  data-&gt;&gt;&#39;name&#39; as name,
  ts_rank(
    setweight(to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;name&#39;), &#39;A&#39;) ||
    setweight(to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;description&#39;), &#39;B&#39;),
    to_tsquery(&#39;english&#39;, &#39;laptop&#39;)
  ) as rank
FROM products
WHERE 
  setweight(to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;name&#39;), &#39;A&#39;) ||
  setweight(to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;description&#39;), &#39;B&#39;)
  @@ to_tsquery(&#39;english&#39;, &#39;laptop&#39;)
ORDER BY rank DESC;
</code></pre>
<hr>
<h3>Search Nested JSON</h3>
<pre><code class="language-sql">-- Data structure
INSERT INTO products (data) VALUES (&#39;{
  &quot;name&quot;: &quot;MacBook Pro&quot;,
  &quot;specs&quot;: {
    &quot;processor&quot;: &quot;M2 Pro chip with neural engine&quot;,
    &quot;display&quot;: &quot;Liquid Retina XDR display&quot;
  },
  &quot;reviews&quot;: [
    {&quot;text&quot;: &quot;Excellent performance for developers&quot;},
    {&quot;text&quot;: &quot;Amazing display quality&quot;}
  ]
}&#39;);

-- Search in nested object
SELECT * FROM products
WHERE to_tsvector(&#39;english&#39;, data#&gt;&gt;&#39;{specs,processor}&#39;) 
  @@ to_tsquery(&#39;english&#39;, &#39;neural&#39;);

-- Search in array elements
SELECT * FROM products
WHERE EXISTS (
  SELECT 1 FROM jsonb_array_elements(data-&gt;&#39;reviews&#39;) as review
  WHERE to_tsvector(&#39;english&#39;, review-&gt;&gt;&#39;text&#39;) 
    @@ to_tsquery(&#39;english&#39;, &#39;developer&#39;)
);
</code></pre>
<hr>
<h3>Rails Integration</h3>
<pre><code class="language-ruby"># Migration
class AddSearchToProducts &lt; ActiveRecord::Migration[7.0]
  def up
    # Add generated column
    execute &lt;&lt;-SQL
      ALTER TABLE products
      ADD COLUMN searchable tsvector
      GENERATED ALWAYS AS (
        to_tsvector(&#39;english&#39;,
          COALESCE(data-&gt;&gt;&#39;name&#39;, &#39;&#39;) || &#39; &#39; ||
          COALESCE(data-&gt;&gt;&#39;description&#39;, &#39;&#39;)
        )
      ) STORED;
    SQL
    
    # Add GIN index
    add_index :products, :searchable, using: :gin
  end
  
  def down
    remove_index :products, :searchable
    remove_column :products, :searchable
  end
end

# Model
class Product &lt; ApplicationRecord
  scope :search, -&gt;(query) {
    where(
      &quot;searchable @@ to_tsquery(&#39;english&#39;, ?)&quot;,
      query.split.map { |word| word + &#39;:*&#39; }.join(&#39; &amp; &#39;)
    )
  }
  
  scope :search_with_rank, -&gt;(query) {
    select(
      &quot;products.*&quot;,
      &quot;ts_rank(searchable, to_tsquery(&#39;english&#39;, ?)) as rank&quot;,
      query.split.map { |word| word + &#39;:*&#39; }.join(&#39; &amp; &#39;)
    )
    .where(
      &quot;searchable @@ to_tsquery(&#39;english&#39;, ?)&quot;,
      query.split.map { |word| word + &#39;:*&#39; }.join(&#39; &amp; &#39;)
    )
    .order(&#39;rank DESC&#39;)
  }
end

# Usage
Product.search(&#39;laptop developer&#39;)
Product.search_with_rank(&#39;laptop developer&#39;)

# Advanced search
class Product &lt; ApplicationRecord
  def self.full_text_search(query)
    tsquery = query.split.map { |word| &quot;#{word}:*&quot; }.join(&#39; &amp; &#39;)
    
    where(&quot;searchable @@ to_tsquery(&#39;english&#39;, ?)&quot;, tsquery)
      .select(&quot;products.*, ts_rank(searchable, to_tsquery(&#39;english&#39;, ?)) as rank&quot;, tsquery)
      .order(&#39;rank DESC&#39;)
  end
end
</code></pre>
<hr>
<h3>Search Operators</h3>
<pre><code class="language-sql">-- &amp; (AND)
SELECT * FROM products
WHERE searchable @@ to_tsquery(&#39;english&#39;, &#39;laptop &amp; powerful&#39;);

-- | (OR)
SELECT * FROM products
WHERE searchable @@ to_tsquery(&#39;english&#39;, &#39;laptop | tablet&#39;);

-- ! (NOT)
SELECT * FROM products
WHERE searchable @@ to_tsquery(&#39;english&#39;, &#39;laptop &amp; !expensive&#39;);

-- &lt;-&gt; (FOLLOWED BY)
SELECT * FROM products
WHERE searchable @@ to_tsquery(&#39;english&#39;, &#39;powerful &lt;-&gt; laptop&#39;);

-- Prefix search (*)
SELECT * FROM products
WHERE searchable @@ to_tsquery(&#39;english&#39;, &#39;lap:*&#39;);
-- Matches: laptop, laptops, etc.
</code></pre>
<hr>
<h3>Phrase Search</h3>
<pre><code class="language-sql">-- Use phraseto_tsquery for exact phrases
SELECT * FROM products
WHERE searchable @@ phraseto_tsquery(&#39;english&#39;, &#39;powerful laptop&#39;);

-- websearch_to_tsquery (user-friendly)
SELECT * FROM products
WHERE searchable @@ websearch_to_tsquery(&#39;english&#39;, &#39;&quot;powerful laptop&quot; or tablet&#39;);
</code></pre>
<hr>
<h3>Highlighting Results</h3>
<pre><code class="language-sql">-- Highlight matching terms
SELECT 
  data-&gt;&gt;&#39;name&#39; as name,
  ts_headline(
    &#39;english&#39;,
    data-&gt;&gt;&#39;description&#39;,
    to_tsquery(&#39;english&#39;, &#39;laptop&#39;),
    &#39;StartSel=&lt;b&gt;, StopSel=&lt;/b&gt;&#39;
  ) as highlighted_description
FROM products
WHERE searchable @@ to_tsquery(&#39;english&#39;, &#39;laptop&#39;);

-- Result:
-- name: &quot;MacBook Pro&quot;
-- highlighted_description: &quot;Powerful &lt;b&gt;laptop&lt;/b&gt; for developers&quot;
</code></pre>
<hr>
<h3>Real-World Example</h3>
<pre><code class="language-ruby"># Schema
create_table :articles do |t|
  t.jsonb :content, default: {}
  t.timestamps
end

execute &lt;&lt;-SQL
  ALTER TABLE articles
  ADD COLUMN searchable tsvector
  GENERATED ALWAYS AS (
    setweight(to_tsvector(&#39;english&#39;, COALESCE(content-&gt;&gt;&#39;title&#39;, &#39;&#39;)), &#39;A&#39;) ||
    setweight(to_tsvector(&#39;english&#39;, COALESCE(content-&gt;&gt;&#39;body&#39;, &#39;&#39;)), &#39;B&#39;) ||
    setweight(to_tsvector(&#39;english&#39;, COALESCE(content-&gt;&gt;&#39;author&#39;, &#39;&#39;)), &#39;C&#39;)
  ) STORED;
SQL

add_index :articles, :searchable, using: :gin

# Model
class Article &lt; ApplicationRecord
  def self.search(query, page: 1, per_page: 20)
    tsquery = query.split.map { |word| &quot;#{word}:*&quot; }.join(&#39; &amp; &#39;)
    
    select(
      &quot;articles.*&quot;,
      &quot;ts_rank(searchable, to_tsquery(&#39;english&#39;, ?)) as rank&quot;,
      &quot;ts_headline(&#39;english&#39;, content-&gt;&gt;&#39;body&#39;, to_tsquery(&#39;english&#39;, ?), 
        &#39;MaxWords=50, MinWords=20&#39;) as snippet&quot;,
      tsquery,
      tsquery
    )
    .where(&quot;searchable @@ to_tsquery(&#39;english&#39;, ?)&quot;, tsquery)
    .order(&#39;rank DESC&#39;)
    .limit(per_page)
    .offset((page - 1) * per_page)
  end
end

# Usage
results = Article.search(&#39;ruby on rails performance&#39;)
results.each do |article|
  puts article.content[&#39;title&#39;]
  puts &quot;Rank: #{article.rank}&quot;
  puts article.snippet
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>to_tsvector</strong> converts text to searchable</li>
<li><strong>to_tsquery</strong> creates search query</li>
<li><strong>GIN index</strong> essential for performance</li>
<li><strong>Generated column</strong> for complex searches</li>
<li><strong>ts_rank</strong> for relevance scoring</li>
<li><strong>Weighted search</strong> for field priority</li>
<li><strong>ts_headline</strong> for highlighting</li>
<li><strong>websearch_to_tsquery</strong> user-friendly</li>
<li><strong>Prefix search</strong> with :*</li>
<li><strong>Combine</strong> with JSONB operators</li>
</ol>
<hr>
<h2>Question 205: What is hstore in PostgreSQL, and how does it compare to JSON?</h2>
<h3>Answer</h3>
<p><strong>hstore</strong> is a key-value store extension in PostgreSQL for flat string-to-string mappings. <strong>JSONB</strong> is more flexible, supporting nested structures and multiple data types. Use hstore for simple key-value data, JSONB for complex structures.</p>
<hr>
<h3>hstore Basics</h3>
<pre><code class="language-sql">-- Enable extension
CREATE EXTENSION hstore;

-- Create table
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name TEXT,
  attributes hstore
);

-- Insert data (all values are strings)
INSERT INTO products (name, attributes) VALUES
  (&#39;Laptop&#39;, &#39;brand =&gt; Apple, color =&gt; Silver, weight =&gt; 1.4kg&#39;),
  (&#39;Phone&#39;, &#39;brand =&gt; Samsung, color =&gt; Black, storage =&gt; 128GB&#39;);

-- Or use hstore() function
INSERT INTO products (name, attributes) VALUES
  (&#39;Tablet&#39;, hstore(&#39;brand&#39;, &#39;Apple&#39;) || hstore(&#39;color&#39;, &#39;Gold&#39;));
</code></pre>
<hr>
<h3>hstore Operators</h3>
<pre><code class="language-sql">-- Access value
SELECT attributes-&gt;&#39;brand&#39; FROM products;
-- Result: Apple

-- Check key exists
SELECT * FROM products WHERE attributes ? &#39;brand&#39;;

-- Check multiple keys exist
SELECT * FROM products WHERE attributes ?&amp; ARRAY[&#39;brand&#39;, &#39;color&#39;];

-- Check any key exists
SELECT * FROM products WHERE attributes ?| ARRAY[&#39;brand&#39;, &#39;model&#39;];

-- Contains
SELECT * FROM products 
WHERE attributes @&gt; &#39;brand =&gt; Apple&#39;;

-- Get keys
SELECT akeys(attributes) FROM products;

-- Get values
SELECT avals(attributes) FROM products;

-- Convert to array
SELECT hstore_to_array(attributes) FROM products;

-- Convert to JSON
SELECT hstore_to_json(attributes) FROM products;
</code></pre>
<hr>
<h3>hstore vs JSONB Comparison</h3>
<pre><code class="language-sql">-- hstore: Flat key-value (strings only)
CREATE TABLE products_hstore (
  id SERIAL PRIMARY KEY,
  data hstore
);

INSERT INTO products_hstore (data) VALUES
  (&#39;name =&gt; Laptop, brand =&gt; Apple, price =&gt; 1299&#39;);

-- ✅ Fast for simple lookups
-- ✅ Smaller storage for flat data
-- ❌ No nesting
-- ❌ All values are strings
-- ❌ No arrays

-- JSONB: Nested structures, multiple types
CREATE TABLE products_jsonb (
  id SERIAL PRIMARY KEY,
  data JSONB
);

INSERT INTO products_jsonb (data) VALUES
  (&#39;{
    &quot;name&quot;: &quot;Laptop&quot;,
    &quot;brand&quot;: &quot;Apple&quot;,
    &quot;price&quot;: 1299,
    &quot;specs&quot;: {
      &quot;cpu&quot;: &quot;M2&quot;,
      &quot;ram&quot;: 16
    },
    &quot;features&quot;: [&quot;Touch ID&quot;, &quot;Retina Display&quot;]
  }&#39;);

-- ✅ Nested structures
-- ✅ Multiple data types (string, number, boolean, null)
-- ✅ Arrays
-- ✅ More flexible
-- ❌ Slightly larger storage
-- ❌ Slightly slower for simple lookups
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>hstore</th>
<th>JSONB</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Structure</strong></td>
<td>Flat key-value</td>
<td>Nested</td>
</tr>
<tr>
<td><strong>Data Types</strong></td>
<td>Strings only</td>
<td>String, number, boolean, null, array, object</td>
</tr>
<tr>
<td><strong>Nesting</strong></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Arrays</strong></td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Indexing</strong></td>
<td>GIN, GiST</td>
<td>GIN</td>
</tr>
<tr>
<td><strong>Size</strong></td>
<td>Smaller</td>
<td>Larger</td>
</tr>
<tr>
<td><strong>Speed</strong></td>
<td>Faster (simple)</td>
<td>Faster (complex)</td>
</tr>
<tr>
<td><strong>Use Case</strong></td>
<td>Simple attributes</td>
<td>Complex documents</td>
</tr>
</tbody></table>
<hr>
<h3>When to Use Each</h3>
<p><strong>Use hstore when:</strong></p>
<pre><code class="language-sql">-- ✅ Simple key-value attributes
-- Example: Product attributes
attributes: color =&gt; Red, size =&gt; Large, material =&gt; Cotton

-- ✅ All values are strings
-- ✅ No nesting needed
-- ✅ Performance critical for simple lookups
</code></pre>
<p><strong>Use JSONB when:</strong></p>
<pre><code class="language-sql">-- ✅ Nested data structures
{
  &quot;user&quot;: {
    &quot;name&quot;: &quot;John&quot;,
    &quot;address&quot;: {
      &quot;city&quot;: &quot;NYC&quot;,
      &quot;zip&quot;: &quot;10001&quot;
    }
  }
}

-- ✅ Multiple data types
{ &quot;price&quot;: 1299, &quot;in_stock&quot;: true, &quot;tags&quot;: [&quot;laptop&quot;, &quot;apple&quot;] }

-- ✅ Arrays needed
{ &quot;features&quot;: [&quot;Feature 1&quot;, &quot;Feature 2&quot;] }

-- ✅ Future flexibility
-- JSONB is more future-proof
</code></pre>
<hr>
<h3>Migration from hstore to JSONB</h3>
<pre><code class="language-sql">-- Convert hstore column to JSONB
ALTER TABLE products 
ADD COLUMN data_jsonb JSONB;

UPDATE products 
SET data_jsonb = hstore_to_jsonb(data_hstore);

-- Or in Rails
class ConvertHstoreToJsonb &lt; ActiveRecord::Migration[7.0]
  def up
    add_column :products, :data_jsonb, :jsonb
    
    execute &lt;&lt;-SQL
      UPDATE products 
      SET data_jsonb = hstore_to_jsonb(data_hstore)
    SQL
    
    remove_column :products, :data_hstore
    rename_column :products, :data_jsonb, :data
  end
end
</code></pre>
<hr>
<h3>Rails Integration</h3>
<pre><code class="language-ruby"># hstore
class AddAttributesToProducts &lt; ActiveRecord::Migration[7.0]
  def change
    enable_extension &#39;hstore&#39;
    add_column :products, :attributes, :hstore
    add_index :products, :attributes, using: :gin
  end
end

class Product &lt; ApplicationRecord
  store_accessor :attributes, :brand, :color, :size
end

product = Product.create(brand: &#39;Apple&#39;, color: &#39;Silver&#39;)
Product.where(&quot;attributes -&gt; &#39;brand&#39; = ?&quot;, &#39;Apple&#39;)

# JSONB (recommended)
class AddDataToProducts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :products, :data, :jsonb, default: {}
    add_index :products, :data, using: :gin
  end
end

class Product &lt; ApplicationRecord
  store_accessor :data, :brand, :color, :size
end

product = Product.create(
  data: {
    brand: &#39;Apple&#39;,
    specs: { cpu: &#39;M2&#39;, ram: 16 },
    features: [&#39;Touch ID&#39;]
  }
)

Product.where(&quot;data @&gt; ?&quot;, { brand: &#39;Apple&#39; }.to_json)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>hstore</strong> = flat key-value</li>
<li><strong>JSONB</strong> = nested structures</li>
<li><strong>hstore</strong> strings only</li>
<li><strong>JSONB</strong> multiple types</li>
<li><strong>hstore</strong> faster for simple</li>
<li><strong>JSONB</strong> more flexible</li>
<li><strong>JSONB recommended</strong> for new projects</li>
<li><strong>hstore</strong> legacy support</li>
<li><strong>Easy migration</strong> hstore → JSONB</li>
<li><strong>Use JSONB</strong> unless specific reason for hstore</li>
</ol>
<hr>
<h2>Question 206: How do you index JSON fields in PostgreSQL?</h2>
<h3>Answer</h3>
<p>Index JSON fields using <strong>GIN indexes</strong> for containment queries, <strong>expression indexes</strong> for specific paths, and <strong>partial indexes</strong> for filtered data. Choose index type based on query patterns.</p>
<hr>
<h3>1. GIN Index on Entire JSONB Column</h3>
<pre><code class="language-sql">-- Most common: Index entire JSONB column
CREATE INDEX idx_products_data ON products USING gin(data);

-- Supports queries:
-- Containment (@&gt;)
SELECT * FROM products WHERE data @&gt; &#39;{&quot;brand&quot;: &quot;Apple&quot;}&#39;;

-- Key existence (?)
SELECT * FROM products WHERE data ? &#39;warranty&#39;;

-- Any/all keys (?|, ?&amp;)
SELECT * FROM products WHERE data ?| ARRAY[&#39;brand&#39;, &#39;model&#39;];
</code></pre>
<hr>
<h3>2. GIN Index with jsonb_path_ops</h3>
<pre><code class="language-sql">-- More efficient for containment queries only
CREATE INDEX idx_products_data_path ON products 
USING gin(data jsonb_path_ops);

-- Smaller index, faster containment
-- Only supports @&gt; operator
SELECT * FROM products WHERE data @&gt; &#39;{&quot;brand&quot;: &quot;Apple&quot;}&#39;;

-- Does NOT support:
-- ?, ?|, ?&amp; operators
</code></pre>
<hr>
<h3>3. Expression Index on Specific Path</h3>
<pre><code class="language-sql">-- Index specific JSON field
CREATE INDEX idx_products_brand 
ON products ((data-&gt;&gt;&#39;brand&#39;));

-- Fast queries on that field
SELECT * FROM products WHERE data-&gt;&gt;&#39;brand&#39; = &#39;Apple&#39;;

-- Multiple expression indexes
CREATE INDEX idx_products_price 
ON products (((data-&gt;&gt;&#39;price&#39;)::numeric));

SELECT * FROM products 
WHERE (data-&gt;&gt;&#39;price&#39;)::numeric BETWEEN 500 AND 1000;

-- Nested paths
CREATE INDEX idx_products_cpu 
ON products ((data#&gt;&gt;&#39;{specs,cpu}&#39;));

SELECT * FROM products 
WHERE data#&gt;&gt;&#39;{specs,cpu}&#39; = &#39;M2&#39;;
</code></pre>
<hr>
<h3>4. Partial Index</h3>
<pre><code class="language-sql">-- Index only active products
CREATE INDEX idx_active_products_brand 
ON products ((data-&gt;&gt;&#39;brand&#39;))
WHERE (data-&gt;&gt;&#39;active&#39;)::boolean = true;

-- Smaller index, faster queries
SELECT * FROM products 
WHERE data-&gt;&gt;&#39;brand&#39; = &#39;Apple&#39;
  AND (data-&gt;&gt;&#39;active&#39;)::boolean = true;

-- Index products in price range
CREATE INDEX idx_mid_range_products 
ON products USING gin(data)
WHERE (data-&gt;&gt;&#39;price&#39;)::numeric BETWEEN 500 AND 2000;
</code></pre>
<hr>
<h3>5. Multi-Column Index with JSON</h3>
<pre><code class="language-sql">-- Combine regular column with JSON expression
CREATE INDEX idx_products_category_brand 
ON products (category, (data-&gt;&gt;&#39;brand&#39;));

-- Efficient for:
SELECT * FROM products 
WHERE category = &#39;Electronics&#39; 
  AND data-&gt;&gt;&#39;brand&#39; = &#39;Apple&#39;;
</code></pre>
<hr>
<h3>6. Full-Text Search Index</h3>
<pre><code class="language-sql">-- Index for text search
CREATE INDEX idx_products_description_search 
ON products 
USING gin(to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;description&#39;));

-- Fast text search
SELECT * FROM products
WHERE to_tsvector(&#39;english&#39;, data-&gt;&gt;&#39;description&#39;) 
  @@ to_tsquery(&#39;english&#39;, &#39;laptop&#39;);

-- Multiple fields
CREATE INDEX idx_products_fulltext 
ON products 
USING gin(
  to_tsvector(&#39;english&#39;,
    COALESCE(data-&gt;&gt;&#39;name&#39;, &#39;&#39;) || &#39; &#39; ||
    COALESCE(data-&gt;&gt;&#39;description&#39;, &#39;&#39;)
  )
);
</code></pre>
<hr>
<h3>Index Selection Strategy</h3>
<pre><code class="language-sql">-- 1. Query patterns: Find common queries
-- Use pg_stat_statements to identify:
SELECT 
  query,
  calls,
  total_exec_time,
  mean_exec_time
FROM pg_stat_statements
WHERE query LIKE &#39;%products%&#39;
ORDER BY total_exec_time DESC
LIMIT 10;

-- 2. Create indexes based on findings:

-- Frequent: WHERE data @&gt; &#39;{&quot;brand&quot;: &quot;X&quot;}&#39;
-- → CREATE INDEX USING gin(data)

-- Frequent: WHERE data-&gt;&gt;&#39;brand&#39; = &#39;X&#39;
-- → CREATE INDEX ((data-&gt;&gt;&#39;brand&#39;))

-- Frequent: WHERE data @&gt; &#39;{&quot;active&quot;: true}&#39;
-- → CREATE INDEX USING gin(data) WHERE (data-&gt;&gt;&#39;active&#39;)::boolean = true

-- Frequent: Full-text search
-- → CREATE INDEX USING gin(to_tsvector(...))
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-sql">-- Test data: 1,000,000 products
-- Query: SELECT * FROM products WHERE data-&gt;&gt;&#39;brand&#39; = &#39;Apple&#39;

-- No index:
-- Execution time: 2500ms
-- Seq Scan on products (cost=0.00..25000.00)

-- GIN index on data:
-- Execution time: 450ms
-- Bitmap Heap Scan (cost=100.00..5000.00)

-- Expression index on (data-&gt;&gt;&#39;brand&#39;):
-- Execution time: 15ms
-- Index Scan using idx_products_brand (cost=0.42..8.44)

-- Winner: Expression index (165x faster than no index!)
</code></pre>
<hr>
<h3>Rails Migration Examples</h3>
<pre><code class="language-ruby"># GIN index on entire column
class AddIndexToProductsData &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :products, :data, using: :gin
  end
end

# Expression index
class AddBrandIndexToProducts &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :products, &quot;(data-&gt;&gt;&#39;brand&#39;)&quot;, name: &#39;idx_products_brand&#39;
  end
end

# Path ops for better containment performance
class AddPathOpsIndexToProducts &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE INDEX idx_products_data_path 
      ON products USING gin(data jsonb_path_ops)
    SQL
  end
  
  def down
    remove_index :products, name: &#39;idx_products_data_path&#39;
  end
end

# Partial index
class AddPartialIndexToProducts &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE INDEX idx_active_products_brand 
      ON products ((data-&gt;&gt;&#39;brand&#39;))
      WHERE (data-&gt;&gt;&#39;active&#39;)::boolean = true
    SQL
  end
  
  def down
    remove_index :products, name: &#39;idx_active_products_brand&#39;
  end
end

# Full-text search
class AddFullTextSearchToProducts &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE INDEX idx_products_search 
      ON products 
      USING gin(to_tsvector(&#39;english&#39;, 
        COALESCE(data-&gt;&gt;&#39;name&#39;, &#39;&#39;) || &#39; &#39; ||
        COALESCE(data-&gt;&gt;&#39;description&#39;, &#39;&#39;)
      ))
    SQL
  end
  
  def down
    remove_index :products, name: &#39;idx_products_search&#39;
  end
end
</code></pre>
<hr>
<h3>Index Maintenance</h3>
<pre><code class="language-sql">-- Check index usage
SELECT 
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch,
  pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
WHERE schemaname = &#39;public&#39;
  AND tablename = &#39;products&#39;
ORDER BY idx_scan;

-- Unused indexes (idx_scan = 0)
-- Consider dropping

-- Reindex if bloated
REINDEX INDEX idx_products_data;

-- Or concurrent (doesn&#39;t lock table)
REINDEX INDEX CONCURRENTLY idx_products_data;
</code></pre>
<hr>
<h3>Best Practices</h3>
<pre><code class="language-sql">-- ✅ Use GIN for general JSON queries
CREATE INDEX ON products USING gin(data);

-- ✅ Use expression indexes for frequent specific paths
CREATE INDEX ON products ((data-&gt;&gt;&#39;brand&#39;));

-- ✅ Use jsonb_path_ops for containment-only queries
CREATE INDEX ON products USING gin(data jsonb_path_ops);

-- ✅ Use partial indexes for filtered data
CREATE INDEX ON products USING gin(data) 
WHERE (data-&gt;&gt;&#39;active&#39;)::boolean = true;

-- ✅ Monitor index usage
-- Drop unused indexes

-- ✅ Consider index size
-- Balance performance vs storage

-- ❌ Don&#39;t create too many indexes
-- Each index slows writes

-- ❌ Don&#39;t index entire large documents
-- Extract frequent fields to columns
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>GIN</strong> for general JSONB queries</li>
<li><strong>jsonb_path_ops</strong> for @&gt; only</li>
<li><strong>Expression index</strong> for specific paths</li>
<li><strong>Partial index</strong> for filtered data</li>
<li><strong>Full-text</strong> index for search</li>
<li><strong>Monitor</strong> index usage</li>
<li><strong>Drop</strong> unused indexes</li>
<li><strong>Reindex</strong> when bloated</li>
<li><strong>Balance</strong> performance vs storage</li>
<li><strong>Test</strong> with real data</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 207-210 Summary (PostgreSQL Specific)</h2>
<p><strong>Q207: Partitioning in PostgreSQL</strong></p>
<pre><code class="language-sql">-- Range partitioning by date
CREATE TABLE orders (
  id BIGSERIAL,
  order_date DATE,
  amount DECIMAL
) PARTITION BY RANGE (order_date);

-- Create partitions
CREATE TABLE orders_2024_q1 PARTITION OF orders
  FOR VALUES FROM (&#39;2024-01-01&#39;) TO (&#39;2024-04-01&#39;);

CREATE TABLE orders_2024_q2 PARTITION OF orders
  FOR VALUES FROM (&#39;2024-04-01&#39;) TO (&#39;2024-07-01&#39;);

-- List partitioning
CREATE TABLE customers (
  id SERIAL,
  country TEXT,
  name TEXT
) PARTITION BY LIST (country);

CREATE TABLE customers_us PARTITION OF customers
  FOR VALUES IN (&#39;US&#39;, &#39;USA&#39;);

-- Hash partitioning
CREATE TABLE events (
  id BIGSERIAL,
  user_id INTEGER,
  event_type TEXT
) PARTITION BY HASH (user_id);

CREATE TABLE events_0 PARTITION OF events
  FOR VALUES WITH (MODULUS 4, REMAINDER 0);
</code></pre>
<p><strong>Q208: Write-Ahead Logs (WAL)</strong></p>
<pre><code class="language-sql">-- WAL ensures durability (ACID)
-- Changes written to WAL before data files
-- Enables point-in-time recovery
-- Supports replication

-- Check WAL settings
SHOW wal_level;  -- replica (or logical)
SHOW max_wal_size;  -- 1GB default

-- WAL archiving for backups
archive_mode = on
archive_command = &#39;cp %p /archive/%f&#39;

-- WAL segments in pg_wal directory
-- Each segment typically 16MB
</code></pre>
<p><strong>Q209: Prevent Deadlocks</strong></p>
<pre><code class="language-ruby"># 1. Always acquire locks in same order
def transfer(from_account, to_account, amount)
  accounts = [from_account, to_account].sort_by(&amp;:id)
  
  ActiveRecord::Base.transaction do
    accounts.each { |account| account.lock! }
    from_account.update!(balance: from_account.balance - amount)
    to_account.update!(balance: to_account.balance + amount)
  end
end

# 2. Keep transactions short
# 3. Use lower isolation levels when possible
# 4. Set lock timeout
ActiveRecord::Base.connection.execute(
  &quot;SET LOCAL lock_timeout = &#39;5s&#39;&quot;
)

# 5. Retry on deadlock
begin
  transfer(account_a, account_b, 100)
rescue ActiveRecord::Deadlocked
  retry  # Or handle appropriately
end
</code></pre>
<p><strong>Q210: Row-Level Security (RLS)</strong></p>
<pre><code class="language-sql">-- Enable RLS on table
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Create policy
CREATE POLICY user_documents ON documents
  FOR ALL
  TO authenticated_users
  USING (owner_id = current_user_id());

-- Users can only see their own documents
SELECT * FROM documents;
-- Automatically filtered: WHERE owner_id = current_user_id()

-- Multiple policies
CREATE POLICY admin_all ON documents
  FOR ALL
  TO admin_users
  USING (true);  -- Admins see everything

-- Rails integration
class ApplicationRecord &lt; ActiveRecord::Base
  def self.with_rls(user_id)
    connection.execute(&quot;SET LOCAL app.current_user_id = #{user_id}&quot;)
    yield
  ensure
    connection.execute(&quot;RESET app.current_user_id&quot;)
  end
end

User.with_rls(current_user.id) do
  Document.all  # Filtered by RLS
end
</code></pre>
<hr>
<h2>Data Warehousing and Analytics</h2>
<h2>Question 211: How do you handle large-scale analytics queries?</h2>
<h3>Answer</h3>
<p>Handle large-scale analytics using <strong>aggregation tables</strong>, <strong>materialized views</strong>, <strong>partitioning</strong>, <strong>columnar storage</strong>, <strong>query optimization</strong>, <strong>read replicas</strong>, and <strong>data warehouse tools</strong>. Separate OLTP from OLAP workloads.</p>
<hr>
<h3>1. Materialized Views</h3>
<pre><code class="language-sql">-- Pre-compute expensive aggregations
CREATE MATERIALIZED VIEW daily_sales_summary AS
SELECT 
  DATE(created_at) as date,
  product_id,
  COUNT(*) as order_count,
  SUM(amount) as total_revenue,
  AVG(amount) as avg_order_value
FROM orders
GROUP BY DATE(created_at), product_id;

-- Add indexes
CREATE INDEX idx_daily_sales_date 
ON daily_sales_summary(date);

CREATE INDEX idx_daily_sales_product 
ON daily_sales_summary(product_id);

-- Refresh periodically
REFRESH MATERIALIZED VIEW CONCURRENTLY daily_sales_summary;

-- Query is instant
SELECT * FROM daily_sales_summary 
WHERE date &gt;= &#39;2024-01-01&#39;;
</code></pre>
<hr>
<h3>2. Partitioning</h3>
<pre><code class="language-sql">-- Partition by time range
CREATE TABLE analytics_events (
  id BIGSERIAL,
  user_id INTEGER,
  event_type TEXT,
  created_at TIMESTAMP,
  properties JSONB
) PARTITION BY RANGE (created_at);

-- Monthly partitions
CREATE TABLE analytics_events_2024_01 
PARTITION OF analytics_events
FOR VALUES FROM (&#39;2024-01-01&#39;) TO (&#39;2024-02-01&#39;);

CREATE TABLE analytics_events_2024_02 
PARTITION OF analytics_events
FOR VALUES FROM (&#39;2024-02-01&#39;) TO (&#39;2024-03-01&#39;);

-- Query only touches relevant partition
SELECT COUNT(*) FROM analytics_events
WHERE created_at &gt;= &#39;2024-01-15&#39;
  AND created_at &lt; &#39;2024-01-20&#39;;
-- Only scans analytics_events_2024_01
</code></pre>
<hr>
<h3>3. Summary Tables</h3>
<pre><code class="language-ruby"># Pre-aggregate data
class DailyStat &lt; ApplicationRecord
  # Columns: date, metric_name, value, metadata
end

# Daily job to compute
class ComputeDailyStatsJob &lt; ApplicationJob
  def perform(date)
    {
      total_orders: Order.where(date: date).count,
      total_revenue: Order.where(date: date).sum(:amount),
      new_users: User.where(date: date).count,
      active_users: Activity.where(date: date).distinct.count(:user_id)
    }.each do |metric, value|
      DailyStat.find_or_create_by(date: date, metric_name: metric) do |stat|
        stat.value = value
      end
    end
  end
end

# Fast queries
DailyStat.where(metric_name: &#39;total_revenue&#39;)
         .where(&#39;date &gt;= ?&#39;, 30.days.ago)
         .sum(:value)
</code></pre>
<hr>
<h3>4. OLAP Cube / Roll-up Tables</h3>
<pre><code class="language-sql">-- Multi-dimensional aggregation
CREATE TABLE sales_cube AS
SELECT 
  DATE_TRUNC(&#39;day&#39;, created_at) as date,
  DATE_TRUNC(&#39;week&#39;, created_at) as week,
  DATE_TRUNC(&#39;month&#39;, created_at) as month,
  DATE_TRUNC(&#39;year&#39;, created_at) as year,
  product_category,
  customer_segment,
  region,
  COUNT(*) as order_count,
  SUM(amount) as revenue,
  AVG(amount) as avg_order_value
FROM orders
GROUP BY CUBE(
  DATE_TRUNC(&#39;day&#39;, created_at),
  DATE_TRUNC(&#39;week&#39;, created_at),
  DATE_TRUNC(&#39;month&#39;, created_at),
  DATE_TRUNC(&#39;year&#39;, created_at),
  product_category,
  customer_segment,
  region
);

-- Indexes for fast slicing
CREATE INDEX idx_sales_cube_date ON sales_cube(date);
CREATE INDEX idx_sales_cube_category ON sales_cube(product_category);
</code></pre>
<hr>
<h3>5. Read Replica for Analytics</h3>
<pre><code class="language-ruby"># config/database.yml
production:
  primary:
    &lt;&lt;: *default
    database: myapp_production
  
  analytics:
    &lt;&lt;: *default
    database: myapp_production
    host: analytics-replica.example.com
    replica: true

# Model
class AnalyticsQuery &lt; ApplicationRecord
  connects_to database: { writing: :primary, reading: :analytics }
end

# Usage
ActiveRecord::Base.connected_to(role: :reading) do
  # Heavy analytics queries run on replica
  Order.group(:product_id).sum(:amount)
end
</code></pre>
<hr>
<h3>6. Approximate Queries</h3>
<pre><code class="language-sql">-- Approximate count for huge tables
SELECT reltuples::bigint AS estimate
FROM pg_class
WHERE relname = &#39;orders&#39;;
-- Much faster than COUNT(*)

-- Approximate distinct count (HyperLogLog)
CREATE EXTENSION hll;

-- Approximate percentiles
SELECT percentile_disc(0.95) WITHIN GROUP (ORDER BY amount)
FROM orders TABLESAMPLE BERNOULLI(1);  -- Sample 1%
</code></pre>
<hr>
<h3>7. Column-Store Extensions</h3>
<pre><code class="language-sql">-- cstore_fdw for columnar storage
CREATE EXTENSION cstore_fdw;

-- Create foreign table
CREATE FOREIGN TABLE analytics_columnar (
  date DATE,
  user_id INTEGER,
  event_type TEXT,
  value NUMERIC
) SERVER cstore_server;

-- Much faster for analytical queries
-- Compresses 10x better than row storage
</code></pre>
<hr>
<h3>8. Query Optimization</h3>
<pre><code class="language-sql">-- ✅ Filter early
SELECT 
  product_id,
  SUM(amount) as revenue
FROM orders
WHERE created_at &gt;= &#39;2024-01-01&#39;  -- Filter first
  AND status = &#39;completed&#39;
GROUP BY product_id;

-- ✅ Use EXPLAIN ANALYZE
EXPLAIN (ANALYZE, BUFFERS) SELECT ...;

-- ✅ Add covering indexes
CREATE INDEX idx_orders_analytics 
ON orders(created_at, status, product_id, amount)
WHERE created_at &gt;= &#39;2024-01-01&#39;;

-- ✅ Increase work_mem for sorting/grouping
SET work_mem = &#39;256MB&#39;;
</code></pre>
<hr>
<h3>9. Incremental Updates</h3>
<pre><code class="language-ruby"># Only process new data
class UpdateAnalyticsJob &lt; ApplicationJob
  def perform
    last_processed = AnalyticsSummary.maximum(:processed_until) || 1.year.ago
    
    # Process only new orders
    Order.where(&#39;created_at &gt; ?&#39;, last_processed)
         .find_in_batches(batch_size: 10000) do |batch|
      process_batch(batch)
    end
    
    AnalyticsSummary.update_all(processed_until: Time.current)
  end
end
</code></pre>
<hr>
<h3>10. Separate Data Warehouse</h3>
<pre><code class="language-ruby"># Export to data warehouse (Snowflake, Redshift, BigQuery)
class ExportToWarehouseJob &lt; ApplicationJob
  def perform
    # Extract
    data = Order.where(&#39;created_at &gt;= ?&#39;, 1.day.ago)
                .select(:id, :user_id, :amount, :created_at)
    
    # Transform
    transformed = data.map do |order|
      {
        order_id: order.id,
        user_id: order.user_id,
        amount: order.amount.to_f,
        date: order.created_at.to_date
      }
    end
    
    # Load
    WarehouseClient.bulk_insert(&#39;orders&#39;, transformed)
  end
end

# Query warehouse for analytics
# Keep production DB for OLTP
</code></pre>
<hr>
<h3>Real-World Architecture</h3>
<pre><code class="language-ruby"># Separate concerns
class Order &lt; ApplicationRecord
  # OLTP: Fast writes, simple reads
  # Queries: find, create, update
end

class OrderAnalytics &lt; ApplicationRecord
  # OLAP: Complex reads, batch writes
  # Materialized from orders table
  # Queries: sum, avg, group by, window functions
  
  self.table_name = &#39;order_analytics_summary&#39;
  
  def self.refresh
    connection.execute(
      &quot;REFRESH MATERIALIZED VIEW CONCURRENTLY order_analytics_summary&quot;
    )
  end
end

# Scheduler
# Every hour: OrderAnalytics.refresh
# Run analytics queries on OrderAnalytics, not Order
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Materialized views</strong> for pre-computation</li>
<li><strong>Partitioning</strong> for time-series data</li>
<li><strong>Summary tables</strong> for aggregates</li>
<li><strong>Read replicas</strong> for heavy queries</li>
<li><strong>Approximate queries</strong> for speed</li>
<li><strong>Columnar storage</strong> for analytics</li>
<li><strong>Separate OLTP/OLAP</strong> workloads</li>
<li><strong>Incremental updates</strong> not full refresh</li>
<li><strong>Data warehouse</strong> for complex analytics</li>
<li><strong>Monitor and optimize</strong> continuously</li>
</ol>
<hr>
<h2>Question 212: What are fact tables and dimension tables?</h2>
<h3>Answer</h3>
<p><strong>Fact tables</strong> store measurable business events (sales, clicks, transactions). <strong>Dimension tables</strong> store descriptive attributes (customers, products, dates). Facts reference dimensions via foreign keys.</p>
<hr>
<h3>Fact Table</h3>
<pre><code class="language-sql">-- Stores quantitative data (metrics)
CREATE TABLE fact_sales (
  sale_id SERIAL PRIMARY KEY,
  
  -- Foreign keys to dimensions
  date_id INTEGER REFERENCES dim_date(date_id),
  product_id INTEGER REFERENCES dim_product(product_id),
  customer_id INTEGER REFERENCES dim_customer(customer_id),
  store_id INTEGER REFERENCES dim_store(store_id),
  
  -- Measures (what you want to analyze)
  quantity INTEGER,
  unit_price DECIMAL(10,2),
  discount DECIMAL(10,2),
  total_amount DECIMAL(10,2),
  cost DECIMAL(10,2),
  profit DECIMAL(10,2)
);

-- Characteristics:
-- ✅ Many rows (millions/billions)
-- ✅ Narrow (few columns)
-- ✅ Foreign keys to dimensions
-- ✅ Numeric measures
-- ✅ Atomic granularity
</code></pre>
<hr>
<h3>Dimension Tables</h3>
<pre><code class="language-sql">-- Describe WHO, WHAT, WHERE, WHEN
CREATE TABLE dim_date (
  date_id INTEGER PRIMARY KEY,
  full_date DATE,
  day_of_week TEXT,
  day_name TEXT,
  month INTEGER,
  month_name TEXT,
  quarter INTEGER,
  year INTEGER,
  is_weekend BOOLEAN,
  is_holiday BOOLEAN
);

CREATE TABLE dim_product (
  product_id INTEGER PRIMARY KEY,
  product_name TEXT,
  category TEXT,
  subcategory TEXT,
  brand TEXT,
  supplier TEXT,
  unit_cost DECIMAL(10,2),
  unit_price DECIMAL(10,2)
);

CREATE TABLE dim_customer (
  customer_id INTEGER PRIMARY KEY,
  customer_name TEXT,
  email TEXT,
  phone TEXT,
  address TEXT,
  city TEXT,
  state TEXT,
  country TEXT,
  customer_segment TEXT,
  registration_date DATE
);

CREATE TABLE dim_store (
  store_id INTEGER PRIMARY KEY,
  store_name TEXT,
  address TEXT,
  city TEXT,
  state TEXT,
  country TEXT,
  region TEXT,
  store_type TEXT,
  opening_date DATE
);

-- Characteristics:
-- ✅ Fewer rows (thousands)
-- ✅ Wide (many columns)
-- ✅ Descriptive attributes
-- ✅ Slowly changing
-- ✅ Used for filtering/grouping
</code></pre>
<hr>
<h3>Example Query</h3>
<pre><code class="language-sql">-- Analyze sales by product category and region
SELECT 
  dp.category,
  ds.region,
  dd.year,
  dd.quarter,
  SUM(fs.quantity) as units_sold,
  SUM(fs.total_amount) as revenue,
  SUM(fs.profit) as profit
FROM fact_sales fs
JOIN dim_product dp ON fs.product_id = dp.product_id
JOIN dim_store ds ON fs.store_id = ds.store_id
JOIN dim_date dd ON fs.date_id = dd.date_id
WHERE dd.year = 2024
  AND ds.region = &#39;Northeast&#39;
GROUP BY dp.category, ds.region, dd.year, dd.quarter
ORDER BY revenue DESC;
</code></pre>
<hr>
<h3>Fact Table Types</h3>
<p><strong>1. Transaction Fact Table:</strong></p>
<pre><code class="language-sql">-- One row per transaction
CREATE TABLE fact_orders (
  order_id SERIAL PRIMARY KEY,
  date_id INTEGER,
  customer_id INTEGER,
  product_id INTEGER,
  quantity INTEGER,
  amount DECIMAL(10,2)
);
-- Most common, highest granularity
</code></pre>
<p><strong>2. Periodic Snapshot Fact Table:</strong></p>
<pre><code class="language-sql">-- Snapshot at regular intervals
CREATE TABLE fact_inventory_snapshot (
  snapshot_id SERIAL PRIMARY KEY,
  date_id INTEGER,
  product_id INTEGER,
  warehouse_id INTEGER,
  quantity_on_hand INTEGER,
  quantity_ordered INTEGER,
  quantity_available INTEGER
);
-- Daily inventory levels
</code></pre>
<p><strong>3. Accumulating Snapshot Fact Table:</strong></p>
<pre><code class="language-sql">-- Track process milestones
CREATE TABLE fact_order_fulfillment (
  order_id INTEGER PRIMARY KEY,
  order_date_id INTEGER,
  payment_date_id INTEGER,
  shipment_date_id INTEGER,
  delivery_date_id INTEGER,
  order_to_payment_days INTEGER,
  order_to_shipment_days INTEGER,
  order_to_delivery_days INTEGER,
  total_amount DECIMAL(10,2)
);
-- Updated as order progresses
</code></pre>
<hr>
<h3>Rails Implementation</h3>
<pre><code class="language-ruby"># Fact table
class FactSale &lt; ApplicationRecord
  belongs_to :date, class_name: &#39;DimDate&#39;, foreign_key: &#39;date_id&#39;
  belongs_to :product, class_name: &#39;DimProduct&#39;
  belongs_to :customer, class_name: &#39;DimCustomer&#39;
  belongs_to :store, class_name: &#39;DimStore&#39;
end

# Dimension tables
class DimDate &lt; ApplicationRecord
  self.primary_key = &#39;date_id&#39;
  has_many :fact_sales, foreign_key: &#39;date_id&#39;
end

class DimProduct &lt; ApplicationRecord
  has_many :fact_sales
end

# ETL: Load fact table
class LoadFactSalesJob &lt; ApplicationJob
  def perform(date)
    Order.where(created_at: date.all_day).find_each do |order|
      FactSale.create!(
        date_id: DimDate.find_by(full_date: order.created_at.to_date).date_id,
        product_id: order.product_id,
        customer_id: order.user_id,
        store_id: order.store_id,
        quantity: order.quantity,
        unit_price: order.unit_price,
        total_amount: order.total_amount,
        profit: order.total_amount - order.cost
      )
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Facts</strong> = measurable events</li>
<li><strong>Dimensions</strong> = descriptive context</li>
<li><strong>Facts</strong> have metrics</li>
<li><strong>Dimensions</strong> have attributes</li>
<li><strong>Facts</strong> reference dimensions</li>
<li><strong>Facts</strong> many rows</li>
<li><strong>Dimensions</strong> fewer rows</li>
<li><strong>Join</strong> for analysis</li>
<li><strong>Separate</strong> for performance</li>
<li><strong>Star/snowflake</strong> schema</li>
</ol>
<hr>
<h2>Question 213: What are star schema and snowflake schema?</h2>
<h3>Answer</h3>
<p><strong>Star schema</strong> has fact table at center with direct connections to denormalized dimension tables. <strong>Snowflake schema</strong> normalizes dimension tables into multiple related tables. Star = simpler/faster, Snowflake = normalized/storage efficient.</p>
<hr>
<h3>Star Schema</h3>
<pre><code class="language-sql">-- Central fact table
CREATE TABLE fact_sales (
  sale_id SERIAL PRIMARY KEY,
  date_id INTEGER,
  product_id INTEGER,
  customer_id INTEGER,
  store_id INTEGER,
  quantity INTEGER,
  amount DECIMAL(10,2)
);

-- Denormalized dimension (all attributes in one table)
CREATE TABLE dim_product (
  product_id INTEGER PRIMARY KEY,
  product_name TEXT,
  category TEXT,        -- Not normalized!
  subcategory TEXT,     -- Not normalized!
  brand TEXT,           -- Not normalized!
  supplier_name TEXT,   -- Not normalized!
  supplier_country TEXT -- Not normalized!
);

-- Visual:
--         dim_date
--             |
--         fact_sales --- dim_product
--             |
--         dim_customer
--             |
--         dim_store

-- Advantages:
-- ✅ Simple queries (fewer joins)
-- ✅ Faster performance
-- ✅ Easy to understand
-- ✅ Better for BI tools

-- Disadvantages:
-- ❌ Data redundancy
-- ❌ Larger storage
-- ❌ Update anomalies
</code></pre>
<hr>
<h3>Snowflake Schema</h3>
<pre><code class="language-sql">-- Same fact table
CREATE TABLE fact_sales (
  sale_id SERIAL PRIMARY KEY,
  date_id INTEGER,
  product_id INTEGER,
  customer_id INTEGER,
  store_id INTEGER,
  quantity INTEGER,
  amount DECIMAL(10,2)
);

-- Normalized dimensions (multiple tables)
CREATE TABLE dim_product (
  product_id INTEGER PRIMARY KEY,
  product_name TEXT,
  subcategory_id INTEGER,  -- Foreign key!
  brand_id INTEGER         -- Foreign key!
);

CREATE TABLE dim_category (
  category_id INTEGER PRIMARY KEY,
  category_name TEXT
);

CREATE TABLE dim_subcategory (
  subcategory_id INTEGER PRIMARY KEY,
  subcategory_name TEXT,
  category_id INTEGER     -- Foreign key to category!
);

CREATE TABLE dim_brand (
  brand_id INTEGER PRIMARY KEY,
  brand_name TEXT,
  supplier_id INTEGER     -- Foreign key!
);

CREATE TABLE dim_supplier (
  supplier_id INTEGER PRIMARY KEY,
  supplier_name TEXT,
  supplier_country TEXT
);

-- Visual:
--                    dim_date
--                        |
--     dim_supplier   fact_sales   dim_customer
--         |              |              |
--     dim_brand    dim_product    dim_city
--                       |              |
--              dim_subcategory    dim_state
--                       |              |
--                  dim_category   dim_country

-- Advantages:
-- ✅ Less redundancy
-- ✅ Smaller storage
-- ✅ Easier updates
-- ✅ Better data integrity

-- Disadvantages:
-- ❌ More complex queries
-- ❌ More joins = slower
-- ❌ Harder to understand
-- ❌ BI tools may struggle
</code></pre>
<hr>
<h3>Query Comparison</h3>
<p><strong>Star Schema Query:</strong></p>
<pre><code class="language-sql">-- Simple: 1 join per dimension
SELECT 
  dp.category,
  SUM(fs.amount) as revenue
FROM fact_sales fs
JOIN dim_product dp ON fs.product_id = dp.product_id
WHERE dp.category = &#39;Electronics&#39;
GROUP BY dp.category;

-- Fast: 2 tables
</code></pre>
<p><strong>Snowflake Schema Query:</strong></p>
<pre><code class="language-sql">-- Complex: Multiple joins per dimension
SELECT 
  dc.category_name,
  SUM(fs.amount) as revenue
FROM fact_sales fs
JOIN dim_product dp ON fs.product_id = dp.product_id
JOIN dim_subcategory dsc ON dp.subcategory_id = dsc.subcategory_id
JOIN dim_category dc ON dsc.category_id = dc.category_id
WHERE dc.category_name = &#39;Electronics&#39;
GROUP BY dc.category_name;

-- Slower: 4 tables
</code></pre>
<hr>
<h3>Hybrid Approach</h3>
<pre><code class="language-sql">-- Start with snowflake for storage
-- Create star views for querying

CREATE VIEW v_dim_product_star AS
SELECT 
  dp.product_id,
  dp.product_name,
  dsc.subcategory_name,
  dc.category_name,
  db.brand_name,
  ds.supplier_name,
  ds.supplier_country
FROM dim_product dp
JOIN dim_subcategory dsc ON dp.subcategory_id = dsc.subcategory_id
JOIN dim_category dc ON dsc.category_id = dc.category_id
JOIN dim_brand db ON dp.brand_id = db.brand_id
JOIN dim_supplier ds ON db.supplier_id = ds.supplier_id;

-- Query star view (fast)
SELECT 
  vp.category_name,
  SUM(fs.amount) as revenue
FROM fact_sales fs
JOIN v_dim_product_star vp ON fs.product_id = vp.product_id
WHERE vp.category_name = &#39;Electronics&#39;
GROUP BY vp.category_name;

-- Benefits:
-- ✅ Normalized storage (snowflake)
-- ✅ Denormalized queries (star)
-- ✅ Best of both worlds
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Star</strong> = denormalized dimensions</li>
<li><strong>Snowflake</strong> = normalized dimensions</li>
<li><strong>Star</strong> faster queries</li>
<li><strong>Snowflake</strong> less storage</li>
<li><strong>Star</strong> simpler</li>
<li><strong>Snowflake</strong> more integrity</li>
<li><strong>Star</strong> for BI tools</li>
<li><strong>Snowflake</strong> for data purity</li>
<li><strong>Hybrid</strong> possible</li>
<li><strong>Choose</strong> based on needs</li>
</ol>
<hr>
<h2>Question 214-215 Summary</h2>
<p><strong>Q214: ETL Operations</strong></p>
<pre><code class="language-ruby"># Extract
data = Order.where(&#39;created_at &gt;= ?&#39;, 1.day.ago)

# Transform
transformed = data.map do |order|
  {
    date_id: date_dimension_lookup(order.created_at),
    product_id: order.product_id,
    customer_id: order.user_id,
    amount: order.total_amount,
    quantity: order.items.sum(:quantity)
  }
end

# Load
FactSale.insert_all(transformed)

# Tools: Airflow, dbt, Fivetran, Stitch
</code></pre>
<p><strong>Q215: Real-Time Analytics</strong></p>
<pre><code class="language-ruby"># 1. Stream processing (Kafka + ksqlDB)
# 2. In-memory aggregation (Redis)
# 3. Incremental materialized views
CREATE MATERIALIZED VIEW real_time_stats 
WITH (timescaledb.continuous) AS
SELECT 
  time_bucket(&#39;1 minute&#39;, created_at) as bucket,
  COUNT(*) as events
FROM events
GROUP BY bucket;

# 4. Change Data Capture (CDC)
# 5. Approximate queries
# 6. Read replicas with streaming replication
</code></pre>
<h1>Multi-tenancy, Security, and Backup &amp; Recovery Interview Questions</h1>
<h2>Multi-tenancy</h2>
<h2>Question 216: How do you implement multi-tenancy in Rails?</h2>
<h3>Answer</h3>
<p>Implement multi-tenancy using <strong>row-based</strong> (shared database with tenant_id), <strong>schema-based</strong> (separate PostgreSQL schemas), or <strong>database-based</strong> (separate databases). Choose based on isolation needs, scale, and complexity requirements.</p>
<hr>
<h3>1. Row-Based Multi-Tenancy (Shared Database)</h3>
<p><strong>Most common approach:</strong></p>
<pre><code class="language-ruby"># Add tenant_id to all tables
class AddTenantIdToTables &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :tenant_id, :bigint, null: false
    add_column :orders, :tenant_id, :bigint, null: false
    add_column :products, :tenant_id, :bigint, null: false
    
    add_index :users, :tenant_id
    add_index :orders, :tenant_id
    add_index :products, :tenant_id
    
    add_foreign_key :users, :tenants
    add_foreign_key :orders, :tenants
    add_foreign_key :products, :tenants
  end
end

# Base model with tenant scoping
class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  # Automatically scope all queries by current tenant
  def self.inherited(subclass)
    super
    
    if subclass.column_names.include?(&#39;tenant_id&#39;)
      subclass.class_eval do
        belongs_to :tenant
        
        default_scope { where(tenant_id: Current.tenant_id) }
        
        before_validation :set_tenant_id
        
        private
        
        def set_tenant_id
          self.tenant_id ||= Current.tenant_id
        end
      end
    end
  end
end

# Current context (Rails 5.2+)
class Current &lt; ActiveSupport::CurrentAttributes
  attribute :tenant, :tenant_id
  
  def tenant=(tenant)
    super
    self.tenant_id = tenant&amp;.id
  end
end

# Controller
class ApplicationController &lt; ActionController::Base
  before_action :set_current_tenant
  
  private
  
  def set_current_tenant
    tenant = Tenant.find_by(subdomain: request.subdomain)
    Current.tenant = tenant
  end
end

# Usage (automatic scoping)
class OrdersController &lt; ApplicationController
  def index
    @orders = Order.all  # Automatically scoped to Current.tenant_id
  end
  
  def create
    @order = Order.create(order_params)  # tenant_id set automatically
  end
end
</code></pre>
<hr>
<h3>2. Schema-Based Multi-Tenancy (PostgreSQL Schemas)</h3>
<p><strong>Better isolation:</strong></p>
<pre><code class="language-ruby"># Gemfile
gem &#39;apartment&#39;

# config/initializers/apartment.rb
Apartment.configure do |config|
  config.excluded_models = [&quot;Tenant&quot;, &quot;User&quot;]
  config.tenant_names = -&gt; { Tenant.pluck(:schema_name) }
  config.use_schemas = true
end

# Middleware
class TenantMiddleware
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request = Rack::Request.new(env)
    tenant = Tenant.find_by(subdomain: request.host.split(&#39;.&#39;).first)
    
    if tenant
      Apartment::Tenant.switch!(tenant.schema_name)
    end
    
    @app.call(env)
  ensure
    Apartment::Tenant.reset
  end
end

# Create tenant schema
class Tenant &lt; ApplicationRecord
  after_create :create_schema
  after_destroy :drop_schema
  
  def create_schema
    Apartment::Tenant.create(schema_name)
  end
  
  def drop_schema
    Apartment::Tenant.drop(schema_name)
  end
end

# Usage
Apartment::Tenant.switch!(&#39;tenant1&#39;) do
  Order.create(amount: 100)  # Stored in tenant1 schema
end

# Each tenant has separate tables in their schema
# public.tenants (shared)
# tenant1.orders (isolated)
# tenant2.orders (isolated)
</code></pre>
<hr>
<h3>3. Database-Based Multi-Tenancy</h3>
<p><strong>Maximum isolation:</strong></p>
<pre><code class="language-ruby"># config/database.yml
development:
  primary:
    adapter: postgresql
    database: app_primary
  
  # Tenant databases
  tenant_template:
    adapter: postgresql
    database: tenant_&lt;%= ENV[&#39;TENANT_ID&#39;] %&gt;

# Dynamic database connection
class Tenant &lt; ApplicationRecord
  def establish_connection
    config = Rails.configuration.database_configuration
    tenant_config = config[&#39;tenant_template&#39;].dup
    tenant_config[&#39;database&#39;] = &quot;tenant_#{id}&quot;
    
    ActiveRecord::Base.establish_connection(tenant_config)
  end
end

# Middleware
class TenantDatabaseMiddleware
  def call(env)
    tenant = identify_tenant(env)
    
    if tenant
      tenant.establish_connection
    end
    
    @app.call(env)
  ensure
    ActiveRecord::Base.establish_connection(:primary)
  end
end

# Create new tenant database
class CreateTenantService
  def call(tenant)
    # Create database
    ActiveRecord::Base.connection.create_database(&quot;tenant_#{tenant.id}&quot;)
    
    # Run migrations
    tenant.establish_connection
    ActiveRecord::Tasks::DatabaseTasks.migrate
    
    # Seed data
    Rails.application.load_seed
  end
end
</code></pre>
<hr>
<h3>4. Using acts_as_tenant Gem</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;acts_as_tenant&#39;

# Models
class Tenant &lt; ApplicationRecord
  has_many :users
  has_many :orders
end

class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true
end

class User &lt; ApplicationRecord
  acts_as_tenant :tenant
end

class Order &lt; ApplicationRecord
  acts_as_tenant :tenant
end

# Controller
class ApplicationController &lt; ActionController::Base
  set_current_tenant_through_filter
  before_action :set_tenant
  
  private
  
  def set_tenant
    tenant = Tenant.find_by(subdomain: request.subdomain)
    set_current_tenant(tenant)
  end
end

# Automatic scoping
User.all  # SELECT * FROM users WHERE tenant_id = ?
Order.create(amount: 100)  # tenant_id automatically set
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Isolation</th>
<th>Complexity</th>
<th>Scalability</th>
<th>Cost</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Row-based</strong></td>
<td>Low</td>
<td>Low</td>
<td>High</td>
<td>Low</td>
</tr>
<tr>
<td><strong>Schema-based</strong></td>
<td>Medium</td>
<td>Medium</td>
<td>Medium</td>
<td>Medium</td>
</tr>
<tr>
<td><strong>Database-based</strong></td>
<td>High</td>
<td>High</td>
<td>Low</td>
<td>High</td>
</tr>
</tbody></table>
<hr>
<h3>Row-Based: Pros &amp; Cons</h3>
<pre><code class="language-ruby"># ✅ Advantages
# - Simple implementation
# - Easy to query across tenants (admin)
# - Cost-effective (shared resources)
# - Easy backups (single database)

# ❌ Disadvantages
# - Data leakage risk (if scoping fails)
# - All tenants affected by downtime
# - Difficult to move tenant to different server
# - Noisy neighbor problem

# Best for:
# - Many small tenants
# - Limited data per tenant
# - Cost-sensitive SaaS
</code></pre>
<hr>
<h3>Schema-Based: Pros &amp; Cons</h3>
<pre><code class="language-ruby"># ✅ Advantages
# - Good isolation
# - Easier to backup/restore single tenant
# - Can migrate schema independently
# - Better than row-based for compliance

# ❌ Disadvantages
# - More complex
# - Connection pool per schema
# - Migrations more complex
# - PostgreSQL schema limit (~10k)

# Best for:
# - Medium isolation needs
# - Moderate number of tenants
# - Need to restore single tenant
</code></pre>
<hr>
<h3>Database-Based: Pros &amp; Cons</h3>
<pre><code class="language-ruby"># ✅ Advantages
# - Maximum isolation
# - Easy to move tenant
# - Independent backups
# - No data leakage possible

# ❌ Disadvantages
# - Expensive (connection per DB)
# - Complex infrastructure
# - Difficult to query across tenants
# - Migration management complex

# Best for:
# - Few large tenants
# - High isolation requirements
# - Compliance needs (HIPAA, etc.)
</code></pre>
<hr>
<h3>Security Considerations</h3>
<pre><code class="language-ruby"># 1. Prevent tenant_id manipulation
class ApplicationController &lt; ActionController::Base
  before_action :verify_tenant_access
  
  private
  
  def verify_tenant_access
    if params[:tenant_id] &amp;&amp; params[:tenant_id].to_i != Current.tenant_id
      raise ActiveRecord::RecordNotFound
    end
  end
end

# 2. Strong parameters
def order_params
  params.require(:order).permit(:amount, :status)
  # Never permit :tenant_id from user input!
end

# 3. Disable default_scope in specific cases
Order.unscoped.where(id: params[:id], tenant_id: Current.tenant_id).first

# 4. Admin access to all tenants
if current_user.admin?
  Tenant.unscoped { Order.all }
end
</code></pre>
<hr>
<h3>Real-World Example</h3>
<pre><code class="language-ruby"># Complete row-based multi-tenancy setup

# 1. Tenant model
class Tenant &lt; ApplicationRecord
  has_many :users, dependent: :destroy
  validates :subdomain, presence: true, uniqueness: true
end

# 2. Current context
class Current &lt; ActiveSupport::CurrentAttributes
  attribute :tenant
  
  def tenant_id
    tenant&amp;.id
  end
end

# 3. Base model
class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  def self.multitenant?
    column_names.include?(&#39;tenant_id&#39;)
  end
  
  def self.inherited(subclass)
    super
    
    if subclass.multitenant?
      subclass.class_eval do
        belongs_to :tenant
        
        default_scope { where(tenant_id: Current.tenant_id) if Current.tenant_id }
        
        validates :tenant_id, presence: true
        before_validation :set_tenant_id
        
        private
        
        def set_tenant_id
          self.tenant_id ||= Current.tenant_id
        end
      end
    end
  end
end

# 4. Controller
class ApplicationController &lt; ActionController::Base
  include SetCurrentTenant
  
  rescue_from ActiveRecord::RecordNotFound, with: :not_found
  
  private
  
  def not_found
    render json: { error: &#39;Not found&#39; }, status: :not_found
  end
end

# 5. Concern
module SetCurrentTenant
  extend ActiveSupport::Concern
  
  included do
    before_action :set_current_tenant
    before_action :verify_tenant_access
  end
  
  private
  
  def set_current_tenant
    subdomain = request.subdomain.presence || &#39;www&#39;
    tenant = Tenant.find_by!(subdomain: subdomain)
    Current.tenant = tenant
  rescue ActiveRecord::RecordNotFound
    render json: { error: &#39;Tenant not found&#39; }, status: :not_found
  end
  
  def verify_tenant_access
    if params[:tenant_id] &amp;&amp; params[:tenant_id].to_i != Current.tenant_id
      render json: { error: &#39;Unauthorized&#39; }, status: :unauthorized
    end
  end
end

# 6. Tests
RSpec.describe Order, type: :model do
  let(:tenant1) { create(:tenant) }
  let(:tenant2) { create(:tenant) }
  
  it &#39;scopes to current tenant&#39; do
    Current.tenant = tenant1
    order1 = create(:order)
    
    Current.tenant = tenant2
    order2 = create(:order)
    
    Current.tenant = tenant1
    expect(Order.all).to eq([order1])
    expect(Order.all).not_to include(order2)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Row-based</strong> simplest and most common</li>
<li><strong>Schema-based</strong> better isolation</li>
<li><strong>Database-based</strong> maximum isolation</li>
<li><strong>tenant_id</strong> in all tables (row-based)</li>
<li><strong>Current attributes</strong> for tenant context</li>
<li><strong>default_scope</strong> for automatic filtering</li>
<li><strong>Security</strong> critical (prevent data leakage)</li>
<li><strong>Choose</strong> based on requirements</li>
<li><strong>Test</strong> tenant isolation thoroughly</li>
<li><strong>Monitor</strong> performance per tenant</li>
</ol>
<hr>
<h2>Question 217: How do you implement multi-tenancy using PostgreSQL schemas?</h2>
<h3>Answer</h3>
<p>PostgreSQL schema-based multi-tenancy creates <strong>separate schemas per tenant</strong> within a single database. Each tenant&#39;s data is isolated in their own schema with identical table structures. Use Apartment gem or custom implementation.</p>
<hr>
<h3>PostgreSQL Schema Basics</h3>
<pre><code class="language-sql">-- Create schemas
CREATE SCHEMA tenant_acme;
CREATE SCHEMA tenant_globex;
CREATE SCHEMA public;  -- Shared data

-- Each schema has same tables
CREATE TABLE tenant_acme.users (id SERIAL PRIMARY KEY, name TEXT);
CREATE TABLE tenant_globex.users (id SERIAL PRIMARY KEY, name TEXT);

-- Switch search path
SET search_path TO tenant_acme;
SELECT * FROM users;  -- Queries tenant_acme.users

SET search_path TO tenant_globex;
SELECT * FROM users;  -- Queries tenant_globex.users

-- View all schemas
SELECT schema_name FROM information_schema.schemata;
</code></pre>
<hr>
<h3>Using Apartment Gem</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;apartment&#39;

# config/initializers/apartment.rb
require &#39;apartment/elevators/subdomain&#39;

Apartment.configure do |config|
  # Tables that should remain in public schema
  config.excluded_models = %w[Tenant User]
  
  # Use PostgreSQL schemas
  config.use_schemas = true
  
  # Tenant names (schema names)
  config.tenant_names = -&gt; { Tenant.pluck(:schema_name) }
  
  # Schema to use when not in tenant context
  config.default_schema = &#39;public&#39;
  
  # Prepend environment to schema name
  config.prepend_environment = false
  
  # Append environment to schema name
  config.append_environment = false
end

# Use subdomain elevator
Rails.application.config.middleware.use Apartment::Elevators::Subdomain

# Or custom elevator
Rails.application.config.middleware.use Apartment::Elevators::Generic, lambda { |request|
  Tenant.find_by(domain: request.host)&amp;.schema_name
}
</code></pre>
<hr>
<h3>Tenant Model</h3>
<pre><code class="language-ruby">class Tenant &lt; ApplicationRecord
  # Stored in public schema
  # Columns: id, name, schema_name, domain, subdomain
  
  after_create :create_schema
  after_destroy :drop_schema
  
  validates :schema_name, presence: true, uniqueness: true
  validates :subdomain, presence: true, uniqueness: true
  
  def create_schema
    Apartment::Tenant.create(schema_name)
  end
  
  def drop_schema
    Apartment::Tenant.drop(schema_name)
  end
  
  def switch!
    Apartment::Tenant.switch!(schema_name)
  end
end

# Create new tenant
tenant = Tenant.create!(
  name: &#39;Acme Corp&#39;,
  schema_name: &#39;tenant_acme&#39;,
  subdomain: &#39;acme&#39;
)
# Automatically creates schema and runs migrations
</code></pre>
<hr>
<h3>Switching Tenants</h3>
<pre><code class="language-ruby"># Manual switching
Apartment::Tenant.switch!(&#39;tenant_acme&#39;)
Order.all  # Queries tenant_acme.orders

# With block (auto-reset)
Apartment::Tenant.switch(&#39;tenant_acme&#39;) do
  Order.create!(amount: 100)
end
# Switches back to previous schema

# Get current schema
Apartment::Tenant.current  # &#39;tenant_acme&#39;

# Reset to default
Apartment::Tenant.reset

# Switch in controller
class ApplicationController &lt; ActionController::Base
  before_action :switch_tenant
  
  private
  
  def switch_tenant
    tenant = Tenant.find_by!(subdomain: request.subdomain)
    Apartment::Tenant.switch!(tenant.schema_name)
  rescue ActiveRecord::RecordNotFound
    render_404
  end
end
</code></pre>
<hr>
<h3>Migrations</h3>
<pre><code class="language-ruby"># Regular migrations run on ALL tenant schemas
class CreateOrders &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :orders do |t|
      t.decimal :amount
      t.string :status
      t.timestamps
    end
  end
end

# Run migrations
rake db:migrate
# Runs on public schema + all tenant schemas

# Migrate specific tenant
Apartment::Tenant.switch(&#39;tenant_acme&#39;) do
  ActiveRecord::Tasks::DatabaseTasks.migrate
end

# Seed specific tenant
Apartment::Tenant.switch(&#39;tenant_acme&#39;) do
  Rails.application.load_seed
end
</code></pre>
<hr>
<h3>Shared vs Tenant-Specific Tables</h3>
<pre><code class="language-ruby"># config/initializers/apartment.rb
Apartment.configure do |config|
  # These stay in public schema (shared across tenants)
  config.excluded_models = %w[
    Tenant
    User
    Plan
    Payment
  ]
  
  # These tables created in each tenant schema
  # - orders
  # - products
  # - customers
  # - invoices
end

# Schema structure:
# public.tenants (shared)
# public.users (shared)
# public.plans (shared)
# tenant_acme.orders (isolated)
# tenant_acme.products (isolated)
# tenant_globex.orders (isolated)
# tenant_globex.products (isolated)
</code></pre>
<hr>
<h3>Background Jobs</h3>
<pre><code class="language-ruby"># Pass tenant in job
class ProcessOrderJob &lt; ApplicationJob
  queue_as :default
  
  def perform(order_id, tenant_schema)
    Apartment::Tenant.switch(tenant_schema) do
      order = Order.find(order_id)
      order.process!
    end
  end
end

# Enqueue with tenant
class Order &lt; ApplicationRecord
  after_create :enqueue_processing
  
  def enqueue_processing
    ProcessOrderJob.perform_later(id, Apartment::Tenant.current)
  end
end

# Sidekiq integration
class TenantJob
  include Sidekiq::Worker
  
  def perform(tenant_schema, *args)
    Apartment::Tenant.switch(tenant_schema) do
      # Job logic
    end
  end
end
</code></pre>
<hr>
<h3>Console Access</h3>
<pre><code class="language-ruby"># Rails console
rails console

# Switch to tenant
Apartment::Tenant.switch!(&#39;tenant_acme&#39;)

# Query tenant data
Order.all
Product.count

# Switch back
Apartment::Tenant.reset

# List all tenants
Tenant.all.each do |tenant|
  Apartment::Tenant.switch(tenant.schema_name) do
    puts &quot;#{tenant.name}: #{Order.count} orders&quot;
  end
end
</code></pre>
<hr>
<h3>Backup &amp; Restore Single Tenant</h3>
<pre><code class="language-bash"># Backup specific schema
pg_dump -n tenant_acme myapp_production &gt; tenant_acme_backup.sql

# Restore specific schema
psql myapp_production &lt; tenant_acme_backup.sql

# Copy tenant to another database
pg_dump -n tenant_acme myapp_production | \
  psql myapp_staging
</code></pre>
<hr>
<h3>Performance Considerations</h3>
<pre><code class="language-sql">-- Each schema has own indexes
CREATE INDEX idx_orders_status 
ON tenant_acme.orders(status);

CREATE INDEX idx_orders_status 
ON tenant_globex.orders(status);

-- Connection pooling
-- Each schema switch may need new connection
-- Monitor connection pool usage

-- Schema limits
-- PostgreSQL: ~10,000 schemas per database
-- Beyond that, consider database-per-tenant

-- Query performance
-- Switching schemas is fast (metadata lookup)
-- No cross-tenant queries needed
</code></pre>
<hr>
<h3>Testing</h3>
<pre><code class="language-ruby"># spec/support/apartment.rb
RSpec.configure do |config|
  config.before(:suite) do
    Apartment::Tenant.drop(&#39;test_tenant&#39;) rescue nil
    Apartment::Tenant.create(&#39;test_tenant&#39;)
  end
  
  config.before(:each) do
    Apartment::Tenant.switch!(&#39;test_tenant&#39;)
  end
  
  config.after(:each) do
    Apartment::Tenant.reset
  end
end

# Test tenant isolation
RSpec.describe Order, type: :model do
  it &#39;isolates data between tenants&#39; do
    tenant1 = Tenant.create!(schema_name: &#39;test1&#39;, subdomain: &#39;test1&#39;)
    tenant2 = Tenant.create!(schema_name: &#39;test2&#39;, subdomain: &#39;test2&#39;)
    
    Apartment::Tenant.switch(&#39;test1&#39;) do
      Order.create!(amount: 100)
    end
    
    Apartment::Tenant.switch(&#39;test2&#39;) do
      expect(Order.count).to eq(0)
    end
  end
end
</code></pre>
<hr>
<h3>Real-World Example</h3>
<pre><code class="language-ruby"># Complete schema-based setup

# 1. Tenant provisioning service
class TenantProvisioningService
  def call(params)
    ActiveRecord::Base.transaction do
      # Create tenant record
      tenant = Tenant.create!(
        name: params[:name],
        schema_name: generate_schema_name(params[:name]),
        subdomain: params[:subdomain],
        plan: params[:plan]
      )
      
      # Create schema and run migrations
      Apartment::Tenant.create(tenant.schema_name)
      
      # Seed initial data
      seed_tenant_data(tenant)
      
      # Send welcome email
      TenantMailer.welcome(tenant).deliver_later
      
      tenant
    end
  end
  
  private
  
  def generate_schema_name(name)
    &quot;tenant_#{name.parameterize.underscore}_#{SecureRandom.hex(4)}&quot;
  end
  
  def seed_tenant_data(tenant)
    Apartment::Tenant.switch(tenant.schema_name) do
      # Create default data
      Setting.create!(key: &#39;company_name&#39;, value: tenant.name)
      Category.create!(name: &#39;General&#39;)
    end
  end
end

# 2. Middleware
class TenantSchemaMiddleware
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request = Rack::Request.new(env)
    
    tenant = if request.subdomain.present?
      Tenant.find_by(subdomain: request.subdomain)
    elsif request.host =~ /^([^.]+)\./
      Tenant.find_by(domain: request.host)
    end
    
    if tenant
      Apartment::Tenant.switch!(tenant.schema_name)
      env[&#39;apartment.tenant&#39;] = tenant
    end
    
    @app.call(env)
  ensure
    Apartment::Tenant.reset
  end
end

# 3. Admin namespace (access all tenants)
class Admin::TenantsController &lt; Admin::BaseController
  def show
    @tenant = Tenant.find(params[:id])
    
    Apartment::Tenant.switch(@tenant.schema_name) do
      @stats = {
        orders: Order.count,
        revenue: Order.sum(:amount),
        customers: Customer.count
      }
    end
  end
  
  def export_data
    @tenant = Tenant.find(params[:id])
    
    ExportTenantDataJob.perform_later(@tenant.id)
    
    redirect_to admin_tenant_path(@tenant), 
      notice: &#39;Export started&#39;
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Separate schemas</strong> per tenant</li>
<li><strong>Same table structure</strong> in each</li>
<li><strong>Apartment gem</strong> simplifies</li>
<li><strong>search_path</strong> switches context</li>
<li><strong>Shared tables</strong> in public schema</li>
<li><strong>Good isolation</strong> from row-based</li>
<li><strong>Migrations</strong> run on all schemas</li>
<li><strong>Backup</strong> per schema possible</li>
<li><strong>10k schema</strong> limit (PostgreSQL)</li>
<li><strong>Better</strong> for compliance needs</li>
</ol>
<hr>
<h2>Question 218-220 Summary (Multi-tenancy)</h2>
<p><strong>Q218: Row-based multi-tenancy</strong></p>
<pre><code class="language-ruby"># Add tenant_id to all tables
# Use default_scope for automatic filtering
# Store in Current.tenant_id
# Prevent tenant_id manipulation in params
# Test tenant isolation thoroughly

class ApplicationRecord &lt; ActiveRecord::Base
  def self.inherited(subclass)
    super
    if subclass.column_names.include?(&#39;tenant_id&#39;)
      subclass.default_scope { where(tenant_id: Current.tenant_id) }
    end
  end
end
</code></pre>
<p><strong>Q219: Shared vs Isolated</strong></p>
<pre><code class="language-ruby"># Shared (Row-based):
# - Single database
# - tenant_id column
# - Cost-effective
# - Data leakage risk

# Isolated (Schema/Database-based):
# - Separate schemas or databases
# - No data leakage
# - More expensive
# - Better compliance

# Choose based on:
# - Number of tenants
# - Isolation requirements
# - Budget
# - Compliance needs
</code></pre>
<p><strong>Q220: Migrate multi-tenant database</strong></p>
<pre><code class="language-ruby"># Schema-based
rake db:migrate
# Runs on all schemas

# Or migrate specific tenant
Apartment::Tenant.switch(&#39;tenant_acme&#39;) do
  ActiveRecord::Tasks::DatabaseTasks.migrate
end

# Zero-downtime migration
# 1. Add column (nullable)
# 2. Backfill data (in batches)
# 3. Make not null
# 4. Deploy code

# Row-based
# Standard Rails migrations
# All tenants migrated together
</code></pre>
<hr>
<h2>Security</h2>
<h2>Question 221: How do you prevent SQL injection in Rails applications?</h2>
<h3>Answer</h3>
<p>Prevent SQL injection by using <strong>ActiveRecord query methods</strong>, <strong>parameterized queries</strong>, <strong>sanitization helpers</strong>, and <strong>never interpolating user input</strong> directly into SQL. Rails protects by default with parameter binding.</p>
<hr>
<h3>1. Use ActiveRecord (Safe by Default)</h3>
<pre><code class="language-ruby"># ✅ SAFE: ActiveRecord uses parameter binding
User.where(email: params[:email])
# SQL: SELECT * FROM users WHERE email = $1
# Parameters: [&quot;user@example.com&quot;]

User.where(status: &#39;active&#39;, role: params[:role])
# SQL: SELECT * FROM users WHERE status = $1 AND role = $2

User.find_by(email: params[:email])
User.where(&quot;created_at &gt; ?&quot;, 30.days.ago)
User.where(&quot;age &gt; ? AND city = ?&quot;, params[:age], params[:city])

# All safe - parameters properly escaped
</code></pre>
<hr>
<h3>2. Dangerous String Interpolation</h3>
<pre><code class="language-ruby"># ❌ DANGEROUS: SQL injection vulnerable
User.where(&quot;email = &#39;#{params[:email]}&#39;&quot;)

# Attack:
# params[:email] = &quot;&#39; OR &#39;1&#39;=&#39;1&quot;
# SQL: SELECT * FROM users WHERE email = &#39;&#39; OR &#39;1&#39;=&#39;1&#39;
# Returns ALL users!

# ❌ DANGEROUS: String concatenation
User.where(&quot;role = &#39;&quot; + params[:role] + &quot;&#39;&quot;)

# Attack:
# params[:role] = &quot;admin&#39;; DROP TABLE users; --&quot;
# SQL: SELECT * FROM users WHERE role = &#39;admin&#39;; DROP TABLE users; --&#39;
# DELETES THE TABLE!
</code></pre>
<hr>
<h3>3. Safe Parameterized Queries</h3>
<pre><code class="language-ruby"># ✅ SAFE: Question mark placeholders
User.where(&quot;email = ?&quot;, params[:email])
User.where(&quot;age &gt; ? AND city = ?&quot;, params[:age], params[:city])

# ✅ SAFE: Named placeholders
User.where(&quot;email = :email AND status = :status&quot;, 
  email: params[:email], 
  status: params[:status]
)

# ✅ SAFE: Hash conditions
User.where(email: params[:email], status: params[:status])

# ✅ SAFE: Array conditions
User.where([&quot;email = ? OR username = ?&quot;, params[:email], params[:username]])
</code></pre>
<hr>
<h3>4. Dynamic Column Names (Special Care)</h3>
<pre><code class="language-ruby"># ❌ DANGEROUS: Column name from user input
User.order(params[:sort_by])

# Attack:
# params[:sort_by] = &quot;name); DROP TABLE users; --&quot;

# ✅ SAFE: Whitelist column names
ALLOWED_SORT_COLUMNS = %w[name email created_at].freeze

def sort_column
  ALLOWED_SORT_COLUMNS.include?(params[:sort_by]) ? params[:sort_by] : &#39;name&#39;
end

User.order(sort_column)

# ✅ SAFE: Use sanitize_sql_for_order
User.order(sanitize_sql_for_order(params[:sort_by]))

# ✅ SAFE: Hash syntax
User.order(params[:sort_by] =&gt; params[:direction])
# Only works if column exists
</code></pre>
<hr>
<h3>5. LIKE Queries</h3>
<pre><code class="language-ruby"># ✅ SAFE: Parameterized LIKE
User.where(&quot;name LIKE ?&quot;, &quot;%#{params[:query]}%&quot;)

# ⚠️  CAUTION: Escape special characters
query = params[:query].gsub(/[%_]/, &#39;\\\\\0&#39;)
User.where(&quot;name LIKE ?&quot;, &quot;%#{query}%&quot;)

# ✅ SAFE: Use sanitize_sql_like
query = ActiveRecord::Base.sanitize_sql_like(params[:query])
User.where(&quot;name LIKE ?&quot;, &quot;%#{query}%&quot;)

# Or in scope
scope :search, -&gt;(term) {
  sanitized = sanitize_sql_like(term)
  where(&quot;name LIKE ?&quot;, &quot;%#{sanitized}%&quot;)
}
</code></pre>
<hr>
<h3>6. Raw SQL Queries</h3>
<pre><code class="language-ruby"># ❌ DANGEROUS: String interpolation in execute
ActiveRecord::Base.connection.execute(
  &quot;SELECT * FROM users WHERE email = &#39;#{params[:email]}&#39;&quot;
)

# ✅ SAFE: Use exec_query with binds
sql = &quot;SELECT * FROM users WHERE email = $1&quot;
ActiveRecord::Base.connection.exec_query(
  sql, 
  &#39;User Load&#39;,
  [[nil, params[:email]]]
)

# ✅ SAFE: Use sanitize_sql_array
sql = ActiveRecord::Base.sanitize_sql_array([
  &quot;SELECT * FROM users WHERE email = ?&quot;, 
  params[:email]
])
ActiveRecord::Base.connection.execute(sql)
</code></pre>
<hr>
<h3>7. find_by_sql</h3>
<pre><code class="language-ruby"># ❌ DANGEROUS
User.find_by_sql(&quot;SELECT * FROM users WHERE role = &#39;#{params[:role]}&#39;&quot;)

# ✅ SAFE: Use placeholders
User.find_by_sql([
  &quot;SELECT * FROM users WHERE role = ?&quot;, 
  params[:role]
])

# ✅ SAFE: Named placeholders
User.find_by_sql([
  &quot;SELECT * FROM users WHERE role = :role AND status = :status&quot;,
  { role: params[:role], status: params[:status] }
])
</code></pre>
<hr>
<h3>8. Arel for Complex Queries</h3>
<pre><code class="language-ruby"># ✅ SAFE: Use Arel for complex queries
users = User.arel_table

User.where(
  users[:email].eq(params[:email])
  .or(users[:username].eq(params[:username]))
)

# Arel automatically parameterizes
# No SQL injection possible
</code></pre>
<hr>
<h3>9. Mass Assignment Protection</h3>
<pre><code class="language-ruby"># Strong parameters (Rails 4+)
class UsersController &lt; ApplicationController
  def create
    @user = User.create(user_params)
  end
  
  private
  
  def user_params
    params.require(:user).permit(:name, :email)
    # Only allowed attributes can be set
    # Prevents: User.create(params[:user])
  end
end

# Model validations
class User &lt; ApplicationRecord
  attr_readonly :role, :admin
  # Prevents modification after creation
end
</code></pre>
<hr>
<h3>10. Testing for SQL Injection</h3>
<pre><code class="language-ruby"># RSpec
RSpec.describe User, type: :model do
  it &#39;prevents SQL injection in search&#39; do
    malicious_input = &quot;&#39;; DROP TABLE users; --&quot;
    
    # Should not raise error or drop table
    expect {
      User.search(malicious_input)
    }.not_to raise_error
    
    # Table should still exist
    expect(User.count).to be &gt;= 0
  end
end

# Brakeman gem (static analysis)
# gem &#39;brakeman&#39;
# bundle exec brakeman
# Detects potential SQL injection vulnerabilities
</code></pre>
<hr>
<h3>Real-World Prevention Checklist</h3>
<pre><code class="language-ruby"># ✅ Use ActiveRecord query methods
User.where(email: params[:email])

# ✅ Use placeholders for raw SQL
User.where(&quot;email = ?&quot;, params[:email])

# ✅ Whitelist dynamic column names
ALLOWED_COLUMNS = %w[name email created_at]
column = ALLOWED_COLUMNS.include?(params[:col]) ? params[:col] : &#39;name&#39;

# ✅ Escape LIKE special characters
query = sanitize_sql_like(params[:query])

# ✅ Use strong parameters
params.require(:user).permit(:name, :email)

# ✅ Never interpolate user input
# ❌ &quot;WHERE x = &#39;#{input}&#39;&quot;
# ✅ &quot;WHERE x = ?&quot;, input

# ✅ Run Brakeman regularly
bundle exec brakeman

# ✅ Code review for SQL queries
# Search codebase for:
# - String interpolation in SQL
# - Raw execute() calls
# - find_by_sql without placeholders

# ✅ Audit logs
# Log all SQL queries in development
# Review for unsafe patterns
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>ActiveRecord</strong> safe by default</li>
<li><strong>Never interpolate</strong> user input</li>
<li><strong>Use placeholders</strong> (? or :name)</li>
<li><strong>Whitelist</strong> column names</li>
<li><strong>Escape</strong> LIKE wildcards</li>
<li><strong>Strong parameters</strong> required</li>
<li><strong>Brakeman</strong> for detection</li>
<li><strong>Test</strong> with malicious input</li>
<li><strong>Code review</strong> SQL queries</li>
<li><strong>Default to AR</strong> not raw SQL</li>
</ol>
<hr>
<h2>Question 222-224 Summary (Security)</h2>
<p><strong>Q222: Prepared statements</strong></p>
<pre><code class="language-ruby"># Prepared statements:
# - Pre-compiled SQL with placeholders
# - Parameters bound at execution
# - Prevents SQL injection
# - Better performance (cached plan)

# Rails uses prepared statements by default
User.where(email: params[:email])
# Prepared: SELECT * FROM users WHERE email = $1
# Bound: [&quot;user@example.com&quot;]

# Connection adapter prepares statement
# Parameters sanitized and bound separately
# No SQL injection possible
</code></pre>
<p><strong>Q223: SQL timing attacks</strong></p>
<pre><code class="language-ruby"># Timing attack: Infer data from query timing
# Example: Login timing reveals valid usernames

# ❌ Vulnerable
user = User.find_by(email: params[:email])
if user &amp;&amp; user.authenticate(params[:password])
  # Login
end
# Fast fail if email not found (timing leak)

# ✅ Secure: Constant-time comparison
user = User.find_by(email: params[:email]) || User.new
user.authenticate(params[:password])
# Always runs password check (same time)

# Use secure_compare for strings
ActiveSupport::SecurityUtils.secure_compare(
  user.password_digest,
  calculated_digest
)
</code></pre>
<p><strong>Q224: Audit data changes</strong></p>
<pre><code class="language-ruby"># 1. paper_trail gem
gem &#39;paper_trail&#39;

class User &lt; ApplicationRecord
  has_paper_trail
end

user.versions  # All versions
user.paper_trail.previous_version  # Previous state

# 2. audited gem
gem &#39;audited&#39;

class Order &lt; ApplicationRecord
  audited
end

order.audits  # All changes
order.audits.last.audited_changes  # What changed

# 3. Custom audit log
class AuditLog &lt; ApplicationRecord
  # user_id, action, record_type, record_id, changes, created_at
end

class ApplicationRecord &lt; ActiveRecord::Base
  after_create :log_create
  after_update :log_update
  after_destroy :log_destroy
  
  private
  
  def log_create
    AuditLog.create!(
      user: Current.user,
      action: &#39;create&#39;,
      record: self
    )
  end
end
</code></pre>
<hr>
<h2>Backup and Recovery</h2>
<h2>Question 225-229: Backup &amp; Recovery</h2>
<h3>Question 225: Database Snapshots</h3>
<pre><code class="language-sql">-- PostgreSQL: Create snapshot (filesystem)
-- Requires filesystem support (ZFS, LVM)

-- pg_dump: Logical backup
pg_dump myapp_production &gt; backup.sql

-- pg_basebackup: Physical backup
pg_basebackup -D /backup/base -F tar -z -P
</code></pre>
<h3>Question 226: Point-in-Time Recovery (PITR)</h3>
<pre><code class="language-sql">-- 1. Enable WAL archiving
-- postgresql.conf
wal_level = replica
archive_mode = on
archive_command = &#39;cp %p /archive/%f&#39;

-- 2. Take base backup
pg_basebackup -D /backup/base

-- 3. Restore to specific time
-- recovery.conf
restore_command = &#39;cp /archive/%f %p&#39;
recovery_target_time = &#39;2024-01-15 14:30:00&#39;

-- 4. Start PostgreSQL
# Recovers to specified time
</code></pre>
<h3>Question 227: pg_dump and pg_restore</h3>
<pre><code class="language-bash"># Dump entire database
pg_dump myapp_production &gt; backup.sql

# Dump with compression
pg_dump -Fc myapp_production &gt; backup.dump

# Dump specific table
pg_dump -t users myapp_production &gt; users.sql

# Dump schema only
pg_dump --schema-only myapp_production &gt; schema.sql

# Restore plain SQL
psql myapp_production &lt; backup.sql

# Restore custom format
pg_restore -d myapp_production backup.dump

# Restore with clean
pg_restore -d myapp_production -c backup.dump

# Parallel restore (faster)
pg_restore -d myapp_production -j 4 backup.dump
</code></pre>
<h3>Question 228: Disaster Recovery</h3>
<pre><code class="language-ruby"># 1. Regular backups (automated)
# 2. Offsite storage (S3, GCS)
# 3. Test restores regularly
# 4. Monitor backup success
# 5. Document recovery procedures
# 6. Maintain standby servers
# 7. Practice DR drills

# Recovery Time Objective (RTO): 1 hour
# Recovery Point Objective (RPO): 15 minutes

# Hot standby:
# - Streaming replication
# - Automatic failover
# - Zero data loss

# Cold standby:
# - Periodic backups
# - Manual restore
# - Some data loss
</code></pre>
<h3>Question 229: Automate Backups</h3>
<pre><code class="language-ruby"># 1. Whenever gem
# config/schedule.rb
every 1.day, at: &#39;2:00 am&#39; do
  rake &#39;db:backup&#39;
end

# 2. Backup script
# lib/tasks/backup.rake
namespace :db do
  desc &#39;Backup database&#39;
  task backup: :environment do
    timestamp = Time.now.strftime(&#39;%Y%m%d_%H%M%S&#39;)
    filename = &quot;backup_#{timestamp}.dump&quot;
    
    system(&quot;pg_dump -Fc #{db_config[&#39;database&#39;]} &gt; /tmp/#{filename}&quot;)
    
    # Upload to S3
    s3 = Aws::S3::Resource.new
    obj = s3.bucket(&#39;backups&#39;).object(&quot;postgres/#{filename}&quot;)
    obj.upload_file(&quot;/tmp/#{filename}&quot;)
    
    # Delete old backups (keep 30 days)
    delete_old_backups(30)
    
    # Notify success
    SlackNotifier.notify(&quot;Backup completed: #{filename}&quot;)
  end
end

# 3. Monitor backup jobs
# 4. Alert on failures
# 5. Test restores monthly
</code></pre>
<h1>API Development Interview Questions</h1>
<h2>RESTful APIs</h2>
<h2>Question 230: What are the key principles of RESTful API design?</h2>
<h3>Answer</h3>
<p><strong>RESTful API principles:</strong> Use <strong>HTTP methods</strong> correctly (GET, POST, PUT, DELETE), <strong>stateless communication</strong>, <strong>resource-based URLs</strong>, <strong>JSON responses</strong>, <strong>proper status codes</strong>, and <strong>consistent naming</strong>. REST = Representational State Transfer.</p>
<hr>
<h3>1. Resource-Based URLs</h3>
<pre><code class="language-ruby"># ✅ GOOD: Noun-based resources
GET    /api/v1/users          # List users
GET    /api/v1/users/123      # Show user
POST   /api/v1/users          # Create user
PUT    /api/v1/users/123      # Update user
DELETE /api/v1/users/123      # Delete user

# Nested resources
GET    /api/v1/users/123/orders       # User&#39;s orders
POST   /api/v1/users/123/orders       # Create order for user

# ❌ BAD: Verb-based URLs
GET    /api/v1/getUser/123
POST   /api/v1/createUser
POST   /api/v1/deleteUser/123
</code></pre>
<hr>
<h3>2. HTTP Methods (Verbs)</h3>
<pre><code class="language-ruby"># GET: Retrieve resource(s)
GET /api/v1/products
GET /api/v1/products/123
# Safe, idempotent, cacheable

# POST: Create new resource
POST /api/v1/products
# Not idempotent, creates new resource each time

# PUT: Update entire resource (replace)
PUT /api/v1/products/123
# Idempotent, replaces entire resource

# PATCH: Partial update
PATCH /api/v1/products/123
# Idempotent, updates specific fields

# DELETE: Remove resource
DELETE /api/v1/products/123
# Idempotent

# HEAD: Get headers only (no body)
HEAD /api/v1/products
# Like GET but no response body

# OPTIONS: Get allowed methods
OPTIONS /api/v1/products
# Returns allowed HTTP methods
</code></pre>
<hr>
<h3>3. HTTP Status Codes</h3>
<pre><code class="language-ruby"># Success codes
200 OK              # Successful GET, PUT, PATCH, DELETE
201 Created         # Successful POST
204 No Content      # Successful DELETE (no body)

# Redirection codes
301 Moved Permanently
302 Found (temporary redirect)
304 Not Modified    # Cached resource still valid

# Client error codes
400 Bad Request     # Invalid syntax
401 Unauthorized    # Missing/invalid authentication
403 Forbidden       # Authenticated but not authorized
404 Not Found       # Resource doesn&#39;t exist
422 Unprocessable Entity  # Validation errors

# Server error codes
500 Internal Server Error
502 Bad Gateway
503 Service Unavailable
504 Gateway Timeout

# Rails API example
class Api::V1::ProductsController &lt; ApiController
  def create
    product = Product.new(product_params)
    
    if product.save
      render json: product, status: :created  # 201
    else
      render json: { errors: product.errors }, status: :unprocessable_entity  # 422
    end
  end
  
  def update
    product = Product.find(params[:id])
    
    if product.update(product_params)
      render json: product, status: :ok  # 200
    else
      render json: { errors: product.errors }, status: :unprocessable_entity  # 422
    end
  rescue ActiveRecord::RecordNotFound
    render json: { error: &#39;Not found&#39; }, status: :not_found  # 404
  end
  
  def destroy
    product = Product.find(params[:id])
    product.destroy
    head :no_content  # 204
  end
end
</code></pre>
<hr>
<h3>4. Stateless Communication</h3>
<pre><code class="language-ruby"># ✅ Each request contains all necessary information
# No server-side session state

# Request includes authentication token
GET /api/v1/users/123
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Server doesn&#39;t store session
# Every request is independent
# Enables horizontal scaling

# ❌ BAD: Stateful (session-based)
# POST /api/v1/login
# Server creates session, stores in memory/database
# Subsequent requests use session cookie
# Harder to scale
</code></pre>
<hr>
<h3>5. JSON Response Format</h3>
<pre><code class="language-ruby"># Consistent JSON structure
class Api::V1::ProductsController &lt; ApiController
  def index
    products = Product.all
    
    render json: {
      data: products.map { |p| product_json(p) },
      meta: {
        total: products.count,
        page: params[:page] || 1,
        per_page: 20
      }
    }
  end
  
  def show
    product = Product.find(params[:id])
    
    render json: {
      data: product_json(product)
    }
  end
  
  private
  
  def product_json(product)
    {
      id: product.id,
      name: product.name,
      price: product.price,
      created_at: product.created_at.iso8601,
      links: {
        self: api_v1_product_url(product)
      }
    }
  end
end

# Error format
{
  &quot;error&quot;: {
    &quot;message&quot;: &quot;Validation failed&quot;,
    &quot;code&quot;: &quot;validation_error&quot;,
    &quot;details&quot;: {
      &quot;name&quot;: [&quot;can&#39;t be blank&quot;],
      &quot;price&quot;: [&quot;must be greater than 0&quot;]
    }
  }
}
</code></pre>
<hr>
<h3>6. Versioning</h3>
<pre><code class="language-ruby"># URL versioning (most common)
GET /api/v1/products
GET /api/v2/products

# config/routes.rb
namespace :api do
  namespace :v1 do
    resources :products
  end
  
  namespace :v2 do
    resources :products
  end
end

# Header versioning
GET /api/products
Accept: application/vnd.myapp.v1+json

# Query parameter versioning
GET /api/products?version=1
</code></pre>
<hr>
<h3>7. Pagination</h3>
<pre><code class="language-ruby"># Limit results, include pagination metadata
class Api::V1::ProductsController &lt; ApiController
  def index
    page = params[:page] || 1
    per_page = params[:per_page] || 20
    
    products = Product.page(page).per(per_page)
    
    render json: {
      data: products,
      meta: {
        current_page: products.current_page,
        total_pages: products.total_pages,
        total_count: products.total_count,
        per_page: per_page
      },
      links: {
        self: api_v1_products_url(page: page),
        first: api_v1_products_url(page: 1),
        last: api_v1_products_url(page: products.total_pages),
        prev: page &gt; 1 ? api_v1_products_url(page: page - 1) : nil,
        next: page &lt; products.total_pages ? api_v1_products_url(page: page + 1) : nil
      }
    }
  end
end
</code></pre>
<hr>
<h3>8. Filtering, Sorting, Searching</h3>
<pre><code class="language-ruby"># Query parameters for filtering
GET /api/v1/products?category=electronics&amp;min_price=100&amp;max_price=500
GET /api/v1/products?sort=price&amp;order=desc
GET /api/v1/products?search=laptop

class Api::V1::ProductsController &lt; ApiController
  def index
    products = Product.all
    
    # Filtering
    products = products.where(category: params[:category]) if params[:category]
    products = products.where(&#39;price &gt;= ?&#39;, params[:min_price]) if params[:min_price]
    products = products.where(&#39;price &lt;= ?&#39;, params[:max_price]) if params[:max_price]
    
    # Searching
    products = products.where(&#39;name ILIKE ?&#39;, &quot;%#{params[:search]}%&quot;) if params[:search]
    
    # Sorting
    if params[:sort]
      order = params[:order] == &#39;desc&#39; ? :desc : :asc
      products = products.order(params[:sort] =&gt; order)
    end
    
    render json: products
  end
end
</code></pre>
<hr>
<h3>9. HATEOAS (Hypermedia)</h3>
<pre><code class="language-ruby"># Include links to related resources
{
  &quot;id&quot;: 123,
  &quot;name&quot;: &quot;Laptop&quot;,
  &quot;price&quot;: 999,
  &quot;links&quot;: {
    &quot;self&quot;: &quot;/api/v1/products/123&quot;,
    &quot;category&quot;: &quot;/api/v1/categories/5&quot;,
    &quot;reviews&quot;: &quot;/api/v1/products/123/reviews&quot;,
    &quot;related&quot;: &quot;/api/v1/products?category=5&quot;
  }
}
</code></pre>
<hr>
<h3>10. Documentation</h3>
<pre><code class="language-ruby"># Use Swagger/OpenAPI
# Gemfile
gem &#39;rswag&#39;

# Generate documentation
# swagger_helper.rb
RSwag::Api.configure do |c|
  c.swagger_docs = {
    &#39;v1/swagger.json&#39; =&gt; {
      openapi: &#39;3.0.1&#39;,
      info: {
        title: &#39;API V1&#39;,
        version: &#39;v1&#39;
      },
      paths: {},
      servers: [
        {
          url: &#39;https://api.example.com&#39;,
          variables: {
            defaultHost: {
              default: &#39;api.example.com&#39;
            }
          }
        }
      ]
    }
  }
end

# Access at /api-docs
</code></pre>
<hr>
<h3>Complete RESTful API Example</h3>
<pre><code class="language-ruby"># routes.rb
namespace :api do
  namespace :v1 do
    resources :products do
      resources :reviews, only: [:index, :create]
    end
  end
end

# app/controllers/api/v1/api_controller.rb
module Api
  module V1
    class ApiController &lt; ActionController::API
      rescue_from ActiveRecord::RecordNotFound, with: :not_found
      rescue_from ActiveRecord::RecordInvalid, with: :unprocessable_entity
      
      private
      
      def not_found
        render json: { error: &#39;Resource not found&#39; }, status: :not_found
      end
      
      def unprocessable_entity(exception)
        render json: { 
          error: &#39;Validation failed&#39;,
          details: exception.record.errors 
        }, status: :unprocessable_entity
      end
    end
  end
end

# app/controllers/api/v1/products_controller.rb
module Api
  module V1
    class ProductsController &lt; ApiController
      before_action :set_product, only: [:show, :update, :destroy]
      
      def index
        products = Product.page(params[:page]).per(params[:per_page] || 20)
        
        render json: {
          data: products.map { |p| ProductSerializer.new(p).as_json },
          meta: pagination_meta(products)
        }
      end
      
      def show
        render json: { data: ProductSerializer.new(@product).as_json }
      end
      
      def create
        product = Product.create!(product_params)
        
        render json: { data: ProductSerializer.new(product).as_json }, 
               status: :created,
               location: api_v1_product_url(product)
      end
      
      def update
        @product.update!(product_params)
        
        render json: { data: ProductSerializer.new(@product).as_json }
      end
      
      def destroy
        @product.destroy
        head :no_content
      end
      
      private
      
      def set_product
        @product = Product.find(params[:id])
      end
      
      def product_params
        params.require(:product).permit(:name, :description, :price, :category)
      end
      
      def pagination_meta(collection)
        {
          current_page: collection.current_page,
          total_pages: collection.total_pages,
          total_count: collection.total_count
        }
      end
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Resources</strong> not actions in URLs</li>
<li><strong>HTTP methods</strong> for operations</li>
<li><strong>Status codes</strong> indicate results</li>
<li><strong>Stateless</strong> communication</li>
<li><strong>JSON</strong> standard format</li>
<li><strong>Versioning</strong> for evolution</li>
<li><strong>Pagination</strong> for large datasets</li>
<li><strong>Filtering</strong> with query params</li>
<li><strong>HATEOAS</strong> for discoverability</li>
<li><strong>Documentation</strong> essential</li>
</ol>
<hr>
<h2>Question 231: What are RESTful constraints, and how do you enforce them?</h2>
<h3>Answer</h3>
<p><strong>RESTful constraints</strong> are six architectural principles: <strong>Client-Server</strong>, <strong>Stateless</strong>, <strong>Cacheable</strong>, <strong>Uniform Interface</strong>, <strong>Layered System</strong>, and <strong>Code-On-Demand</strong> (optional). Enforce through proper API design, HTTP standards, and documentation.</p>
<hr>
<h3>1. Client-Server Separation</h3>
<pre><code class="language-ruby"># Constraint: Separate concerns
# Client: UI, user interaction
# Server: Data storage, business logic

# ✅ Enforcement:
# - API returns data only (JSON)
# - No HTML templates in API controllers
# - Client handles presentation

class Api::V1::ProductsController &lt; ApiController
  def show
    product = Product.find(params[:id])
    render json: product  # Data only, no HTML
  end
end

# Client (React, Vue, mobile app) handles presentation
# Server doesn&#39;t know/care about UI
</code></pre>
<hr>
<h3>2. Stateless</h3>
<pre><code class="language-ruby"># Constraint: Each request contains all necessary information
# No server-side session state

# ✅ Enforcement:
# - JWT tokens (not sessions)
# - Include authentication in every request
# - No cookies for authentication

class ApiController &lt; ActionController::API
  before_action :authenticate_user
  
  private
  
  def authenticate_user
    token = request.headers[&#39;Authorization&#39;]&amp;.split(&#39; &#39;)&amp;.last
    @current_user = decode_jwt(token)
  rescue
    render json: { error: &#39;Unauthorized&#39; }, status: :unauthorized
  end
  
  def decode_jwt(token)
    payload = JWT.decode(token, Rails.application.secret_key_base)[0]
    User.find(payload[&#39;user_id&#39;])
  end
end

# Every request independent
# Can scale horizontally
</code></pre>
<hr>
<h3>3. Cacheable</h3>
<pre><code class="language-ruby"># Constraint: Responses must define cacheability

# ✅ Enforcement:
# - Use Cache-Control headers
# - ETag for conditional requests
# - Last-Modified headers

class Api::V1::ProductsController &lt; ApiController
  def index
    products = Product.all
    
    # Set cache headers
    expires_in 5.minutes, public: true
    
    render json: products
    # Response includes: Cache-Control: public, max-age=300
  end
  
  def show
    product = Product.find(params[:id])
    
    # Conditional GET with ETag
    if stale?(product)
      render json: product
    end
    # Returns 304 Not Modified if ETag matches
  end
end

# Client can cache responses
# Reduces server load
</code></pre>
<hr>
<h3>4. Uniform Interface</h3>
<p><strong>Four sub-constraints:</strong></p>
<p><strong>a) Resource Identification:</strong></p>
<pre><code class="language-ruby"># Each resource has unique URI
GET /api/v1/products/123
GET /api/v1/users/456

# ✅ Enforcement: RESTful routes
resources :products  # Generates standard routes
</code></pre>
<p><strong>b) Manipulation through Representations:</strong></p>
<pre><code class="language-ruby"># Client manipulates resources via representations (JSON)
PUT /api/v1/products/123
Content-Type: application/json

{
  &quot;name&quot;: &quot;Updated Name&quot;,
  &quot;price&quot;: 999
}

# ✅ Enforcement: Accept JSON input
def update
  product = Product.find(params[:id])
  product.update!(product_params)
  render json: product
end
</code></pre>
<p><strong>c) Self-Descriptive Messages:</strong></p>
<pre><code class="language-ruby"># Each message includes enough info to process it

# Request
GET /api/v1/products/123
Accept: application/json
Authorization: Bearer token123

# Response
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=3600

{
  &quot;id&quot;: 123,
  &quot;name&quot;: &quot;Laptop&quot;
}

# ✅ Enforcement: Proper headers
response.headers[&#39;Content-Type&#39;] = &#39;application/json&#39;
response.headers[&#39;Cache-Control&#39;] = &#39;max-age=3600&#39;
</code></pre>
<p><strong>d) HATEOAS:</strong></p>
<pre><code class="language-ruby"># Hypermedia as the Engine of Application State
# Include links to related resources

def show
  product = Product.find(params[:id])
  
  render json: {
    data: product,
    links: {
      self: api_v1_product_url(product),
      category: api_v1_category_url(product.category),
      reviews: api_v1_product_reviews_url(product),
      edit: api_v1_product_url(product),
      delete: api_v1_product_url(product)
    }
  }
end

# Client discovers actions via links
</code></pre>
<hr>
<h3>5. Layered System</h3>
<pre><code class="language-ruby"># Constraint: Client can&#39;t tell if connected to end server

# ✅ Enforcement:
# - Use load balancers
# - API gateways
# - Reverse proxies
# - CDNs

# Architecture:
# Client → CDN → Load Balancer → API Gateway → Rails App → Database

# Rails doesn&#39;t expose internal architecture
# Client sees consistent API endpoint
# Can add/remove layers without affecting client
</code></pre>
<hr>
<h3>6. Code-On-Demand (Optional)</h3>
<pre><code class="language-ruby"># Constraint: Server can send executable code to client

# Rarely used in APIs
# Examples:
# - JavaScript widgets
# - Applets

# Usually not implemented in RESTful APIs
</code></pre>
<hr>
<h3>Enforcement Checklist</h3>
<pre><code class="language-ruby"># 1. Client-Server
✅ Separate API from client
✅ Return JSON, not HTML
✅ No views in API controllers

# 2. Stateless
✅ JWT authentication
✅ No server-side sessions
✅ Every request self-contained

# 3. Cacheable
✅ Cache-Control headers
✅ ETag support
✅ expires_in directives

# 4. Uniform Interface
✅ RESTful URLs
✅ Standard HTTP methods
✅ Consistent JSON format
✅ HATEOAS links

# 5. Layered System
✅ Load balancers
✅ API gateways
✅ CDN for static content

# 6. Code-On-Demand
⚠️  Optional (usually not needed)
</code></pre>
<hr>
<h3>Testing Constraints</h3>
<pre><code class="language-ruby"># RSpec
RSpec.describe &#39;API Constraints&#39;, type: :request do
  describe &#39;Stateless&#39; do
    it &#39;requires authentication token in each request&#39; do
      get &#39;/api/v1/products&#39;
      expect(response).to have_http_status(:unauthorized)
      
      get &#39;/api/v1/products&#39;, headers: { &#39;Authorization&#39; =&gt; &quot;Bearer #{token}&quot; }
      expect(response).to have_http_status(:ok)
    end
  end
  
  describe &#39;Cacheable&#39; do
    it &#39;includes cache headers&#39; do
      get &#39;/api/v1/products&#39;
      expect(response.headers[&#39;Cache-Control&#39;]).to include(&#39;max-age&#39;)
    end
    
    it &#39;returns 304 when ETag matches&#39; do
      product = create(:product)
      
      get &quot;/api/v1/products/#{product.id}&quot;
      etag = response.headers[&#39;ETag&#39;]
      
      get &quot;/api/v1/products/#{product.id}&quot;, headers: { &#39;If-None-Match&#39; =&gt; etag }
      expect(response).to have_http_status(:not_modified)
    end
  end
  
  describe &#39;Uniform Interface&#39; do
    it &#39;returns consistent JSON structure&#39; do
      get &#39;/api/v1/products&#39;
      json = JSON.parse(response.body)
      
      expect(json).to have_key(&#39;data&#39;)
      expect(json).to have_key(&#39;meta&#39;)
      expect(json).to have_key(&#39;links&#39;)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Six constraints</strong> define REST</li>
<li><strong>Client-Server</strong> separation</li>
<li><strong>Stateless</strong> communication</li>
<li><strong>Cacheable</strong> responses</li>
<li><strong>Uniform Interface</strong> (4 sub-constraints)</li>
<li><strong>Layered System</strong> architecture</li>
<li><strong>Code-On-Demand</strong> optional</li>
<li><strong>Enforce</strong> through design</li>
<li><strong>Test</strong> constraint compliance</li>
<li><strong>Document</strong> API behavior</li>
</ol>
<hr>
<h2>Question 232-234 Summary (RESTful APIs)</h2>
<p><strong>Q232: HATEOAS Implementation</strong></p>
<pre><code class="language-ruby"># Hypermedia as the Engine of Application State
# Include links to related resources and actions

class ProductSerializer
  def initialize(product)
    @product = product
  end
  
  def as_json
    {
      id: @product.id,
      name: @product.name,
      price: @product.price,
      _links: {
        self: { href: &quot;/api/v1/products/#{@product.id}&quot; },
        category: { href: &quot;/api/v1/categories/#{@product.category_id}&quot; },
        reviews: { href: &quot;/api/v1/products/#{@product.id}/reviews&quot; },
        update: { 
          href: &quot;/api/v1/products/#{@product.id}&quot;,
          method: &quot;PUT&quot;
        },
        delete: {
          href: &quot;/api/v1/products/#{@product.id}&quot;,
          method: &quot;DELETE&quot;
        }
      }
    }
  end
end

# Client discovers available actions from links
</code></pre>
<p><strong>Q233: API-Only Rails Application</strong></p>
<pre><code class="language-bash"># Create API-only app
rails new myapi --api

# Generates:
# - No views, helpers, assets
# - ApiController inherits from ActionController::API
# - Middleware optimized for API
# - No session middleware

# app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::API
  # Lightweight base controller
end

# Add CORS
gem &#39;rack-cors&#39;

# config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins &#39;*&#39;
    resource &#39;*&#39;, headers: :any, methods: [:get, :post, :put, :patch, :delete]
  end
end
</code></pre>
<p><strong>Q234: Data Serialization</strong></p>
<pre><code class="language-ruby"># 1. ActiveModel::Serializers
gem &#39;active_model_serializers&#39;

class ProductSerializer &lt; ActiveModel::Serializer
  attributes :id, :name, :price
  has_many :reviews
  belongs_to :category
  
  def price
    &quot;$#{object.price}&quot;
  end
end

render json: products, each_serializer: ProductSerializer

# 2. JBuilder
# app/views/api/v1/products/index.json.jbuilder
json.array! @products do |product|
  json.id product.id
  json.name product.name
  json.price product.price
  json.category do
    json.id product.category.id
    json.name product.category.name
  end
end

# 3. Fast JSON API (Netflix)
gem &#39;fast_jsonapi&#39;

class ProductSerializer
  include JSONAPI::Serializer
  
  attributes :name, :price
  has_many :reviews
  belongs_to :category
end

ProductSerializer.new(products).serializable_hash
</code></pre>
<hr>
<h2>Authentication and Authorization</h2>
<h2>Question 235: What is the difference between authentication and authorization?</h2>
<h3>Answer</h3>
<p><strong>Authentication</strong> verifies <strong>who you are</strong> (identity). <strong>Authorization</strong> determines <strong>what you can do</strong> (permissions). Authentication = login, Authorization = access control.</p>
<hr>
<h3>Authentication (Who are you?)</h3>
<pre><code class="language-ruby"># Verifies user identity
# Methods:
# - Username/password
# - JWT tokens
# - OAuth
# - API keys

class AuthenticationController &lt; ApiController
  def login
    user = User.find_by(email: params[:email])
    
    if user&amp;.authenticate(params[:password])
      token = generate_jwt(user)
      render json: { token: token }, status: :ok
    else
      render json: { error: &#39;Invalid credentials&#39; }, status: :unauthorized
    end
  end
  
  private
  
  def generate_jwt(user)
    JWT.encode(
      { user_id: user.id, exp: 24.hours.from_now.to_i },
      Rails.application.secret_key_base
    )
  end
end

# Authentication middleware
class ApiController &lt; ActionController::API
  before_action :authenticate_user
  
  private
  
  def authenticate_user
    token = request.headers[&#39;Authorization&#39;]&amp;.split(&#39; &#39;)&amp;.last
    @current_user = decode_jwt(token)
  rescue
    render json: { error: &#39;Unauthorized&#39; }, status: :unauthorized
  end
  
  def decode_jwt(token)
    payload = JWT.decode(token, Rails.application.secret_key_base)[0]
    User.find(payload[&#39;user_id&#39;])
  end
  
  attr_reader :current_user
end
</code></pre>
<hr>
<h3>Authorization (What can you do?)</h3>
<pre><code class="language-ruby"># Controls access to resources
# Methods:
# - Role-based (RBAC)
# - Permission-based
# - Policy-based (Pundit)

# 1. Simple role-based
class User &lt; ApplicationRecord
  enum role: { user: 0, admin: 1, moderator: 2 }
  
  def can_edit?(resource)
    admin? || resource.user_id == id
  end
end

class ProductsController &lt; ApiController
  def update
    product = Product.find(params[:id])
    
    unless current_user.can_edit?(product)
      return render json: { error: &#39;Forbidden&#39; }, status: :forbidden
    end
    
    product.update!(product_params)
    render json: product
  end
end

# 2. Pundit gem (policy-based)
gem &#39;pundit&#39;

class ProductPolicy
  attr_reader :user, :product
  
  def initialize(user, product)
    @user = user
    @product = product
  end
  
  def update?
    user.admin? || product.user_id == user.id
  end
  
  def destroy?
    user.admin?
  end
end

class ProductsController &lt; ApiController
  include Pundit::Authorization
  
  def update
    product = Product.find(params[:id])
    authorize product  # Calls ProductPolicy#update?
    
    product.update!(product_params)
    render json: product
  rescue Pundit::NotAuthorizedError
    render json: { error: &#39;Forbidden&#39; }, status: :forbidden
  end
end

# 3. CanCanCan gem (ability-based)
gem &#39;cancancan&#39;

class Ability
  include CanCan::Ability
  
  def initialize(user)
    user ||= User.new  # Guest user
    
    if user.admin?
      can :manage, :all
    else
      can :read, Product
      can :update, Product, user_id: user.id
      can :destroy, Product, user_id: user.id
    end
  end
end

class ProductsController &lt; ApiController
  load_and_authorize_resource
  
  def update
    # Authorization automatic
    @product.update!(product_params)
    render json: @product
  end
end
</code></pre>
<hr>
<h3>Combined Example</h3>
<pre><code class="language-ruby"># Complete authentication + authorization flow

# 1. Authentication (login)
POST /api/v1/auth/login
{
  &quot;email&quot;: &quot;user@example.com&quot;,
  &quot;password&quot;: &quot;password123&quot;
}

# Response
{
  &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;,
  &quot;user&quot;: {
    &quot;id&quot;: 123,
    &quot;email&quot;: &quot;user@example.com&quot;,
    &quot;role&quot;: &quot;user&quot;
  }
}

# 2. Authenticated request
GET /api/v1/products/456
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Authentication: Verify token, identify user
# Authorization: Check if user can access product 456

# 3. Update request (needs authorization)
PUT /api/v1/products/456
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
{
  &quot;name&quot;: &quot;Updated Name&quot;
}

# Authentication: Verify token → user_id: 123
# Authorization: Check if user 123 can update product 456
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Authentication</th>
<th>Authorization</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Purpose</strong></td>
<td>Verify identity</td>
<td>Control access</td>
</tr>
<tr>
<td><strong>Question</strong></td>
<td>Who are you?</td>
<td>What can you do?</td>
</tr>
<tr>
<td><strong>Methods</strong></td>
<td>JWT, OAuth, API keys</td>
<td>RBAC, Policies, ACL</td>
</tr>
<tr>
<td><strong>Happens</strong></td>
<td>First (login)</td>
<td>After authentication</td>
</tr>
<tr>
<td><strong>Example</strong></td>
<td>Login with email/password</td>
<td>Admin can delete posts</td>
</tr>
<tr>
<td><strong>Status Code</strong></td>
<td>401 Unauthorized</td>
<td>403 Forbidden</td>
</tr>
<tr>
<td><strong>Gems</strong></td>
<td>Devise, JWT</td>
<td>Pundit, CanCanCan</td>
</tr>
</tbody></table>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Authentication</strong> = identity verification</li>
<li><strong>Authorization</strong> = permission checking</li>
<li><strong>401</strong> = authentication failed</li>
<li><strong>403</strong> = authorization denied</li>
<li><strong>Authentication</strong> comes first</li>
<li><strong>Authorization</strong> checks permissions</li>
<li><strong>Separate concerns</strong> in code</li>
<li><strong>Both required</strong> for secure APIs</li>
<li><strong>Different gems</strong> for each</li>
<li><strong>Test both</strong> independently</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 236: How do you implement authentication in a Rails API (Devise, JWT)?</h2>
<h3>Answer</h3>
<p>Implement API authentication using <strong>JWT (JSON Web Tokens)</strong> for stateless auth, or <strong>Devise with token authentication</strong>. JWT preferred for APIs due to statelessness and scalability.</p>
<hr>
<h3>JWT Authentication (Recommended)</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;jwt&#39;
gem &#39;bcrypt&#39;  # For password hashing

# app/models/user.rb
class User &lt; ApplicationRecord
  has_secure_password
  
  validates :email, presence: true, uniqueness: true
  validates :password, length: { minimum: 6 }, if: :password_required?
  
  def generate_jwt
    JWT.encode(
      {
        user_id: id,
        exp: 24.hours.from_now.to_i
      },
      Rails.application.credentials.secret_key_base,
      &#39;HS256&#39;
    )
  end
  
  def self.from_token(token)
    decoded = JWT.decode(
      token,
      Rails.application.credentials.secret_key_base,
      true,
      { algorithm: &#39;HS256&#39; }
    )
    find(decoded[0][&#39;user_id&#39;])
  rescue JWT::DecodeError, ActiveRecord::RecordNotFound
    nil
  end
end

# app/controllers/api/v1/auth_controller.rb
module Api
  module V1
    class AuthController &lt; ApiController
      skip_before_action :authenticate_user, only: [:login, :signup]
      
      def signup
        user = User.create!(user_params)
        token = user.generate_jwt
        
        render json: {
          user: UserSerializer.new(user).as_json,
          token: token
        }, status: :created
      end
      
      def login
        user = User.find_by(email: params[:email])
        
        if user&amp;.authenticate(params[:password])
          token = user.generate_jwt
          
          render json: {
            user: UserSerializer.new(user).as_json,
            token: token
          }
        else
          render json: { error: &#39;Invalid email or password&#39; }, 
                 status: :unauthorized
        end
      end
      
      def me
        render json: { user: UserSerializer.new(current_user).as_json }
      end
      
      private
      
      def user_params
        params.require(:user).permit(:email, :password, :password_confirmation, :name)
      end
    end
  end
end

# app/controllers/api/v1/api_controller.rb
module Api
  module V1
    class ApiController &lt; ActionController::API
      before_action :authenticate_user
      
      attr_reader :current_user
      
      private
      
      def authenticate_user
        token = extract_token
        @current_user = User.from_token(token)
        
        render json: { error: &#39;Unauthorized&#39; }, status: :unauthorized unless @current_user
      end
      
      def extract_token
        request.headers[&#39;Authorization&#39;]&amp;.split(&#39; &#39;)&amp;.last
      end
    end
  end
end

# config/routes.rb
namespace :api do
  namespace :v1 do
    post &#39;auth/signup&#39;, to: &#39;auth#signup&#39;
    post &#39;auth/login&#39;, to: &#39;auth#login&#39;
    get &#39;auth/me&#39;, to: &#39;auth#me&#39;
    
    resources :products
  end
end
</code></pre>
<hr>
<h3>Usage</h3>
<pre><code class="language-bash"># Sign up
POST /api/v1/auth/signup
Content-Type: application/json

{
  &quot;user&quot;: {
    &quot;email&quot;: &quot;user@example.com&quot;,
    &quot;password&quot;: &quot;password123&quot;,
    &quot;name&quot;: &quot;John Doe&quot;
  }
}

# Response
{
  &quot;user&quot;: {
    &quot;id&quot;: 1,
    &quot;email&quot;: &quot;user@example.com&quot;,
    &quot;name&quot;: &quot;John Doe&quot;
  },
  &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;
}

# Login
POST /api/v1/auth/login
Content-Type: application/json

{
  &quot;email&quot;: &quot;user@example.com&quot;,
  &quot;password&quot;: &quot;password123&quot;
}

# Authenticated request
GET /api/v1/products
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
</code></pre>
<hr>
<h3>Devise with Token Authentication</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;devise&#39;
gem &#39;devise-jwt&#39;

# Generate Devise
rails generate devise:install
rails generate devise User

# app/models/user.rb
class User &lt; ApplicationRecord
  devise :database_authenticatable, :registerable,
         :jwt_authenticatable, jwt_revocation_strategy: JwtDenylist
end

# Create JwtDenylist model
rails g model jwt_denylist jti:string:index exp:datetime

# app/models/jwt_denylist.rb
class JwtDenylist &lt; ApplicationRecord
  include Devise::JWT::RevocationStrategies::Denylist
  
  self.table_name = &#39;jwt_denylists&#39;
end

# config/initializers/devise.rb
Devise.setup do |config|
  config.jwt do |jwt|
    jwt.secret = Rails.application.credentials.secret_key_base
    jwt.dispatch_requests = [
      [&#39;POST&#39;, %r{^/api/v1/auth/login$}]
    ]
    jwt.revocation_requests = [
      [&#39;DELETE&#39;, %r{^/api/v1/auth/logout$}]
    ]
    jwt.expiration_time = 24.hours.to_i
  end
end

# app/controllers/api/v1/auth/sessions_controller.rb
module Api
  module V1
    module Auth
      class SessionsController &lt; Devise::SessionsController
        respond_to :json
        
        private
        
        def respond_with(resource, _opts = {})
          render json: {
            user: UserSerializer.new(resource).as_json
          }, status: :ok
        end
        
        def respond_to_on_destroy
          head :no_content
        end
      end
    end
  end
end

# config/routes.rb
devise_for :users, 
  path: &#39;api/v1/auth&#39;,
  controllers: {
    sessions: &#39;api/v1/auth/sessions&#39;,
    registrations: &#39;api/v1/auth/registrations&#39;
  }
</code></pre>
<hr>
<h3>Refresh Tokens</h3>
<pre><code class="language-ruby"># For longer sessions with refresh tokens

# app/models/user.rb
class User &lt; ApplicationRecord
  has_secure_password
  has_many :refresh_tokens, dependent: :destroy
  
  def generate_tokens
    access_token = JWT.encode(
      {
        user_id: id,
        type: &#39;access&#39;,
        exp: 15.minutes.from_now.to_i
      },
      Rails.application.credentials.secret_key_base
    )
    
    refresh_token = SecureRandom.hex(32)
    RefreshToken.create!(
      user: self,
      token: refresh_token,
      expires_at: 30.days.from_now
    )
    
    { access_token: access_token, refresh_token: refresh_token }
  end
end

# app/models/refresh_token.rb
class RefreshToken &lt; ApplicationRecord
  belongs_to :user
  
  validates :token, presence: true, uniqueness: true
  
  scope :valid, -&gt; { where(&#39;expires_at &gt; ?&#39;, Time.current) }
end

# app/controllers/api/v1/auth_controller.rb
def refresh
  refresh_token = RefreshToken.valid.find_by(token: params[:refresh_token])
  
  if refresh_token
    tokens = refresh_token.user.generate_tokens
    refresh_token.destroy  # Invalidate old refresh token
    
    render json: tokens
  else
    render json: { error: &#39;Invalid refresh token&#39; }, status: :unauthorized
  end
end

# Usage
# 1. Login → get access_token + refresh_token
# 2. Use access_token for API requests (expires in 15 minutes)
# 3. When access_token expires, use refresh_token to get new pair
# 4. Refresh tokens valid for 30 days
</code></pre>
<hr>
<h3>Token Revocation</h3>
<pre><code class="language-ruby"># Blacklist tokens on logout

# app/models/blacklisted_token.rb
class BlacklistedToken &lt; ApplicationRecord
  validates :jti, presence: true, uniqueness: true
  
  def self.revoke(token)
    decoded = JWT.decode(token, Rails.application.credentials.secret_key_base)[0]
    create!(jti: decoded[&#39;jti&#39;], exp: Time.at(decoded[&#39;exp&#39;]))
  end
  
  def self.revoked?(jti)
    exists?(jti: jti)
  end
  
  # Cleanup expired tokens
  def self.cleanup_expired
    where(&#39;exp &lt; ?&#39;, Time.current).delete_all
  end
end

# app/models/user.rb
def generate_jwt
  jti = SecureRandom.uuid
  JWT.encode(
    {
      user_id: id,
      jti: jti,  # JWT ID for revocation
      exp: 24.hours.from_now.to_i
    },
    Rails.application.credentials.secret_key_base
  )
end

def self.from_token(token)
  decoded = JWT.decode(token, Rails.application.credentials.secret_key_base)[0]
  
  # Check if token blacklisted
  return nil if BlacklistedToken.revoked?(decoded[&#39;jti&#39;])
  
  find(decoded[&#39;user_id&#39;])
rescue JWT::DecodeError, ActiveRecord::RecordNotFound
  nil
end

# app/controllers/api/v1/auth_controller.rb
def logout
  token = extract_token
  BlacklistedToken.revoke(token)
  head :no_content
end
</code></pre>
<hr>
<h3>Testing</h3>
<pre><code class="language-ruby"># spec/requests/api/v1/auth_spec.rb
RSpec.describe &#39;Api::V1::Auth&#39;, type: :request do
  describe &#39;POST /api/v1/auth/signup&#39; do
    it &#39;creates user and returns token&#39; do
      post &#39;/api/v1/auth/signup&#39;, params: {
        user: {
          email: &#39;test@example.com&#39;,
          password: &#39;password123&#39;,
          password_confirmation: &#39;password123&#39;
        }
      }
      
      expect(response).to have_http_status(:created)
      expect(json[&#39;token&#39;]).to be_present
      expect(json[&#39;user&#39;][&#39;email&#39;]).to eq(&#39;test@example.com&#39;)
    end
  end
  
  describe &#39;POST /api/v1/auth/login&#39; do
    let(:user) { create(:user, password: &#39;password123&#39;) }
    
    it &#39;returns token for valid credentials&#39; do
      post &#39;/api/v1/auth/login&#39;, params: {
        email: user.email,
        password: &#39;password123&#39;
      }
      
      expect(response).to have_http_status(:ok)
      expect(json[&#39;token&#39;]).to be_present
    end
    
    it &#39;returns error for invalid credentials&#39; do
      post &#39;/api/v1/auth/login&#39;, params: {
        email: user.email,
        password: &#39;wrong&#39;
      }
      
      expect(response).to have_http_status(:unauthorized)
    end
  end
  
  describe &#39;GET /api/v1/auth/me&#39; do
    let(:user) { create(:user) }
    let(:token) { user.generate_jwt }
    
    it &#39;returns current user&#39; do
      get &#39;/api/v1/auth/me&#39;, headers: { &#39;Authorization&#39; =&gt; &quot;Bearer #{token}&quot; }
      
      expect(response).to have_http_status(:ok)
      expect(json[&#39;user&#39;][&#39;id&#39;]).to eq(user.id)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>JWT</strong> for stateless auth</li>
<li><strong>has_secure_password</strong> for passwords</li>
<li><strong>Bearer token</strong> in Authorization header</li>
<li><strong>Refresh tokens</strong> for long sessions</li>
<li><strong>Blacklist</strong> for revocation</li>
<li><strong>Short expiration</strong> for access tokens</li>
<li><strong>Test</strong> authentication flows</li>
<li><strong>Secure</strong> secret keys</li>
<li><strong>HTTPS</strong> in production</li>
<li><strong>Rate limit</strong> login endpoints</li>
</ol>
<hr>
<h2>Question 237-241 Summary (Authentication &amp; Authorization)</h2>
<p><strong>Q237: OAuth Implementation</strong></p>
<pre><code class="language-ruby"># Use omniauth gem
gem &#39;omniauth&#39;
gem &#39;omniauth-google-oauth2&#39;
gem &#39;omniauth-github&#39;

# config/initializers/omniauth.rb
Rails.application.config.middleware.use OmniAuth::Builder do
  provider :google_oauth2, ENV[&#39;GOOGLE_CLIENT_ID&#39;], ENV[&#39;GOOGLE_CLIENT_SECRET&#39;]
  provider :github, ENV[&#39;GITHUB_CLIENT_ID&#39;], ENV[&#39;GITHUB_CLIENT_SECRET&#39;]
end

# app/controllers/api/v1/auth/oauth_controller.rb
class Api::V1::Auth::OauthController &lt; ApiController
  skip_before_action :authenticate_user
  
  def callback
    auth = request.env[&#39;omniauth.auth&#39;]
    
    user = User.from_omniauth(auth)
    token = user.generate_jwt
    
    render json: { user: user, token: token }
  end
end

# app/models/user.rb
def self.from_omniauth(auth)
  find_or_create_by(provider: auth.provider, uid: auth.uid) do |user|
    user.email = auth.info.email
    user.name = auth.info.name
    user.password = SecureRandom.hex(16)
  end
end
</code></pre>
<p><strong>Q238: JWT vs Session Authentication</strong></p>
<pre><code class="language-ruby"># JWT Advantages:
✅ Stateless (no server-side storage)
✅ Scalable (no session store)
✅ Cross-domain (CORS friendly)
✅ Mobile-friendly
✅ Microservices-ready

# JWT Disadvantages:
❌ Can&#39;t revoke easily
❌ Larger payload than session ID
❌ Token in localStorage vulnerable to XSS

# Session Advantages:
✅ Easy to revoke (delete session)
✅ Smaller cookie size
✅ Can store more data server-side

# Session Disadvantages:
❌ Requires server-side storage
❌ Harder to scale horizontally
❌ CSRF vulnerability
❌ Doesn&#39;t work well for mobile apps

# Use JWT for:
# - APIs consumed by mobile apps
# - Microservices
# - Cross-domain requests
# - Stateless architecture

# Use Sessions for:
# - Traditional web apps
# - When need to revoke frequently
# - Server-rendered pages
</code></pre>
<p><strong>Q239: JWT Security Vulnerabilities</strong></p>
<pre><code class="language-ruby"># 1. Algorithm Confusion Attack
# ❌ Vulnerable: Accepting any algorithm
JWT.decode(token, public_key)

# ✅ Secure: Specify algorithm
JWT.decode(token, public_key, true, { algorithm: &#39;RS256&#39; })

# 2. Weak Secret Key
# ❌ Vulnerable
JWT.encode(payload, &#39;secret123&#39;)

# ✅ Secure: Strong secret
JWT.encode(payload, Rails.application.credentials.secret_key_base)

# 3. No Expiration
# ❌ Vulnerable: Token valid forever
JWT.encode({ user_id: 1 }, secret)

# ✅ Secure: Short expiration
JWT.encode({ user_id: 1, exp: 15.minutes.from_now.to_i }, secret)

# 4. Sensitive Data in Payload
# ❌ Don&#39;t store sensitive data
JWT.encode({ user_id: 1, password: &#39;secret&#39; }, secret)

# ✅ Only store IDs
JWT.encode({ user_id: 1 }, secret)

# 5. No HTTPS
# ❌ HTTP transmits tokens in plain text
# ✅ Always use HTTPS in production

# 6. LocalStorage XSS
# ❌ Store in localStorage (vulnerable to XSS)
localStorage.setItem(&#39;token&#39;, token)

# ✅ Better: httpOnly cookie (not accessible to JS)
# Or use secure storage on mobile

# Mitigation Checklist:
✅ Use strong secret key
✅ Specify algorithm explicitly
✅ Set short expiration (15-60 minutes)
✅ Use refresh tokens for long sessions
✅ Implement token revocation (blacklist)
✅ Use HTTPS always
✅ Validate token on every request
✅ Don&#39;t store sensitive data in token
✅ Rotate secret keys periodically
✅ Monitor for suspicious activity
</code></pre>
<p><strong>Q240-241: API Security Best Practices</strong></p>
<pre><code class="language-ruby"># 1. HTTPS Only
config.force_ssl = true

# 2. CORS Configuration
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins &#39;https://trusted-domain.com&#39;  # Not &#39;*&#39;
    resource &#39;*&#39;, 
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete],
      credentials: true
  end
end

# 3. Rate Limiting
gem &#39;rack-attack&#39;

class Rack::Attack
  throttle(&#39;api/ip&#39;, limit: 100, period: 1.hour) do |req|
    req.ip if req.path.start_with?(&#39;/api/&#39;)
  end
  
  throttle(&#39;api/login&#39;, limit: 5, period: 1.hour) do |req|
    req.ip if req.path == &#39;/api/v1/auth/login&#39; &amp;&amp; req.post?
  end
end

# 4. Input Validation
def user_params
  params.require(:user).permit(:email, :name)
  # Whitelist only
end

# 5. SQL Injection Prevention
User.where(&quot;email = ?&quot;, params[:email])  # Parameterized
# Never: User.where(&quot;email = &#39;#{params[:email]}&#39;&quot;)

# 6. API Versioning
namespace :api do
  namespace :v1 do
    resources :products
  end
end

# 7. Authentication
before_action :authenticate_user

# 8. Authorization
authorize @product  # Pundit

# 9. Audit Logging
after_action :log_api_request

def log_api_request
  ApiLog.create!(
    user: current_user,
    endpoint: request.path,
    method: request.method,
    ip: request.ip,
    status: response.status
  )
end

# 10. Security Headers
config.action_dispatch.default_headers = {
  &#39;X-Frame-Options&#39; =&gt; &#39;DENY&#39;,
  &#39;X-Content-Type-Options&#39; =&gt; &#39;nosniff&#39;,
  &#39;X-XSS-Protection&#39; =&gt; &#39;1; mode=block&#39;
}
</code></pre>
<h1>API Features, GraphQL, and Alternative APIs Interview Questions</h1>
<h2>API Features</h2>
<h2>Question 242: What is CORS, and how do you enable it in a Rails API?</h2>
<h3>Answer</h3>
<p><strong>CORS (Cross-Origin Resource Sharing)</strong> allows web applications on one domain to access resources from another domain. Required for APIs consumed by browser-based clients. Enable with <strong>rack-cors gem</strong>.</p>
<hr>
<h3>Why CORS is Needed</h3>
<pre><code class="language-javascript">// Browser security: Same-Origin Policy
// Frontend at: https://app.example.com
// API at: https://api.example.com

// Without CORS: Browser blocks request
fetch(&#39;https://api.example.com/products&#39;)
// ❌ CORS error: No &#39;Access-Control-Allow-Origin&#39; header

// With CORS: Request allowed
fetch(&#39;https://api.example.com/products&#39;)
// ✅ Success
</code></pre>
<hr>
<h3>Enable CORS in Rails</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;rack-cors&#39;

# config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins &#39;*&#39;  # Allow all origins (development only!)
    
    resource &#39;*&#39;,
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete, :options, :head]
  end
end
</code></pre>
<hr>
<h3>Production CORS Configuration</h3>
<pre><code class="language-ruby"># config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    # Specific origins only
    origins &#39;https://app.example.com&#39;, &#39;https://www.example.com&#39;
    
    resource &#39;/api/*&#39;,
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete],
      credentials: true,  # Allow cookies/auth headers
      max_age: 3600       # Cache preflight for 1 hour
  end
  
  # Public endpoints (no auth)
  allow do
    origins &#39;*&#39;
    
    resource &#39;/api/v1/public/*&#39;,
      headers: :any,
      methods: [:get]
  end
end
</code></pre>
<hr>
<h3>Environment-Specific CORS</h3>
<pre><code class="language-ruby"># config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins case Rails.env
    when &#39;development&#39;
      &#39;*&#39;  # Allow all in development
    when &#39;staging&#39;
      &#39;https://staging.example.com&#39;
    when &#39;production&#39;
      [&#39;https://app.example.com&#39;, &#39;https://www.example.com&#39;]
    end
    
    resource &#39;*&#39;,
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete],
      credentials: true
  end
end
</code></pre>
<hr>
<h3>CORS Headers Explained</h3>
<pre><code class="language-ruby"># Preflight Request (OPTIONS)
OPTIONS /api/v1/products
Origin: https://app.example.com

# Response Headers:
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 3600

# Actual Request
GET /api/v1/products
Origin: https://app.example.com
Authorization: Bearer token123

# Response Headers:
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Credentials: true
</code></pre>
<hr>
<h3>Custom CORS Configuration</h3>
<pre><code class="language-ruby"># config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins do |source, env|
      # Dynamic origin validation
      allowed_domains = ENV[&#39;ALLOWED_ORIGINS&#39;]&amp;.split(&#39;,&#39;) || []
      allowed_domains.include?(source)
    end
    
    resource &#39;/api/*&#39;,
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete],
      credentials: true,
      expose: [&#39;X-Total-Count&#39;, &#39;X-Page&#39;, &#39;Link&#39;],  # Custom headers
      max_age: 7200
  end
end

# .env
ALLOWED_ORIGINS=https://app.example.com,https://admin.example.com
</code></pre>
<hr>
<h3>Testing CORS</h3>
<pre><code class="language-ruby"># spec/requests/cors_spec.rb
RSpec.describe &#39;CORS&#39;, type: :request do
  it &#39;allows requests from allowed origin&#39; do
    get &#39;/api/v1/products&#39;,
        headers: { &#39;Origin&#39; =&gt; &#39;https://app.example.com&#39; }
    
    expect(response.headers[&#39;Access-Control-Allow-Origin&#39;])
      .to eq(&#39;https://app.example.com&#39;)
  end
  
  it &#39;handles preflight requests&#39; do
    options &#39;/api/v1/products&#39;,
            headers: {
              &#39;Origin&#39; =&gt; &#39;https://app.example.com&#39;,
              &#39;Access-Control-Request-Method&#39; =&gt; &#39;POST&#39;,
              &#39;Access-Control-Request-Headers&#39; =&gt; &#39;Content-Type, Authorization&#39;
            }
    
    expect(response).to have_http_status(:ok)
    expect(response.headers[&#39;Access-Control-Allow-Methods&#39;])
      .to include(&#39;POST&#39;)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>CORS</strong> allows cross-origin requests</li>
<li><strong>rack-cors gem</strong> for Rails</li>
<li><strong>Specific origins</strong> in production</li>
<li><strong>Wildcard (*)</strong> only in development</li>
<li><strong>credentials: true</strong> for auth</li>
<li><strong>Preflight</strong> OPTIONS requests</li>
<li><strong>max_age</strong> caches preflight</li>
<li><strong>expose</strong> custom headers</li>
<li><strong>Test</strong> CORS configuration</li>
<li><strong>Security</strong> over convenience</li>
</ol>
<hr>
<h2>Question 243: How do you handle API versioning in Rails?</h2>
<h3>Answer</h3>
<p>Handle API versioning using <strong>URL versioning</strong> (most common), <strong>header versioning</strong>, or <strong>parameter versioning</strong>. Structure with namespaces and maintain backward compatibility.</p>
<hr>
<h3>1. URL Versioning (Recommended)</h3>
<pre><code class="language-ruby"># config/routes.rb
namespace :api do
  namespace :v1 do
    resources :products
    resources :users
  end
  
  namespace :v2 do
    resources :products  # Different implementation
    resources :users
  end
end

# URLs:
# GET /api/v1/products
# GET /api/v2/products

# Directory structure:
# app/controllers/api/v1/products_controller.rb
# app/controllers/api/v2/products_controller.rb
</code></pre>
<hr>
<h3>2. Base Controllers</h3>
<pre><code class="language-ruby"># app/controllers/api/v1/api_controller.rb
module Api
  module V1
    class ApiController &lt; ActionController::API
      rescue_from ActiveRecord::RecordNotFound, with: :not_found
      
      private
      
      def not_found
        render json: { error: &#39;Not found&#39; }, status: :not_found
      end
    end
  end
end

# app/controllers/api/v2/api_controller.rb
module Api
  module V2
    class ApiController &lt; ActionController::API
      # V2 specific configuration
    end
  end
end
</code></pre>
<hr>
<h3>3. Shared Logic</h3>
<pre><code class="language-ruby"># app/controllers/concerns/api/shared_logic.rb
module Api
  module SharedLogic
    extend ActiveSupport::Concern
    
    included do
      before_action :authenticate_user
    end
    
    private
    
    def authenticate_user
      token = request.headers[&#39;Authorization&#39;]&amp;.split(&#39; &#39;)&amp;.last
      @current_user = User.from_token(token)
      render json: { error: &#39;Unauthorized&#39; }, status: :unauthorized unless @current_user
    end
  end
end

# Use in controllers
class Api::V1::ProductsController &lt; Api::V1::ApiController
  include Api::SharedLogic
end
</code></pre>
<hr>
<h3>4. Version-Specific Serializers</h3>
<pre><code class="language-ruby"># app/serializers/api/v1/product_serializer.rb
module Api
  module V1
    class ProductSerializer
      def initialize(product)
        @product = product
      end
      
      def as_json
        {
          id: @product.id,
          name: @product.name,
          price: @product.price
        }
      end
    end
  end
end

# app/serializers/api/v2/product_serializer.rb
module Api
  module V2
    class ProductSerializer
      def initialize(product)
        @product = product
      end
      
      def as_json
        {
          id: @product.id,
          name: @product.name,
          price: format_price(@product.price),
          currency: @product.currency,  # New in V2
          images: @product.images.map(&amp;:url)  # New in V2
        }
      end
      
      private
      
      def format_price(price)
        &quot;$#{price}&quot;
      end
    end
  end
end
</code></pre>
<hr>
<h3>5. Deprecation Strategy</h3>
<pre><code class="language-ruby"># Mark V1 as deprecated
module Api
  module V1
    class ApiController &lt; ActionController::API
      after_action :add_deprecation_header
      
      private
      
      def add_deprecation_header
        response.headers[&#39;X-API-Deprecated&#39;] = &#39;true&#39;
        response.headers[&#39;X-API-Sunset&#39;] = &#39;2024-12-31&#39;
        response.headers[&#39;Link&#39;] = &#39;&lt;/api/v2&gt;; rel=&quot;successor-version&quot;&#39;
      end
    end
  end
end

# Client sees:
# X-API-Deprecated: true
# X-API-Sunset: 2024-12-31
# Link: &lt;/api/v2&gt;; rel=&quot;successor-version&quot;
</code></pre>
<hr>
<h3>6. Header Versioning</h3>
<pre><code class="language-ruby"># config/routes.rb
namespace :api, defaults: { format: :json } do
  scope module: :v1, constraints: ApiVersion.new(&#39;v1&#39;, true) do
    resources :products
  end
  
  scope module: :v2, constraints: ApiVersion.new(&#39;v2&#39;) do
    resources :products
  end
end

# lib/api_version.rb
class ApiVersion
  def initialize(version, default = false)
    @version = version
    @default = default
  end
  
  def matches?(request)
    @default || check_headers(request.headers)
  end
  
  private
  
  def check_headers(headers)
    accept = headers[&#39;Accept&#39;]
    accept &amp;&amp; accept.include?(&quot;application/vnd.myapp.#{@version}+json&quot;)
  end
end

# Usage:
# GET /api/products
# Accept: application/vnd.myapp.v2+json
</code></pre>
<hr>
<h3>7. Backward Compatibility</h3>
<pre><code class="language-ruby"># Support old response format in new version
module Api
  module V2
    class ProductsController &lt; ApiController
      def index
        products = Product.all
        
        # Check if client wants V1 format
        if legacy_client?
          render json: products, each_serializer: Api::V1::ProductSerializer
        else
          render json: products, each_serializer: Api::V2::ProductSerializer
        end
      end
      
      private
      
      def legacy_client?
        request.headers[&#39;X-API-Client-Version&#39;] == &#39;1.0&#39;
      end
    end
  end
end
</code></pre>
<hr>
<h3>8. Migration Guide</h3>
<pre><code class="language-ruby"># Documentation for V1 → V2 migration

# Breaking Changes:
# 1. Price format changed from float to string
#    V1: &quot;price&quot;: 29.99
#    V2: &quot;price&quot;: &quot;$29.99&quot;
#
# 2. Added required field: currency
#    V2: &quot;currency&quot;: &quot;USD&quot;
#
# 3. Images now array of URLs
#    V1: &quot;image_url&quot;: &quot;...&quot;
#    V2: &quot;images&quot;: [&quot;...&quot;, &quot;...&quot;]
#
# 4. Removed: description_html
#    Use: description with Markdown

# Migration code example:
# Old V1:
response = get(&#39;/api/v1/products&#39;)
price = response[&#39;price&#39;]  # 29.99

# New V2:
response = get(&#39;/api/v2/products&#39;)
price = response[&#39;price&#39;].delete(&#39;$&#39;).to_f  # Extract number
currency = response[&#39;currency&#39;]  # &quot;USD&quot;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>URL versioning</strong> most common</li>
<li><strong>Namespace</strong> by version</li>
<li><strong>Separate serializers</strong> per version</li>
<li><strong>Share</strong> common logic</li>
<li><strong>Deprecation</strong> headers</li>
<li><strong>Backward compatibility</strong> when possible</li>
<li><strong>Document</strong> breaking changes</li>
<li><strong>Migration guide</strong> essential</li>
<li><strong>Semantic versioning</strong> (major.minor.patch)</li>
<li><strong>Support</strong> 2-3 versions max</li>
</ol>
<hr>
<h2>Question 244-250 Summary (API Features)</h2>
<p><strong>Q244: Pagination</strong></p>
<pre><code class="language-ruby"># Using Kaminari gem
gem &#39;kaminari&#39;

class Api::V1::ProductsController &lt; ApiController
  def index
    page = params[:page] || 1
    per_page = params[:per_page] || 20
    
    products = Product.page(page).per(per_page)
    
    render json: {
      data: products.map { |p| ProductSerializer.new(p).as_json },
      meta: {
        current_page: products.current_page,
        total_pages: products.total_pages,
        total_count: products.total_count,
        per_page: per_page
      },
      links: pagination_links(products)
    }
  end
  
  private
  
  def pagination_links(collection)
    {
      self: products_url(page: collection.current_page),
      first: products_url(page: 1),
      last: products_url(page: collection.total_pages),
      prev: collection.prev_page ? products_url(page: collection.prev_page) : nil,
      next: collection.next_page ? products_url(page: collection.next_page) : nil
    }
  end
end

# Cursor-based pagination (better performance)
def index
  cursor = params[:cursor]
  limit = params[:limit] || 20
  
  products = if cursor
    Product.where(&#39;id &gt; ?&#39;, cursor).limit(limit)
  else
    Product.limit(limit)
  end
  
  render json: {
    data: products,
    cursor: products.last&amp;.id,
    has_more: products.count == limit
  }
end
</code></pre>
<p><strong>Q245-246: Rate Limiting</strong></p>
<pre><code class="language-ruby"># Using Rack::Attack gem
gem &#39;rack-attack&#39;

# config/initializers/rack_attack.rb
class Rack::Attack
  # Throttle all requests by IP
  throttle(&#39;req/ip&#39;, limit: 300, period: 5.minutes) do |req|
    req.ip unless req.path.start_with?(&#39;/admin&#39;)
  end
  
  # Throttle login attempts
  throttle(&#39;logins/ip&#39;, limit: 5, period: 20.seconds) do |req|
    if req.path == &#39;/api/v1/auth/login&#39; &amp;&amp; req.post?
      req.ip
    end
  end
  
  # Throttle by user token
  throttle(&#39;api/user&#39;, limit: 1000, period: 1.hour) do |req|
    if req.path.start_with?(&#39;/api/&#39;)
      token = req.headers[&#39;Authorization&#39;]&amp;.split(&#39; &#39;)&amp;.last
      User.from_token(token)&amp;.id
    end
  end
  
  # Block bad actors
  blocklist(&#39;block bad IPs&#39;) do |req|
    BadIp.exists?(ip: req.ip)
  end
  
  # Custom response
  self.throttled_response = lambda do |env|
    retry_after = env[&#39;rack.attack.match_data&#39;][:period]
    [
      429,
      {
        &#39;Content-Type&#39; =&gt; &#39;application/json&#39;,
        &#39;Retry-After&#39; =&gt; retry_after.to_s
      },
      [{ error: &#39;Rate limit exceeded&#39;, retry_after: retry_after }.to_json]
    ]
  end
end

# Enable middleware
# config/application.rb
config.middleware.use Rack::Attack
</code></pre>
<p><strong>Q247: API Gateway</strong></p>
<pre><code class="language-ruby"># API Gateway pattern (separate service)
# Use tools like Kong, AWS API Gateway, or custom

# Example: Custom gateway
class ApiGateway
  def self.call(env)
    request = Rack::Request.new(env)
    
    # Rate limiting
    return rate_limit_response if rate_limited?(request)
    
    # Authentication
    return unauthorized_response unless authenticated?(request)
    
    # Route to backend service
    response = route_request(request)
    
    # Add headers
    response[1][&#39;X-Gateway-Version&#39;] = &#39;1.0&#39;
    
    response
  end
  
  def self.rate_limited?(request)
    # Check Redis for rate limit
    key = &quot;rate_limit:#{request.ip}&quot;
    count = REDIS.get(key).to_i
    
    if count &gt;= 100
      true
    else
      REDIS.incr(key)
      REDIS.expire(key, 3600)
      false
    end
  end
end
</code></pre>
<p><strong>Q248: Caching API Responses</strong></p>
<pre><code class="language-ruby"># 1. HTTP Caching
class Api::V1::ProductsController &lt; ApiController
  def show
    product = Product.find(params[:id])
    
    # ETag
    if stale?(product)
      render json: product
    end
    # Returns 304 Not Modified if ETag matches
  end
  
  def index
    products = Product.all
    
    # Cache-Control
    expires_in 5.minutes, public: true
    
    render json: products
  end
end

# 2. Fragment Caching
def index
  products = Product.all
  
  cached_json = Rails.cache.fetch(
    [&#39;products&#39;, products.maximum(:updated_at)],
    expires_in: 1.hour
  ) do
    products.map { |p| ProductSerializer.new(p).as_json }.to_json
  end
  
  render json: cached_json
end

# 3. Redis Caching
def show
  product_json = Rails.cache.fetch(
    &quot;product:#{params[:id]}&quot;,
    expires_in: 1.hour
  ) do
    product = Product.find(params[:id])
    ProductSerializer.new(product).as_json.to_json
  end
  
  render json: product_json
end

# 4. Conditional Requests
def show
  product = Product.find(params[:id])
  
  # Last-Modified
  if stale?(last_modified: product.updated_at, public: true)
    render json: product
  end
end
</code></pre>
<p><strong>Q249: Secure Public API</strong></p>
<pre><code class="language-ruby"># 1. API Keys
class ApiController &lt; ActionController::API
  before_action :authenticate_api_key
  
  private
  
  def authenticate_api_key
    api_key = request.headers[&#39;X-API-Key&#39;]
    
    unless ApiKey.valid?(api_key)
      render json: { error: &#39;Invalid API key&#39; }, status: :unauthorized
    end
  end
end

# 2. Rate Limiting (per API key)
throttle(&#39;api/key&#39;, limit: 10000, period: 1.hour) do |req|
  req.headers[&#39;X-API-Key&#39;]
end

# 3. HTTPS Only
config.force_ssl = true

# 4. Input Validation
def product_params
  params.require(:product).permit(:name, :description, :price)
end

# 5. Output Sanitization
def as_json
  {
    id: product.id,
    name: CGI.escapeHTML(product.name),
    description: sanitize_html(product.description)
  }
end

# 6. Monitor &amp; Alert
after_action :log_api_access

def log_api_access
  ApiAccessLog.create!(
    api_key: request.headers[&#39;X-API-Key&#39;],
    endpoint: request.path,
    ip: request.ip,
    response_status: response.status
  )
end
</code></pre>
<p><strong>Q250: Dynamic Filtering</strong></p>
<pre><code class="language-ruby"># Flexible filtering with SQL
class Api::V1::ProductsController &lt; ApiController
  def index
    products = Product.all
    
    # Apply filters
    products = apply_filters(products, filter_params)
    
    # Apply sorting
    products = apply_sorting(products, params[:sort], params[:order])
    
    render json: products
  end
  
  private
  
  def filter_params
    params.permit(
      :category,
      :min_price,
      :max_price,
      :in_stock,
      :brand,
      :search
    )
  end
  
  def apply_filters(scope, filters)
    scope = scope.where(category: filters[:category]) if filters[:category]
    scope = scope.where(&#39;price &gt;= ?&#39;, filters[:min_price]) if filters[:min_price]
    scope = scope.where(&#39;price &lt;= ?&#39;, filters[:max_price]) if filters[:max_price]
    scope = scope.where(in_stock: true) if filters[:in_stock] == &#39;true&#39;
    scope = scope.where(brand: filters[:brand]) if filters[:brand]
    
    if filters[:search]
      scope = scope.where(
        &#39;name ILIKE ? OR description ILIKE ?&#39;,
        &quot;%#{filters[:search]}%&quot;,
        &quot;%#{filters[:search]}%&quot;
      )
    end
    
    scope
  end
  
  def apply_sorting(scope, sort_by, order)
    return scope unless sort_by
    
    # Whitelist sortable columns
    allowed_columns = %w[name price created_at]
    column = allowed_columns.include?(sort_by) ? sort_by : &#39;created_at&#39;
    direction = order == &#39;asc&#39; ? :asc : :desc
    
    scope.order(column =&gt; direction)
  end
end

# Advanced: JSON filtering
def apply_json_filters(scope, json_filters)
  json_filters.each do |key, value|
    scope = scope.where(&quot;metadata @&gt; ?&quot;, { key =&gt; value }.to_json)
  end
  scope
end

# Usage:
# GET /api/v1/products?category=electronics&amp;min_price=100&amp;max_price=500&amp;sort=price&amp;order=desc
</code></pre>
<hr>
<h2>GraphQL</h2>
<h2>Question 251: Explain GraphQL and its benefits over REST</h2>
<h3>Answer</h3>
<p><strong>GraphQL</strong> is a query language for APIs where clients specify exactly what data they need. Benefits: <strong>no over/under-fetching</strong>, <strong>single endpoint</strong>, <strong>strongly typed schema</strong>, <strong>real-time subscriptions</strong>, <strong>better developer experience</strong>.</p>
<hr>
<h3>GraphQL vs REST</h3>
<pre><code class="language-graphql"># GraphQL: Single request, exact data needed
query {
  user(id: 123) {
    name
    email
    posts(limit: 5) {
      title
      comments(limit: 3) {
        author
        text
      }
    }
  }
}

# Response: Exactly what was requested
{
  &quot;data&quot;: {
    &quot;user&quot;: {
      &quot;name&quot;: &quot;John&quot;,
      &quot;email&quot;: &quot;john@example.com&quot;,
      &quot;posts&quot;: [
        {
          &quot;title&quot;: &quot;GraphQL Guide&quot;,
          &quot;comments&quot;: [...]
        }
      ]
    }
  }
}
</code></pre>
<pre><code class="language-ruby"># REST: Multiple requests, extra data
# GET /users/123
# GET /users/123/posts?limit=5
# GET /posts/1/comments?limit=3
# GET /posts/2/comments?limit=3
# ...

# 4+ requests vs 1 GraphQL query
# Returns all user fields (over-fetching)
</code></pre>
<hr>
<h3>Setup GraphQL in Rails</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;graphql&#39;
gem &#39;graphql-batch&#39;  # N+1 query prevention

# Install
rails generate graphql:install

# Creates:
# app/graphql/
#   types/
#     query_type.rb
#     mutation_type.rb
#   myapp_schema.rb
# graphql_controller.rb
</code></pre>
<hr>
<h3>Define Types</h3>
<pre><code class="language-ruby"># app/graphql/types/user_type.rb
module Types
  class UserType &lt; Types::BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :email, String, null: false
    field :created_at, GraphQL::Types::ISO8601DateTime, null: false
    
    # Associations
    field :posts, [Types::PostType], null: false
    
    # Computed fields
    field :full_name, String, null: false
    
    def full_name
      &quot;#{object.first_name} #{object.last_name}&quot;
    end
    
    # With arguments
    field :recent_posts, [Types::PostType], null: false do
      argument :limit, Integer, required: false, default_value: 10
    end
    
    def recent_posts(limit:)
      object.posts.order(created_at: :desc).limit(limit)
    end
  end
end
</code></pre>
<hr>
<h3>Query Type</h3>
<pre><code class="language-ruby"># app/graphql/types/query_type.rb
module Types
  class QueryType &lt; Types::BaseObject
    # Single record
    field :user, UserType, null: true do
      argument :id, ID, required: true
    end
    
    def user(id:)
      User.find(id)
    end
    
    # Collection
    field :users, [UserType], null: false do
      argument :limit, Integer, required: false
    end
    
    def users(limit: nil)
      scope = User.all
      scope = scope.limit(limit) if limit
      scope
    end
    
    # Search
    field :search_users, [UserType], null: false do
      argument :query, String, required: true
    end
    
    def search_users(query:)
      User.where(&#39;name ILIKE ?&#39;, &quot;%#{query}%&quot;)
    end
  end
end
</code></pre>
<hr>
<h3>Benefits Over REST</h3>
<p><strong>1. No Over-fetching:</strong></p>
<pre><code class="language-graphql"># Get only needed fields
query {
  user(id: 123) {
    name
    email
  }
}

# REST: GET /users/123 returns all 20+ fields
</code></pre>
<p><strong>2. No Under-fetching:</strong></p>
<pre><code class="language-graphql"># Get related data in single request
query {
  user(id: 123) {
    name
    posts {
      title
      comments {
        text
      }
    }
  }
}

# REST: 3+ requests needed
</code></pre>
<p><strong>3. Strongly Typed:</strong></p>
<pre><code class="language-ruby"># Schema defines exact types
field :age, Integer, null: false
field :email, String, null: false
field :created_at, GraphQL::Types::ISO8601DateTime, null: false

# Auto-generated documentation
# IDE autocomplete
# Type validation
</code></pre>
<p><strong>4. Introspection:</strong></p>
<pre><code class="language-graphql"># Query schema itself
query {
  __schema {
    types {
      name
      fields {
        name
        type {
          name
        }
      }
    }
  }
}

# Powers GraphiQL, Playground
# Auto-generates documentation
</code></pre>
<p><strong>5. Versioning Not Needed:</strong></p>
<pre><code class="language-graphql"># Add new fields without breaking clients
type User {
  name: String
  email: String
  phone: String  # New field, old clients unaffected
}

# Deprecate fields gracefully
type User {
  name: String
  old_field: String @deprecated(reason: &quot;Use new_field instead&quot;)
  new_field: String
}
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>REST</th>
<th>GraphQL</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Endpoints</strong></td>
<td>Multiple</td>
<td>Single</td>
</tr>
<tr>
<td><strong>Data Fetching</strong></td>
<td>Fixed by server</td>
<td>Flexible by client</td>
</tr>
<tr>
<td><strong>Over-fetching</strong></td>
<td>Common</td>
<td>Eliminated</td>
</tr>
<tr>
<td><strong>Under-fetching</strong></td>
<td>Requires multiple requests</td>
<td>Single request</td>
</tr>
<tr>
<td><strong>Versioning</strong></td>
<td>/api/v1, /api/v2</td>
<td>Not needed</td>
</tr>
<tr>
<td><strong>Type System</strong></td>
<td>Optional</td>
<td>Built-in</td>
</tr>
<tr>
<td><strong>Documentation</strong></td>
<td>Manual (Swagger)</td>
<td>Auto-generated</td>
</tr>
<tr>
<td><strong>Caching</strong></td>
<td>HTTP caching</td>
<td>Requires Apollo/Relay</td>
</tr>
<tr>
<td><strong>File Upload</strong></td>
<td>Native</td>
<td>Requires multipart</td>
</tr>
<tr>
<td><strong>Learning Curve</strong></td>
<td>Low</td>
<td>Medium</td>
</tr>
</tbody></table>
<hr>
<h3>When to Use GraphQL</h3>
<pre><code class="language-ruby">✅ Use GraphQL when:
# - Mobile apps (bandwidth matters)
# - Complex data relationships
# - Multiple clients (web, mobile, IoT)
# - Rapid frontend iteration
# - Need flexible queries

❌ Stick with REST when:
# - Simple CRUD API
# - File uploads primary use case
# - Team unfamiliar with GraphQL
# - Heavy caching requirements
# - Public API (REST more familiar)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Single endpoint</strong> for all queries</li>
<li><strong>Client specifies</strong> exact data needed</li>
<li><strong>No over/under-fetching</strong></li>
<li><strong>Strongly typed</strong> schema</li>
<li><strong>Introspection</strong> built-in</li>
<li><strong>No versioning</strong> needed</li>
<li><strong>Better mobile</strong> experience</li>
<li><strong>Complex queries</strong> in one request</li>
<li><strong>Learning curve</strong> higher than REST</li>
<li><strong>Use</strong> based on requirements</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 252-257 Summary (GraphQL Continued)</h2>
<p><strong>Q252: GraphQL Mutations</strong></p>
<pre><code class="language-ruby"># app/graphql/types/mutation_type.rb
module Types
  class MutationType &lt; Types::BaseObject
    field :create_user, mutation: Mutations::CreateUser
    field :update_user, mutation: Mutations::UpdateUser
    field :delete_user, mutation: Mutations::DeleteUser
  end
end

# app/graphql/mutations/create_user.rb
module Mutations
  class CreateUser &lt; BaseMutation
    argument :name, String, required: true
    argument :email, String, required: true
    argument :password, String, required: true
    
    field :user, Types::UserType, null: false
    field :errors, [String], null: false
    
    def resolve(name:, email:, password:)
      user = User.new(name: name, email: email, password: password)
      
      if user.save
        { user: user, errors: [] }
      else
        { user: nil, errors: user.errors.full_messages }
      end
    end
  end
end

# Usage
mutation {
  createUser(input: {
    name: &quot;John Doe&quot;
    email: &quot;john@example.com&quot;
    password: &quot;password123&quot;
  }) {
    user {
      id
      name
      email
    }
    errors
  }
}
</code></pre>
<p><strong>Q253: Batch Queries (N+1 Prevention)</strong></p>
<pre><code class="language-ruby"># Install graphql-batch
gem &#39;graphql-batch&#39;

# app/graphql/myapp_schema.rb
class MyappSchema &lt; GraphQL::Schema
  use GraphQL::Batch
end

# app/graphql/loaders/record_loader.rb
class RecordLoader &lt; GraphQL::Batch::Loader
  def initialize(model)
    @model = model
  end
  
  def perform(ids)
    records = @model.where(id: ids).index_by(&amp;:id)
    ids.each { |id| fulfill(id, records[id]) }
  end
end

# app/graphql/loaders/association_loader.rb
class AssociationLoader &lt; GraphQL::Batch::Loader
  def initialize(model, association)
    @model = model
    @association = association
  end
  
  def perform(ids)
    records = @model.where(id: ids).includes(@association).index_by(&amp;:id)
    ids.each do |id|
      record = records[id]
      fulfill(id, record.public_send(@association))
    end
  end
end

# Usage in resolver
field :author, Types::UserType, null: false

def author
  RecordLoader.for(User).load(object.author_id)
end

field :comments, [Types::CommentType], null: false

def comments
  AssociationLoader.for(Post, :comments).load(object.id)
end

# Before: N+1 queries
# After: 2 queries total (batched)
</code></pre>
<p><strong>Q254: GraphQL Resolvers vs REST Controllers</strong></p>
<pre><code class="language-ruby"># REST Controller
class UsersController &lt; ApplicationController
  def show
    @user = User.find(params[:id])
    render json: @user  # Fixed response structure
  end
end

# GraphQL Resolver
module Types
  class QueryType &lt; Types::BaseObject
    field :user, UserType, null: true do
      argument :id, ID, required: true
    end
    
    def user(id:)
      User.find(id)  # Client chooses fields
    end
  end
end

# Key Differences:
# 1. REST: Fixed response structure
#    GraphQL: Client-specified fields
#
# 2. REST: Multiple endpoints
#    GraphQL: Single endpoint, multiple resolvers
#
# 3. REST: HTTP verbs (GET, POST, PUT, DELETE)
#    GraphQL: Query (read) or Mutation (write)
#
# 4. REST: URL-based routing
#    GraphQL: Field-based resolution
</code></pre>
<p><strong>Q255: Rate Limiting: REST vs GraphQL</strong></p>
<pre><code class="language-ruby"># REST: Simple request-based rate limiting
throttle(&#39;api/ip&#39;, limit: 100, period: 1.hour) do |req|
  req.ip if req.path.start_with?(&#39;/api/&#39;)
end

# GraphQL: Query complexity analysis
# app/graphql/myapp_schema.rb
class MyappSchema &lt; GraphQL::Schema
  max_complexity 200  # Maximum query complexity
  max_depth 10        # Maximum nesting depth
  
  # Query analyzer
  query_analyzer(GraphQL::Analysis::QueryComplexity.new { |query, complexity|
    if complexity &gt; 200
      GraphQL::AnalysisError.new(&quot;Query too complex: #{complexity}&quot;)
    end
  })
end

# Assign complexity to fields
field :users, [UserType], null: false, complexity: 5
field :posts, [PostType], null: false, complexity: 10

# Nested complexity multiplies:
# query { users { posts { comments } } }
# Complexity: 5 * 10 * 5 = 250 (exceeds limit)

# Implement cost-based limits
class Types::QueryType &lt; Types::BaseObject
  field :expensive_data, [DataType], null: false do
    argument :limit, Integer, required: false
    complexity -&gt;(ctx, args, child_complexity) {
      # Limit determines cost
      limit = args[:limit] || 10
      child_complexity * limit
    }
  end
end
</code></pre>
<p><strong>Q256-257: GraphQL Subscriptions (Real-time)</strong></p>
<pre><code class="language-ruby"># Install ActionCable adapter
gem &#39;graphql&#39;

# app/graphql/types/subscription_type.rb
module Types
  class SubscriptionType &lt; GraphQL::Schema::Object
    field :message_added, Types::MessageType, null: false do
      argument :channel_id, ID, required: true
    end
    
    def message_added(channel_id:)
      # Subscription triggered elsewhere
    end
  end
end

# app/graphql/myapp_schema.rb
class MyappSchema &lt; GraphQL::Schema
  use GraphQL::Subscriptions::ActionCableSubscriptions
  subscription Types::SubscriptionType
end

# Trigger subscription from controller
class MessagesController &lt; ApplicationController
  def create
    message = Message.create!(message_params)
    
    # Trigger GraphQL subscription
    MyappSchema.subscriptions.trigger(
      :message_added,
      { channel_id: message.channel_id },
      message
    )
    
    render json: message
  end
end

# Client subscription
subscription {
  messageAdded(channelId: &quot;123&quot;) {
    id
    text
    author {
      name
    }
    createdAt
  }
}

# Real-time use cases:
# - Chat messages
# - Live notifications
# - Real-time dashboards
# - Collaborative editing
# - Live sports scores
# - Stock price updates

# ActionCable configuration
# config/cable.yml
development:
  adapter: redis
  url: redis://localhost:6379/1

# app/channels/graphql_channel.rb
class GraphqlChannel &lt; ApplicationCable::Channel
  def subscribed
    @subscription_ids = []
  end
  
  def execute(data)
    result = MyappSchema.execute(
      query: data[&#39;query&#39;],
      context: { channel: self, current_user: current_user },
      variables: data[&#39;variables&#39;],
      operation_name: data[&#39;operationName&#39;]
    )
    
    transmit(result.to_h)
  end
end
</code></pre>
<hr>
<h2>Alternative APIs</h2>
<h2>Question 258: What is gRPC, and how does it compare to REST and GraphQL?</h2>
<h3>Answer</h3>
<p><strong>gRPC</strong> is a high-performance RPC framework using <strong>Protocol Buffers</strong> and <strong>HTTP/2</strong>. Faster than REST/GraphQL, language-agnostic, but requires code generation and less human-readable.</p>
<hr>
<h3>gRPC Overview</h3>
<pre><code class="language-proto">// user.proto - Protocol Buffer definition
syntax = &quot;proto3&quot;;

service UserService {
  rpc GetUser (GetUserRequest) returns (User);
  rpc ListUsers (ListUsersRequest) returns (ListUsersResponse);
  rpc CreateUser (CreateUserRequest) returns (User);
}

message User {
  int32 id = 1;
  string name = 2;
  string email = 3;
}

message GetUserRequest {
  int32 id = 1;
}

message ListUsersRequest {
  int32 page = 1;
  int32 per_page = 2;
}

message ListUsersResponse {
  repeated User users = 1;
  int32 total = 2;
}
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>REST</th>
<th>GraphQL</th>
<th>gRPC</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Protocol</strong></td>
<td>HTTP/1.1</td>
<td>HTTP/1.1</td>
<td>HTTP/2</td>
</tr>
<tr>
<td><strong>Format</strong></td>
<td>JSON</td>
<td>JSON</td>
<td>Protobuf (binary)</td>
</tr>
<tr>
<td><strong>Schema</strong></td>
<td>Optional</td>
<td>Required</td>
<td>Required</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Medium</td>
<td>Medium</td>
<td>High</td>
</tr>
<tr>
<td><strong>Streaming</strong></td>
<td>No</td>
<td>Subscriptions</td>
<td>Bidirectional</td>
</tr>
<tr>
<td><strong>Browser</strong></td>
<td>Native</td>
<td>Native</td>
<td>Requires proxy</td>
</tr>
<tr>
<td><strong>Human Readable</strong></td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><strong>Type Safety</strong></td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td><strong>Learning Curve</strong></td>
<td>Low</td>
<td>Medium</td>
<td>High</td>
</tr>
<tr>
<td><strong>Use Case</strong></td>
<td>Public APIs</td>
<td>Complex queries</td>
<td>Microservices</td>
</tr>
</tbody></table>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-ruby"># REST: JSON over HTTP/1.1
GET /api/users/123
Response: 500 bytes JSON
Latency: ~50ms

# GraphQL: JSON over HTTP/1.1
POST /graphql
query { user(id: 123) { name email } }
Response: 200 bytes JSON (only requested fields)
Latency: ~45ms

# gRPC: Protobuf over HTTP/2
GetUser(id: 123)
Response: 50 bytes binary
Latency: ~10ms

# gRPC advantages:
# - Binary format (smaller)
# - HTTP/2 (multiplexing, header compression)
# - Connection reuse
</code></pre>
<hr>
<h3>When to Use Each</h3>
<pre><code class="language-ruby"># REST:
✅ Public APIs
✅ Simple CRUD
✅ Browser clients
✅ Caching important
✅ Team familiar with REST

# GraphQL:
✅ Complex data relationships
✅ Mobile apps (flexible queries)
✅ Multiple client types
✅ Rapid frontend development
✅ Real-time subscriptions

# gRPC:
✅ Internal microservices
✅ Low latency critical
✅ Bidirectional streaming
✅ Language-agnostic
✅ Type safety required
</code></pre>
<hr>
<h3>gRPC in Rails (Server)</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;grpc&#39;
gem &#39;grpc-tools&#39;

# Generate Ruby code from proto
grpc_tools_ruby_protoc -I . --ruby_out=lib --grpc_out=lib user.proto

# app/grpc/user_service.rb
class UserService &lt; User::Service
  def get_user(get_user_req, _call)
    user = User.find(get_user_req.id)
    User.new(id: user.id, name: user.name, email: user.email)
  rescue ActiveRecord::RecordNotFound
    raise GRPC::NotFound.new(&#39;User not found&#39;)
  end
  
  def list_users(list_users_req, _call)
    users = User.page(list_users_req.page).per(list_users_req.per_page)
    
    ListUsersResponse.new(
      users: users.map { |u| User.new(id: u.id, name: u.name, email: u.email) },
      total: users.total_count
    )
  end
end

# Start gRPC server
server = GRPC::RpcServer.new
server.add_http2_port(&#39;0.0.0.0:50051&#39;, :this_port_is_insecure)
server.handle(UserService)
server.run_till_terminated
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>gRPC</strong> for microservices</li>
<li><strong>Protobuf</strong> binary format</li>
<li><strong>HTTP/2</strong> performance</li>
<li><strong>Type safe</strong> with schema</li>
<li><strong>Bidirectional</strong> streaming</li>
<li><strong>Not browser-friendly</strong></li>
<li><strong>Language agnostic</strong></li>
<li><strong>REST</strong> for public APIs</li>
<li><strong>GraphQL</strong> for complex queries</li>
<li><strong>Choose</strong> based on use case</li>
</ol>
<hr>
<h2>Question 259: Explain Grape vs GraphQL</h2>
<h3>Answer</h3>
<p><strong>Grape</strong> is a REST API framework for Ruby. <strong>GraphQL</strong> is a query language specification. Grape = build REST APIs faster, GraphQL = flexible client-driven queries.</p>
<hr>
<h3>Grape Overview</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;grape&#39;

# app/api/v1/products.rb
module V1
  class Products &lt; Grape::API
    version &#39;v1&#39;, using: :path
    format :json
    
    resource :products do
      desc &#39;List all products&#39;
      params do
        optional :category, type: String
        optional :page, type: Integer, default: 1
      end
      get do
        products = Product.all
        products = products.where(category: params[:category]) if params[:category]
        products = products.page(params[:page])
        
        present products, with: Entities::Product
      end
      
      desc &#39;Get product by ID&#39;
      params do
        requires :id, type: Integer
      end
      route_param :id do
        get do
          product = Product.find(params[:id])
          present product, with: Entities::Product
        end
      end
      
      desc &#39;Create product&#39;
      params do
        requires :name, type: String
        requires :price, type: Float
        optional :description, type: String
      end
      post do
        product = Product.create!(declared(params))
        present product, with: Entities::Product
      end
    end
  end
end

# app/api/entities/product.rb
module Entities
  class Product &lt; Grape::Entity
    expose :id
    expose :name
    expose :price
    expose :description
    expose :created_at
  end
end

# Mount API
# config/routes.rb
mount V1::Products =&gt; &#39;/api&#39;
</code></pre>
<hr>
<h3>Comparison</h3>
<p><strong>Grape (REST Framework):</strong></p>
<pre><code class="language-ruby"># Pros:
✅ Fast REST API development
✅ Built-in validation
✅ Versioning support
✅ Entity serialization
✅ Parameter coercion
✅ Lightweight
✅ Familiar REST patterns

# Cons:
❌ Multiple endpoints needed
❌ Over/under-fetching
❌ Versioning complexity
❌ Fixed response structure

# Use when:
# - Building REST API
# - Simple CRUD operations
# - Team prefers REST
# - Quick MVP needed
</code></pre>
<p><strong>GraphQL:</strong></p>
<pre><code class="language-ruby"># Pros:
✅ Single endpoint
✅ Client specifies data
✅ No over/under-fetching
✅ Strong typing
✅ Introspection
✅ No versioning needed

# Cons:
❌ More complex setup
❌ Steeper learning curve
❌ Caching more complex
❌ Query complexity management

# Use when:
# - Complex data relationships
# - Mobile apps
# - Multiple client types
# - Flexible queries needed
</code></pre>
<hr>
<h3>Side-by-Side Example</h3>
<p><strong>Grape (REST):</strong></p>
<pre><code class="language-ruby"># Multiple requests needed
GET /api/v1/users/123
GET /api/v1/users/123/posts
GET /api/v1/posts/1/comments

# 3+ requests
# Returns all fields (over-fetching)
</code></pre>
<p><strong>GraphQL:</strong></p>
<pre><code class="language-graphql"># Single request
query {
  user(id: 123) {
    name
    email
    posts {
      title
      comments {
        text
      }
    }
  }
}

# 1 request
# Returns only requested fields
</code></pre>
<hr>
<h3>When to Use Each</h3>
<pre><code class="language-ruby"># Use Grape when:
✅ Building REST API quickly
✅ Simple CRUD operations
✅ Team familiar with REST
✅ Public API (REST more common)
✅ Caching is critical

# Use GraphQL when:
✅ Complex nested data
✅ Mobile apps (bandwidth)
✅ Rapid frontend changes
✅ Multiple client types
✅ Real-time subscriptions needed
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Grape</strong> = REST framework</li>
<li><strong>GraphQL</strong> = query language</li>
<li><strong>Grape</strong> faster to start</li>
<li><strong>GraphQL</strong> more flexible</li>
<li><strong>Grape</strong> for simple APIs</li>
<li><strong>GraphQL</strong> for complex data</li>
<li><strong>Both</strong> have trade-offs</li>
<li><strong>Choose</strong> based on needs</li>
<li><strong>Can use</strong> both together</li>
<li><strong>Test</strong> with real use cases</li>
</ol>
<h1>Frontend Integration Interview Questions</h1>
<h2>JavaScript Frameworks</h2>
<h2>Question 260: How do you integrate React or Vue with Rails?</h2>
<h3>Answer</h3>
<p>Integrate React/Vue with Rails using <strong>Webpacker/Shakapacker</strong> (Rails 6), <strong>Importmaps</strong> (Rails 7), <strong>esbuild/Vite</strong>, or <strong>API-only approach</strong>. Choose based on complexity and requirements.</p>
<hr>
<h3>Theory: Frontend Integration Architecture</h3>
<p><strong>Why integrate JavaScript frameworks with Rails?</strong></p>
<ol>
<li><strong>Progressive Enhancement</strong>: Add interactivity to server-rendered pages</li>
<li><strong>Rich User Interfaces</strong>: Complex components (dashboards, editors, charts)</li>
<li><strong>Real-time Updates</strong>: Live data without page refreshes</li>
<li><strong>Single Page Application</strong>: Client-side routing and state management</li>
<li><strong>Mobile-like Experience</strong>: Smooth transitions and instant feedback</li>
</ol>
<p><strong>Integration Spectrum:</strong></p>
<pre><code>Minimal JS         →         Full SPA
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Sprinkles  |  Islands  |  Hybrid  |  API-Only
(Stimulus) | (Hotwire) | (SSR)    | (Separate)
</code></pre>
<p><strong>Architecture Patterns:</strong></p>
<ol>
<li><p><strong>Monolithic (Traditional)</strong></p>
<ul>
<li>Rails serves HTML + embedded JS</li>
<li>JavaScript enhances server-rendered pages</li>
<li>Shared codebase, simpler deployment</li>
<li>Limited to page-based navigation</li>
</ul>
</li>
<li><p><strong>Hybrid (Modern Rails)</strong></p>
<ul>
<li>Rails handles routing and initial render</li>
<li>React/Vue components for interactive sections</li>
<li>Best of both worlds</li>
<li>Complexity in asset pipeline</li>
</ul>
</li>
<li><p><strong>API-Driven (Decoupled)</strong></p>
<ul>
<li>Rails provides JSON API only</li>
<li>Separate React/Vue application</li>
<li>Complete separation of concerns</li>
<li>Two deployments to manage</li>
</ul>
</li>
</ol>
<p><strong>Build Tool Evolution:</strong></p>
<pre><code>Rails 3-5: Asset Pipeline (Sprockets)
  ↓
Rails 6: Webpacker (Webpack)
  ↓
Rails 7: Multiple options (Importmaps, esbuild, Vite)
  ↓
Future: Native ESM + HTTP/2
</code></pre>
<hr>
<h3>Approach 1: Importmaps (Rails 7 Default)</h3>
<p><strong>Theory: Import Maps Explained</strong></p>
<p>Import maps are a browser standard (supported in Chrome 89+, Firefox 108+, Safari 16.4+) that allow you to control how JavaScript modules are resolved, without requiring a build step.</p>
<p><strong>How Import Maps Work:</strong></p>
<pre><code class="language-javascript">// Traditional way (requires bundler)
import React from &#39;react&#39;  // Bundler resolves to node_modules

// With Import Maps (no bundler needed)
&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    &quot;react&quot;: &quot;https://cdn.skypack.dev/react@18.2.0&quot;
  }
}
&lt;/script&gt;

&lt;script type=&quot;module&quot;&gt;
import React from &#39;react&#39;  // Browser resolves via import map
&lt;/script&gt;
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li>✅ No Node.js required</li>
<li>✅ No build step (faster development)</li>
<li>✅ HTTP/2 multiplexing (parallel downloads)</li>
<li>✅ Browser-native caching</li>
<li>✅ Simpler deployment</li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li>❌ No JSX transformation (use .jsx via pin or use HTM)</li>
<li>❌ Larger initial payload (no bundling)</li>
<li>❌ Requires HTTP/2 for performance</li>
<li>❌ Limited browser support (need polyfill for old browsers)</li>
</ul>
<p><strong>When to Use:</strong></p>
<ul>
<li>Simple React/Vue integration</li>
<li>Modern browser requirement acceptable</li>
<li>Prefer simplicity over optimization</li>
<li>Small to medium applications</li>
</ul>
<pre><code class="language-ruby"># Rails 7 default - no Node.js needed
# Gemfile
gem &#39;importmap-rails&#39;

# Install
rails importmap:install

# config/importmap.rb
# Pin npm packages by running ./bin/importmap pin &lt;package-name&gt;

pin &quot;application&quot;, preload: true
pin &quot;react&quot;, to: &quot;https://ga.jspm.io/npm:react@18.2.0/index.js&quot;
pin &quot;react-dom&quot;, to: &quot;https://ga.jspm.io/npm:react-dom@18.2.0/index.js&quot;

# Add React (automatically adds to importmap.rb)
./bin/importmap pin react react-dom

# app/javascript/application.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import App from &#39;./components/App&#39;

document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; {
  const root = document.getElementById(&#39;root&#39;)
  if (root) {
    ReactDOM.render(&lt;App /&gt;, root)
  }
})

# app/javascript/components/App.jsx
// Use HTM for JSX-like syntax without compilation
import { html } from &#39;htm/preact&#39;

export default function App() {
  return html`&lt;h1&gt;Hello from React!&lt;/h1&gt;`
}

# Or use plain createElement
export default function App() {
  return React.createElement(&#39;h1&#39;, null, &#39;Hello from React!&#39;)
}

# app/views/layouts/application.html.erb
&lt;%= javascript_importmap_tags %&gt;
&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;

# Generated HTML includes:
# &lt;script type=&quot;importmap&quot;&gt;
#   { &quot;imports&quot;: { &quot;react&quot;: &quot;https://...&quot;, ... } }
# &lt;/script&gt;
# &lt;script type=&quot;module&quot; src=&quot;/assets/application.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><strong>Import Map Resolution Process:</strong></p>
<pre><code>1. Browser parses HTML
2. Finds &lt;script type=&quot;importmap&quot;&gt;
3. Registers module mappings
4. When import React from &#39;react&#39; encountered:
   - Looks up &#39;react&#39; in import map
   - Resolves to CDN URL
   - Fetches from CDN
   - Caches (standard HTTP caching)
5. Module available for use
</code></pre>
<p><strong>Performance Considerations:</strong></p>
<pre><code class="language-ruby"># HTTP/2 Server Push for critical modules
# config/environments/production.rb
config.action_cable.mount_path = &#39;/cable&#39;

# Preload critical JavaScript
pin &quot;application&quot;, preload: true  # Downloaded immediately
pin &quot;helper&quot;, preload: false      # Downloaded when imported

# Use CDN for packages (better caching across sites)
pin &quot;react&quot;, to: &quot;https://cdn.jsdelivr.net/npm/react@18/+esm&quot;
</code></pre>
<hr>
<h3>Approach 2: Shakapacker (Webpack)</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;shakapacker&#39;

# Install
rails shakapacker:install
rails shakapacker:install:react  # or :vue

# app/javascript/packs/application.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import App from &#39;../components/App&#39;

document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; {
  ReactDOM.render(
    &lt;App /&gt;,
    document.getElementById(&#39;root&#39;)
  )
})

# app/views/layouts/application.html.erb
&lt;%= javascript_pack_tag &#39;application&#39; %&gt;
&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre>
<hr>
<h3>Approach 3: esbuild (Fast Build)</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;jsbundling-rails&#39;

# Install
rails javascript:install:esbuild

# package.json
{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;esbuild app/javascript/*.* --bundle --outdir=app/assets/builds&quot;
  },
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;^18.0.0&quot;,
    &quot;react-dom&quot;: &quot;^18.0.0&quot;
  }
}

# app/javascript/application.jsx
import React from &#39;react&#39;
import { createRoot } from &#39;react-dom/client&#39;
import App from &#39;./components/App&#39;

const root = createRoot(document.getElementById(&#39;root&#39;))
root.render(&lt;App /&gt;)
</code></pre>
<hr>
<h3>Approach 4: Vite (Modern &amp; Fast)</h3>
<pre><code class="language-ruby"># Gemfile
gem &#39;vite_rails&#39;

# Install
bundle exec vite install

# vite.config.ts
import { defineConfig } from &#39;vite&#39;
import RubyPlugin from &#39;vite-plugin-ruby&#39;
import react from &#39;@vitejs/plugin-react&#39;

export default defineConfig({
  plugins: [
    RubyPlugin(),
    react()
  ]
})

# app/frontend/entrypoints/application.jsx
import React from &#39;react&#39;
import { createRoot } from &#39;react-dom/client&#39;
import App from &#39;../components/App&#39;

const root = createRoot(document.getElementById(&#39;root&#39;))
root.render(&lt;App /&gt;)

# app/views/layouts/application.html.erb
&lt;%= vite_javascript_tag &#39;application&#39; %&gt;
</code></pre>
<hr>
<h3>Approach 5: API-Only + Separate Frontend</h3>
<pre><code class="language-ruby"># Rails as API backend
# config/application.rb
config.api_only = true

# React/Vue as separate app
# Frontend: create-react-app or Vite project
# Backend: Rails API on different port/domain

# Frontend .env
REACT_APP_API_URL=http://localhost:3000/api

# React component
import { useState, useEffect } from &#39;react&#39;

function Products() {
  const [products, setProducts] = useState([])
  
  useEffect(() =&gt; {
    fetch(`${process.env.REACT_APP_API_URL}/products`)
      .then(res =&gt; res.json())
      .then(data =&gt; setProducts(data))
  }, [])
  
  return (
    &lt;div&gt;
      {products.map(product =&gt; (
        &lt;div key={product.id}&gt;{product.name}&lt;/div&gt;
      ))}
    &lt;/div&gt;
  )
}
</code></pre>
<hr>
<h3>Vue Integration</h3>
<pre><code class="language-ruby"># Using Vite
# Gemfile
gem &#39;vite_rails&#39;

# Install
bundle exec vite install
npm install vue

# vite.config.ts
import { defineConfig } from &#39;vite&#39;
import RubyPlugin from &#39;vite-plugin-ruby&#39;
import vue from &#39;@vitejs/plugin-vue&#39;

export default defineConfig({
  plugins: [
    RubyPlugin(),
    vue()
  ]
})

# app/frontend/entrypoints/application.js
import { createApp } from &#39;vue&#39;
import App from &#39;../components/App.vue&#39;

const app = createApp(App)
app.mount(&#39;#app&#39;)

# app/frontend/components/App.vue
&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;{{ message }}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      message: &#39;Hello from Vue!&#39;
    }
  }
}
&lt;/script&gt;
</code></pre>
<hr>
<h3>Comparison Table</h3>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Speed</th>
<th>Complexity</th>
<th>Best For</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Importmaps</strong></td>
<td>Fast</td>
<td>Low</td>
<td>Simple apps, HTTP/2</td>
</tr>
<tr>
<td><strong>Shakapacker</strong></td>
<td>Medium</td>
<td>High</td>
<td>Complex apps, legacy</td>
</tr>
<tr>
<td><strong>esbuild</strong></td>
<td>Very Fast</td>
<td>Medium</td>
<td>Modern apps</td>
</tr>
<tr>
<td><strong>Vite</strong></td>
<td>Very Fast</td>
<td>Medium</td>
<td>Modern apps, HMR</td>
</tr>
<tr>
<td><strong>API-Only</strong></td>
<td>N/A</td>
<td>High</td>
<td>SPAs, mobile apps</td>
</tr>
</tbody></table>
<hr>
<h3>Component Communication</h3>
<pre><code class="language-ruby"># Pass Rails data to React
# app/views/products/index.html.erb
&lt;div id=&quot;products-root&quot; 
     data-products=&#39;&lt;%= @products.to_json %&gt;&#39;&gt;
&lt;/div&gt;

# app/javascript/components/Products.jsx
import React from &#39;react&#39;

function Products({ initialProducts }) {
  const [products, setProducts] = React.useState(initialProducts)
  
  return (
    &lt;div&gt;
      {products.map(p =&gt; (
        &lt;div key={p.id}&gt;{p.name}&lt;/div&gt;
      ))}
    &lt;/div&gt;
  )
}

# app/javascript/application.js
document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; {
  const root = document.getElementById(&#39;products-root&#39;)
  if (root) {
    const initialProducts = JSON.parse(root.dataset.products)
    ReactDOM.render(&lt;Products initialProducts={initialProducts} /&gt;, root)
  }
})
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Importmaps</strong> simplest (Rails 7)</li>
<li><strong>Vite</strong> fastest modern option</li>
<li><strong>esbuild</strong> good balance</li>
<li><strong>API-only</strong> for SPAs</li>
<li><strong>Shakapacker</strong> for legacy</li>
<li><strong>Choose</strong> based on needs</li>
<li><strong>HMR</strong> for development</li>
<li><strong>Bundle size</strong> matters</li>
<li><strong>TypeScript</strong> support varies</li>
<li><strong>Test</strong> build times</li>
</ol>
<hr>
<h2>Question 261-263 Summary (State Management)</h2>
<p><strong>Q261-262: State Management in Rails + React</strong></p>
<pre><code class="language-jsx">// 1. React Context (simple state)
import { createContext, useContext, useState } from &#39;react&#39;

const AppContext = createContext()

export function AppProvider({ children }) {
  const [user, setUser] = useState(null)
  const [products, setProducts] = useState([])
  
  return (
    &lt;AppContext.Provider value={{ user, setUser, products, setProducts }}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  )
}

export const useAppContext = () =&gt; useContext(AppContext)

// 2. Redux (complex state)
// store.js
import { configureStore } from &#39;@reduxjs/toolkit&#39;
import userReducer from &#39;./userSlice&#39;
import productsReducer from &#39;./productsSlice&#39;

export const store = configureStore({
  reducer: {
    user: userReducer,
    products: productsReducer
  }
})

// userSlice.js
import { createSlice, createAsyncThunk } from &#39;@reduxjs/toolkit&#39;

export const fetchUser = createAsyncThunk(
  &#39;user/fetch&#39;,
  async (userId) =&gt; {
    const response = await fetch(`/api/users/${userId}`)
    return response.json()
  }
)

const userSlice = createSlice({
  name: &#39;user&#39;,
  initialState: { data: null, loading: false, error: null },
  reducers: {
    setUser: (state, action) =&gt; {
      state.data = action.payload
    }
  },
  extraReducers: (builder) =&gt; {
    builder
      .addCase(fetchUser.pending, (state) =&gt; {
        state.loading = true
      })
      .addCase(fetchUser.fulfilled, (state, action) =&gt; {
        state.loading = false
        state.data = action.payload
      })
      .addCase(fetchUser.rejected, (state, action) =&gt; {
        state.loading = false
        state.error = action.error.message
      })
  }
})

export const { setUser } = userSlice.actions
export default userSlice.reducer

// Component
import { useSelector, useDispatch } from &#39;react-redux&#39;
import { fetchUser } from &#39;./userSlice&#39;

function UserProfile() {
  const dispatch = useDispatch()
  const user = useSelector(state =&gt; state.user.data)
  const loading = useSelector(state =&gt; state.user.loading)
  
  useEffect(() =&gt; {
    dispatch(fetchUser(123))
  }, [])
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;
  
  return &lt;div&gt;{user?.name}&lt;/div&gt;
}

// 3. React Query (API state)
import { useQuery, useMutation, useQueryClient } from &#39;@tanstack/react-query&#39;

function Products() {
  const queryClient = useQueryClient()
  
  // Fetch products
  const { data: products, isLoading } = useQuery({
    queryKey: [&#39;products&#39;],
    queryFn: async () =&gt; {
      const res = await fetch(&#39;/api/products&#39;)
      return res.json()
    }
  })
  
  // Create product
  const createProduct = useMutation({
    mutationFn: async (newProduct) =&gt; {
      const res = await fetch(&#39;/api/products&#39;, {
        method: &#39;POST&#39;,
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
        body: JSON.stringify(newProduct)
      })
      return res.json()
    },
    onSuccess: () =&gt; {
      // Invalidate and refetch
      queryClient.invalidateQueries([&#39;products&#39;])
    }
  })
  
  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;
  
  return (
    &lt;div&gt;
      {products.map(p =&gt; &lt;div key={p.id}&gt;{p.name}&lt;/div&gt;)}
      &lt;button onClick={() =&gt; createProduct.mutate({ name: &#39;New Product&#39; })}&gt;
        Add Product
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

// 4. Zustand (lightweight)
import create from &#39;zustand&#39;

const useStore = create((set) =&gt; ({
  user: null,
  products: [],
  setUser: (user) =&gt; set({ user }),
  setProducts: (products) =&gt; set({ products }),
  addProduct: (product) =&gt; set((state) =&gt; ({
    products: [...state.products, product]
  }))
}))

function Component() {
  const user = useStore(state =&gt; state.user)
  const setUser = useStore(state =&gt; state.setUser)
  
  return &lt;div&gt;{user?.name}&lt;/div&gt;
}
</code></pre>
<p><strong>Q263: Vue Best Practices</strong></p>
<pre><code class="language-vue">&lt;!-- 1. Composition API with Rails API --&gt;
&lt;script setup&gt;
import { ref, onMounted } from &#39;vue&#39;

const products = ref([])
const loading = ref(false)

async function fetchProducts() {
  loading.value = true
  try {
    const response = await fetch(&#39;/api/products&#39;)
    products.value = await response.json()
  } finally {
    loading.value = false
  }
}

onMounted(() =&gt; {
  fetchProducts()
})
&lt;/script&gt;

&lt;template&gt;
  &lt;div v-if=&quot;loading&quot;&gt;Loading...&lt;/div&gt;
  &lt;div v-else&gt;
    &lt;div v-for=&quot;product in products&quot; :key=&quot;product.id&quot;&gt;
      {{ product.name }}
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;!-- 2. Pinia store (Vue state management) --&gt;
// stores/products.js
import { defineStore } from &#39;pinia&#39;

export const useProductsStore = defineStore(&#39;products&#39;, {
  state: () =&gt; ({
    products: [],
    loading: false
  }),
  
  actions: {
    async fetchProducts() {
      this.loading = true
      try {
        const response = await fetch(&#39;/api/products&#39;)
        this.products = await response.json()
      } finally {
        this.loading = false
      }
    },
    
    async createProduct(product) {
      const response = await fetch(&#39;/api/products&#39;, {
        method: &#39;POST&#39;,
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
        body: JSON.stringify(product)
      })
      const newProduct = await response.json()
      this.products.push(newProduct)
    }
  },
  
  getters: {
    activeProducts: (state) =&gt; state.products.filter(p =&gt; p.active)
  }
})

&lt;!-- Component --&gt;
&lt;script setup&gt;
import { useProductsStore } from &#39;@/stores/products&#39;

const productsStore = useProductsStore()

onMounted(() =&gt; {
  productsStore.fetchProducts()
})
&lt;/script&gt;

&lt;template&gt;
  &lt;div v-for=&quot;product in productsStore.products&quot; :key=&quot;product.id&quot;&gt;
    {{ product.name }}
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<hr>
<h2>Question 264-265 Summary (Performance &amp; Forms)</h2>
<p><strong>Q264: React/Redux Performance</strong></p>
<pre><code class="language-jsx">// 1. Memoization
import { memo, useMemo, useCallback } from &#39;react&#39;

const ProductItem = memo(({ product, onUpdate }) =&gt; {
  console.log(&#39;Rendering:&#39;, product.name)
  return &lt;div onClick={() =&gt; onUpdate(product.id)}&gt;{product.name}&lt;/div&gt;
})

function ProductList({ products }) {
  // Memoize expensive calculations
  const sortedProducts = useMemo(() =&gt; {
    return [...products].sort((a, b) =&gt; a.name.localeCompare(b.name))
  }, [products])
  
  // Memoize callbacks
  const handleUpdate = useCallback((id) =&gt; {
    dispatch(updateProduct(id))
  }, [dispatch])
  
  return (
    &lt;div&gt;
      {sortedProducts.map(p =&gt; (
        &lt;ProductItem key={p.id} product={p} onUpdate={handleUpdate} /&gt;
      ))}
    &lt;/div&gt;
  )
}

// 2. Redux selectors with Reselect
import { createSelector } from &#39;@reduxjs/toolkit&#39;

const selectProducts = state =&gt; state.products.items
const selectFilter = state =&gt; state.products.filter

export const selectFilteredProducts = createSelector(
  [selectProducts, selectFilter],
  (products, filter) =&gt; {
    // Only recomputes when products or filter change
    return products.filter(p =&gt; p.category === filter)
  }
)

// 3. Code splitting
import { lazy, Suspense } from &#39;react&#39;

const ProductDetails = lazy(() =&gt; import(&#39;./ProductDetails&#39;))

function App() {
  return (
    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
      &lt;ProductDetails /&gt;
    &lt;/Suspense&gt;
  )
}

// 4. Virtual scrolling (react-window)
import { FixedSizeList } from &#39;react-window&#39;

function ProductList({ products }) {
  const Row = ({ index, style }) =&gt; (
    &lt;div style={style}&gt;
      {products[index].name}
    &lt;/div&gt;
  )
  
  return (
    &lt;FixedSizeList
      height={600}
      itemCount={products.length}
      itemSize={50}
      width=&quot;100%&quot;
    &gt;
      {Row}
    &lt;/FixedSizeList&gt;
  )
}
</code></pre>
<p><strong>Q265: Form Validations</strong></p>
<pre><code class="language-jsx">// 1. React Hook Form with Rails API
import { useForm } from &#39;react-hook-form&#39;

function ProductForm() {
  const { register, handleSubmit, formState: { errors }, setError } = useForm()
  
  const onSubmit = async (data) =&gt; {
    try {
      const response = await fetch(&#39;/api/products&#39;, {
        method: &#39;POST&#39;,
        headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
        body: JSON.stringify({ product: data })
      })
      
      if (!response.ok) {
        const errors = await response.json()
        // Set server errors
        Object.keys(errors).forEach(field =&gt; {
          setError(field, { message: errors[field].join(&#39;, &#39;) })
        })
      }
    } catch (error) {
      console.error(error)
    }
  }
  
  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;input
        {...register(&#39;name&#39;, {
          required: &#39;Name is required&#39;,
          minLength: { value: 3, message: &#39;Min 3 characters&#39; }
        })}
      /&gt;
      {errors.name &amp;&amp; &lt;span&gt;{errors.name.message}&lt;/span&gt;}
      
      &lt;input
        {...register(&#39;price&#39;, {
          required: &#39;Price is required&#39;,
          min: { value: 0, message: &#39;Must be positive&#39; }
        })}
        type=&quot;number&quot;
      /&gt;
      {errors.price &amp;&amp; &lt;span&gt;{errors.price.message}&lt;/span&gt;}
      
      &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  )
}

// 2. Vue with Vuelidate
&lt;script setup&gt;
import { useVuelidate } from &#39;@vuelidate/core&#39;
import { required, minLength, numeric } from &#39;@vuelidate/validators&#39;

const state = reactive({
  name: &#39;&#39;,
  price: 0
})

const rules = {
  name: { required, minLength: minLength(3) },
  price: { required, numeric }
}

const v$ = useVuelidate(rules, state)

async function submit() {
  const isValid = await v$.value.$validate()
  
  if (!isValid) return
  
  try {
    const response = await fetch(&#39;/api/products&#39;, {
      method: &#39;POST&#39;,
      headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
      body: JSON.stringify({ product: state })
    })
    
    if (!response.ok) {
      const errors = await response.json()
      // Handle server errors
    }
  } catch (error) {
    console.error(error)
  }
}
&lt;/script&gt;

&lt;template&gt;
  &lt;form @submit.prevent=&quot;submit&quot;&gt;
    &lt;input v-model=&quot;state.name&quot; /&gt;
    &lt;span v-if=&quot;v$.name.$error&quot;&gt;{{ v$.name.$errors[0].$message }}&lt;/span&gt;
    
    &lt;input v-model=&quot;state.price&quot; type=&quot;number&quot; /&gt;
    &lt;span v-if=&quot;v$.price.$error&quot;&gt;{{ v$.price.$errors[0].$message }}&lt;/span&gt;
    
    &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
&lt;/template&gt;
</code></pre>
<hr>
<h2>Server-Side Rendering</h2>
<h2>Question 266-269: SSR Implementation</h2>
<p><strong>Q266-267: Server-Side Rendering in Rails</strong></p>
<pre><code class="language-ruby"># Using react_on_rails gem
# Gemfile
gem &#39;react_on_rails&#39;
gem &#39;webpacker&#39;

# Install
rails generate react_on_rails:install

# app/javascript/bundles/HelloWorld/components/HelloWorld.jsx
import React from &#39;react&#39;

export default function HelloWorld({ name }) {
  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
}

# app/javascript/packs/hello-world-bundle.js
import ReactOnRails from &#39;react-on-rails&#39;
import HelloWorld from &#39;../bundles/HelloWorld/components/HelloWorld&#39;

ReactOnRails.register({ HelloWorld })

# app/controllers/hello_world_controller.rb
class HelloWorldController &lt; ApplicationController
  def index
    @hello_world_props = { name: &#39;Stranger&#39; }
  end
end

# app/views/hello_world/index.html.erb
&lt;%= react_component(&#39;HelloWorld&#39;, props: @hello_world_props, prerender: true) %&gt;

# Server renders HTML, React hydrates on client
</code></pre>
<p><strong>Q268: React Hydration</strong></p>
<pre><code class="language-jsx">// Hydration: Making server-rendered HTML interactive

// Server-rendered HTML:
&lt;div id=&quot;root&quot;&gt;
  &lt;h1&gt;Hello, World!&lt;/h1&gt;  &lt;!-- Static HTML from server --&gt;
&lt;/div&gt;

// Client-side hydration:
import { hydrateRoot } from &#39;react-dom/client&#39;

const root = document.getElementById(&#39;root&#39;)
hydrateRoot(root, &lt;App /&gt;)  // React attaches event listeners

// Before hydration: Static HTML (no interactivity)
// After hydration: Interactive React app

// Important: Server and client render MUST match
// Otherwise: Hydration mismatch warnings
</code></pre>
<p><strong>Q269: Pre-rendering React</strong></p>
<pre><code class="language-ruby"># Using react_on_rails
# config/initializers/react_on_rails.rb
ReactOnRails.configure do |config|
  config.prerender = true
  config.server_bundle_js_file = &#39;server-bundle.js&#39;
end

# app/javascript/packs/server-bundle.js
import ReactOnRails from &#39;react-on-rails&#39;
import HelloWorld from &#39;../bundles/HelloWorld/components/HelloWorld&#39;

ReactOnRails.register({ HelloWorld })

# View
&lt;%= react_component(&#39;HelloWorld&#39;, props: @props, prerender: true) %&gt;

# Benefits:
# - SEO friendly (crawlers see content)
# - Faster perceived load time
# - Works without JavaScript
</code></pre>
<hr>
<h2>Modern Web Features</h2>
<h2>Question 270-278 Summary (AJAX, WebSockets, PWA)</h2>
<p><strong>Q270: AJAX with Stimulus</strong></p>
<pre><code class="language-javascript">// app/javascript/controllers/products_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  static targets = [&quot;list&quot;]
  
  async load() {
    const response = await fetch(&#39;/api/products&#39;)
    const products = await response.json()
    
    this.listTarget.innerHTML = products.map(p =&gt; `
      &lt;div&gt;${p.name}&lt;/div&gt;
    `).join(&#39;&#39;)
  }
  
  async create(event) {
    event.preventDefault()
    
    const formData = new FormData(event.target)
    
    const response = await fetch(&#39;/api/products&#39;, {
      method: &#39;POST&#39;,
      headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
      body: JSON.stringify(Object.fromEntries(formData))
    })
    
    if (response.ok) {
      this.load()  // Reload list
    }
  }
}

// HTML
&lt;div data-controller=&quot;products&quot;&gt;
  &lt;button data-action=&quot;click-&gt;products#load&quot;&gt;Load Products&lt;/button&gt;
  &lt;div data-products-target=&quot;list&quot;&gt;&lt;/div&gt;
  
  &lt;form data-action=&quot;submit-&gt;products#create&quot;&gt;
    &lt;input name=&quot;name&quot; /&gt;
    &lt;button type=&quot;submit&quot;&gt;Create&lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;
</code></pre>
<p><strong>Q271: ActionCable Live Updates</strong></p>
<pre><code class="language-ruby"># app/channels/products_channel.rb
class ProductsChannel &lt; ApplicationCable::Channel
  def subscribed
    stream_from &#39;products&#39;
  end
end

# Broadcast from controller/job
class ProductsController &lt; ApplicationController
  def create
    @product = Product.create!(product_params)
    
    ActionCable.server.broadcast(&#39;products&#39;, {
      action: &#39;created&#39;,
      product: ProductSerializer.new(@product).as_json
    })
    
    render json: @product
  end
end

# JavaScript client
import consumer from &#39;./consumer&#39;

consumer.subscriptions.create(&#39;ProductsChannel&#39;, {
  received(data) {
    console.log(&#39;Received:&#39;, data)
    if (data.action === &#39;created&#39;) {
      addProductToList(data.product)
    }
  }
})
</code></pre>
<p><strong>Q272: ActionCable vs Hotwire</strong></p>
<pre><code class="language-ruby"># ActionCable: WebSocket real-time communication
# - Bidirectional communication
# - Custom channels and messages
# - More control, more code

# Hotwire (Turbo + Stimulus): Server-rendered HTML over WebSocket
# - Turbo Streams for live updates
# - Less JavaScript needed
# - Simpler for CRUD operations

# ActionCable example:
class ChatChannel &lt; ApplicationCable::Channel
  def receive(data)
    ActionCable.server.broadcast(&#39;chat&#39;, message: data[&#39;message&#39;])
  end
end

# Hotwire/Turbo example:
# Controller
def create
  @product = Product.create!(product_params)
  
  respond_to do |format|
    format.turbo_stream  # Automatically broadcasts
  end
end

# app/views/products/create.turbo_stream.erb
&lt;%= turbo_stream.append &#39;products&#39;, @product %&gt;

# HTML automatically updates, no JavaScript needed
</code></pre>
<p><strong>Q273: ActionCable with React/Vue</strong></p>
<pre><code class="language-jsx">// React with ActionCable
import { useEffect, useState } from &#39;react&#39;
import { createConsumer } from &#39;@rails/actioncable&#39;

function Products() {
  const [products, setProducts] = useState([])
  
  useEffect(() =&gt; {
    const cable = createConsumer(&#39;ws://localhost:3000/cable&#39;)
    
    const subscription = cable.subscriptions.create(&#39;ProductsChannel&#39;, {
      received(data) {
        if (data.action === &#39;created&#39;) {
          setProducts(prev =&gt; [...prev, data.product])
        }
      }
    })
    
    return () =&gt; {
      subscription.unsubscribe()
    }
  }, [])
  
  return (
    &lt;div&gt;
      {products.map(p =&gt; &lt;div key={p.id}&gt;{p.name}&lt;/div&gt;)}
    &lt;/div&gt;
  )
}

// Vue with ActionCable
&lt;script setup&gt;
import { ref, onMounted, onUnmounted } from &#39;vue&#39;
import { createConsumer } from &#39;@rails/actioncable&#39;

const products = ref([])
let subscription = null

onMounted(() =&gt; {
  const cable = createConsumer(&#39;ws://localhost:3000/cable&#39;)
  
  subscription = cable.subscriptions.create(&#39;ProductsChannel&#39;, {
    received(data) {
      if (data.action === &#39;created&#39;) {
        products.value.push(data.product)
      }
    }
  })
})

onUnmounted(() =&gt; {
  subscription?.unsubscribe()
})
&lt;/script&gt;
</code></pre>
<p><strong>Q274: Livewire vs Hotwire</strong></p>
<pre><code class="language-ruby"># Livewire (Laravel): Full component in PHP
# - Write components in PHP
# - Automatic DOM updates
# - Laravel specific

# Hotwire (Rails): HTML over the wire
# - Write components in Ruby/ERB
# - Turbo Streams for updates
# - Rails conventions

# Both: Minimal JavaScript, server-driven
</code></pre>
<p><strong>Q275: Long-polling, WebSockets, SSE</strong></p>
<pre><code class="language-ruby"># 1. Long-polling (legacy)
# Client repeatedly requests, server holds until data
def poll
  Timeout.timeout(30) do
    until new_data?
      sleep 1
    end
  end
  render json: get_data
rescue Timeout::Error
  head :no_content
end

# 2. WebSockets (ActionCable)
# Bidirectional, persistent connection
class ChatChannel &lt; ApplicationCable::Channel
  def receive(data)
    broadcast_message(data)
  end
end

# 3. Server-Sent Events (SSE)
# Server pushes, client receives
def stream
  response.headers[&#39;Content-Type&#39;] = &#39;text/event-stream&#39;
  
  sse = SSE.new(response.stream)
  
  begin
    loop do
      sse.write({ data: get_updates })
      sleep 1
    end
  ensure
    sse.close
  end
end

# JavaScript
const eventSource = new EventSource(&#39;/stream&#39;)
eventSource.onmessage = (event) =&gt; {
  console.log(JSON.parse(event.data))
}
</code></pre>
<p><strong>Q276: PWA with Rails</strong></p>
<pre><code class="language-ruby"># 1. Service Worker
# app/javascript/service-worker.js
self.addEventListener(&#39;install&#39;, (event) =&gt; {
  event.waitUntil(
    caches.open(&#39;v1&#39;).then((cache) =&gt; {
      return cache.addAll([
        &#39;/&#39;,
        &#39;/assets/application.css&#39;,
        &#39;/assets/application.js&#39;
      ])
    })
  )
})

self.addEventListener(&#39;fetch&#39;, (event) =&gt; {
  event.respondWith(
    caches.match(event.request).then((response) =&gt; {
      return response || fetch(event.request)
    })
  )
})

# 2. Manifest
# public/manifest.json
{
  &quot;name&quot;: &quot;My Rails App&quot;,
  &quot;short_name&quot;: &quot;Rails App&quot;,
  &quot;start_url&quot;: &quot;/&quot;,
  &quot;display&quot;: &quot;standalone&quot;,
  &quot;background_color&quot;: &quot;#ffffff&quot;,
  &quot;theme_color&quot;: &quot;#000000&quot;,
  &quot;icons&quot;: [
    {
      &quot;src&quot;: &quot;/icon-192.png&quot;,
      &quot;sizes&quot;: &quot;192x192&quot;,
      &quot;type&quot;: &quot;image/png&quot;
    }
  ]
}

# 3. Register service worker
# app/views/layouts/application.html.erb
&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;
&lt;script&gt;
  if (&#39;serviceWorker&#39; in navigator) {
    navigator.serviceWorker.register(&#39;/service-worker.js&#39;)
  }
&lt;/script&gt;
</code></pre>
<p><strong>Q277-278: Code Splitting &amp; Lazy Loading</strong></p>
<pre><code class="language-jsx">// React lazy loading
import { lazy, Suspense } from &#39;react&#39;

const ProductDetails = lazy(() =&gt; import(&#39;./ProductDetails&#39;))
const Dashboard = lazy(() =&gt; import(&#39;./Dashboard&#39;))

function App() {
  return (
    &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/products/:id&quot; element={&lt;ProductDetails /&gt;} /&gt;
        &lt;Route path=&quot;/dashboard&quot; element={&lt;Dashboard /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/Suspense&gt;
  )
}

// Vue lazy loading
const ProductDetails = () =&gt; import(&#39;./ProductDetails.vue&#39;)

const routes = [
  {
    path: &#39;/products/:id&#39;,
    component: ProductDetails  // Loaded on demand
  }
]

// Webpack magic comments for chunk naming
const Dashboard = () =&gt; import(/* webpackChunkName: &quot;dashboard&quot; */ &#39;./Dashboard&#39;)
</code></pre>
<hr>
<h2>CSS and Styling</h2>
<h2>Question 279: CSS Frameworks in Rails</h2>
<pre><code class="language-ruby"># Tailwind CSS
# Gemfile
gem &#39;tailwindcss-rails&#39;

# Install
rails tailwindcss:install

# app/views/products/index.html.erb
&lt;div class=&quot;container mx-auto&quot;&gt;
  &lt;h1 class=&quot;text-3xl font-bold text-gray-900&quot;&gt;Products&lt;/h1&gt;
  &lt;div class=&quot;grid grid-cols-3 gap-4&quot;&gt;
    &lt;% @products.each do |product| %&gt;
      &lt;div class=&quot;bg-white shadow rounded-lg p-4&quot;&gt;
        &lt;h2 class=&quot;text-xl font-semibold&quot;&gt;&lt;%= product.name %&gt;&lt;/h2&gt;
        &lt;p class=&quot;text-gray-600&quot;&gt;&lt;%= product.price %&gt;&lt;/p&gt;
      &lt;/div&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
&lt;/div&gt;

# Bootstrap
# Gemfile
gem &#39;bootstrap&#39;

# app/assets/stylesheets/application.scss
@import &#39;bootstrap&#39;;

# app/views/products/index.html.erb
&lt;div class=&quot;container&quot;&gt;
  &lt;h1 class=&quot;display-4&quot;&gt;Products&lt;/h1&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;% @products.each do |product| %&gt;
      &lt;div class=&quot;col-md-4&quot;&gt;
        &lt;div class=&quot;card&quot;&gt;
          &lt;div class=&quot;card-body&quot;&gt;
            &lt;h5 class=&quot;card-title&quot;&gt;&lt;%= product.name %&gt;&lt;/h5&gt;
            &lt;p class=&quot;card-text&quot;&gt;&lt;%= product.price %&gt;&lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<hr>
<h2>Build Tools</h2>
<h2>Question 280: Incremental Static Regeneration (ISR)</h2>
<pre><code class="language-javascript">// Next.js ISR with Rails API backend
// pages/products/[id].js
export async function getStaticProps({ params }) {
  const res = await fetch(`https://api.example.com/products/${params.id}`)
  const product = await res.json()
  
  return {
    props: { product },
    revalidate: 60  // Regenerate page every 60 seconds
  }
}

export async function getStaticPaths() {
  const res = await fetch(&#39;https://api.example.com/products&#39;)
  const products = await res.json()
  
  const paths = products.map(product =&gt; ({
    params: { id: product.id.toString() }
  }))
  
  return {
    paths,
    fallback: &#39;blocking&#39;  // Generate on first request
  }
}

export default function Product({ product }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;{product.name}&lt;/h1&gt;
      &lt;p&gt;{product.description}&lt;/p&gt;
    &lt;/div&gt;
  )
}

// Benefits:
// - Static generation (fast)
// - Automatic updates (revalidate)
// - Best of static + dynamic
</code></pre>
<hr>
<h2>Summary of Questions 260-280</h2>
<p><strong>JavaScript Frameworks (260-265):</strong></p>
<ul>
<li>React/Vue integration (Importmaps, Vite, esbuild, API-only)</li>
<li>State management (Context, Redux, React Query, Pinia)</li>
<li>Performance optimization (memoization, code splitting)</li>
<li>Form validation (React Hook Form, Vuelidate)</li>
</ul>
<p><strong>Server-Side Rendering (266-269):</strong></p>
<ul>
<li>SSR implementation (react_on_rails gem)</li>
<li>Hydration concept (static HTML → interactive)</li>
<li>Pre-rendering benefits (SEO, performance)</li>
</ul>
<p><strong>Modern Web Features (270-278):</strong></p>
<ul>
<li>AJAX with Stimulus</li>
<li>ActionCable for WebSockets</li>
<li>Hotwire (Turbo + Stimulus)</li>
<li>Long-polling, WebSockets, SSE</li>
<li>PWA architecture</li>
<li>Code splitting and lazy loading</li>
</ul>
<p><strong>CSS &amp; Build Tools (279-280):</strong></p>
<ul>
<li>Tailwind CSS and Bootstrap integration</li>
<li>ISR with Next.js and Rails API</li>
</ul>
<p>ENDOFFILE</p>
<hr>
<h2>Additional Theory and Deep Dives</h2>
<h3>The Evolution of Rails Asset Management</h3>
<p><strong>Historical Context:</strong></p>
<pre><code>2010: Rails 3.1 - Asset Pipeline (Sprockets)
├─ CoffeeScript support
├─ SCSS/SASS compilation
├─ Asset concatenation
└─ Fingerprinting for cache busting

2019: Rails 6 - Webpacker (Webpack)
├─ Modern JavaScript (ES6+)
├─ React/Vue/Angular support
├─ Hot Module Replacement
└─ Code splitting

2021: Rails 7 - Multiple Options
├─ Importmaps (no build, native ESM)
├─ jsbundling-rails (esbuild, Rollup, Webpack)
├─ cssbundling-rails (Tailwind, PostCSS, Sass)
└─ Hotwire (minimal JavaScript)

Future: ESM + HTTP/3
├─ Native browser modules
├─ QUIC protocol
└─ Even faster asset delivery
</code></pre>
<p><strong>Why the Change?</strong></p>
<p>The JavaScript ecosystem evolved rapidly, and Rails adapted:</p>
<ol>
<li><strong>Webpacker Complexity</strong>: Webpack configuration became overwhelming</li>
<li><strong>Build Time</strong>: Large applications had slow webpack builds (5-10 minutes)</li>
<li><strong>Native ESM</strong>: Browsers gained native module support</li>
<li><strong>HTTP/2</strong>: Multiplexing made multiple small files efficient</li>
<li><strong>Developer Experience</strong>: Faster iteration without build steps</li>
</ol>
<hr>
<h3>Deep Dive: How Import Maps Work</h3>
<p><strong>The Module Resolution Problem:</strong></p>
<pre><code class="language-javascript">// You write this:
import React from &#39;react&#39;

// But browsers need:
import React from &#39;https://cdn.jsdelivr.net/npm/react@18.2.0/+esm&#39;

// Import maps bridge the gap:
{
  &quot;imports&quot;: {
    &quot;react&quot;: &quot;https://cdn.jsdelivr.net/npm/react@18.2.0/+esm&quot;
  }
}
</code></pre>
<p><strong>Import Map Structure:</strong></p>
<pre><code class="language-html">&lt;script type=&quot;importmap&quot;&gt;
{
  &quot;imports&quot;: {
    // Bare specifiers (package names)
    &quot;react&quot;: &quot;/assets/react-abc123.js&quot;,
    &quot;lodash&quot;: &quot;https://cdn.skypack.dev/lodash&quot;,
    
    // Path mapping
    &quot;@/components/&quot;: &quot;/assets/components/&quot;,
    
    // Scoped packages
    &quot;@rails/actioncable&quot;: &quot;/assets/actioncable.js&quot;
  },
  &quot;scopes&quot;: {
    // Different resolution per path
    &quot;/admin/&quot;: {
      &quot;react&quot;: &quot;/assets/react-admin-xyz789.js&quot;
    }
  }
}
&lt;/script&gt;
</code></pre>
<p><strong>Resolution Algorithm:</strong></p>
<pre><code class="language-javascript">// When browser encounters:
import Button from &#39;@/components/Button&#39;

// Resolution steps:
1. Check if URL or path → Use directly
2. Check scopes for current page
3. Check imports map
4. Apply path mapping: @/components/ → /assets/components/
5. Final URL: /assets/components/Button.js
6. Fetch and execute
</code></pre>
<p><strong>Browser Compatibility:</strong></p>
<pre><code class="language-javascript">// Check support
if (HTMLScriptElement.supports &amp;&amp; HTMLScriptElement.supports(&#39;importmap&#39;)) {
  console.log(&#39;Import maps supported!&#39;)
} else {
  console.log(&#39;Import maps NOT supported, load polyfill&#39;)
}

// Polyfill for older browsers
&lt;script async src=&quot;https://ga.jspm.io/npm:es-module-shims@1.6.2/dist/es-module-shims.js&quot;&gt;&lt;/script&gt;
</code></pre>
<hr>
<h3>Deep Dive: Webpack vs esbuild vs Vite</h3>
<p><strong>Build Tool Comparison:</strong></p>
<pre><code>Webpack (2012)
├─ Pros: Mature, extensive plugins, everything configurable
├─ Cons: Slow, complex configuration, steep learning curve
└─ Build time: ~60 seconds (large app)

esbuild (2020)
├─ Pros: Extremely fast (Go-based), simple config
├─ Cons: Limited plugins, less mature
└─ Build time: ~2 seconds (same app) - 30x faster!

Vite (2021)
├─ Pros: Fast dev (ESM), fast build (esbuild), great DX
├─ Cons: Newer, some edge cases
└─ Dev server: Instant, Build: ~5 seconds
</code></pre>
<p><strong>Performance Benchmark (Large Rails App):</strong></p>
<pre><code>Application: 50 components, 200 modules, 2MB JavaScript

Cold Start (First Build):
├─ Webpack:   87 seconds
├─ esbuild:    3 seconds (29x faster)
└─ Vite:       4 seconds (22x faster)

Hot Reload (Single File Change):
├─ Webpack:    2.1 seconds
├─ esbuild:    0.3 seconds (7x faster)
└─ Vite:       0.05 seconds (42x faster)

Production Build:
├─ Webpack:   124 seconds
├─ esbuild:     7 seconds (18x faster)
└─ Vite:       12 seconds (10x faster)
</code></pre>
<p><strong>Why is esbuild so fast?</strong></p>
<ol>
<li><strong>Written in Go</strong>: Compiled, not interpreted like JavaScript</li>
<li><strong>Parallelization</strong>: Uses all CPU cores efficiently</li>
<li><strong>Memory Efficiency</strong>: Optimized data structures</li>
<li><strong>Simplicity</strong>: Fewer features = less overhead</li>
</ol>
<p><strong>Why choose Vite over esbuild?</strong></p>
<p>Vite = esbuild (production) + Native ESM (development)</p>
<pre><code class="language-javascript">// Development Mode:
// Vite doesn&#39;t bundle - uses browser&#39;s native ES modules
import Button from &#39;./Button.jsx&#39;  // Loaded directly, instantly

// Only transforms on request:
Browser: GET /src/Button.jsx
Vite:    Transform JSX → JS → Send
         Cache result
         Time: ~5ms

// Production Mode:
// Vite uses esbuild to bundle everything
npm run build → esbuild → Optimized bundle
</code></pre>
<hr>
<h3>Deep Dive: State Management Theory</h3>
<p><strong>The State Management Problem:</strong></p>
<pre><code>Component Hierarchy:
App
├─ Header
│  ├─ UserMenu (needs user data)
│  └─ Cart (needs cart data)
├─ Main
│  ├─ ProductList (needs products data)
│  └─ ProductDetail (needs product + cart data)
└─ Footer

Problem: How does ProductList update Cart?
├─ Prop drilling: Pass through 4+ levels
├─ Context: Create shared state
└─ State management: Centralized store
</code></pre>
<p><strong>State Types:</strong></p>
<pre><code class="language-javascript">// 1. Server State (from API)
const products = fetch(&#39;/api/products&#39;)
// Characteristics: Asynchronous, Can be stale, Shared

// 2. UI State (local to component)
const [isOpen, setIsOpen] = useState(false)
// Characteristics: Synchronous, Always fresh, Component-specific

// 3. URL State (in query params)
const page = new URLSearchParams(window.location.search).get(&#39;page&#39;)
// Characteristics: Shareable, Bookmarkable, SSR-friendly

// 4. Form State (input values, validation)
const [formData, setFormData] = useState({ name: &#39;&#39;, email: &#39;&#39; })
// Characteristics: Temporary, Needs validation, May persist
</code></pre>
<p><strong>State Management Patterns:</strong></p>
<pre><code class="language-javascript">// 1. Prop Drilling (Small apps)
function App() {
  const [user, setUser] = useState(null)
  return &lt;Header user={user} setUser={setUser} /&gt;
}

function Header({ user, setUser }) {
  return &lt;UserMenu user={user} setUser={setUser} /&gt;
}
// Pros: Simple, explicit
// Cons: Tedious, breaks on refactor

// 2. Context (Medium apps)
const UserContext = createContext()

function App() {
  const [user, setUser] = useState(null)
  return (
    &lt;UserContext.Provider value={{ user, setUser }}&gt;
      &lt;Header /&gt;
    &lt;/UserContext.Provider&gt;
  )
}

function UserMenu() {
  const { user } = useContext(UserContext)
  return &lt;div&gt;{user.name}&lt;/div&gt;
}
// Pros: No prop drilling, built-in
// Cons: Re-renders all consumers, limited features

// 3. Redux (Large apps)
// Store: Single source of truth
const store = createStore({
  user: { data: null, loading: false },
  cart: { items: [], total: 0 }
})

// Actions: What happened
dispatch({ type: &#39;USER_LOADED&#39;, payload: user })

// Reducers: How state changes
function userReducer(state, action) {
  switch (action.type) {
    case &#39;USER_LOADED&#39;:
      return { ...state, data: action.payload, loading: false }
  }
}
// Pros: Predictable, time-travel debugging, middleware
// Cons: Boilerplate, learning curve

// 4. React Query (Server state)
const { data: products, isLoading } = useQuery(&#39;products&#39;, fetchProducts)
// Pros: Caching, refetching, optimistic updates
// Cons: Only for server state
</code></pre>
<p><strong>Redux Data Flow:</strong></p>
<pre><code>┌─────────┐
│Component│
└────┬────┘
     │ dispatch(action)
     ↓
┌─────────┐      ┌────────┐
│  Store  │─────→│Reducer │
└────┬────┘      └────┬───┘
     │                │ returns new state
     │←───────────────┘
     │ state updated
     ↓
┌─────────┐
│Component│ (re-renders)
└─────────┘

Action: { type: &#39;ADD_TO_CART&#39;, payload: product }
      ↓
Reducer: (state, action) =&gt; newState
      ↓
Store: { cart: { items: [...items, product] } }
      ↓
Component: useSelector(state =&gt; state.cart.items)
</code></pre>
<hr>
<h3>Deep Dive: Server-Side Rendering (SSR)</h3>
<p><strong>What is SSR?</strong></p>
<p>Server-Side Rendering means generating HTML on the server instead of in the browser:</p>
<pre><code>Traditional SPA (Client-Side Rendering):
Server → Browser: &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; + app.js (500KB)
                  ↓
Browser: Run JavaScript
         ↓
         Build DOM
         ↓
         Render content (2-3 seconds later)

SSR:
Server: Run React → Generate HTML
        ↓
Server → Browser: &lt;div id=&quot;root&quot;&gt;&lt;h1&gt;Content&lt;/h1&gt;&lt;/div&gt; + app.js
                  ↓
Browser: Display HTML immediately (0.1 seconds)
         ↓
         Run JavaScript (hydration)
         ↓
         Make interactive (0.5 seconds)
</code></pre>
<p><strong>Why SSR?</strong></p>
<ol>
<li><strong>SEO</strong>: Search engines see content immediately</li>
<li><strong>Performance</strong>: Faster First Contentful Paint</li>
<li><strong>Social Sharing</strong>: Preview cards work (OpenGraph)</li>
<li><strong>Accessibility</strong>: Works without JavaScript</li>
</ol>
<p><strong>SSR Challenges:</strong></p>
<pre><code class="language-javascript">// Challenge 1: Browser APIs not available on server
// ❌ This crashes on server:
const width = window.innerWidth

// ✅ Solution: Check environment
if (typeof window !== &#39;undefined&#39;) {
  const width = window.innerWidth
}

// Challenge 2: Different state on server vs client
// Server renders: &quot;You have 0 items&quot;
// Client hydrates: &quot;You have 3 items&quot; (from localStorage)
// Result: Hydration mismatch!

// ✅ Solution: Sync server and client state
// Or: Only render after hydration:
const [mounted, setMounted] = useState(false)
useEffect(() =&gt; setMounted(true), [])
if (!mounted) return null
return &lt;div&gt;{itemCount} items&lt;/div&gt;
</code></pre>
<p><strong>SSR Performance Pattern:</strong></p>
<pre><code>┌──────────────────────────────────┐
│ Time to First Byte (TTFB)       │
│ ├─ Server processing            │
│ │  ├─ Run React                 │ 100ms
│ │  ├─ Fetch data                │ 50ms
│ │  └─ Generate HTML             │ 20ms
│ └─ Network                       │ 30ms
│                                  │
│ First Contentful Paint (FCP)    │ 200ms ✓ Fast!
├──────────────────────────────────┤
│                                  │
│ Time to Interactive (TTI)       │
│ ├─ Download JavaScript          │ 300ms
│ ├─ Parse JavaScript              │ 100ms
│ └─ Hydrate                       │ 200ms
│                                  │
│ Fully Interactive                │ 800ms
└──────────────────────────────────┘

Compare to CSR (Client-Side Rendering):
├─ First Contentful Paint: 2000ms ✗ Slow!
└─ Time to Interactive:    2500ms
</code></pre>
<hr>
<h3>Deep Dive: React Hydration</h3>
<p><strong>Hydration Process Explained:</strong></p>
<pre><code class="language-javascript">// 1. Server generates HTML
ReactDOMServer.renderToString(&lt;App initialData={data} /&gt;)
// Output: &lt;div class=&quot;app&quot;&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;button&gt;Click&lt;/button&gt;&lt;/div&gt;

// 2. HTML sent to browser
// Browser displays immediately - but not interactive!

// 3. Browser loads JavaScript
// 4. React hydrates (makes interactive)
const root = ReactDOM.hydrateRoot(container, &lt;App initialData={data} /&gt;)

// Hydration steps:
// ├─ React builds virtual DOM
// ├─ Compares with server HTML
// ├─ If match: Attach event listeners
// └─ If mismatch: Warning + re-render
</code></pre>
<p><strong>Hydration Matching:</strong></p>
<pre><code class="language-javascript">// Server HTML must match client render

// ✅ Good: Same output
// Server: &lt;div&gt;Count: 0&lt;/div&gt;
// Client: &lt;div&gt;Count: 0&lt;/div&gt;
// Result: Hydrates smoothly

// ❌ Bad: Different output
// Server: &lt;div&gt;Count: 0&lt;/div&gt;
// Client: &lt;div&gt;Count: 5&lt;/div&gt; (from localStorage)
// Result: Hydration mismatch warning!

// React reconciliation on mismatch:
// 1. Log warning
// 2. Client render overwrites server HTML
// 3. Performance penalty + visual flash
</code></pre>
<p><strong>Hydration Cost:</strong></p>
<pre><code>Hydration is expensive for large apps:

Component Count: 1,000 components
JavaScript Size: 500 KB
Hydration Time:  800ms

Optimization strategies:
├─ Progressive Hydration (hydrate in chunks)
├─ Selective Hydration (only interactive parts)
├─ Resumable Hydration (serialize state)
└─ Islands Architecture (isolated interactive islands)
</code></pre>
<p><strong>Progressive Hydration Example:</strong></p>
<pre><code class="language-javascript">// Only hydrate when needed
function LazyComponent() {
  const [hydrated, setHydrated] = useState(false)
  
  useEffect(() =&gt; {
    // Hydrate when in viewport
    const observer = new IntersectionObserver(([entry]) =&gt; {
      if (entry.isIntersecting) {
        setHydrated(true)
      }
    })
    observer.observe(ref.current)
  }, [])
  
  if (!hydrated) {
    return &lt;div ref={ref} dangerouslySetInnerHTML={{ __html: serverHtml }} /&gt;
  }
  
  return &lt;InteractiveComponent /&gt;
}
</code></pre>
<hr>
<h3>Deep Dive: WebSockets vs Server-Sent Events vs Long-Polling</h3>
<p><strong>Real-Time Communication Patterns:</strong></p>
<pre><code>┌────────────────────────────────────────────────────────────┐
│                    Communication Flow                      │
├────────────────────────────────────────────────────────────┤
│                                                            │
│ Long-Polling:                                              │
│ Client ──Request──→ Server (holds connection)             │
│ Client ←─Response─┘ Server (data ready or timeout)        │
│ Client ──Request──→ Server (immediately repeat)            │
│                                                            │
│ Server-Sent Events (SSE):                                 │
│ Client ──Request──→ Server (keep alive)                   │
│        ←──Data────┐                                       │
│        ←──Data────┤ Server (push when ready)              │
│        ←──Data────┘                                       │
│                                                            │
│ WebSockets:                                                │
│ Client ←─Upgrade─→ Server (bidirectional)                │
│        ←──Data────→                                       │
│        ←──Data────→ (full duplex)                         │
│        ←──Data────→                                       │
└────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Detailed Comparison:</strong></p>
<pre><code class="language-javascript">// 1. Long-Polling
// How it works:
function longPoll() {
  fetch(&#39;/api/messages?lastId=&#39; + lastId)
    .then(res =&gt; res.json())
    .then(data =&gt; {
      updateUI(data)
      longPoll() // Immediately reconnect
    })
    .catch(err =&gt; {
      setTimeout(longPoll, 5000) // Retry on error
    })
}

// Pros:
// ✅ Works everywhere (HTTP)
// ✅ No special infrastructure

// Cons:
// ❌ High latency (request overhead)
// ❌ Wasteful (many connections)
// ❌ Scalability issues

// 2. Server-Sent Events (SSE)
// How it works:
const eventSource = new EventSource(&#39;/api/stream&#39;)

eventSource.onmessage = (event) =&gt; {
  const data = JSON.parse(event.data)
  updateUI(data)
}

// Server (Rails):
def stream
  response.headers[&#39;Content-Type&#39;] = &#39;text/event-stream&#39;
  response.headers[&#39;Cache-Control&#39;] = &#39;no-cache&#39;
  
  sse = SSE.new(response.stream)
  begin
    loop do
      message = Message.where(&#39;id &gt; ?&#39;, last_id).first
      if message
        sse.write({ id: message.id, text: message.text })
      end
      sleep 1
    end
  ensure
    sse.close
  end
end

// Pros:
// ✅ Simple HTTP
// ✅ Auto-reconnect
// ✅ Event types

// Cons:
// ❌ Unidirectional (server → client only)
// ❌ Browser connection limit (6 per domain)
// ❌ No binary data

// 3. WebSockets (ActionCable)
// How it works:
const cable = createConsumer(&#39;ws://localhost:3000/cable&#39;)

const subscription = cable.subscriptions.create(&#39;ChatChannel&#39;, {
  received(data) {
    updateUI(data)
  },
  
  send(message) {
    this.perform(&#39;send_message&#39;, { text: message })
  }
})

// Server (Rails):
class ChatChannel &lt; ApplicationCable::Channel
  def subscribed
    stream_from &#39;chat&#39;
  end
  
  def send_message(data)
    ActionCable.server.broadcast(&#39;chat&#39;, {
      user: current_user.name,
      text: data[&#39;text&#39;]
    })
  end
end

// Pros:
// ✅ Bidirectional (client ↔ server)
// ✅ Low latency
// ✅ Binary data support
// ✅ Scalable

// Cons:
// ❌ More complex
// ❌ Requires WebSocket support
// ❌ Sticky sessions (load balancing)
</code></pre>
<p><strong>Performance Metrics:</strong></p>
<pre><code>Latency (Client → Server → Client):

Long-Polling:
├─ Request:         50ms
├─ Server wait:     100ms
├─ Response:        50ms
└─ Total:          200ms per message

SSE:
├─ Initial:         50ms (connection)
├─ Server push:     5ms
└─ Total:          5ms per message (40x faster!)

WebSocket:
├─ Upgrade:         100ms (once)
├─ Message:         2ms
└─ Total:          2ms per message (100x faster!)

Bandwidth (10,000 users, 1 message/sec):

Long-Polling:
├─ Connections:     10,000/sec
├─ Headers:        ~500 bytes/request
└─ Bandwidth:      ~50 MB/sec 😱

SSE:
├─ Connections:     10,000 (persistent)
├─ Headers:        ~50 bytes/message
└─ Bandwidth:      ~0.5 MB/sec ✓

WebSocket:
├─ Connections:     10,000 (persistent)
├─ Frame overhead: ~6 bytes
└─ Bandwidth:      ~0.06 MB/sec ✓✓
</code></pre>
<p><strong>When to Use Each:</strong></p>
<pre><code class="language-ruby"># Long-Polling:
# ├─ Use for: Legacy browser support
# ├─ Use for: Simple notifications
# └─ Avoid:  Real-time applications

# SSE:
# ├─ Use for: Live dashboards
# ├─ Use for: Stock tickers
# ├─ Use for: News feeds
# └─ Avoid:  Need client → server messages

# WebSocket (ActionCable):
# ├─ Use for: Chat applications
# ├─ Use for: Collaborative editing
# ├─ Use for: Real-time games
# └─ Avoid:  Simple notifications
</code></pre>
<hr>
<h3>Deep Dive: Progressive Web Apps (PWA)</h3>
<p><strong>PWA Architecture:</strong></p>
<pre><code>Traditional Web App:
Browser → Server → HTML/CSS/JS → Render
(Every navigation = new request)

PWA:
Browser → Service Worker → Cache/Network → Render
         ↓
     App Shell (cached)
     ↓
     Content (fresh or cached)

App Shell Pattern:
┌───────────────────────────────────┐
│ Header (cached)                   │
├───────────────────────────────────┤
│ Nav (cached)  │ Content (dynamic) │
│               │                   │
│               │                   │
├───────────────┴───────────────────┤
│ Footer (cached)                   │
└───────────────────────────────────┘
</code></pre>
<p><strong>Service Worker Lifecycle:</strong></p>
<pre><code class="language-javascript">// 1. Registration
if (&#39;serviceWorker&#39; in navigator) {
  navigator.serviceWorker.register(&#39;/service-worker.js&#39;)
    .then(reg =&gt; console.log(&#39;SW registered&#39;))
    .catch(err =&gt; console.log(&#39;SW failed&#39;))
}

// 2. Installation (first time)
self.addEventListener(&#39;install&#39;, (event) =&gt; {
  event.waitUntil(
    caches.open(&#39;v1&#39;).then(cache =&gt; {
      // Cache app shell
      return cache.addAll([
        &#39;/&#39;,
        &#39;/app.css&#39;,
        &#39;/app.js&#39;,
        &#39;/logo.png&#39;
      ])
    })
  )
})

// 3. Activation (after install)
self.addEventListener(&#39;activate&#39;, (event) =&gt; {
  // Clean up old caches
  event.waitUntil(
    caches.keys().then(keys =&gt; {
      return Promise.all(
        keys.filter(key =&gt; key !== &#39;v1&#39;)
            .map(key =&gt; caches.delete(key))
      )
    })
  )
})

// 4. Fetch interception
self.addEventListener(&#39;fetch&#39;, (event) =&gt; {
  event.respondWith(
    caches.match(event.request)
      .then(response =&gt; {
        // Cache hit
        if (response) return response
        
        // Cache miss - fetch from network
        return fetch(event.request)
      })
  )
})
</code></pre>
<p><strong>Caching Strategies:</strong></p>
<pre><code class="language-javascript">// 1. Cache First (App Shell)
// Fast, offline-capable, stale data
self.addEventListener(&#39;fetch&#39;, (event) =&gt; {
  event.respondWith(
    caches.match(event.request)
      .then(response =&gt; response || fetch(event.request))
  )
})

// 2. Network First (Dynamic Content)
// Fresh data, slow, requires network
self.addEventListener(&#39;fetch&#39;, (event) =&gt; {
  event.respondWith(
    fetch(event.request)
      .catch(() =&gt; caches.match(event.request))
  )
})

// 3. Stale-While-Revalidate (Best of Both)
// Fast + fresh, eventual consistency
self.addEventListener(&#39;fetch&#39;, (event) =&gt; {
  event.respondWith(
    caches.open(&#39;dynamic&#39;).then(cache =&gt; {
      return cache.match(event.request).then(cached =&gt; {
        // Fetch in background
        const fetchPromise = fetch(event.request).then(response =&gt; {
          // Update cache
          cache.put(event.request, response.clone())
          return response
        })
        
        // Return cached immediately, update in background
        return cached || fetchPromise
      })
    })
  )
})

// 4. Cache Only (Static Assets)
// Fastest, never updates
self.addEventListener(&#39;fetch&#39;, (event) =&gt; {
  event.respondWith(caches.match(event.request))
})

// 5. Network Only (Always Fresh)
// Always fresh, requires connection
self.addEventListener(&#39;fetch&#39;, (event) =&gt; {
  event.respondWith(fetch(event.request))
})
</code></pre>
<p><strong>Performance Impact:</strong></p>
<pre><code>Without PWA:
├─ First visit:      2.5s load time
├─ Repeat visit:     2.5s (full reload)
└─ Offline:         ✗ Doesn&#39;t work

With PWA:
├─ First visit:      2.5s (install + cache)
├─ Repeat visit:     0.3s (from cache) 8x faster!
├─ Offline:         ✓ Works!
└─ Storage:         ~2MB cached
</code></pre>
<hr>
<h3>Theory: Code Splitting Benefits</h3>
<p><strong>Bundle Size Problem:</strong></p>
<pre><code>Without Code Splitting:
app.js: 2.5 MB
├─ React:              150 KB
├─ React DOM:          130 KB
├─ Router:              50 KB
├─ Dashboard:          800 KB (charts, tables)
├─ Admin:              600 KB (forms, validation)
├─ Editor:             500 KB (WYSIWYG)
└─ Misc:               270 KB

User loads: ALL 2.5 MB to view homepage
Result: 10-15 second load time on 3G
</code></pre>
<p><strong>With Code Splitting:</strong></p>
<pre><code>Initial bundle (home): 330 KB
├─ React:              150 KB
├─ React DOM:          130 KB
├─ Router:              50 KB

Lazy loaded:
├─ /dashboard  → dashboard.chunk.js (800 KB)
├─ /admin      → admin.chunk.js (600 KB)
└─ /editor     → editor.chunk.js (500 KB)

User loads: Only 330 KB for homepage
Result: 2-3 second load time ✓
Dashboard: Loads 800 KB when visited
</code></pre>
<p><strong>Load Time Calculation:</strong></p>
<pre><code>Network: 4G (10 Mbps download)

Without splitting:
2500 KB ÷ (10 Mbps ÷ 8) = 2 seconds download
+ 1 second parse/compile
+ 0.5 seconds execute
= 3.5 seconds to interactive

With splitting:
330 KB ÷ (10 Mbps ÷ 8) = 0.26 seconds download
+ 0.15 seconds parse/compile
+ 0.1 seconds execute
= 0.51 seconds to interactive (7x faster!)
</code></pre>
<p>This comprehensive theory and explanation gives much deeper understanding of how these technologies work under the hood!</p>
<h1>Final Advanced Topics Interview Questions (305-315)</h1>
<h2>Question 305: What are Design Patterns in Rails, and which ones are commonly used?</h2>
<h3>Answer</h3>
<p><strong>Design Patterns</strong> are reusable solutions to common software design problems. Rails commonly uses Service Objects, Form Objects, Query Objects, Decorators/Presenters, Policy Objects, and Value Objects to organize business logic and keep models thin.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Service Objects</strong>: Encapsulate business logic (CreateOrder, ProcessPayment)</li>
<li><strong>Form Objects</strong>: Handle complex form validation (UserRegistrationForm)</li>
<li><strong>Query Objects</strong>: Encapsulate complex queries (ActiveUsersQuery)</li>
<li><strong>Decorators</strong>: Add presentation logic (UserDecorator for view formatting)</li>
<li><strong>Policy Objects</strong>: Authorization logic (UserPolicy for permissions)</li>
<li><strong>Value Objects</strong>: Immutable data objects (Money, Address)</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<p><strong>Why Design Patterns?</strong></p>
<pre><code class="language-ruby"># Problem: Fat models with too much responsibility
class User &lt; ApplicationRecord
  # Authentication
  has_secure_password
  
  # Validations
  validates :email, presence: true, uniqueness: true
  validates :age, numericality: { greater_than: 18 }
  
  # Business logic
  def create_account_with_subscription(plan)
    transaction do
      self.save!
      subscription = subscriptions.create!(plan: plan)
      PaymentService.charge(subscription)
      WelcomeMailer.send_email(self)
      Analytics.track(&#39;user_created&#39;, user_id: id)
    end
  end
  
  # Queries
  def self.active_premium_users
    where(status: &#39;active&#39;)
      .joins(:subscriptions)
      .where(subscriptions: { plan: &#39;premium&#39; })
      .where(&#39;last_login_at &gt; ?&#39;, 30.days.ago)
  end
  
  # Presentation
  def full_name_with_title
    &quot;#{title} #{first_name} #{last_name}&quot;.strip
  end
  
  # And 50 more methods...
end

# Solution: Extract into design patterns
# - Service Objects: create_account_with_subscription
# - Query Objects: active_premium_users
# - Decorators: full_name_with_title
# - Policy Objects: can_edit?, can_delete?
</code></pre>
<hr>
<h3>1. Service Objects (Business Logic)</h3>
<p><strong>When to Use:</strong></p>
<ul>
<li>Multi-step operations</li>
<li>Multiple model interactions</li>
<li>External API calls</li>
<li>Complex business logic</li>
</ul>
<pre><code class="language-ruby"># app/services/create_user_account_service.rb
class CreateUserAccountService
  def initialize(user_params, subscription_plan)
    @user_params = user_params
    @subscription_plan = subscription_plan
  end
  
  def call
    ActiveRecord::Base.transaction do
      create_user
      create_subscription
      process_payment
      send_welcome_email
      track_analytics
      
      Result.success(user: @user)
    rescue =&gt; e
      Result.failure(error: e.message)
    end
  end
  
  private
  
  def create_user
    @user = User.create!(@user_params)
  end
  
  def create_subscription
    @subscription = @user.subscriptions.create!(
      plan: @subscription_plan,
      status: &#39;active&#39;
    )
  end
  
  def process_payment
    PaymentService.charge(
      user: @user,
      amount: @subscription_plan.price
    )
  end
  
  def send_welcome_email
    WelcomeMailer.welcome_email(@user).deliver_later
  end
  
  def track_analytics
    Analytics.track(&#39;user_created&#39;, {
      user_id: @user.id,
      plan: @subscription_plan.name
    })
  end
end

# Usage in controller
class UsersController &lt; ApplicationController
  def create
    result = CreateUserAccountService.new(
      user_params,
      subscription_plan
    ).call
    
    if result.success?
      redirect_to result.user, notice: &#39;Welcome!&#39;
    else
      flash.now[:error] = result.error
      render :new
    end
  end
end

# Result object
class Result
  attr_reader :data, :error
  
  def self.success(data)
    new(success: true, data: data)
  end
  
  def self.failure(error:)
    new(success: false, error: error)
  end
  
  def initialize(success:, data: {}, error: nil)
    @success = success
    @data = data
    @error = error
  end
  
  def success?
    @success
  end
  
  def failure?
    !@success
  end
  
  def method_missing(method, *args)
    @data[method] || super
  end
end
</code></pre>
<hr>
<h3>2. Form Objects (Complex Forms)</h3>
<p><strong>When to Use:</strong></p>
<ul>
<li>Forms spanning multiple models</li>
<li>Complex validations</li>
<li>Virtual attributes</li>
<li>Nested forms</li>
</ul>
<pre><code class="language-ruby"># app/forms/user_registration_form.rb
class UserRegistrationForm
  include ActiveModel::Model
  include ActiveModel::Validations
  
  # Attributes
  attr_accessor :email, :password, :password_confirmation
  attr_accessor :first_name, :last_name, :company_name
  attr_accessor :card_number, :card_expiry, :card_cvc
  attr_accessor :terms_accepted
  
  # Validations
  validates :email, presence: true, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :password, length: { minimum: 8 }, confirmation: true
  validates :first_name, :last_name, presence: true
  validates :terms_accepted, acceptance: true
  validate :credit_card_valid
  
  def save
    return false unless valid?
    
    ActiveRecord::Base.transaction do
      create_user
      create_company
      create_payment_method
      send_confirmation_email
      true
    end
  rescue =&gt; e
    errors.add(:base, e.message)
    false
  end
  
  private
  
  def create_user
    @user = User.create!(
      email: email,
      password: password,
      first_name: first_name,
      last_name: last_name
    )
  end
  
  def create_company
    @company = Company.create!(
      name: company_name,
      owner: @user
    )
  end
  
  def create_payment_method
    PaymentMethod.create!(
      user: @user,
      card_number: card_number,
      card_expiry: card_expiry
    )
  end
  
  def send_confirmation_email
    UserMailer.confirmation_email(@user).deliver_later
  end
  
  def credit_card_valid
    unless CreditCard.valid?(card_number)
      errors.add(:card_number, &#39;is invalid&#39;)
    end
  end
end

# Usage in controller
class RegistrationsController &lt; ApplicationController
  def create
    @form = UserRegistrationForm.new(registration_params)
    
    if @form.save
      redirect_to dashboard_path, notice: &#39;Welcome!&#39;
    else
      render :new
    end
  end
  
  private
  
  def registration_params
    params.require(:registration).permit(
      :email, :password, :password_confirmation,
      :first_name, :last_name, :company_name,
      :card_number, :card_expiry, :card_cvc,
      :terms_accepted
    )
  end
end
</code></pre>
<hr>
<h3>3. Query Objects (Complex Queries)</h3>
<p><strong>When to Use:</strong></p>
<ul>
<li>Complex queries with multiple conditions</li>
<li>Reusable query logic</li>
<li>Keep models clean</li>
<li>Composable queries</li>
</ul>
<pre><code class="language-ruby"># app/queries/active_users_query.rb
class ActiveUsersQuery
  def initialize(relation = User.all)
    @relation = relation
  end
  
  def call
    @relation
      .where(status: &#39;active&#39;)
      .where(&#39;last_login_at &gt; ?&#39;, 30.days.ago)
  end
end

# app/queries/premium_users_query.rb
class PremiumUsersQuery
  def initialize(relation = User.all)
    @relation = relation
  end
  
  def call
    @relation
      .joins(:subscription)
      .where(subscriptions: { plan: &#39;premium&#39; })
  end
end

# app/queries/high_value_users_query.rb
class HighValueUsersQuery
  def initialize(relation = User.all, min_revenue: 1000)
    @relation = relation
    @min_revenue = min_revenue
  end
  
  def call
    @relation
      .joins(:orders)
      .group(&#39;users.id&#39;)
      .having(&#39;SUM(orders.total) &gt; ?&#39;, @min_revenue)
  end
end

# Usage - Composable!
class DashboardController &lt; ApplicationController
  def index
    # Chain query objects
    @users = User.all
    @users = ActiveUsersQuery.new(@users).call
    @users = PremiumUsersQuery.new(@users).call
    @users = HighValueUsersQuery.new(@users, min_revenue: 5000).call
    
    # Or use a scope-like approach
    @users = User.active.premium.high_value(5000)
  end
end

# In User model, delegate to query objects
class User &lt; ApplicationRecord
  scope :active, -&gt; { ActiveUsersQuery.new(all).call }
  scope :premium, -&gt; { PremiumUsersQuery.new(all).call }
  scope :high_value, -&gt;(amount) { HighValueUsersQuery.new(all, min_revenue: amount).call }
end
</code></pre>
<hr>
<h3>4. Decorators/Presenters (Presentation Logic)</h3>
<p><strong>When to Use:</strong></p>
<ul>
<li>Formatting data for views</li>
<li>Keep views clean</li>
<li>Reusable presentation logic</li>
<li>Hide complexity from views</li>
</ul>
<pre><code class="language-ruby"># Using Draper gem
# Gemfile
gem &#39;draper&#39;

# app/decorators/user_decorator.rb
class UserDecorator &lt; Draper::Decorator
  delegate_all  # Delegate all methods to the user object
  
  # Full name with title
  def full_name
    &quot;#{object.title} #{object.first_name} #{object.last_name}&quot;.strip
  end
  
  # Formatted created date
  def joined_date
    object.created_at.strftime(&quot;%B %d, %Y&quot;)
  end
  
  # Avatar with fallback
  def avatar_url(size: :medium)
    if object.avatar.attached?
      h.url_for(object.avatar.variant(resize_to_limit: avatar_size(size)))
    else
      &quot;https://ui-avatars.com/api/?name=#{CGI.escape(full_name)}&quot;
    end
  end
  
  # Status badge HTML
  def status_badge
    css_class = case object.status
                when &#39;active&#39; then &#39;badge-success&#39;
                when &#39;inactive&#39; then &#39;badge-secondary&#39;
                when &#39;suspended&#39; then &#39;badge-danger&#39;
                end
    
    h.content_tag(:span, object.status.titleize, class: &quot;badge #{css_class}&quot;)
  end
  
  # Link to profile
  def profile_link
    h.link_to(full_name, h.user_path(object), class: &#39;user-link&#39;)
  end
  
  # Membership duration
  def member_for
    duration = Time.current - object.created_at
    years = (duration / 1.year).to_i
    
    if years &gt; 0
      &quot;#{years} #{years == 1 ? &#39;year&#39; : &#39;years&#39;}&quot;
    else
      months = (duration / 1.month).to_i
      &quot;#{months} #{months == 1 ? &#39;month&#39; : &#39;months&#39;}&quot;
    end
  end
  
  private
  
  def avatar_size(size)
    { small: [50, 50], medium: [100, 100], large: [200, 200] }[size]
  end
end

# Usage in controller
class UsersController &lt; ApplicationController
  def show
    @user = User.find(params[:id]).decorate
  end
end

# Usage in view
&lt;%= @user.full_name %&gt;
&lt;%= image_tag @user.avatar_url(size: :large) %&gt;
&lt;%= @user.status_badge %&gt;
&lt;p&gt;Member for &lt;%= @user.member_for %&gt;&lt;/p&gt;
</code></pre>
<hr>
<h3>5. Policy Objects (Authorization)</h3>
<p><strong>When to Use:</strong></p>
<ul>
<li>Complex authorization rules</li>
<li>Separate concerns from models</li>
<li>Reusable permission logic</li>
<li>Testing authorization</li>
</ul>
<pre><code class="language-ruby"># Using Pundit gem
# Gemfile
gem &#39;pundit&#39;

# app/policies/post_policy.rb
class PostPolicy
  attr_reader :user, :post
  
  def initialize(user, post)
    @user = user
    @post = post
  end
  
  # Can view post?
  def show?
    post.published? || user_is_author? || user_is_admin?
  end
  
  # Can create post?
  def create?
    user.present?
  end
  
  # Can update post?
  def update?
    user_is_author? || user_is_admin?
  end
  
  # Can delete post?
  def destroy?
    user_is_admin? || (user_is_author? &amp;&amp; post.created_recently?)
  end
  
  # Can publish post?
  def publish?
    user_is_admin? || (user_is_author? &amp;&amp; post.approved?)
  end
  
  # Scope - what posts can user see?
  class Scope
    attr_reader :user, :scope
    
    def initialize(user, scope)
      @user = user
      @scope = scope
    end
    
    def resolve
      if user.admin?
        scope.all
      elsif user.present?
        scope.where(published: true)
             .or(scope.where(author: user))
      else
        scope.where(published: true)
      end
    end
  end
  
  private
  
  def user_is_author?
    user.present? &amp;&amp; post.author == user
  end
  
  def user_is_admin?
    user.present? &amp;&amp; user.admin?
  end
end

# Usage in controller
class PostsController &lt; ApplicationController
  def index
    @posts = policy_scope(Post)
  end
  
  def show
    @post = Post.find(params[:id])
    authorize @post
  end
  
  def update
    @post = Post.find(params[:id])
    authorize @post
    
    if @post.update(post_params)
      redirect_to @post
    else
      render :edit
    end
  end
end

# Usage in views
&lt;% if policy(@post).update? %&gt;
  &lt;%= link_to &#39;Edit&#39;, edit_post_path(@post) %&gt;
&lt;% end %&gt;

&lt;% if policy(@post).destroy? %&gt;
  &lt;%= link_to &#39;Delete&#39;, post_path(@post), method: :delete %&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>6. Value Objects (Immutable Data)</h3>
<p><strong>When to Use:</strong></p>
<ul>
<li>Immutable data structures</li>
<li>Money, Address, DateRange</li>
<li>Comparison logic</li>
<li>Type safety</li>
</ul>
<pre><code class="language-ruby"># app/value_objects/money.rb
class Money
  include Comparable
  
  attr_reader :amount, :currency
  
  def initialize(amount, currency = &#39;USD&#39;)
    @amount = BigDecimal(amount.to_s)
    @currency = currency
    freeze  # Make immutable
  end
  
  # Addition
  def +(other)
    raise_currency_mismatch(other) unless same_currency?(other)
    Money.new(@amount + other.amount, @currency)
  end
  
  # Subtraction
  def -(other)
    raise_currency_mismatch(other) unless same_currency?(other)
    Money.new(@amount - other.amount, @currency)
  end
  
  # Multiplication
  def *(multiplier)
    Money.new(@amount * multiplier, @currency)
  end
  
  # Comparison
  def &lt;=&gt;(other)
    raise_currency_mismatch(other) unless same_currency?(other)
    @amount &lt;=&gt; other.amount
  end
  
  # Formatting
  def to_s
    format(&quot;%.2f %s&quot;, @amount, @currency)
  end
  
  def to_cents
    (@amount * 100).to_i
  end
  
  private
  
  def same_currency?(other)
    @currency == other.currency
  end
  
  def raise_currency_mismatch(other)
    raise &quot;Cannot operate on different currencies: #{@currency} vs #{other.currency}&quot;
  end
end

# Usage
price = Money.new(19.99, &#39;USD&#39;)
tax = Money.new(2.00, &#39;USD&#39;)
total = price + tax  # Money.new(21.99, &#39;USD&#39;)

# In models
class Product &lt; ApplicationRecord
  def price
    Money.new(read_attribute(:price_cents) / 100.0, currency)
  end
  
  def price=(money)
    write_attribute(:price_cents, money.to_cents)
    write_attribute(:currency, money.currency)
  end
end

# app/value_objects/address.rb
class Address
  attr_reader :street, :city, :state, :zip_code, :country
  
  def initialize(street:, city:, state:, zip_code:, country: &#39;USA&#39;)
    @street = street
    @city = city
    @state = state
    @zip_code = zip_code
    @country = country
    freeze
  end
  
  def to_s
    &quot;#{street}, #{city}, #{state} #{zip_code}, #{country}&quot;
  end
  
  def ==(other)
    return false unless other.is_a?(Address)
    
    street == other.street &amp;&amp;
    city == other.city &amp;&amp;
    state == other.state &amp;&amp;
    zip_code == other.zip_code &amp;&amp;
    country == other.country
  end
  
  alias eql? ==
  
  def hash
    [street, city, state, zip_code, country].hash
  end
end

# Usage
address = Address.new(
  street: &#39;123 Main St&#39;,
  city: &#39;New York&#39;,
  state: &#39;NY&#39;,
  zip_code: &#39;10001&#39;
)

puts address.to_s
# =&gt; &quot;123 Main St, New York, NY 10001, USA&quot;
</code></pre>
<hr>
<h3>Design Pattern Comparison</h3>
<pre><code class="language-ruby"># When to use which pattern?

# Service Objects - Business Logic
# Use when: Multi-step operations, external services
CreateOrderService.new(user, cart).call
ProcessPaymentService.new(order).call
SendNotificationService.new(user, event).call

# Form Objects - Complex Forms
# Use when: Multiple models, virtual attributes
UserRegistrationForm.new(params).save
CheckoutForm.new(params).process
ProfileUpdateForm.new(user, params).save

# Query Objects - Complex Queries
# Use when: Reusable queries, composable conditions
ActiveUsersQuery.new.call
PremiumUsersQuery.new.call
HighValueCustomersQuery.new(min_value: 1000).call

# Decorators - Presentation Logic
# Use when: Formatting for views, keeping views clean
user.decorate.full_name
product.decorate.price_with_currency
order.decorate.status_badge

# Policy Objects - Authorization
# Use when: Complex permissions, role-based access
PostPolicy.new(user, post).update?
authorize @post, :destroy?
policy_scope(Post)

# Value Objects - Immutable Data
# Use when: Money, Address, DateRange
Money.new(19.99, &#39;USD&#39;)
Address.new(street: &#39;123 Main St&#39;, city: &#39;NYC&#39;)
DateRange.new(Date.today, Date.today + 7.days)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Service Objects</strong> encapsulate complex business logic</li>
<li><strong>Form Objects</strong> handle multi-model forms</li>
<li><strong>Query Objects</strong> make complex queries reusable</li>
<li><strong>Decorators</strong> keep presentation logic out of models/views</li>
<li><strong>Policy Objects</strong> centralize authorization logic</li>
<li><strong>Value Objects</strong> represent immutable data</li>
<li><strong>Thin controllers</strong>: Move logic to appropriate patterns</li>
<li><strong>Thin models</strong>: Extract business logic to services</li>
<li><strong>Testability</strong>: Patterns make code easier to test</li>
<li><strong>Maintainability</strong>: Clear separation of concerns</li>
</ol>
<hr>
<h2>Question 306: What is the Singleton Pattern, and how is it used in Rails?</h2>
<h3>Answer</h3>
<p>The <strong>Singleton Pattern</strong> ensures a class has only one instance throughout the application lifecycle. In Rails, it&#39;s commonly used for configuration objects, connection pools, caches, and loggers that should be shared across the application.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Singleton</strong>: One instance per application</li>
<li><strong>Rails examples</strong>: <code>Rails.cache</code>, <code>Rails.logger</code>, <code>ActionCable.server</code></li>
<li><strong>Implementation</strong>: Use Ruby&#39;s <code>Singleton</code> module or class variables</li>
<li><strong>Use cases</strong>: Configuration, connection pools, caches</li>
<li><strong>Thread-safety</strong>: Important in multi-threaded environments</li>
</ul>
<hr>
<h3>Implementation</h3>
<pre><code class="language-ruby"># Using Ruby&#39;s built-in Singleton module
require &#39;singleton&#39;

class ApplicationConfig
  include Singleton
  
  attr_accessor :api_key, :api_secret, :timeout
  
  def initialize
    @api_key = ENV[&#39;API_KEY&#39;]
    @api_secret = ENV[&#39;API_SECRET&#39;]
    @timeout = 30
  end
  
  def configure
    yield self if block_given?
  end
end

# Usage
config = ApplicationConfig.instance
config.configure do |c|
  c.timeout = 60
end

# Always returns the same instance
config1 = ApplicationConfig.instance
config2 = ApplicationConfig.instance
config1.object_id == config2.object_id  # =&gt; true

# Cannot create new instances
ApplicationConfig.new  # =&gt; NoMethodError: private method `new&#39;

# Manual Singleton implementation (without module)
class DatabaseConnection
  @instance = nil
  @mutex = Mutex.new
  
  private_class_method :new
  
  def self.instance
    return @instance if @instance
    
    @mutex.synchronize do
      @instance ||= new
    end
  end
  
  def initialize
    @connection = connect_to_database
  end
  
  def query(sql)
    @connection.execute(sql)
  end
  
  private
  
  def connect_to_database
    # Database connection logic
    PG.connect(host: &#39;localhost&#39;, dbname: &#39;myapp&#39;)
  end
end

# Thread-safe Singleton
class Cache
  @instance = nil
  @mutex = Mutex.new
  
  def self.instance
    return @instance if @instance
    
    @mutex.synchronize do
      @instance ||= new
    end
  end
  
  private_class_method :new
  
  def initialize
    @store = {}
    @mutex = Mutex.new
  end
  
  def get(key)
    @mutex.synchronize { @store[key] }
  end
  
  def set(key, value)
    @mutex.synchronize { @store[key] = value }
  end
  
  def clear
    @mutex.synchronize { @store.clear }
  end
end

# Rails examples of Singleton
# 1. Rails.logger - single logger instance
Rails.logger.info &quot;This uses the singleton logger&quot;

# 2. Rails.cache - single cache instance
Rails.cache.fetch(&#39;key&#39;) { expensive_operation }

# 3. ActionCable.server - single WebSocket server
ActionCable.server.broadcast(&#39;channel&#39;, { data: &#39;message&#39; })

# 4. Redis connection (in initializer)
# config/initializers/redis.rb
class RedisConnection
  include Singleton
  
  def client
    @client ||= Redis.new(url: ENV[&#39;REDIS_URL&#39;])
  end
end

# Usage throughout app
RedisConnection.instance.client.get(&#39;key&#39;)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Singleton</strong> ensures only one instance exists</li>
<li><strong>Thread-safety</strong> is critical in Rails (use Mutex)</li>
<li><strong>Rails uses singletons</strong> for logger, cache, ActionCable</li>
<li><strong>Private constructor</strong> prevents direct instantiation</li>
<li><strong>Lazy initialization</strong> creates instance when first needed</li>
<li><strong>Global access</strong> through <code>instance</code> class method</li>
<li><strong>Memory efficient</strong> - one instance shared</li>
<li><strong>Testing challenge</strong>: Hard to reset state between tests</li>
<li><strong>Use sparingly</strong>: Can introduce hidden dependencies</li>
<li><strong>Alternative</strong>: Dependency injection for testability</li>
</ol>
<hr>
<h2>Question 307: What is the Repository Pattern in Rails?</h2>
<h3>Answer</h3>
<p>The <strong>Repository Pattern</strong> abstracts data access logic, providing a clean interface between business logic and data storage. It encapsulates queries and data operations, making it easier to test and switch data sources.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Repository</strong>: Abstraction layer over data access</li>
<li><strong>Benefits</strong>: Testable, swappable data sources, clean interface</li>
<li><strong>Use cases</strong>: Complex queries, multiple data sources, testing</li>
<li><strong>Rails</strong>: Not commonly used (Active Record is sufficient)</li>
<li><strong>When needed</strong>: Microservices, complex domains, non-AR data sources</li>
</ul>
<hr>
<h3>Implementation</h3>
<pre><code class="language-ruby"># app/repositories/user_repository.rb
class UserRepository
  def find(id)
    User.find(id)
  end
  
  def find_by_email(email)
    User.find_by(email: email)
  end
  
  def create(attributes)
    User.create(attributes)
  end
  
  def update(user, attributes)
    user.update(attributes)
  end
  
  def delete(user)
    user.destroy
  end
  
  # Complex queries
  def active_users
    User.where(status: &#39;active&#39;)
        .where(&#39;last_login_at &gt; ?&#39;, 30.days.ago)
  end
  
  def premium_users
    User.joins(:subscription)
        .where(subscriptions: { plan: &#39;premium&#39; })
  end
  
  def search(query)
    User.where(&#39;email LIKE ? OR first_name LIKE ?&#39;, &quot;%#{query}%&quot;, &quot;%#{query}%&quot;)
  end
end

# Usage in service
class CreateUserService
  def initialize(user_repository: UserRepository.new)
    @user_repository = user_repository
  end
  
  def call(params)
    user = @user_repository.create(params)
    # Business logic...
    user
  end
end

# Easy to test - mock repository
RSpec.describe CreateUserService do
  it &#39;creates a user&#39; do
    mock_repo = double(&#39;UserRepository&#39;)
    allow(mock_repo).to receive(:create).and_return(User.new)
    
    service = CreateUserService.new(user_repository: mock_repo)
    service.call(email: &#39;test@example.com&#39;)
    
    expect(mock_repo).to have_received(:create)
  end
end

# Repository with multiple data sources
class ProductRepository
  def initialize(source: :database)
    @source = source
  end
  
  def all
    case @source
    when :database
      Product.all
    when :api
      fetch_from_api
    when :cache
      fetch_from_cache
    end
  end
  
  private
  
  def fetch_from_api
    response = HTTParty.get(&#39;https://api.example.com/products&#39;)
    response.parsed_response.map { |data| Product.new(data) }
  end
  
  def fetch_from_cache
    cached = Rails.cache.read(&#39;products&#39;)
    cached || (Rails.cache.write(&#39;products&#39;, Product.all) &amp;&amp; Product.all)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Repository</strong> abstracts data access from business logic</li>
<li><strong>Benefits</strong>: Testability, flexibility, clean architecture</li>
<li><strong>Not common in Rails</strong>: Active Record pattern usually sufficient</li>
<li><strong>Use when</strong>: Multiple data sources, complex testing, microservices</li>
<li><strong>Interface</strong>: Provides consistent API regardless of source</li>
<li><strong>Swappable</strong>: Easy to switch from DB to API to cache</li>
<li><strong>Testing</strong>: Mock repositories instead of database</li>
<li><strong>Trade-off</strong>: Extra layer of abstraction</li>
<li><strong>DDD</strong>: Common in Domain-Driven Design</li>
<li><strong>Alternative</strong>: Query Objects for complex queries</li>
</ol>
<hr>
<h2>Question 308: What is Metaprogramming in Ruby/Rails? Give examples.</h2>
<h3>Answer</h3>
<p><strong>Metaprogramming</strong> is writing code that writes code at runtime. Ruby&#39;s dynamic nature enables powerful metaprogramming features like <code>define_method</code>, <code>method_missing</code>, <code>class_eval</code>, and <code>instance_eval</code> used extensively in Rails.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Metaprogramming</strong>: Code that generates code at runtime</li>
<li><strong>Ruby features</strong>: <code>define_method</code>, <code>method_missing</code>, <code>send</code>, <code>eval</code></li>
<li><strong>Rails examples</strong>: <code>has_many</code>, <code>validates</code>, <code>scope</code>, <code>attr_accessor</code></li>
<li><strong>Benefits</strong>: DRY code, DSLs, flexibility</li>
<li><strong>Caution</strong>: Can be hard to debug and understand</li>
</ul>
<hr>
<h3>Examples</h3>
<pre><code class="language-ruby"># 1. define_method - Create methods dynamically
class User &lt; ApplicationRecord
  # Create getter/setter methods for each attribute
  [:first_name, :last_name, :email].each do |attr|
    define_method(&quot;formatted_#{attr}&quot;) do
      send(attr)&amp;.titleize
    end
  end
end

user = User.new(first_name: &#39;john&#39;, last_name: &#39;doe&#39;)
user.formatted_first_name  # =&gt; &quot;John&quot;
user.formatted_last_name   # =&gt; &quot;Doe&quot;

# 2. method_missing - Handle undefined methods
class DynamicFinder
  def initialize(model)
    @model = model
  end
  
  def method_missing(method_name, *args)
    if method_name.to_s.start_with?(&#39;find_by_&#39;)
      attribute = method_name.to_s.sub(&#39;find_by_&#39;, &#39;&#39;)
      @model.where(attribute =&gt; args.first)
    else
      super
    end
  end
  
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.start_with?(&#39;find_by_&#39;) || super
  end
end

finder = DynamicFinder.new(User)
finder.find_by_email(&#39;john@example.com&#39;)  # Dynamically created!

# 3. class_eval - Evaluate code in class context
class ApiClient
  # Define methods based on API endpoints
  {
    users: &#39;/users&#39;,
    posts: &#39;/posts&#39;,
    comments: &#39;/comments&#39;
  }.each do |name, endpoint|
    class_eval &lt;&lt;-RUBY, __FILE__, __LINE__ + 1
      def get_#{name}(id = nil)
        path = id ? &quot;#{endpoint}/\#{id}&quot; : &quot;#{endpoint}&quot;
        make_request(:get, path)
      end
      
      def create_#{name}(data)
        make_request(:post, &quot;#{endpoint}&quot;, data)
      end
    RUBY
  end
  
  private
  
  def make_request(method, path, data = nil)
    # HTTP request logic
  end
end

client = ApiClient.new
client.get_users          # GET /users
client.get_users(1)       # GET /users/1
client.create_users(data) # POST /users

# 4. send - Call methods dynamically
class Calculator
  def add(a, b)
    a + b
  end
  
  def subtract(a, b)
    a - b
  end
  
  def perform(operation, a, b)
    send(operation, a, b)
  end
end

calc = Calculator.new
calc.perform(:add, 5, 3)      # =&gt; 8
calc.perform(:subtract, 5, 3) # =&gt; 2

# 5. instance_eval - Evaluate code in instance context
class Configuration
  def initialize
    @settings = {}
  end
  
  def configure(&amp;block)
    instance_eval(&amp;block)
  end
  
  def method_missing(method_name, *args)
    if method_name.to_s.end_with?(&#39;=&#39;)
      @settings[method_name.to_s.chomp(&#39;=&#39;)] = args.first
    else
      @settings[method_name.to_s]
    end
  end
end

config = Configuration.new
config.configure do
  api_key = &#39;secret123&#39;
  timeout = 30
  retries = 3
end

config.api_key  # =&gt; &quot;secret123&quot;
config.timeout  # =&gt; 30

# 6. Rails metaprogramming examples

# has_many macro
class User &lt; ApplicationRecord
  has_many :posts  # Creates methods: posts, posts=, post_ids, etc.
end

# How has_many works (simplified):
module Associations
  def has_many(name)
    # Define getter
    define_method(name) do
      # Return associated records
    end
    
    # Define setter
    define_method(&quot;#{name}=&quot;) do |values|
      # Set associated records
    end
    
    # Define ids getter
    define_method(&quot;#{name.to_s.singularize}_ids&quot;) do
      # Return array of IDs
    end
  end
end

# scope macro
class Product &lt; ApplicationRecord
  scope :active, -&gt; { where(active: true) }
  scope :expensive, -&gt; { where(&#39;price &gt; ?&#39;, 100) }
end

# How scope works (simplified):
module Scoping
  def scope(name, body)
    singleton_class.send(:define_method, name, &amp;body)
  end
end

# validates macro
class User &lt; ApplicationRecord
  validates :email, presence: true, uniqueness: true
end

# How validates works (simplified):
module Validations
  def validates(attribute, options)
    options.each do |validator, value|
      validator_class = &quot;#{validator.to_s.camelize}Validator&quot;.constantize
      validator_class.new(attribute, value).validate(self)
    end
  end
end

# 7. Creating a DSL with metaprogramming
class QueryBuilder
  def initialize(model)
    @model = model
    @conditions = []
  end
  
  def where(field, value)
    @conditions &lt;&lt; &quot;#{field} = &#39;#{value}&#39;&quot;
    self
  end
  
  def or_where(field, value)
    @conditions &lt;&lt; &quot;OR #{field} = &#39;#{value}&#39;&quot;
    self
  end
  
  def to_sql
    &quot;SELECT * FROM #{@model.table_name} WHERE #{@conditions.join(&#39; &#39;)}&quot;
  end
  
  def execute
    @model.find_by_sql(to_sql)
  end
end

# Usage (DSL):
QueryBuilder.new(User)
  .where(:status, &#39;active&#39;)
  .or_where(:role, &#39;admin&#39;)
  .execute
</code></pre>
<hr>
<h3>Rails Metaprogramming Under the Hood</h3>
<pre><code class="language-ruby"># How attr_accessor works
class Person
  attr_accessor :name
end

# Is equivalent to:
class Person
  def name
    @name
  end
  
  def name=(value)
    @name = value
  end
end

# Actual implementation:
module Kernel
  def attr_accessor(*names)
    names.each do |name|
      define_method(name) do
        instance_variable_get(&quot;@#{name}&quot;)
      end
      
      define_method(&quot;#{name}=&quot;) do |value|
        instance_variable_set(&quot;@#{name}&quot;, value)
      end
    end
  end
end

# How delegate works
class User &lt; ApplicationRecord
  belongs_to :company
  delegate :name, :address, to: :company, prefix: true
end

# Creates:
# user.company_name =&gt; user.company.name
# user.company_address =&gt; user.company.address

# Implementation:
module Delegation
  def delegate(*methods, to:, prefix: false)
    methods.each do |method|
      method_name = prefix ? &quot;#{to}_#{method}&quot; : method
      
      define_method(method_name) do
        send(to).send(method)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Metaprogramming</strong> writes code at runtime</li>
<li><strong>define_method</strong> creates methods dynamically</li>
<li><strong>method_missing</strong> handles undefined method calls</li>
<li><strong>class_eval/instance_eval</strong> evaluate code in specific context</li>
<li><strong>send</strong> calls methods dynamically</li>
<li><strong>Rails uses metaprogramming</strong> extensively (has_many, validates, scope)</li>
<li><strong>Benefits</strong>: DRY code, DSLs, powerful abstractions</li>
<li><strong>Drawbacks</strong>: Harder to debug, performance overhead</li>
<li><strong>Use responsibly</strong>: Balance power with maintainability</li>
<li><strong>Document well</strong>: Make metaprogramming code clear</li>
</ol>
<hr>
<h2>Question 309: What is Hotwire (Turbo + Stimulus), and how does it compare to React/Vue?</h2>
<h3>Answer</h3>
<p><strong>Hotwire</strong> (HTML Over The Wire) is Rails&#39; approach to building modern web applications without JavaScript frameworks. It uses <strong>Turbo</strong> for server-rendered HTML updates and <strong>Stimulus</strong> for minimal JavaScript sprinkles.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Hotwire</strong> = Turbo (navigation/streams) + Stimulus (JS controllers)</li>
<li><strong>Philosophy</strong>: Server renders HTML, minimal client-side JS</li>
<li><strong>vs React/Vue</strong>: Less JS, simpler, server-centric</li>
<li><strong>Benefits</strong>: Faster development, less complexity, works without JS</li>
<li><strong>Trade-offs</strong>: Less suitable for complex client-side apps</li>
</ul>
<hr>
<h3>Detailed Comparison</h3>
<pre><code>Traditional SPA (React/Vue):
Browser ← JSON data ← Server
        ↓
     React renders HTML
        ↓
     Complex client-side state

Hotwire:
Browser ← HTML fragments ← Server
        ↓
     Turbo swaps HTML
        ↓
     Minimal client-side state
</code></pre>
<h3>Implementation Examples</h3>
<pre><code class="language-ruby"># 1. Turbo Drive - Fast page navigation
# Automatically enabled, no configuration needed
# Replaces full page loads with AJAX requests

# 2. Turbo Frames - Lazy-loaded sections
&lt;!-- app/views/posts/index.html.erb --&gt;
&lt;turbo-frame id=&quot;posts&quot;&gt;
  &lt;%= render @posts %&gt;
  &lt;%= link_to &quot;New Post&quot;, new_post_path %&gt;
&lt;/turbo-frame&gt;

&lt;!-- app/views/posts/new.html.erb --&gt;
&lt;turbo-frame id=&quot;posts&quot;&gt;
  &lt;%= form_with model: @post do |f| %&gt;
    &lt;%= f.text_field :title %&gt;
    &lt;%= f.submit %&gt;
  &lt;% end %&gt;
&lt;/turbo-frame&gt;

# When clicking &quot;New Post&quot;, only the frame updates!

# 3. Turbo Streams - Real-time updates
# app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  def create
    @post = Post.create(post_params)
    
    respond_to do |format|
      format.turbo_stream do
        render turbo_stream: turbo_stream.prepend(&#39;posts&#39;, partial: &#39;post&#39;, locals: { post: @post })
      end
      format.html { redirect_to @post }
    end
  end
  
  def destroy
    @post = Post.find(params[:id])
    @post.destroy
    
    respond_to do |format|
      format.turbo_stream do
        render turbo_stream: turbo_stream.remove(@post)
      end
    end
  end
end

# Turbo Stream actions:
# - append: Add to end
# - prepend: Add to beginning
# - replace: Replace element
# - update: Update innerHTML
# - remove: Remove element
# - before: Insert before
# - after: Insert after

# 4. Stimulus - Minimal JavaScript
// app/javascript/controllers/dropdown_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;

export default class extends Controller {
  static targets = [&quot;menu&quot;]
  
  toggle() {
    this.menuTarget.classList.toggle(&#39;hidden&#39;)
  }
  
  hide(event) {
    if (!this.element.contains(event.target)) {
      this.menuTarget.classList.add(&#39;hidden&#39;)
    }
  }
}

&lt;!-- Usage in view --&gt;
&lt;div data-controller=&quot;dropdown&quot; data-action=&quot;click@window-&gt;dropdown#hide&quot;&gt;
  &lt;button data-action=&quot;click-&gt;dropdown#toggle&quot;&gt;
    Menu
  &lt;/button&gt;
  
  &lt;div data-dropdown-target=&quot;menu&quot; class=&quot;hidden&quot;&gt;
    &lt;a href=&quot;/profile&quot;&gt;Profile&lt;/a&gt;
    &lt;a href=&quot;/settings&quot;&gt;Settings&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;

# 5. Real-time with Turbo Streams + ActionCable
# app/models/post.rb
class Post &lt; ApplicationRecord
  after_create_commit { broadcast_prepend_to &#39;posts&#39; }
  after_update_commit { broadcast_replace_to &#39;posts&#39; }
  after_destroy_commit { broadcast_remove_to &#39;posts&#39; }
end

&lt;!-- app/views/posts/index.html.erb --&gt;
&lt;%= turbo_stream_from &#39;posts&#39; %&gt;

&lt;div id=&quot;posts&quot;&gt;
  &lt;%= render @posts %&gt;
&lt;/div&gt;

# When any user creates/updates/deletes a post,
# ALL connected users see the update in real-time!

# 6. Lazy loading with Turbo Frames
&lt;!-- app/views/dashboard/show.html.erb --&gt;
&lt;h1&gt;Dashboard&lt;/h1&gt;

&lt;!-- Load immediately --&gt;
&lt;turbo-frame id=&quot;quick-stats&quot;&gt;
  &lt;%= render &#39;quick_stats&#39; %&gt;
&lt;/turbo-frame&gt;

&lt;!-- Lazy load --&gt;
&lt;turbo-frame id=&quot;analytics&quot; src=&quot;&lt;%= analytics_path %&gt;&quot; loading=&quot;lazy&quot;&gt;
  &lt;p&gt;Loading analytics...&lt;/p&gt;
&lt;/turbo-frame&gt;

&lt;!-- Only loads when scrolled into view! --&gt;
</code></pre>
<hr>
<h3>Hotwire vs React/Vue Comparison</h3>
<pre><code class="language-ruby"># Task: Add a todo item

# React/Vue approach:
# 1. User submits form
# 2. JavaScript sends POST /todos (JSON)
# 3. Server returns JSON: { id: 123, title: &quot;Buy milk&quot; }
# 4. React/Vue updates state
# 5. React/Vue re-renders component
# 6. New todo appears

# Lines of code: ~50-100 (component + state management)

# Hotwire approach:
# 1. User submits form
# 2. Rails sends POST /todos (form data)
# 3. Server returns Turbo Stream:
#    &lt;turbo-stream action=&quot;prepend&quot; target=&quot;todos&quot;&gt;
#      &lt;template&gt;&lt;li&gt;Buy milk&lt;/li&gt;&lt;/template&gt;
#    &lt;/turbo-stream&gt;
# 4. New todo appears

# Lines of code: ~10-20 (controller + view)

# Code comparison:

# === React ===
// TodoList.jsx (50 lines)
import React, { useState, useEffect } from &#39;react&#39;

function TodoList() {
  const [todos, setTodos] = useState([])
  const [title, setTitle] = useState(&#39;&#39;)
  
  useEffect(() =&gt; {
    fetch(&#39;/api/todos&#39;)
      .then(res =&gt; res.json())
      .then(data =&gt; setTodos(data))
  }, [])
  
  const handleSubmit = async (e) =&gt; {
    e.preventDefault()
    const response = await fetch(&#39;/api/todos&#39;, {
      method: &#39;POST&#39;,
      headers: { &#39;Content-Type&#39;: &#39;application/json&#39; },
      body: JSON.stringify({ title })
    })
    const newTodo = await response.json()
    setTodos([newTodo, ...todos])
    setTitle(&#39;&#39;)
  }
  
  return (
    &lt;div&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;input value={title} onChange={e =&gt; setTitle(e.target.value)} /&gt;
        &lt;button&gt;Add&lt;/button&gt;
      &lt;/form&gt;
      &lt;ul&gt;
        {todos.map(todo =&gt; &lt;li key={todo.id}&gt;{todo.title}&lt;/li&gt;)}
      &lt;/ul&gt;
    &lt;/div&gt;
  )
}

# === Hotwire ===
# Controller (10 lines)
class TodosController &lt; ApplicationController
  def create
    @todo = Todo.create!(todo_params)
    
    respond_to do |format|
      format.turbo_stream
    end
  end
end

# View (5 lines)
&lt;!-- app/views/todos/create.turbo_stream.erb --&gt;
&lt;%= turbo_stream.prepend &#39;todos&#39;, @todo %&gt;

&lt;!-- app/views/todos/_todo.html.erb --&gt;
&lt;li id=&quot;&lt;%= dom_id(todo) %&gt;&quot;&gt;&lt;%= todo.title %&gt;&lt;/li&gt;

&lt;!-- app/views/todos/index.html.erb --&gt;
&lt;%= form_with model: Todo.new %&gt;
  &lt;%= f.text_field :title %&gt;
  &lt;%= f.submit &quot;Add&quot; %&gt;
&lt;% end %&gt;

&lt;ul id=&quot;todos&quot;&gt;
  &lt;%= render @todos %&gt;
&lt;/ul&gt;
</code></pre>
<hr>
<h3>When to Use What?</h3>
<pre><code class="language-ruby"># Use Hotwire when:
✅ CRUD applications
✅ Content-heavy sites
✅ Real-time updates (chat, notifications)
✅ Team prefers server-side rendering
✅ Want to avoid JavaScript complexity
✅ SEO is important
✅ Progressive enhancement needed

# Use React/Vue when:
✅ Complex client-side interactions
✅ Offline functionality needed
✅ Mobile app (React Native)
✅ Heavy client-side state
✅ Rich animations and transitions
✅ Real-time collaboration (like Figma)
✅ Team has strong JS expertise

# Performance comparison:
Hotwire:
- Initial load: Fast (HTML from server)
- Interactions: Medium (server round-trip)
- Bundle size: Tiny (30KB)
- Time to interactive: Fast

React/Vue:
- Initial load: Slow (large bundle)
- Interactions: Fast (client-side)
- Bundle size: Large (200KB+)
- Time to interactive: Slow
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Hotwire</strong> = Turbo + Stimulus (minimal JS)</li>
<li><strong>Server-centric</strong>: HTML rendered on server</li>
<li><strong>Turbo Drive</strong>: Fast page navigation</li>
<li><strong>Turbo Frames</strong>: Lazy-loaded sections</li>
<li><strong>Turbo Streams</strong>: Real-time updates</li>
<li><strong>Stimulus</strong>: Lightweight JS controllers</li>
<li><strong>Less complexity</strong>: No build tools, state management</li>
<li><strong>Trade-offs</strong>: Not for complex SPAs</li>
<li><strong>Progressive enhancement</strong>: Works without JS</li>
<li><strong>Perfect for Rails</strong>: Embraces Rails conventions</li>
</ol>
<hr>
<h2>Question 310: What is Domain-Driven Design (DDD), and how do you apply it in Rails?</h2>
<h3>Answer</h3>
<p><strong>Domain-Driven Design (DDD)</strong> is an approach to software development that focuses on modeling the business domain. It uses concepts like Entities, Value Objects, Aggregates, Repositories, and Services to create a rich domain model.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>DDD</strong>: Model business domain, not database</li>
<li><strong>Building blocks</strong>: Entities, Value Objects, Aggregates, Services</li>
<li><strong>Rails fit</strong>: Conflicts with Active Record pattern</li>
<li><strong>When useful</strong>: Complex business logic, large applications</li>
<li><strong>Implementation</strong>: Use service objects, form objects, value objects</li>
</ul>
<hr>
<h3>DDD Concepts in Rails</h3>
<pre><code class="language-ruby"># 1. Entities - Objects with identity
class Order
  attr_reader :id, :customer_id, :status, :items
  
  def initialize(id:, customer_id:, status: &#39;pending&#39;, items: [])
    @id = id
    @customer_id = customer_id
    @status = status
    @items = items
  end
  
  def add_item(product, quantity)
    @items &lt;&lt; OrderItem.new(product, quantity)
  end
  
  def total
    @items.sum(&amp;:subtotal)
  end
  
  def place
    raise &quot;Order already placed&quot; unless pending?
    @status = &#39;placed&#39;
    # Emit domain event
    OrderPlaced.new(self)
  end
  
  def pending?
    @status == &#39;pending&#39;
  end
end

# 2. Value Objects - Immutable objects without identity
class Money
  attr_reader :amount, :currency
  
  def initialize(amount, currency = &#39;USD&#39;)
    @amount = BigDecimal(amount.to_s)
    @currency = currency
    freeze
  end
  
  def +(other)
    raise &quot;Currency mismatch&quot; unless @currency == other.currency
    Money.new(@amount + other.amount, @currency)
  end
  
  def ==(other)
    @amount == other.amount &amp;&amp; @currency == other.currency
  end
end

# 3. Aggregates - Cluster of entities and value objects
class Order
  # Order is the aggregate root
  # OrderItems can only be accessed through Order
  
  def add_item(product, quantity)
    # Business logic ensures invariants
    raise &quot;Cannot modify placed order&quot; if placed?
    raise &quot;Invalid quantity&quot; if quantity &lt;= 0
    
    @items &lt;&lt; OrderItem.new(product, quantity)
  end
  
  # OrderItem is part of the aggregate
  class OrderItem
    attr_reader :product, :quantity
    
    def initialize(product, quantity)
      @product = product
      @quantity = quantity
    end
    
    def subtotal
      product.price * quantity
    end
  end
end

# 4. Domain Services - Operations that don&#39;t belong to entities
class PricingService
  def calculate_total(order, discount_code = nil)
    subtotal = order.items.sum(&amp;:subtotal)
    discount = calculate_discount(subtotal, discount_code)
    tax = calculate_tax(subtotal - discount)
    
    subtotal - discount + tax
  end
  
  private
  
  def calculate_discount(amount, code)
    return Money.new(0) unless code
    
    discount = Discount.find_by(code: code)
    amount * (discount.percentage / 100.0)
  end
  
  def calculate_tax(amount)
    amount * 0.08 # 8% tax
  end
end

# 5. Repositories - Abstract data access
class OrderRepository
  def find(id)
    record = OrderRecord.find(id)
    map_to_domain(record)
  end
  
  def save(order)
    record = OrderRecord.find_or_initialize_by(id: order.id)
    record.customer_id = order.customer_id
    record.status = order.status
    record.save!
    
    # Save items
    order.items.each do |item|
      OrderItemRecord.create!(
        order_id: order.id,
        product_id: item.product.id,
        quantity: item.quantity
      )
    end
    
    order
  end
  
  private
  
  def map_to_domain(record)
    Order.new(
      id: record.id,
      customer_id: record.customer_id,
      status: record.status,
      items: record.order_items.map { |item_record|
        Order::OrderItem.new(
          Product.find(item_record.product_id),
          item_record.quantity
        )
      }
    )
  end
end

# 6. Domain Events - Things that happened
class OrderPlaced
  attr_reader :order, :occurred_at
  
  def initialize(order)
    @order = order
    @occurred_at = Time.current
  end
end

class EventPublisher
  @subscribers = Hash.new { |h, k| h[k] = [] }
  
  def self.subscribe(event_class, &amp;block)
    @subscribers[event_class] &lt;&lt; block
  end
  
  def self.publish(event)
    @subscribers[event.class].each { |subscriber| subscriber.call(event) }
  end
end

# Subscribe to events
EventPublisher.subscribe(OrderPlaced) do |event|
  SendOrderConfirmationEmail.call(event.order)
  UpdateInventory.call(event.order)
  NotifyWarehouse.call(event.order)
end

# 7. Complete DDD example - Place Order use case
class PlaceOrderService
  def initialize(order_repository: OrderRepository.new,
                 pricing_service: PricingService.new,
                 event_publisher: EventPublisher)
    @order_repository = order_repository
    @pricing_service = pricing_service
    @event_publisher = event_publisher
  end
  
  def call(order_id:, discount_code: nil)
    # Load aggregate
    order = @order_repository.find(order_id)
    
    # Business logic
    total = @pricing_service.calculate_total(order, discount_code)
    order.place
    
    # Persist
    @order_repository.save(order)
    
    # Publish events
    @event_publisher.publish(OrderPlaced.new(order))
    
    Result.success(order: order, total: total)
  rescue =&gt; e
    Result.failure(error: e.message)
  end
end
</code></pre>
<hr>
<h3>DDD vs Rails Active Record</h3>
<pre><code class="language-ruby"># Active Record (Rails default)
class Order &lt; ApplicationRecord
  has_many :order_items
  belongs_to :customer
  
  validates :status, presence: true
  
  def total
    order_items.sum { |item| item.quantity * item.product.price }
  end
end

# Pros:
# ✅ Simple, quick to build
# ✅ Works well for CRUD apps
# ✅ Less code

# Cons:
# ❌ Anemic domain model (just data)
# ❌ Business logic scattered
# ❌ Hard to test in isolation
# ❌ Tight coupling to database

# Domain-Driven Design
class Order
  # Rich domain model with behavior
  def add_item(product, quantity)
    validate_can_add_item
    @items &lt;&lt; OrderItem.new(product, quantity)
    recalculate_total
  end
  
  def place
    validate_can_place
    @status = &#39;placed&#39;
    OrderPlaced.new(self)
  end
  
  def cancel
    validate_can_cancel
    @status = &#39;cancelled&#39;
    OrderCancelled.new(self)
  end
end

# Pros:
# ✅ Rich domain model (behavior + data)
# ✅ Business logic centralized
# ✅ Easy to test (no database)
# ✅ Decoupled from infrastructure

# Cons:
# ❌ More complex
# ❌ More code to write
# ❌ Learning curve
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>DDD</strong> models business domain, not database</li>
<li><strong>Entities</strong> have identity (Order #123)</li>
<li><strong>Value Objects</strong> are immutable (Money, Address)</li>
<li><strong>Aggregates</strong> enforce business rules</li>
<li><strong>Services</strong> contain domain logic</li>
<li><strong>Repositories</strong> abstract data access</li>
<li><strong>Events</strong> communicate what happened</li>
<li><strong>Rails + DDD</strong> requires extra layers</li>
<li><strong>Use when</strong>: Complex business logic</li>
<li><strong>Overkill for</strong>: Simple CRUD apps</li>
</ol>
<hr>
<h2>Question 311: What are the differences between TDD, BDD, and Integration Testing?</h2>
<h3>Answer</h3>
<p><strong>TDD</strong> (Test-Driven Development) writes tests before code. <strong>BDD</strong> (Behavior-Driven Development) focuses on business behavior with readable specs. <strong>Integration Testing</strong> tests multiple components working together.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>TDD</strong>: Write test → Write code → Refactor (Red-Green-Refactor)</li>
<li><strong>BDD</strong>: Describe behavior in plain English (Given-When-Then)</li>
<li><strong>Integration</strong>: Test multiple components together</li>
<li><strong>Unit tests</strong>: Fast, isolated, test single methods</li>
<li><strong>E2E tests</strong>: Slow, test complete user workflows</li>
</ul>
<hr>
<h3>Detailed Comparison</h3>
<pre><code class="language-ruby"># 1. TDD (Test-Driven Development)
# Red → Green → Refactor cycle

# Step 1: Write failing test (RED)
RSpec.describe Calculator do
  describe &#39;#add&#39; do
    it &#39;returns sum of two numbers&#39; do
      calculator = Calculator.new
      expect(calculator.add(2, 3)).to eq(5)
    end
  end
end
# Run: test fails (no Calculator class)

# Step 2: Write minimal code to pass (GREEN)
class Calculator
  def add(a, b)
    a + b
  end
end
# Run: test passes

# Step 3: Refactor
class Calculator
  def add(*numbers)
    numbers.sum
  end
end
# Run: test still passes

# TDD Principles:
# - Write test first
# - Write minimum code to pass
# - Refactor with confidence
# - High test coverage

# 2. BDD (Behavior-Driven Development)
# Uses plain English specifications

# RSpec (BDD style)
RSpec.describe &#39;User registration&#39; do
  context &#39;when user provides valid information&#39; do
    it &#39;creates a new account&#39; do
      # Given: Initial state
      visit new_user_path
      
      # When: User action
      fill_in &#39;Email&#39;, with: &#39;user@example.com&#39;
      fill_in &#39;Password&#39;, with: &#39;password123&#39;
      click_button &#39;Sign Up&#39;
      
      # Then: Expected outcome
      expect(page).to have_content(&#39;Welcome!&#39;)
      expect(User.count).to eq(1)
    end
  end
  
  context &#39;when email is already taken&#39; do
    it &#39;shows error message&#39; do
      # Given
      User.create!(email: &#39;user@example.com&#39;, password: &#39;password&#39;)
      visit new_user_path
      
      # When
      fill_in &#39;Email&#39;, with: &#39;user@example.com&#39;
      fill_in &#39;Password&#39;, with: &#39;password123&#39;
      click_button &#39;Sign Up&#39;
      
      # Then
      expect(page).to have_content(&#39;Email has already been taken&#39;)
      expect(User.count).to eq(1)
    end
  end
end

# Cucumber (BDD with Gherkin syntax)
# features/user_registration.feature
Feature: User Registration
  As a visitor
  I want to create an account
  So that I can access the application
  
  Scenario: Successful registration
    Given I am on the registration page
    When I fill in &quot;Email&quot; with &quot;user@example.com&quot;
    And I fill in &quot;Password&quot; with &quot;password123&quot;
    And I click &quot;Sign Up&quot;
    Then I should see &quot;Welcome!&quot;
    And a new user should be created
  
  Scenario: Registration with taken email
    Given a user exists with email &quot;user@example.com&quot;
    And I am on the registration page
    When I fill in &quot;Email&quot; with &quot;user@example.com&quot;
    And I fill in &quot;Password&quot; with &quot;password123&quot;
    And I click &quot;Sign Up&quot;
    Then I should see &quot;Email has already been taken&quot;

# Step definitions (Cucumber)
# features/step_definitions/user_steps.rb
Given(&#39;I am on the registration page&#39;) do
  visit new_user_path
end

When(&#39;I fill in {string} with {string}&#39;) do |field, value|
  fill_in field, with: value
end

When(&#39;I click {string}&#39;) do |button|
  click_button button
end

Then(&#39;I should see {string}&#39;) do |text|
  expect(page).to have_content(text)
end

# 3. Unit Testing (TDD style)
# Fast, isolated, test single methods

RSpec.describe User do
  describe &#39;#full_name&#39; do
    it &#39;returns first and last name combined&#39; do
      user = User.new(first_name: &#39;John&#39;, last_name: &#39;Doe&#39;)
      expect(user.full_name).to eq(&#39;John Doe&#39;)
    end
  end
  
  describe &#39;.active&#39; do
    it &#39;returns only active users&#39; do
      active = User.create!(status: &#39;active&#39;)
      inactive = User.create!(status: &#39;inactive&#39;)
      
      expect(User.active).to include(active)
      expect(User.active).not_to include(inactive)
    end
  end
end

# 4. Integration Testing
# Tests multiple components together

RSpec.describe &#39;Order placement&#39; do
  it &#39;creates order and charges payment&#39; do
    user = create(:user)
    product = create(:product, price: 19.99)
    
    # Add to cart
    post &#39;/cart/items&#39;, params: { 
      product_id: product.id, 
      quantity: 2 
    }
    
    # Checkout
    post &#39;/orders&#39;, params: {
      payment_method: &#39;credit_card&#39;,
      card_number: &#39;4242424242424242&#39;
    }
    
    # Verify order created
    expect(Order.count).to eq(1)
    order = Order.last
    expect(order.total).to eq(39.98)
    expect(order.status).to eq(&#39;paid&#39;)
    
    # Verify payment charged
    expect(Payment.count).to eq(1)
    payment = Payment.last
    expect(payment.amount).to eq(39.98)
    expect(payment.status).to eq(&#39;succeeded&#39;)
    
    # Verify email sent
    expect(ActionMailer::Base.deliveries.count).to eq(1)
    email = ActionMailer::Base.deliveries.last
    expect(email.to).to eq([user.email])
    expect(email.subject).to eq(&#39;Order Confirmation&#39;)
  end
end

# 5. End-to-End (E2E) Testing
# Tests complete user workflow

RSpec.feature &#39;Complete shopping flow&#39;, type: :system do
  scenario &#39;User browses, adds to cart, and completes checkout&#39; do
    # Setup
    product = create(:product, name: &#39;Ruby Book&#39;, price: 29.99)
    
    # Browse products
    visit products_path
    expect(page).to have_content(&#39;Ruby Book&#39;)
    expect(page).to have_content(&#39;$29.99&#39;)
    
    # Add to cart
    click_button &#39;Add to Cart&#39;
    expect(page).to have_content(&#39;Added to cart&#39;)
    
    # View cart
    click_link &#39;Cart (1)&#39;
    expect(page).to have_content(&#39;Ruby Book&#39;)
    expect(page).to have_content(&#39;$29.99&#39;)
    
    # Checkout
    click_button &#39;Checkout&#39;
    
    # Fill shipping info
    fill_in &#39;Address&#39;, with: &#39;123 Main St&#39;
    fill_in &#39;City&#39;, with: &#39;New York&#39;
    select &#39;NY&#39;, from: &#39;State&#39;
    fill_in &#39;Zip&#39;, with: &#39;10001&#39;
    
    # Fill payment info
    fill_in &#39;Card Number&#39;, with: &#39;4242424242424242&#39;
    fill_in &#39;Expiry&#39;, with: &#39;12/25&#39;
    fill_in &#39;CVC&#39;, with: &#39;123&#39;
    
    # Place order
    click_button &#39;Place Order&#39;
    
    # Verify success
    expect(page).to have_content(&#39;Order placed successfully&#39;)
    expect(page).to have_content(&#39;Order #&#39;)
    
    # Verify email
    open_email(user.email)
    expect(current_email).to have_subject(&#39;Order Confirmation&#39;)
    expect(current_email).to have_content(&#39;Ruby Book&#39;)
  end
end
</code></pre>
<hr>
<h3>Test Pyramid</h3>
<pre><code>           E2E Tests (5%)
          /            \
         /   Slow (10s) \
        /  Full browser  \
       /  Real database   \
      /_____________________\
     
       Integration Tests (15%)
      /                      \
     /    Medium speed (1s)   \
    /   Multiple components    \
   /__________________________\
  
        Unit Tests (80%)
       /                  \
      /   Fast (&lt;100ms)    \
     /   Single methods     \
    /   Mock dependencies    \
   /_______________________\
</code></pre>
<hr>
<h3>When to Use Each</h3>
<pre><code class="language-ruby"># Use Unit Tests (80%) for:
✅ Business logic
✅ Calculations
✅ Validations
✅ Model methods
✅ Utilities

# Example:
it &#39;calculates discount correctly&#39; do
  product = Product.new(price: 100)
  expect(product.discounted_price(0.10)).to eq(90)
end

# Use Integration Tests (15%) for:
✅ Controller actions
✅ API endpoints
✅ Service objects
✅ Multiple models
✅ Database interactions

# Example:
it &#39;creates order with items&#39; do
  post &#39;/orders&#39;, params: { items: [...] }
  expect(Order.count).to eq(1)
  expect(OrderItem.count).to eq(3)
end

# Use E2E Tests (5%) for:
✅ Critical user paths
✅ Registration/login
✅ Checkout flow
✅ Payment processing
✅ Cross-browser testing

# Example:
scenario &#39;user completes purchase&#39; do
  visit products_path
  # ... full workflow ...
  expect(page).to have_content(&#39;Purchase complete&#39;)
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>TDD</strong>: Write test first, then code (Red-Green-Refactor)</li>
<li><strong>BDD</strong>: Focus on behavior, readable by non-developers</li>
<li><strong>Unit tests</strong>: Fast, isolated, 80% of tests</li>
<li><strong>Integration tests</strong>: Multiple components, 15% of tests</li>
<li><strong>E2E tests</strong>: Complete workflows, 5% of tests</li>
<li><strong>Test pyramid</strong>: Many unit tests, few E2E tests</li>
<li><strong>TDD benefits</strong>: Better design, documentation, confidence</li>
<li><strong>BDD benefits</strong>: Shared understanding, living documentation</li>
<li><strong>Balance</strong>: Mix of unit, integration, and E2E tests</li>
<li><strong>Fast feedback</strong>: Run unit tests frequently, E2E less often</li>
</ol>
<hr>
<h2>Question 312: What is Event Sourcing, and how would you implement it in Rails?</h2>
<h3>Answer</h3>
<p><strong>Event Sourcing</strong> stores all changes to application state as a sequence of events. Instead of storing current state, you store all events that led to that state, allowing you to rebuild state at any point in time.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Event Sourcing</strong>: Store events, not current state</li>
<li><strong>Events</strong>: Immutable records of what happened</li>
<li><strong>Benefits</strong>: Complete audit trail, time travel, event replay</li>
<li><strong>Projections</strong>: Build current state from events</li>
<li><strong>Rails implementation</strong>: Events table, event handlers, projections</li>
</ul>
<hr>
<h3>Implementation</h3>
<pre><code class="language-ruby"># 1. Event Store
# app/models/event.rb
class Event &lt; ApplicationRecord
  # Schema:
  # - aggregate_type (string): &quot;Order&quot;, &quot;User&quot;
  # - aggregate_id (integer): 123
  # - event_type (string): &quot;OrderPlaced&quot;, &quot;OrderCancelled&quot;
  # - data (jsonb): Event payload
  # - metadata (jsonb): User ID, IP, timestamp
  # - version (integer): Optimistic locking
  # - created_at (datetime)
  
  serialize :data, JSON
  serialize :metadata, JSON
  
  validates :aggregate_type, :aggregate_id, :event_type, presence: true
  
  scope :for_aggregate, -&gt;(type, id) {
    where(aggregate_type: type, aggregate_id: id)
      .order(:version)
  }
end

# 2. Domain Events
class OrderPlaced
  attr_reader :order_id, :customer_id, :items, :total, :occurred_at
  
  def initialize(order_id:, customer_id:, items:, total:)
    @order_id = order_id
    @customer_id = customer_id
    @items = items
    @total = total
    @occurred_at = Time.current
  end
  
  def to_h
    {
      order_id: @order_id,
      customer_id: @customer_id,
      items: @items,
      total: @total,
      occurred_at: @occurred_at
    }
  end
end

class OrderShipped
  attr_reader :order_id, :tracking_number, :shipped_at
  
  def initialize(order_id:, tracking_number:)
    @order_id = order_id
    @tracking_number = tracking_number
    @shipped_at = Time.current
  end
  
  def to_h
    {
      order_id: @order_id,
      tracking_number: @tracking_number,
      shipped_at: @shipped_at
    }
  end
end

# 3. Event Store Service
class EventStore
  def append(aggregate_type, aggregate_id, event, metadata = {})
    last_version = Event.for_aggregate(aggregate_type, aggregate_id)
                       .maximum(:version) || 0
    
    Event.create!(
      aggregate_type: aggregate_type,
      aggregate_id: aggregate_id,
      event_type: event.class.name,
      data: event.to_h,
      metadata: metadata.merge(timestamp: Time.current),
      version: last_version + 1
    )
  end
  
  def load(aggregate_type, aggregate_id)
    Event.for_aggregate(aggregate_type, aggregate_id)
  end
  
  def replay(aggregate_type, aggregate_id, until_version: nil)
    events = load(aggregate_type, aggregate_id)
    events = events.where(&#39;version &lt;= ?&#39;, until_version) if until_version
    events
  end
end

# 4. Aggregate (reconstructed from events)
class Order
  attr_reader :id, :customer_id, :items, :status, :total
  
  def self.load(order_id)
    events = EventStore.new.load(&#39;Order&#39;, order_id)
    
    order = new(id: order_id)
    events.each do |event|
      order.apply_event(event)
    end
    
    order
  end
  
  def initialize(id:)
    @id = id
    @items = []
    @status = &#39;pending&#39;
    @total = 0
  end
  
  def place(customer_id:, items:, total:)
    event = OrderPlaced.new(
      order_id: @id,
      customer_id: customer_id,
      items: items,
      total: total
    )
    
    store_event(event)
    apply_event_data(event.to_h)
  end
  
  def ship(tracking_number:)
    raise &quot;Cannot ship order that is not placed&quot; unless @status == &#39;placed&#39;
    
    event = OrderShipped.new(
      order_id: @id,
      tracking_number: tracking_number
    )
    
    store_event(event)
    apply_event_data(event.to_h)
  end
  
  def apply_event(event_record)
    data = event_record.data.symbolize_keys
    apply_event_data(data)
  end
  
  private
  
  def apply_event_data(data)
    case data[:class] || self.class.infer_event_class(data)
    when &#39;OrderPlaced&#39;
      @customer_id = data[:customer_id]
      @items = data[:items]
      @total = data[:total]
      @status = &#39;placed&#39;
    when &#39;OrderShipped&#39;
      @tracking_number = data[:tracking_number]
      @status = &#39;shipped&#39;
    end
  end
  
  def store_event(event)
    EventStore.new.append(&#39;Order&#39;, @id, event, {
      user_id: Current.user&amp;.id,
      ip_address: Current.ip_address
    })
  end
end

# 5. Projections (Read Models)
# app/models/order_projection.rb
class OrderProjection &lt; ApplicationRecord
  # Regular ActiveRecord model for queries
  # Schema:
  # - order_id (integer)
  # - customer_id (integer)
  # - status (string)
  # - total (decimal)
  # - placed_at (datetime)
  # - shipped_at (datetime)
end

# app/services/order_projection_builder.rb
class OrderProjectionBuilder
  def rebuild_all
    OrderProjection.delete_all
    
    Event.where(aggregate_type: &#39;Order&#39;)
         .order(:aggregate_id, :version)
         .each do |event|
      apply_event(event)
    end
  end
  
  def apply_event(event)
    projection = OrderProjection.find_or_initialize_by(
      order_id: event.aggregate_id
    )
    
    data = event.data.symbolize_keys
    
    case event.event_type
    when &#39;OrderPlaced&#39;
      projection.customer_id = data[:customer_id]
      projection.total = data[:total]
      projection.status = &#39;placed&#39;
      projection.placed_at = data[:occurred_at]
    when &#39;OrderShipped&#39;
      projection.status = &#39;shipped&#39;
      projection.shipped_at = data[:shipped_at]
    end
    
    projection.save!
  end
end

# 6. Event Handlers (Side Effects)
class OrderEventHandler
  def self.handle(event)
    case event.event_type
    when &#39;OrderPlaced&#39;
      SendOrderConfirmationEmail.call(event.data)
      UpdateInventory.call(event.data)
    when &#39;OrderShipped&#39;
      SendShippingNotification.call(event.data)
    end
  end
end

# Subscribe to events
ActiveSupport::Notifications.subscribe(&#39;event.created&#39;) do |name, start, finish, id, payload|
  event = payload[:event]
  OrderEventHandler.handle(event)
end

# Trigger notification after event stored
class EventStore
  def append(aggregate_type, aggregate_id, event, metadata = {})
    event_record = Event.create!(...)
    
    ActiveSupport::Notifications.instrument(&#39;event.created&#39;, event: event_record)
    
    event_record
  end
end

# 7. Usage in Controller
class OrdersController &lt; ApplicationController
  def create
    order_id = SecureRandom.uuid
    order = Order.new(id: order_id)
    
    order.place(
      customer_id: current_user.id,
      items: cart.items,
      total: cart.total
    )
    
    # Rebuild projection
    OrderProjectionBuilder.new.apply_event(
      Event.for_aggregate(&#39;Order&#39;, order_id).last
    )
    
    redirect_to order_path(order_id)
  end
  
  def show
    # Query projection (fast!)
    @order = OrderProjection.find_by!(order_id: params[:id])
  end
  
  def history
    # Show all events
    @events = Event.for_aggregate(&#39;Order&#39;, params[:id])
  end
  
  def time_travel
    # Replay to specific version
    version = params[:version].to_i
    events = EventStore.new.replay(&#39;Order&#39;, params[:id], until_version: version)
    
    order = Order.new(id: params[:id])
    events.each { |event| order.apply_event(event) }
    
    render json: order
  end
end
</code></pre>
<hr>
<h3>Event Sourcing Benefits</h3>
<pre><code class="language-ruby"># 1. Complete Audit Trail
# See exactly what happened and when
events = Event.for_aggregate(&#39;Order&#39;, 123)
# =&gt; [
#   { event: &quot;OrderPlaced&quot;, at: &quot;2024-01-01 10:00&quot; },
#   { event: &quot;OrderPaid&quot;, at: &quot;2024-01-01 10:05&quot; },
#   { event: &quot;OrderShipped&quot;, at: &quot;2024-01-02 14:30&quot; }
# ]

# 2. Time Travel
# See state at any point in time
order_yesterday = Order.load(123, until: 1.day.ago)
order_last_week = Order.load(123, until: 1.week.ago)

# 3. Event Replay
# Rebuild projections from events
OrderProjectionBuilder.new.rebuild_all

# 4. Debugging
# Reproduce bugs by replaying events
events = Event.for_aggregate(&#39;Order&#39;, 123)
order = Order.new(id: 123)
events.each { |event| order.apply_event(event) }
# Now you can step through exact state changes

# 5. Business Intelligence
# Analyze event patterns
Event.where(event_type: &#39;OrderCancelled&#39;)
     .group_by_day(:created_at)
     .count
# =&gt; { &quot;2024-01-01&quot; =&gt; 5, &quot;2024-01-02&quot; =&gt; 3 }

# 6. Multiple Read Models
# Create different projections for different uses
OrderSummaryProjection  # For listings
OrderDetailProjection   # For details page
OrderAnalyticsProjection # For reports
</code></pre>
<hr>
<h3>Event Sourcing Challenges</h3>
<pre><code class="language-ruby"># 1. Schema Evolution
# What if event structure changes?

# V1 Event
{ event: &quot;OrderPlaced&quot;, total: 100 }

# V2 Event (added currency)
{ event: &quot;OrderPlaced&quot;, total: 100, currency: &quot;USD&quot; }

# Solution: Upcasting
class EventUpcaster
  def upcast(event)
    case event.event_type
    when &#39;OrderPlaced&#39;
      if event.data[:currency].nil?
        event.data[:currency] = &#39;USD&#39; # Default
      end
    end
    
    event
  end
end

# 2. Event Versioning
class Event &lt; ApplicationRecord
  # Add event_version column
  def data
    upcaster = EventUpcaster.new
    upcaster.upcast(super)
  end
end

# 3. Eventual Consistency
# Projections may be slightly behind events

# Write
order.place(...)  # Event stored immediately

# Read (projection may not be updated yet)
OrderProjection.find_by(order_id: order.id)  # May be nil!

# Solution: Ensure projection built before redirect
projection = OrderProjectionBuilder.new.apply_event(event)
redirect_to order_path(projection.order_id)

# 4. Event Store Growth
# Events grow forever!

# Solution: Snapshots
class OrderSnapshot &lt; ApplicationRecord
  # Store current state at intervals
  # Replay from snapshot instead of beginning
end

def self.load(order_id)
  snapshot = OrderSnapshot.where(order_id: order_id).last
  
  if snapshot
    order = snapshot.restore
    events_after_snapshot = Event.where(
      aggregate_id: order_id,
      &#39;version &gt; ?&#39;, snapshot.version
    )
    events_after_snapshot.each { |event| order.apply_event(event) }
  else
    order = new(id: order_id)
    events = Event.for_aggregate(&#39;Order&#39;, order_id)
    events.each { |event| order.apply_event(event) }
  end
  
  order
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Event Sourcing</strong> stores events, not current state</li>
<li><strong>Events</strong> are immutable facts about what happened</li>
<li><strong>Projections</strong> (read models) built from events</li>
<li><strong>Complete audit trail</strong> of all changes</li>
<li><strong>Time travel</strong> to any point in history</li>
<li><strong>Event replay</strong> to rebuild state</li>
<li><strong>Challenges</strong>: Schema evolution, eventual consistency</li>
<li><strong>Not for everything</strong>: Adds complexity</li>
<li><strong>Use when</strong>: Audit trail critical, complex domain</li>
<li><strong>Rails fit</strong>: Requires additional infrastructure</li>
</ol>
<hr>
<h2>Question 313: What is CQRS, and how does it relate to Event Sourcing?</h2>
<h3>Answer</h3>
<p><strong>CQRS</strong> (Command Query Responsibility Segregation) separates read and write operations into different models. Commands change state, queries retrieve data. It&#39;s often used with Event Sourcing but can be used independently.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>CQRS</strong>: Separate models for reads and writes</li>
<li><strong>Commands</strong>: Change state (CreateOrder, CancelOrder)</li>
<li><strong>Queries</strong>: Read data (GetOrderDetails, ListOrders)</li>
<li><strong>Benefits</strong>: Optimized reads/writes, scalability, flexibility</li>
<li><strong>Often paired</strong> with Event Sourcing</li>
</ul>
<hr>
<h3>Implementation</h3>
<pre><code class="language-ruby"># Without CQRS (traditional):
class Order &lt; ApplicationRecord
  # Same model for reads AND writes
  def self.create_order(params)  # Write
    create!(params)
  end
  
  def self.find_order(id)  # Read
    find(id)
  end
end

# With CQRS:
# Separate command and query models

# === WRITE SIDE (Commands) ===
# app/commands/create_order_command.rb
class CreateOrderCommand
  attr_reader :customer_id, :items, :total
  
  def initialize(customer_id:, items:, total:)
    @customer_id = customer_id
    @items = items
    @total = total
  end
  
  def execute
    order_id = SecureRandom.uuid
    
    # Store event
    event = OrderCreatedEvent.new(
      order_id: order_id,
      customer_id: @customer_id,
      items: @items,
      total: @total
    )
    
    EventStore.append(event)
    
    # Publish to update read model
    EventBus.publish(event)
    
    Result.success(order_id: order_id)
  end
end

# app/commands/cancel_order_command.rb
class CancelOrderCommand
  def initialize(order_id:, reason:)
    @order_id = order_id
    @reason = reason
  end
  
  def execute
    # Load aggregate from events
    order = OrderAggregate.load(@order_id)
    
    # Business logic
    order.cancel(@reason)
    
    # Store event
    event = OrderCancelledEvent.new(
      order_id: @order_id,
      reason: @reason
    )
    
    EventStore.append(event)
    EventBus.publish(event)
    
    Result.success
  end
end

# === READ SIDE (Queries) ===
# app/queries/get_order_query.rb
class GetOrderQuery
  def initialize(order_id)
    @order_id = order_id
  end
  
  def execute
    # Query optimized read model
    OrderReadModel.find_by!(order_id: @order_id)
  end
end

# app/queries/list_orders_query.rb
class ListOrdersQuery
  def initialize(customer_id:, status: nil, page: 1)
    @customer_id = customer_id
    @status = status
    @page = page
  end
  
  def execute
    orders = OrderReadModel.where(customer_id: @customer_id)
    orders = orders.where(status: @status) if @status
    orders.page(@page).per(20)
  end
end

# app/queries/order_analytics_query.rb
class OrderAnalyticsQuery
  def execute
    # Query denormalized analytics model
    {
      total_orders: OrderAnalytics.sum(:order_count),
      total_revenue: OrderAnalytics.sum(:revenue),
      by_status: OrderAnalytics.group(:status).sum(:order_count)
    }
  end
end

# === READ MODELS (Projections) ===
# app/models/order_read_model.rb
class OrderReadModel &lt; ApplicationRecord
  # Optimized for queries
  # Denormalized data
  # Schema:
  # - order_id (string, indexed)
  # - customer_id (integer, indexed)
  # - customer_name (string) # denormalized!
  # - status (string, indexed)
  # - total (decimal)
  # - items_json (jsonb)
  # - created_at (datetime, indexed)
  # - updated_at (datetime)
  
  # Fast queries
  scope :pending, -&gt; { where(status: &#39;pending&#39;) }
  scope :for_customer, -&gt;(id) { where(customer_id: id) }
  scope :recent, -&gt; { order(created_at: :desc) }
end

# app/models/order_analytics.rb
class OrderAnalytics &lt; ApplicationRecord
  # Aggregated data for analytics
  # Schema:
  # - date (date, indexed)
  # - order_count (integer)
  # - revenue (decimal)
  # - status (string)
end

# === EVENT HANDLERS (Update Read Models) ===
# app/handlers/order_event_handler.rb
class OrderEventHandler
  def self.handle(event)
    case event
    when OrderCreatedEvent
      create_read_model(event)
      update_analytics(event)
    when OrderCancelledEvent
      update_read_model_status(event)
      update_analytics(event)
    end
  end
  
  private
  
  def self.create_read_model(event)
    customer = Customer.find(event.customer_id)
    
    OrderReadModel.create!(
      order_id: event.order_id,
      customer_id: event.customer_id,
      customer_name: customer.full_name,  # Denormalized
      status: &#39;pending&#39;,
      total: event.total,
      items_json: event.items
    )
  end
  
  def self.update_read_model_status(event)
    order = OrderReadModel.find_by!(order_id: event.order_id)
    order.update!(status: &#39;cancelled&#39;)
  end
  
  def self.update_analytics(event)
    date = event.occurred_at.to_date
    
    analytics = OrderAnalytics.find_or_initialize_by(
      date: date,
      status: event.status
    )
    
    analytics.order_count += 1
    analytics.revenue += event.total if event.is_a?(OrderCreatedEvent)
    analytics.save!
  end
end

# === CONTROLLERS ===
# app/controllers/orders_controller.rb
class OrdersController &lt; ApplicationController
  # Commands (writes)
  def create
    command = CreateOrderCommand.new(
      customer_id: current_user.id,
      items: cart.items,
      total: cart.total
    )
    
    result = command.execute
    
    if result.success?
      redirect_to order_path(result.order_id)
    else
      render :new, alert: result.error
    end
  end
  
  def cancel
    command = CancelOrderCommand.new(
      order_id: params[:id],
      reason: params[:reason]
    )
    
    result = command.execute
    
    if result.success?
      redirect_to orders_path, notice: &#39;Order cancelled&#39;
    else
      redirect_to order_path(params[:id]), alert: result.error
    end
  end
  
  # Queries (reads)
  def index
    query = ListOrdersQuery.new(
      customer_id: current_user.id,
      status: params[:status],
      page: params[:page]
    )
    
    @orders = query.execute
  end
  
  def show
    query = GetOrderQuery.new(params[:id])
    @order = query.execute
  end
  
  def analytics
    query = OrderAnalyticsQuery.new
    @analytics = query.execute
  end
end
</code></pre>
<hr>
<h3>CQRS Benefits</h3>
<pre><code class="language-ruby"># 1. Optimized Read/Write Models
# Write model: Enforces business rules
class OrderAggregate
  def cancel
    raise &quot;Cannot cancel shipped order&quot; if shipped?
    # ...
  end
end

# Read model: Denormalized for fast queries
class OrderReadModel
  # Includes customer name, product names, etc.
  # No joins needed!
end

# 2. Scalability
# Read and write can scale independently
# - Write DB: Small, optimized for writes
# - Read DB: Large, replicated, optimized for queries

# 3. Multiple Read Models
# Different views of same data
OrderReadModel          # For UI
OrderSearchModel        # For ElasticSearch
OrderAnalyticsModel     # For reports
OrderNotificationModel  # For emails

# 4. Flexibility
# Change read models without affecting writes
# Add new projections without touching write side

# 5. Performance
# Queries are fast (no complex joins)
SELECT * FROM order_read_models WHERE customer_id = 123
# vs
SELECT orders.*, customers.*, order_items.*, products.*
FROM orders
JOIN customers ON...
JOIN order_items ON...
JOIN products ON...
WHERE customers.id = 123
</code></pre>
<hr>
<h3>CQRS Challenges</h3>
<pre><code class="language-ruby"># 1. Eventual Consistency
# Read models may lag behind writes

# Write
CreateOrderCommand.new(...).execute
# Returns immediately

# Read (may not see new order yet!)
ListOrdersQuery.new(customer_id: 123).execute
# Doesn&#39;t include new order

# Solution: Return order_id from command
result = CreateOrderCommand.new(...).execute
redirect_to order_path(result.order_id)
# Or poll/wait for read model

# 2. Complexity
# More code, more models
- Commands
- Queries
- Write models
- Read models
- Event handlers
- Projections

# 3. Data Duplication
# Same data in multiple places
- Events
- Aggregates (in memory)
- Read models
- Analytics models

# 4. Rebuilding Projections
# If read model corrupted, must rebuild
OrderReadModel.delete_all
events = Event.where(aggregate_type: &#39;Order&#39;)
events.each { |event| OrderEventHandler.handle(event) }
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>CQRS</strong> separates reads and writes</li>
<li><strong>Commands</strong> change state (writes)</li>
<li><strong>Queries</strong> retrieve data (reads)</li>
<li><strong>Different models</strong> for reads vs writes</li>
<li><strong>Benefits</strong>: Scalability, flexibility, performance</li>
<li><strong>Challenges</strong>: Complexity, eventual consistency</li>
<li><strong>Often paired</strong> with Event Sourcing</li>
<li><strong>Use when</strong>: Complex queries, high read/write ratio</li>
<li><strong>Overkill for</strong>: Simple CRUD apps</li>
<li><strong>Rails fit</strong>: Requires discipline and architecture</li>
</ol>
<hr>
<h2>Question 314: What are the best practices for Rails application security?</h2>
<h3>Answer</h3>
<p>Rails application security requires following best practices for authentication, authorization, input validation, CSRF protection, SQL injection prevention, XSS prevention, and secure configuration.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Strong authentication</strong>: Use bcrypt, 2FA, session management</li>
<li><strong>Authorization</strong>: Implement role-based access control (Pundit/CanCanCan)</li>
<li><strong>Input validation</strong>: Validate all user input, use strong parameters</li>
<li><strong>CSRF protection</strong>: Enabled by default in Rails</li>
<li><strong>SQL injection</strong>: Use parameterized queries, avoid raw SQL</li>
<li><strong>XSS prevention</strong>: Sanitize output, use content security policy</li>
<li><strong>Secrets management</strong>: Use credentials.yml.enc, env variables</li>
<li><strong>HTTPS</strong>: Enforce SSL, use secure cookies</li>
<li><strong>Dependencies</strong>: Keep gems updated, audit for vulnerabilities</li>
<li><strong>Monitoring</strong>: Log suspicious activity, use security headers</li>
</ul>
<hr>
<h3>Comprehensive Security Checklist</h3>
<pre><code class="language-ruby"># ====================
# 1. AUTHENTICATION
# ====================

# Use bcrypt for password hashing
# Gemfile
gem &#39;bcrypt&#39;

# app/models/user.rb
class User &lt; ApplicationRecord
  has_secure_password
  
  # Minimum password length
  validates :password, length: { minimum: 12 }, on: :create
  validates :password, format: { 
    with: /\A(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&amp;])/,
    message: &quot;must include uppercase, lowercase, number, and special character&quot;
  }
  
  # Lock account after failed attempts
  def increment_failed_attempts!
    increment!(:failed_attempts)
    lock_access! if failed_attempts &gt;= 5
  end
  
  def lock_access!
    update!(locked_at: Time.current)
  end
  
  def unlock_access!
    update!(locked_at: nil, failed_attempts: 0)
  end
end

# Session management
# app/controllers/sessions_controller.rb
class SessionsController &lt; ApplicationController
  def create
    user = User.find_by(email: params[:email])
    
    if user&amp;.locked?
      return render json: { error: &#39;Account locked&#39; }, status: :forbidden
    end
    
    if user&amp;.authenticate(params[:password])
      # Regenerate session ID to prevent fixation
      reset_session
      
      session[:user_id] = user.id
      user.update!(
        last_login_at: Time.current,
        failed_attempts: 0
      )
      
      redirect_to root_path
    else
      user&amp;.increment_failed_attempts!
      flash.now[:error] = &#39;Invalid email or password&#39;
      render :new
    end
  end
  
  def destroy
    session.delete(:user_id)
    @current_user = nil
    redirect_to login_path
  end
end

# Two-Factor Authentication
# Gemfile
gem &#39;rotp&#39;    # Time-based OTP
gem &#39;rqrcode&#39; # QR code generation

class User &lt; ApplicationRecord
  def enable_2fa!
    self.otp_secret = ROTP::Base32.random
    save!
  end
  
  def verify_otp(code)
    totp = ROTP::TOTP.new(otp_secret)
    totp.verify(code, drift_behind: 30)
  end
  
  def qr_code
    totp = ROTP::TOTP.new(otp_secret, issuer: &#39;MyApp&#39;)
    RQRCode::QRCode.new(totp.provisioning_uri(email))
  end
end

# ====================
# 2. AUTHORIZATION
# ====================

# Use Pundit for authorization
# Gemfile
gem &#39;pundit&#39;

# app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::Base
  include Pundit::Authorization
  
  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized
  
  private
  
  def user_not_authorized
    flash[:alert] = &quot;You are not authorized to perform this action.&quot;
    redirect_to(request.referrer || root_path)
  end
end

# app/policies/post_policy.rb
class PostPolicy &lt; ApplicationPolicy
  def update?
    user.admin? || record.author == user
  end
  
  def destroy?
    user.admin?
  end
  
  class Scope &lt; Scope
    def resolve
      if user.admin?
        scope.all
      else
        scope.where(published: true)
      end
    end
  end
end

# ====================
# 3. INPUT VALIDATION
# ====================

# Strong parameters (built-in Rails protection)
class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params)
    # ...
  end
  
  private
  
  def user_params
    # Whitelist only allowed parameters
    params.require(:user).permit(:email, :password, :first_name, :last_name)
    # Never permit :admin, :role, etc. directly
  end
end

# Validate all user input
class User &lt; ApplicationRecord
  validates :email, format: { with: URI::MailTo::EMAIL_REGEXP }
  validates :age, numericality: { greater_than: 0, less_than: 150 }
  validates :username, format: { with: /\A[a-zA-Z0-9_]+\z/ }
end

# ====================
# 4. CSRF PROTECTION
# ====================

# Enabled by default in Rails
# app/controllers/application_controller.rb
class ApplicationController &lt; ActionController::Base
  protect_from_forgery with: :exception
end

# For APIs, use token-based auth instead
class ApiController &lt; ActionController::API
  before_action :authenticate_with_token
  
  private
  
  def authenticate_with_token
    token = request.headers[&#39;Authorization&#39;]&amp;.split(&#39; &#39;)&amp;.last
    @current_user = User.find_by(api_token: token)
    
    render json: { error: &#39;Unauthorized&#39; }, status: :unauthorized unless @current_user
  end
end

# ====================
# 5. SQL INJECTION PREVENTION
# ====================

# BAD - Vulnerable to SQL injection
User.where(&quot;email = &#39;#{params[:email]}&#39;&quot;)
# Attack: params[:email] = &quot;&#39; OR &#39;1&#39;=&#39;1&quot;

# GOOD - Parameterized query
User.where(email: params[:email])

# GOOD - With placeholder
User.where(&quot;email = ?&quot;, params[:email])

# GOOD - With named parameters
User.where(&quot;email = :email&quot;, email: params[:email])

# Never use raw SQL with user input
# BAD
ActiveRecord::Base.connection.execute(&quot;DELETE FROM users WHERE id = #{params[:id]}&quot;)

# GOOD
User.find(params[:id]).destroy

# ====================
# 6. XSS PREVENTION
# ====================

# Rails escapes output by default
&lt;%= user.bio %&gt;  # Automatically escaped

# Explicitly mark as safe only when needed
&lt;%= sanitize(user.bio, tags: %w[p br strong em]) %&gt;

# Content Security Policy
# config/initializers/content_security_policy.rb
Rails.application.config.content_security_policy do |policy|
  policy.default_src :self, :https
  policy.font_src    :self, :https, :data
  policy.img_src     :self, :https, :data
  policy.object_src  :none
  policy.script_src  :self, :https
  policy.style_src   :self, :https
end

# ====================
# 7. SECRETS MANAGEMENT
# ====================

# Use Rails encrypted credentials
# rails credentials:edit

# config/credentials.yml.enc
aws:
  access_key_id: xxx
  secret_access_key: yyy

stripe:
  public_key: xxx
  secret_key: yyy

# Access in code
Rails.application.credentials.aws[:access_key_id]

# Environment variables (12-factor app)
# .env (never commit!)
DATABASE_URL=postgres://localhost/myapp
REDIS_URL=redis://localhost:6379

# Use dotenv gem
# Gemfile
gem &#39;dotenv-rails&#39;, groups: [:development, :test]

# Access
ENV[&#39;DATABASE_URL&#39;]

# ====================
# 8. HTTPS ENFORCEMENT
# ====================

# config/environments/production.rb
config.force_ssl = true

# Secure cookies
# config/initializers/session_store.rb
Rails.application.config.session_store :cookie_store,
  key: &#39;_myapp_session&#39;,
  secure: Rails.env.production?,  # HTTPS only in production
  httponly: true,                 # Not accessible via JavaScript
  same_site: :lax                 # CSRF protection

# ====================
# 9. SECURITY HEADERS
# ====================

# config/initializers/security_headers.rb
Rails.application.config.action_dispatch.default_headers.merge!({
  &#39;X-Frame-Options&#39; =&gt; &#39;DENY&#39;,
  &#39;X-Content-Type-Options&#39; =&gt; &#39;nosniff&#39;,
  &#39;X-XSS-Protection&#39; =&gt; &#39;1; mode=block&#39;,
  &#39;Referrer-Policy&#39; =&gt; &#39;strict-origin-when-cross-origin&#39;,
  &#39;Permissions-Policy&#39; =&gt; &#39;geolocation=(), microphone=(), camera=()&#39;
})

# Or use secure_headers gem
# Gemfile
gem &#39;secure_headers&#39;

# config/initializers/secure_headers.rb
SecureHeaders::Configuration.default do |config|
  config.x_frame_options = &quot;DENY&quot;
  config.x_content_type_options = &quot;nosniff&quot;
  config.x_xss_protection = &quot;1; mode=block&quot;
  config.referrer_policy = &quot;strict-origin-when-cross-origin&quot;
end

# ====================
# 10. RATE LIMITING
# ====================

# Gemfile
gem &#39;rack-attack&#39;

# config/initializers/rack_attack.rb
Rack::Attack.throttle(&#39;login/email&#39;, limit: 5, period: 60) do |req|
  if req.path == &#39;/login&#39; &amp;&amp; req.post?
    req.params[&#39;email&#39;]
  end
end

Rack::Attack.throttle(&#39;api/ip&#39;, limit: 300, period: 60) do |req|
  req.ip if req.path.start_with?(&#39;/api&#39;)
end

# Block malicious IPs
Rack::Attack.blocklist(&#39;block bad actors&#39;) do |req|
  BadActor.where(ip_address: req.ip).exists?
end

# ====================
# 11. DEPENDENCY SECURITY
# ====================

# Audit gems for vulnerabilities
bundle audit check --update

# Keep gems up to date
bundle update

# Use Bundler audit in CI
# .github/workflows/security.yml
- name: Security audit
  run: |
    gem install bundler-audit
    bundle audit check --update

# Use Brakeman for static analysis
gem install brakeman
brakeman -q

# ====================
# 12. LOGGING &amp; MONITORING
# ====================

# Log suspicious activity
class ApplicationController &lt; ActionController::Base
  before_action :log_suspicious_activity
  
  private
  
  def log_suspicious_activity
    if suspicious_request?
      Rails.logger.warn({
        event: &#39;suspicious_request&#39;,
        ip: request.remote_ip,
        user_agent: request.user_agent,
        path: request.fullpath,
        params: filtered_params
      }.to_json)
    end
  end
  
  def suspicious_request?
    # Multiple failed logins
    # SQL injection attempts
    # XSS attempts
    request.params.to_s.match?(/(union|select|script|&lt;|&gt;)/i)
  end
end

# Monitor with Sentry
# Gemfile
gem &#39;sentry-ruby&#39;
gem &#39;sentry-rails&#39;

# config/initializers/sentry.rb
Sentry.init do |config|
  config.dsn = ENV[&#39;SENTRY_DSN&#39;]
  config.breadcrumbs_logger = [:active_support_logger, :http_logger]
end

# ====================
# 13. FILE UPLOAD SECURITY
# ====================

# Validate file types
class Avatar &lt; ApplicationRecord
  has_one_attached :image
  
  validates :image, content_type: [&#39;image/png&#39;, &#39;image/jpeg&#39;, &#39;image/gif&#39;],
                    size: { less_than: 5.megabytes }
end

# Scan uploads for viruses
# Gemfile
gem &#39;clamby&#39;

# app/models/document.rb
class Document &lt; ApplicationRecord
  has_one_attached :file
  
  validate :file_is_virus_free
  
  private
  
  def file_is_virus_free
    return unless file.attached?
    
    file.download do |file_path|
      unless Clamby.safe?(file_path)
        errors.add(:file, &#39;contains a virus&#39;)
      end
    end
  end
end

# ====================
# 14. API SECURITY
# ====================

# Use API versioning
namespace :api do
  namespace :v1 do
    resources :posts
  end
end

# Implement API authentication
# JWT tokens, OAuth2, or API keys

# Rate limit API endpoints
Rack::Attack.throttle(&#39;api/key&#39;, limit: 1000, period: 3600) do |req|
  req.env[&#39;HTTP_X_API_KEY&#39;] if req.path.start_with?(&#39;/api&#39;)
end

# CORS configuration
# Gemfile
gem &#39;rack-cors&#39;

# config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins &#39;example.com&#39;  # Specific domains only
    resource &#39;/api/*&#39;,
      headers: :any,
      methods: [:get, :post, :put, :delete]
  end
end
</code></pre>
<hr>
<h3>Security Audit Checklist</h3>
<pre><code class="language-ruby"># Run these regularly:

# 1. Dependency audit
bundle audit check --update

# 2. Static code analysis
brakeman -q

# 3. Check for exposed secrets
git secrets --scan

# 4. Review logs for suspicious activity
grep &quot;suspicious&quot; log/production.log

# 5. Test authentication
# - Can you bypass login?
# - Can you access admin pages without admin role?
# - Does session expire properly?

# 6. Test authorization
# - Can user A access user B&#39;s data?
# - Can regular user access admin endpoints?

# 7. Test input validation
# - SQL injection attempts
# - XSS attempts
# - File upload vulnerabilities

# 8. Check security headers
curl -I https://myapp.com

# 9. SSL/TLS configuration
ssllabs.com/ssltest/analyze.html?d=myapp.com

# 10. Penetration testing
# Hire security professionals to test your app
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Defense in depth</strong>: Multiple layers of security</li>
<li><strong>Authentication</strong>: Strong passwords, 2FA, session management</li>
<li><strong>Authorization</strong>: Implement proper access control</li>
<li><strong>Input validation</strong>: Never trust user input</li>
<li><strong>SQL injection</strong>: Always use parameterized queries</li>
<li><strong>XSS prevention</strong>: Sanitize output, use CSP</li>
<li><strong>HTTPS</strong>: Enforce SSL, secure cookies</li>
<li><strong>Secrets</strong>: Use credentials.yml.enc, never commit secrets</li>
<li><strong>Dependencies</strong>: Audit and update regularly</li>
<li><strong>Monitor</strong>: Log suspicious activity, use error tracking</li>
</ol>
<hr>
<h2>Question 315: How do you scale a Rails application to handle millions of users?</h2>
<h3>Answer</h3>
<p>Scaling Rails to handle millions of users requires horizontal scaling (multiple servers), database optimization, caching, background jobs, CDN, load balancing, and monitoring.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Horizontal scaling</strong>: Multiple application servers behind load balancer</li>
<li><strong>Database</strong>: Read replicas, connection pooling, query optimization</li>
<li><strong>Caching</strong>: Redis, Memcached, CDN for static assets</li>
<li><strong>Background jobs</strong>: Sidekiq for async processing</li>
<li><strong>Load balancing</strong>: Distribute traffic across servers</li>
<li><strong>Monitoring</strong>: Track performance, optimize bottlenecks</li>
<li><strong>CDN</strong>: Serve static assets from edge locations</li>
<li><strong>Database sharding</strong>: Split data across multiple databases</li>
<li><strong>Microservices</strong>: Break monolith into services (when needed)</li>
<li><strong>Auto-scaling</strong>: Scale servers based on load</li>
</ul>
<hr>
<h3>Comprehensive Scaling Strategy</h3>
<pre><code class="language-ruby"># ====================
# 1. APPLICATION SERVERS (Horizontal Scaling)
# ====================

# Multiple Puma/Unicorn servers behind load balancer
# config/puma.rb
workers ENV.fetch(&quot;WEB_CONCURRENCY&quot;) { 4 }
threads_count = ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 }
threads threads_count, threads_count

preload_app!

on_worker_boot do
  ActiveRecord::Base.establish_connection
end

# Deployment: Run multiple instances
# AWS: 10 EC2 instances with ELB (Elastic Load Balancer)
# Heroku: scale web=10
# Kubernetes: replicas: 10

# ====================
# 2. LOAD BALANCING
# ====================

# Nginx load balancer
# /etc/nginx/nginx.conf
upstream rails_app {
  least_conn;  # or ip_hash for sticky sessions
  
  server app1.example.com:3000 max_fails=3 fail_timeout=30s;
  server app2.example.com:3000 max_fails=3 fail_timeout=30s;
  server app3.example.com:3000 max_fails=3 fail_timeout=30s;
}

server {
  listen 80;
  server_name example.com;
  
  location / {
    proxy_pass http://rails_app;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
  }
}

# AWS Application Load Balancer
# - Health checks
# - SSL termination
# - Auto-scaling integration
# - WebSocket support

# ====================
# 3. DATABASE OPTIMIZATION
# ====================

# Read replicas
# config/database.yml
production:
  primary:
    &lt;&lt;: *default
    database: myapp_production
    host: primary.db.example.com
  
  replica:
    &lt;&lt;: *default
    database: myapp_production
    host: replica.db.example.com
    replica: true

# Use replicas for reads
class ApplicationRecord &lt; ActiveRecord::Base
  connects_to database: { writing: :primary, reading: :replica }
end

# Route queries
User.connected_to(role: :reading) do
  User.where(active: true).to_a  # Reads from replica
end

User.connected_to(role: :writing) do
  User.create!(...)  # Writes to primary
end

# Connection pooling
# config/database.yml
production:
  pool: &lt;%= ENV[&#39;DB_POOL&#39;] || 25 %&gt;

# Pgbouncer for PostgreSQL connection pooling
# - Handles 1000s of connections
# - Pools to 25 actual database connections
# - Drastically reduces connection overhead

# Query optimization
# Add indexes
class AddIndexesToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :email
    add_index :users, :status
    add_index :users, [:created_at, :status]  # Composite index
  end
end

# Use explain to find slow queries
User.where(status: &#39;active&#39;).explain

# Avoid N+1 queries
# BAD
posts = Post.all
posts.each { |post| puts post.author.name }  # N+1

# GOOD
posts = Post.includes(:author)
posts.each { |post| puts post.author.name }  # 2 queries

# ====================
# 4. CACHING STRATEGY
# ====================

# Multiple caching layers

# 1. HTTP Caching (Browser/CDN)
class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    
    if stale?(last_modified: @post.updated_at, etag: @post)
      respond_to do |format|
        format.html
      end
    end
  end
end

# 2. Fragment Caching (View)
&lt;% cache @post do %&gt;
  &lt;%= render @post %&gt;
&lt;% end %&gt;

# 3. Russian Doll Caching (Nested)
&lt;% cache @post do %&gt;
  &lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;
  
  &lt;% cache [&#39;comments&#39;, @post] do %&gt;
    &lt;%= render @post.comments %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

# 4. Low-level Caching (Application)
def expensive_operation
  Rails.cache.fetch(&quot;expensive/#{id}&quot;, expires_in: 1.hour) do
    # Expensive calculation
    sleep 2
    { result: &#39;data&#39; }
  end
end

# 5. Redis caching
# config/environments/production.rb
config.cache_store = :redis_cache_store, {
  url: ENV[&#39;REDIS_URL&#39;],
  pool_size: 5,
  pool_timeout: 5,
  expires_in: 1.hour
}

# 6. CDN for static assets
# config/environments/production.rb
config.asset_host = &#39;https://cdn.example.com&#39;

# CloudFront (AWS), Cloudflare, Fastly
# - Cache CSS, JS, images at edge locations
# - Reduce load on app servers
# - Faster for users worldwide

# ====================
# 5. BACKGROUND JOBS
# ====================

# Move slow operations to background
# Gemfile
gem &#39;sidekiq&#39;

# app/jobs/send_email_job.rb
class SendEmailJob &lt; ApplicationJob
  queue_as :default
  
  def perform(user_id)
    user = User.find(user_id)
    UserMailer.welcome_email(user).deliver_now
  end
end

# Enqueue job
SendEmailJob.perform_later(user.id)

# Sidekiq configuration
# config/sidekiq.yml
:concurrency: 25

:queues:
  - [critical, 10]
  - [default, 5]
  - [low, 1]

# Multiple Sidekiq processes
# Each process: 25 threads
# 4 processes = 100 concurrent jobs

# ====================
# 6. DATABASE SHARDING
# ====================

# Split data across multiple databases

# config/database.yml
production:
  shard_one:
    database: myapp_shard_1
    host: shard1.db.example.com
  
  shard_two:
    database: myapp_shard_2
    host: shard2.db.example.com

# Shard by user_id
class ApplicationRecord &lt; ActiveRecord::Base
  def self.shard_for(user_id)
    shard_number = user_id % 2 == 0 ? :shard_one : :shard_two
    connected_to(shard: shard_number) { yield }
  end
end

# Usage
ApplicationRecord.shard_for(user_id) do
  Order.create!(user_id: user_id, ...)
end

# ====================
# 7. MICROSERVICES (When Needed)
# ====================

# Break monolith into services
# - User Service (authentication)
# - Order Service (orders, payments)
# - Notification Service (emails, SMS)
# - Search Service (Elasticsearch)

# Communication: REST APIs, gRPC, message queues

# Example: Extract search to Elasticsearch
# Gemfile
gem &#39;searchkick&#39;

class Product &lt; ApplicationRecord
  searchkick
end

# Reindex in background
Product.reindex

# Fast search
Product.search(&quot;laptop&quot;, fields: [:name, :description])

# ====================
# 8. AUTO-SCALING
# ====================

# AWS Auto Scaling
resource &quot;aws_autoscaling_group&quot; &quot;app&quot; {
  min_size             = 3
  max_size             = 20
  desired_capacity     = 5
  
  health_check_type    = &quot;ELB&quot;
  health_check_grace_period = 300
  
  launch_configuration = aws_launch_configuration.app.id
  vpc_zone_identifier  = [aws_subnet.private_1.id, aws_subnet.private_2.id]
  
  target_group_arns    = [aws_lb_target_group.app.arn]
  
  tag {
    key                 = &quot;Name&quot;
    value               = &quot;rails-app&quot;
    propagate_at_launch = true
  }
}

# Scale based on CPU
resource &quot;aws_autoscaling_policy&quot; &quot;scale_up&quot; {
  name                   = &quot;scale_up&quot;
  scaling_adjustment     = 2
  adjustment_type        = &quot;ChangeInCapacity&quot;
  cooldown               = 300
  autoscaling_group_name = aws_autoscaling_group.app.name
}

resource &quot;aws_cloudwatch_metric_alarm&quot; &quot;cpu_high&quot; {
  alarm_name          = &quot;cpu_high&quot;
  comparison_operator = &quot;GreaterThanThreshold&quot;
  evaluation_periods  = &quot;2&quot;
  metric_name         = &quot;CPUUtilization&quot;
  namespace           = &quot;AWS/EC2&quot;
  period              = &quot;120&quot;
  statistic           = &quot;Average&quot;
  threshold           = &quot;70&quot;
  
  alarm_actions = [aws_autoscaling_policy.scale_up.arn]
}

# Kubernetes Horizontal Pod Autoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: rails-app
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: rails-app
  minReplicas: 3
  maxReplicas: 50
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70

# ====================
# 9. MONITORING &amp; OPTIMIZATION
# ====================

# Track key metrics
# - Response time (p50, p95, p99)
# - Throughput (requests/second)
# - Error rate
# - Database query time
# - Cache hit rate
# - Memory usage
# - CPU usage

# Use APM tools
# - New Relic
# - Datadog
# - Scout APM

# Identify bottlenecks
# 1. Slow database queries → Add indexes
# 2. High CPU → Optimize code, scale horizontally
# 3. High memory → Fix memory leaks, scale vertically
# 4. Low cache hit rate → Increase TTL, add more caching

# ====================
# 10. CAPACITY PLANNING
# ====================

# Calculate capacity
# Current: 1000 req/sec with 5 servers
# Capacity per server: 200 req/sec
# Target: 10,000 req/sec
# Servers needed: 10,000 / 200 = 50 servers

# Load testing
# tools: Apache Bench, wrk, k6, Gatling

# ab -n 100000 -c 100 https://example.com/
# 100,000 requests, 100 concurrent

# Stress test to find breaking point
# Gradually increase load until failure
</code></pre>
<hr>
<h3>Scaling Timeline</h3>
<pre><code class="language-ruby"># 0-1K users
✅ Single server (Heroku dyno)
✅ Basic caching
✅ PostgreSQL (single instance)

# 1K-10K users
✅ 2-3 app servers
✅ Redis caching
✅ CDN for assets
✅ Background jobs (Sidekiq)

# 10K-100K users
✅ 5-10 app servers
✅ Load balancer
✅ Database read replicas
✅ Full caching strategy
✅ Performance monitoring

# 100K-1M users
✅ 20-50 app servers
✅ Database connection pooling (PgBouncer)
✅ Multiple Redis instances
✅ Database query optimization
✅ Auto-scaling
✅ Multiple Sidekiq processes

# 1M-10M users
✅ 100+ app servers
✅ Database sharding
✅ Multiple data centers / regions
✅ Microservices (when needed)
✅ Advanced caching (Varnish)
✅ Search engine (Elasticsearch)
✅ Message queues (RabbitMQ, Kafka)

# 10M+ users
✅ Hundreds of servers
✅ Global CDN
✅ Multi-region deployment
✅ Distributed databases
✅ Service mesh (Istio)
✅ Advanced monitoring
✅ Chaos engineering
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Horizontal scaling</strong>: Add more servers, not bigger servers</li>
<li><strong>Database</strong>: Read replicas, connection pooling, optimization</li>
<li><strong>Caching</strong>: Multiple layers (browser, CDN, application, database)</li>
<li><strong>Background jobs</strong>: Move slow operations async</li>
<li><strong>Load balancing</strong>: Distribute traffic evenly</li>
<li><strong>Monitoring</strong>: Track metrics, find bottlenecks</li>
<li><strong>Auto-scaling</strong>: Scale based on demand</li>
<li><strong>Database sharding</strong>: Split data across databases (at scale)</li>
<li><strong>Microservices</strong>: Break up when monolith can&#39;t scale</li>
<li><strong>Capacity planning</strong>: Load test before you need to scale</li>
</ol>
<h1>Scalability and Performance Interview Questions - Part 3 (313-322)</h1>
<h2>Question 313: How does thread safety work in Rails?</h2>
<h3>Answer</h3>
<p><strong>Thread safety</strong> in Rails means code can be executed by multiple threads simultaneously without causing data corruption or unexpected behavior. Rails 5+ is thread-safe by default, but developers must avoid shared mutable state and use thread-safe patterns.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Thread-safe</strong>: Code works correctly with multiple threads</li>
<li><strong>Rails 5+</strong>: Thread-safe by default (thread-safe caching, query cache)</li>
<li><strong>Common issues</strong>: Shared class variables, global variables, class instance variables</li>
<li><strong>Solutions</strong>: Thread-local variables, mutexes, immutable objects</li>
<li><strong>Must avoid</strong>: Race conditions, deadlocks, memory leaks</li>
<li><strong>Testing</strong>: Use concurrent requests to verify thread safety</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<p><strong>What Makes Code Thread-Unsafe?</strong></p>
<pre><code class="language-ruby"># ============================================
# PROBLEM 1: Shared Class Variables
# ============================================

# ❌ NOT THREAD-SAFE
class RequestCounter
  @@count = 0  # Shared across all threads
  
  def self.increment
    @@count += 1  # Race condition!
  end
  
  def self.count
    @@count
  end
end

# What happens with concurrent requests:
# Thread 1: reads @@count = 0
# Thread 2: reads @@count = 0
# Thread 1: writes @@count = 1
# Thread 2: writes @@count = 1
# Expected: 2, Actual: 1 ❌

# ✅ THREAD-SAFE: Use Mutex
class RequestCounter
  @@count = 0
  @@mutex = Mutex.new
  
  def self.increment
    @@mutex.synchronize do
      @@count += 1
    end
  end
  
  def self.count
    @@mutex.synchronize { @@count }
  end
end

# Now threads wait for mutex:
# Thread 1: locks, reads 0, writes 1, unlocks
# Thread 2: locks, reads 1, writes 2, unlocks
# Result: 2 ✓

# ============================================
# PROBLEM 2: Class Instance Variables
# ============================================

# ❌ NOT THREAD-SAFE
class UserService
  @cache = {}  # Class instance variable
  
  def self.find_cached(id)
    @cache[id] ||= User.find(id)
  end
end

# Race condition on ||=
# Thread 1: checks @cache[1] = nil
# Thread 2: checks @cache[1] = nil
# Thread 1: queries database
# Thread 2: queries database (duplicate!)

# ✅ THREAD-SAFE: Use Thread.current
class UserService
  def self.find_cached(id)
    Thread.current[:user_cache] ||= {}
    Thread.current[:user_cache][id] ||= User.find(id)
  end
end

# ✅ BETTER: Use Rails.cache (thread-safe)
class UserService
  def self.find_cached(id)
    Rails.cache.fetch(&quot;user/#{id}&quot;, expires_in: 1.hour) do
      User.find(id)
    end
  end
end

# ============================================
# PROBLEM 3: Memoization
# ============================================

# ❌ NOT THREAD-SAFE
class Post &lt; ApplicationRecord
  def author_name
    @author_name ||= author.full_name
  end
end

# Race condition:
# Thread 1: @author_name = nil, queries author
# Thread 2: @author_name = nil, queries author
# Both query database!

# ✅ THREAD-SAFE: Simple fix
class Post &lt; ApplicationRecord
  def author_name
    # Read from database each time (with query cache)
    author.full_name
  end
end

# ✅ THREAD-SAFE: Use defined?
class Post &lt; ApplicationRecord
  def author_name
    return @author_name if defined?(@author_name)
    @author_name = author.full_name
  end
end

# ✅ BEST: Let Rails handle it
class Post &lt; ApplicationRecord
  delegate :full_name, to: :author, prefix: true
  # Calls author.full_name each time
end

# ============================================
# PROBLEM 4: Global Variables
# ============================================

# ❌ NEVER USE GLOBAL VARIABLES
$request_count = 0  # Shared across threads

def increment_requests
  $request_count += 1  # Race condition!
end

# ✅ USE: Thread-local storage
def increment_requests
  Thread.current[:request_count] ||= 0
  Thread.current[:request_count] += 1
end

# ✅ BETTER: Use proper instrumentation
ActiveSupport::Notifications.instrument(&#39;request.processed&#39;) do
  # Your code
end

# ============================================
# PROBLEM 5: Singleton Pattern Without Mutex
# ============================================

# ❌ NOT THREAD-SAFE
class Configuration
  @instance = nil
  
  def self.instance
    @instance ||= new  # Race condition!
  end
  
  private_class_method :new
end

# ✅ THREAD-SAFE: Use mutex
class Configuration
  @instance = nil
  @mutex = Mutex.new
  
  def self.instance
    return @instance if @instance
    
    @mutex.synchronize do
      @instance ||= new
    end
  end
  
  private_class_method :new
end

# ✅ BETTER: Use Ruby&#39;s Singleton module
require &#39;singleton&#39;

class Configuration
  include Singleton
  
  def initialize
    @settings = {}
  end
end

# Thread-safe by default
config = Configuration.instance
</code></pre>
<hr>
<h3>Thread-Safe Patterns in Rails</h3>
<pre><code class="language-ruby"># ============================================
# PATTERN 1: Thread-Local Variables
# ============================================

# Store data specific to current thread
class ApplicationController &lt; ActionController::Base
  around_action :set_request_context
  
  private
  
  def set_request_context
    Thread.current[:request_id] = request.uuid
    Thread.current[:current_user] = current_user
    yield
  ensure
    Thread.current[:request_id] = nil
    Thread.current[:current_user] = nil
  end
end

# Access anywhere in thread
class AuditLogger
  def self.log(action)
    Rails.logger.info({
      request_id: Thread.current[:request_id],
      user_id: Thread.current[:current_user]&amp;.id,
      action: action
    }.to_json)
  end
end

# ============================================
# PATTERN 2: RequestStore Gem
# ============================================

# Gemfile
gem &#39;request_store&#39;

# Better than Thread.current (cleans up automatically)
class ApplicationController &lt; ActionController::Base
  before_action :set_request_store
  
  private
  
  def set_request_store
    RequestStore.store[:current_user] = current_user
    RequestStore.store[:request_id] = request.uuid
  end
end

# Access anywhere
class AuditLogger
  def self.log(action)
    Rails.logger.info({
      request_id: RequestStore.store[:request_id],
      user_id: RequestStore.store[:current_user]&amp;.id,
      action: action
    }.to_json)
  end
end

# ============================================
# PATTERN 3: Concurrent-Ruby Gem
# ============================================

# Gemfile
gem &#39;concurrent-ruby&#39;

# Thread-safe collections
require &#39;concurrent&#39;

class StatisticsTracker
  def initialize
    @stats = Concurrent::Hash.new
  end
  
  def increment(key)
    @stats[key] = (@stats[key] || 0) + 1
  end
  
  def get(key)
    @stats[key]
  end
end

# Thread-safe atomic operations
class Counter
  def initialize
    @count = Concurrent::AtomicFixnum.new(0)
  end
  
  def increment
    @count.increment
  end
  
  def value
    @count.value
  end
end

# ============================================
# PATTERN 4: Immutable Objects
# ============================================

# Objects that can&#39;t be modified are thread-safe
class Configuration
  attr_reader :api_key, :timeout, :retries
  
  def initialize(api_key:, timeout:, retries:)
    @api_key = api_key
    @timeout = timeout
    @retries = retries
    freeze  # Make immutable
  end
end

# Usage
config = Configuration.new(api_key: &#39;key&#39;, timeout: 30, retries: 3)
# config.api_key = &#39;new&#39;  # FrozenError!

# To &quot;update&quot;, create new instance
new_config = Configuration.new(
  api_key: config.api_key,
  timeout: 60,  # Updated
  retries: config.retries
)

# ============================================
# PATTERN 5: Connection Pools
# ============================================

# ActiveRecord connection pool (thread-safe)
# config/database.yml
production:
  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;

# How it works:
# - Each thread checks out a connection
# - Uses it for queries
# - Returns it to pool when done

# Manual connection checkout (rare)
ActiveRecord::Base.connection_pool.with_connection do |conn|
  conn.execute(&quot;SELECT * FROM users&quot;)
end

# Redis connection pool
# config/initializers/redis.rb
$redis = ConnectionPool.new(size: 5, timeout: 5) do
  Redis.new(url: ENV[&#39;REDIS_URL&#39;])
end

# Usage
$redis.with do |conn|
  conn.get(&#39;key&#39;)
end

# ============================================
# PATTERN 6: Avoid Lazy Loading in Threads
# ============================================

# ❌ BAD: Lazy loading can cause issues
Thread.new do
  # First thread to load might cause race condition
  user = User.find(1)
  user.posts  # Lazy loads association
end

# ✅ GOOD: Eager load before threading
users = User.includes(:posts).where(active: true)

users.each do |user|
  Thread.new do
    # Already loaded, no database queries
    user.posts.each { |post| process(post) }
  end
end
</code></pre>
<hr>
<h3>Rails Framework Thread Safety</h3>
<pre><code class="language-ruby"># Rails 5+ is thread-safe by default

# 1. Query Cache (thread-safe)
# Each thread has its own query cache
User.find(1)  # Thread 1: Database query
User.find(1)  # Thread 1: Cache hit
User.find(1)  # Thread 2: Database query (different cache)

# 2. Request/Response Objects
# Each thread gets its own request/response
class ApplicationController &lt; ActionController::Base
  def index
    # request, response, params are thread-local
    @user = User.find(params[:id])
  end
end

# 3. Cache Store (thread-safe)
Rails.cache.write(&#39;key&#39;, &#39;value&#39;)  # Thread-safe
Rails.cache.read(&#39;key&#39;)             # Thread-safe
Rails.cache.fetch(&#39;key&#39;) { &#39;value&#39; } # Thread-safe

# 4. Session Store (thread-safe)
# When using Redis/Memcached
session[:user_id] = user.id  # Thread-safe

# 5. Active Job (thread-safe)
# Sidekiq handles thread safety
UserMailer.welcome_email(user).deliver_later

# ============================================
# What&#39;s NOT thread-safe by default:
# ============================================

# 1. Your own class variables
# 2. Your own global variables
# 3. Your own memoization
# 4. Third-party gems (check documentation)
# 5. File I/O without locking
</code></pre>
<hr>
<h3>Testing Thread Safety</h3>
<pre><code class="language-ruby"># ============================================
# TEST 1: Concurrent Requests
# ============================================

# test/integration/thread_safety_test.rb
require &#39;test_helper&#39;

class ThreadSafetyTest &lt; ActionDispatch::IntegrationTest
  test &quot;concurrent requests don&#39;t interfere&quot; do
    threads = 10.times.map do |i|
      Thread.new do
        get user_path(i)
        assert_response :success
      end
    end
    
    threads.each(&amp;:join)
  end
  
  test &quot;counter increments correctly with concurrent requests&quot; do
    initial_count = RequestCounter.count
    
    threads = 100.times.map do
      Thread.new { RequestCounter.increment }
    end
    
    threads.each(&amp;:join)
    
    assert_equal initial_count + 100, RequestCounter.count
  end
end

# ============================================
# TEST 2: Race Condition Detection
# ============================================

# test/models/race_condition_test.rb
require &#39;test_helper&#39;

class RaceConditionTest &lt; ActiveSupport::TestCase
  test &quot;memoization is thread-safe&quot; do
    post = posts(:one)
    
    # Try to trigger race condition
    threads = 10.times.map do
      Thread.new { post.author_name }
    end
    
    threads.each(&amp;:join)
    
    # Check query count (should be 1, not 10)
    assert_queries(1) do
      post.author_name
    end
  end
end

# ============================================
# TEST 3: Load Testing with Threads
# ============================================

# Load test script
# test/load_test.rb
require &#39;benchmark&#39;

def load_test(threads: 10, requests: 100)
  results = Benchmark.measure do
    threads_array = threads.times.map do
      Thread.new do
        requests.times do
          # Make HTTP request
          Net::HTTP.get(URI(&#39;http://localhost:3000/&#39;))
        end
      end
    end
    
    threads_array.each(&amp;:join)
  end
  
  puts &quot;#{threads} threads × #{requests} requests&quot;
  puts &quot;Time: #{results.real}s&quot;
  puts &quot;Requests/sec: #{(threads * requests) / results.real}&quot;
end

load_test(threads: 10, requests: 100)
load_test(threads: 20, requests: 100)
load_test(threads: 50, requests: 100)

# ============================================
# TEST 4: Stress Testing
# ============================================

# Gemfile (development/test)
gem &#39;parallel_tests&#39;

# Run tests in parallel
# parallel_test test/

# Or with RSpec
# parallel_rspec spec/
</code></pre>
<hr>
<h3>Common Thread Safety Issues</h3>
<pre><code class="language-ruby"># ============================================
# ISSUE 1: Time.zone Not Set
# ============================================

# ❌ PROBLEM
Thread.new do
  # Time.zone might be nil in new thread
  Time.zone.now  # NoMethodError!
end

# ✅ SOLUTION
class ApplicationController &lt; ActionController::Base
  around_action :set_timezone_in_thread
  
  private
  
  def set_timezone_in_thread
    Time.use_zone(Time.zone) do
      yield
    end
  end
end

# ============================================
# ISSUE 2: I18n Locale Not Set
# ============================================

# ❌ PROBLEM
Thread.new do
  # I18n.locale might be wrong
  I18n.t(&#39;welcome&#39;)  # Wrong language!
end

# ✅ SOLUTION
class ApplicationController &lt; ActionController::Base
  around_action :set_locale_in_thread
  
  private
  
  def set_locale_in_thread
    I18n.with_locale(I18n.locale) do
      yield
    end
  end
end

# ============================================
# ISSUE 3: Database Connection Leaks
# ============================================

# ❌ PROBLEM
Thread.new do
  User.all.each { |user| process(user) }
  # Connection not returned to pool!
end

# ✅ SOLUTION
Thread.new do
  ActiveRecord::Base.connection_pool.with_connection do
    User.all.each { |user| process(user) }
  end
end

# ============================================
# ISSUE 4: Shared File Handles
# ============================================

# ❌ PROBLEM
file = File.open(&#39;log.txt&#39;, &#39;a&#39;)
threads = 10.times.map do
  Thread.new do
    file.write(&quot;Log entry\n&quot;)  # Interleaved writes!
  end
end

# ✅ SOLUTION: Use mutex
file = File.open(&#39;log.txt&#39;, &#39;a&#39;)
mutex = Mutex.new

threads = 10.times.map do
  Thread.new do
    mutex.synchronize do
      file.write(&quot;Log entry\n&quot;)
    end
  end
end

# ✅ BETTER: Use thread-safe logger
threads = 10.times.map do
  Thread.new do
    Rails.logger.info(&quot;Log entry&quot;)  # Thread-safe
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Rails 5+</strong> is thread-safe by default</li>
<li><strong>Avoid</strong> shared class variables and global variables</li>
<li><strong>Use</strong> Thread.current or RequestStore for thread-local data</li>
<li><strong>Use</strong> mutexes to protect shared mutable state</li>
<li><strong>Use</strong> immutable objects when possible</li>
<li><strong>Connection pools</strong> are thread-safe in Rails</li>
<li><strong>Test</strong> with concurrent requests</li>
<li><strong>Watch out</strong> for memoization race conditions</li>
<li><strong>Third-party gems</strong> may not be thread-safe</li>
<li><strong>Load test</strong> to verify thread safety under load</li>
</ol>
<hr>
<h2>Question 314: How do you prevent race conditions in multi-threaded Rails apps?</h2>
<h3>Answer</h3>
<p>Prevent <strong>race conditions</strong> by using mutexes, atomic operations, database locks, optimistic locking, idempotent operations, and avoiding shared mutable state. Design for thread safety from the beginning.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Mutex</strong>: Lock critical sections with <code>Mutex.synchronize</code></li>
<li><strong>Database locks</strong>: Pessimistic locking (<code>lock!</code>) or optimistic locking</li>
<li><strong>Atomic operations</strong>: Use <code>increment!</code>, <code>decrement!</code>, database constraints</li>
<li><strong>Idempotent</strong>: Design operations that can be safely retried</li>
<li><strong>Avoid sharing</strong>: Use thread-local variables, immutable objects</li>
<li><strong>Test</strong>: Concurrent request testing to catch race conditions</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<p><strong>What is a Race Condition?</strong></p>
<pre><code class="language-ruby"># Race condition: Outcome depends on thread timing

# Example: Bank account transfer
# Initial balance: $1000
# Thread 1: Withdraw $600
# Thread 2: Withdraw $600

# ❌ RACE CONDITION:
class Account &lt; ApplicationRecord
  def withdraw(amount)
    current = balance           # Thread 1: reads 1000
                                # Thread 2: reads 1000
    new_balance = current - amount
                                # Thread 1: calculates 400
                                # Thread 2: calculates 400
    update!(balance: new_balance)
                                # Thread 1: writes 400
                                # Thread 2: writes 400
  end
end

# Result: balance = $400 (should be -$200 or error!)
# Lost $600! 💸

# ✅ CORRECT: Use atomic operation
class Account &lt; ApplicationRecord
  def withdraw(amount)
    # Atomic database operation
    decrement!(:balance, amount)
    
    # Or use SQL:
    # UPDATE accounts SET balance = balance - amount WHERE id = ?
  end
end
</code></pre>
<hr>
<h3>Prevention Techniques</h3>
<pre><code class="language-ruby"># ============================================
# TECHNIQUE 1: Mutex (Mutual Exclusion)
# ============================================

# Use mutex to protect critical sections

class InventoryManager
  def initialize
    @mutex = Mutex.new
  end
  
  def reserve_item(item_id, quantity)
    @mutex.synchronize do
      # Only one thread executes this at a time
      item = Item.find(item_id)
      
      if item.quantity &gt;= quantity
        item.decrement!(:quantity, quantity)
        true
      else
        false
      end
    end
  end
end

# Mutex ensures:
# Thread 1: locks → checks → updates → unlocks
# Thread 2: waits → locks → checks → updates → unlocks

# ============================================
# TECHNIQUE 2: Database Pessimistic Locking
# ============================================

# Lock database row during transaction

class TransferService
  def transfer(from_account, to_account, amount)
    ActiveRecord::Base.transaction do
      # Lock rows (SELECT ... FOR UPDATE)
      from = Account.lock.find(from_account.id)
      to = Account.lock.find(to_account.id)
      
      # Now safe to update
      from.decrement!(:balance, amount)
      to.increment!(:balance, amount)
    end
  end
end

# Database ensures:
# Thread 1: locks rows → updates → commits → unlocks
# Thread 2: waits for lock → updates → commits

# with_lock helper (cleaner syntax)
class Account &lt; ApplicationRecord
  def withdraw(amount)
    with_lock do
      if balance &gt;= amount
        decrement!(:balance, amount)
        true
      else
        false
      end
    end
  end
end

# ============================================
# TECHNIQUE 3: Optimistic Locking
# ============================================

# Use version column to detect concurrent modifications

# Migration
class AddLockVersionToAccounts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :accounts, :lock_version, :integer, default: 0, null: false
  end
end

# Model
class Account &lt; ApplicationRecord
  # Rails automatically handles lock_version
end

# Usage
def update_balance(account_id, new_balance)
  account = Account.find(account_id)
  account.balance = new_balance
  account.save!
rescue ActiveRecord::StaleObjectError
  # Another thread updated this record
  retry  # Or handle conflict
end

# How it works:
# 1. Thread 1 reads: balance=1000, lock_version=1
# 2. Thread 2 reads: balance=1000, lock_version=1
# 3. Thread 1 updates: balance=400, lock_version=2 ✓
# 4. Thread 2 tries: lock_version=1 (stale) ✗ Raises error

# ============================================
# TECHNIQUE 4: Atomic Database Operations
# ============================================

# Use database atomic operations (thread-safe by design)

class Post &lt; ApplicationRecord
  # ❌ NOT ATOMIC
  def increment_views_unsafe
    self.views = views + 1
    save
  end
  
  # ✅ ATOMIC
  def increment_views_safe
    increment!(:views)
    # SQL: UPDATE posts SET views = views + 1 WHERE id = ?
  end
end

# All atomic operations:
post.increment!(:views)         # += 1
post.increment!(:views, 5)      # += 5
post.decrement!(:likes)         # -= 1
post.update_counters(views: 1)  # Bulk update

# Counter cache (automatically atomic)
class Comment &lt; ApplicationRecord
  belongs_to :post, counter_cache: true
end

# Creating comment automatically increments post.comments_count

# ============================================
# TECHNIQUE 5: Database Constraints
# ============================================

# Use database to enforce constraints

# Migration
class AddUniqueConstraintToUsernames &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :users, :username, unique: true
  end
end

# Now database prevents duplicates even with race condition
# Thread 1: INSERT username=&#39;john&#39;
# Thread 2: INSERT username=&#39;john&#39;
# Result: Thread 2 gets UniqueViolation error ✓

# Check constraint
class AddBalanceConstraint &lt; ActiveRecord::Migration[7.0]
  def change
    execute &lt;&lt;-SQL
      ALTER TABLE accounts
      ADD CONSTRAINT balance_non_negative
      CHECK (balance &gt;= 0)
    SQL
  end
end

# Database prevents negative balance even with race condition

# ============================================
# TECHNIQUE 6: Idempotent Operations
# ============================================

# Design operations that can be safely retried

class OrderProcessor
  def process(order_id)
    order = Order.find(order_id)
    
    # ❌ NOT IDEMPOTENT
    # order.total += 10  # Running twice adds $20!
    
    # ✅ IDEMPOTENT: Check current state
    return if order.processed?
    
    order.update!(
      processed: true,
      processed_at: Time.current
    )
    
    # Use unique idempotency key
    charge_payment(order, idempotency_key: &quot;order-#{order.id}&quot;)
  end
end

# Idempotency keys for external APIs
class PaymentService
  def charge(amount, idempotency_key:)
    Stripe::Charge.create(
      amount: amount,
      currency: &#39;usd&#39;,
      idempotency_key: idempotency_key
    )
  end
end

# Calling twice with same key = one charge ✓

# ============================================
# TECHNIQUE 7: Double-Checked Locking
# ============================================

# Check condition, lock, check again

class CacheWarmer
  @warming = false
  @mutex = Mutex.new
  
  def self.warm_cache
    # First check (fast path, no lock)
    return if @warming
    
    @mutex.synchronize do
      # Second check (someone might have started while we waited)
      return if @warming
      
      @warming = true
      perform_warming
    ensure
      @warming = false
    end
  end
end

# ============================================
# TECHNIQUE 8: Redis Distributed Locks
# ============================================

# Lock across multiple app servers

# Gemfile
gem &#39;redlock&#39;

# Usage
class ReportGenerator
  def generate(report_id)
    lock_manager = Redlock::Client.new([ENV[&#39;REDIS_URL&#39;]])
    
    lock_manager.lock(&quot;report:#{report_id}&quot;, 60_000) do |locked|
      if locked
        # Only one server can generate this report
        report = Report.find(report_id)
        report.generate!
      else
        # Another server is generating it
        Rails.logger.info &quot;Report #{report_id} already being generated&quot;
      end
    end
  end
end

# ============================================
# TECHNIQUE 9: Queue-Based Processing
# ============================================

# Avoid race conditions by serializing operations

class InventoryController &lt; ApplicationController
  def reserve
    # Don&#39;t process immediately
    ReserveInventoryJob.perform_later(
      item_id: params[:item_id],
      quantity: params[:quantity],
      user_id: current_user.id
    )
    
    render json: { message: &#39;Reservation queued&#39; }
  end
end

# Job processes sequentially (one at a time per queue)
class ReserveInventoryJob &lt; ApplicationJob
  queue_as :default
  
  def perform(item_id:, quantity:, user_id:)
    item = Item.find(item_id)
    
    item.with_lock do
      if item.quantity &gt;= quantity
        item.decrement!(:quantity, quantity)
        Reservation.create!(item: item, user_id: user_id, quantity: quantity)
      end
    end
  end
end

# ============================================
# TECHNIQUE 10: Eventual Consistency
# ============================================

# Accept temporary inconsistency for better performance

class LikesController &lt; ApplicationController
  def create
    # Increment counter asynchronously
    IncrementLikesJob.perform_later(post_id: params[:post_id])
    
    # Return immediately
    render json: { liked: true }
  end
end

class IncrementLikesJob &lt; ApplicationJob
  def perform(post_id:)
    Post.increment_counter(:likes_count, post_id)
  end
end

# Likes count might be slightly behind, but no race condition
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<pre><code class="language-ruby"># ============================================
# EXAMPLE 1: E-commerce Inventory
# ============================================

class Order &lt; ApplicationRecord
  has_many :order_items
  
  def place_order
    ActiveRecord::Base.transaction do
      order_items.each do |item|
        product = Product.lock.find(item.product_id)
        
        # Check and update atomically
        if product.quantity &lt; item.quantity
          raise InsufficientInventory, &quot;Not enough #{product.name}&quot;
        end
        
        product.decrement!(:quantity, item.quantity)
      end
      
      update!(status: &#39;placed&#39;, placed_at: Time.current)
    end
  end
end

# ============================================
# EXAMPLE 2: Limited Quantity Flash Sale
# ============================================

class FlashSaleController &lt; ApplicationController
  def purchase
    product = Product.find(params[:product_id])
    
    # Use Redis for atomic decrement (fast!)
    key = &quot;flash_sale:#{product.id}:remaining&quot;
    remaining = $redis.with do |conn|
      conn.decr(key)
    end
    
    if remaining &gt;= 0
      # Reserve succeeded
      CreateOrderJob.perform_later(
        user_id: current_user.id,
        product_id: product.id
      )
      render json: { success: true }
    else
      # Sold out
      $redis.with { |conn| conn.incr(key) }  # Undo decrement
      render json: { success: false, message: &#39;Sold out&#39; }, status: 422
    end
  end
end

# ============================================
# EXAMPLE 3: Seat Reservation System
# ============================================

class Seat &lt; ApplicationRecord
  enum status: { available: 0, reserved: 1, confirmed: 2 }
  
  def reserve_for(user, expires_in: 15.minutes)
    with_lock do
      unless available?
        raise SeatUnavailable, &quot;Seat #{seat_number} not available&quot;
      end
      
      update!(
        status: :reserved,
        reserved_by_id: user.id,
        reserved_until: expires_in.from_now
      )
    end
  end
end

# Background job to release expired reservations
class ReleaseExpiredReservationsJob &lt; ApplicationJob
  def perform
    Seat.where(&#39;reserved_until &lt; ?&#39;, Time.current)
        .update_all(
          status: Seat.statuses[:available],
          reserved_by_id: nil,
          reserved_until: nil
        )
  end
end

# ============================================
# EXAMPLE 4: Rate Limiting
# ============================================

class RateLimiter
  def self.check(user_id, action:, limit: 100, period: 1.hour)
    key = &quot;rate_limit:#{user_id}:#{action}&quot;
    
    $redis.with do |conn|
      count = conn.incr(key)
      
      # Set expiry on first request
      conn.expire(key, period.to_i) if count == 1
      
      if count &gt; limit
        raise RateLimitExceeded, &quot;Too many #{action} requests&quot;
      end
      
      count
    end
  end
end

# Usage
class ApiController &lt; ApplicationController
  before_action :check_rate_limit
  
  private
  
  def check_rate_limit
    RateLimiter.check(current_user.id, action: action_name)
  rescue RateLimitExceeded =&gt; e
    render json: { error: e.message }, status: 429
  end
end
</code></pre>
<hr>
<h3>Testing Race Conditions</h3>
<pre><code class="language-ruby"># ============================================
# TEST 1: Concurrent Modifications
# ============================================

require &#39;test_helper&#39;

class RaceConditionTest &lt; ActiveSupport::TestCase
  test &quot;prevents double withdrawal&quot; do
    account = accounts(:checking)
    account.update!(balance: 1000)
    
    threads = 2.times.map do
      Thread.new do
        account.withdraw(600)
      rescue =&gt; e
        e  # Capture exception
      end
    end
    
    results = threads.map(&amp;:value)
    account.reload
    
    # One should succeed, one should fail
    assert_equal 1, results.count(true)
    assert_equal 1, results.count { |r| r.is_a?(Exception) }
    assert_equal 400, account.balance
  end
  
  # ============================================
  # TEST 2: Inventory Race Condition
  # ============================================
  
  test &quot;prevents overselling inventory&quot; do
    product = products(:laptop)
    product.update!(quantity: 10)
    
    # 20 threads try to buy 1 item each
    threads = 20.times.map do
      Thread.new do
        begin
          Order.create_with_inventory_check!(
            product: product,
            quantity: 1
          )
          true
        rescue InsufficientInventory
          false
        end
      end
    end
    
    results = threads.map(&amp;:value)
    product.reload
    
    # Only 10 should succeed
    assert_equal 10, results.count(true)
    assert_equal 10, results.count(false)
    assert_equal 0, product.quantity
  end
  
  # ============================================
  # TEST 3: Counter Race Condition
  # ============================================
  
  test &quot;accurately counts with concurrent increments&quot; do
    post = posts(:one)
    initial_views = post.views
    
    threads = 100.times.map do
      Thread.new { post.increment!(:views) }
    end
    
    threads.each(&amp;:join)
    post.reload
    
    assert_equal initial_views + 100, post.views
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Race conditions</strong> happen when outcome depends on thread timing</li>
<li><strong>Mutex</strong> locks critical sections (one thread at a time)</li>
<li><strong>Database locks</strong> prevent concurrent modifications</li>
<li><strong>Optimistic locking</strong> detects conflicts with version column</li>
<li><strong>Atomic operations</strong> are thread-safe by design</li>
<li><strong>Database constraints</strong> enforce rules even with race conditions</li>
<li><strong>Idempotent operations</strong> can be safely retried</li>
<li><strong>Distributed locks</strong> (Redis) work across multiple servers</li>
<li><strong>Queue-based</strong> processing serializes operations</li>
<li><strong>Test concurrently</strong> to catch race conditions</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Performance Optimization</h2>
<h2>Question 315: How do you optimize a page that takes time to load?</h2>
<h3>Answer</h3>
<p>Optimize slow pages by identifying bottlenecks using profiling tools, then applying targeted fixes: <strong>database query optimization</strong> (N+1, indexes, eager loading), <strong>caching</strong> (fragment, query, HTTP), <strong>asset optimization</strong> (compression, CDN), <strong>lazy loading</strong>, and <strong>background processing</strong>.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Profile first</strong>: Use tools to identify bottlenecks (New Relic, Rack Mini Profiler)</li>
<li><strong>Database</strong>: Fix N+1 queries, add indexes, eager load associations</li>
<li><strong>Caching</strong>: Fragment caching, query caching, HTTP caching</li>
<li><strong>Assets</strong>: Minify, compress, use CDN, lazy load images</li>
<li><strong>Background</strong>: Move slow operations to background jobs</li>
<li><strong>Measure</strong>: Set performance budget (&lt; 200ms target)</li>
</ul>
<hr>
<h3>Step-by-Step Optimization Process</h3>
<pre><code class="language-ruby"># ============================================
# STEP 1: IDENTIFY THE PROBLEM (Profiling)
# ============================================

# Install profiling tools
# Gemfile
gem &#39;rack-mini-profiler&#39;
gem &#39;memory_profiler&#39;
gem &#39;bullet&#39;  # Detects N+1 queries

# config/environments/development.rb
config.after_initialize do
  Bullet.enable = true
  Bullet.bullet_logger = true
  Bullet.console = true
  Bullet.rails_logger = true
end

# Example slow page analysis:
# Page load time: 2.5 seconds
# 
# Rack Mini Profiler shows:
# - Database queries: 1,800ms (72%)
# - View rendering: 600ms (24%)
# - Other: 100ms (4%)
# 
# Conclusion: Database is the bottleneck

# ============================================
# STEP 2: FIX N+1 QUERIES (Most Common Issue)
# ============================================

# ❌ BEFORE: N+1 Query Problem
class PostsController &lt; ApplicationController
  def index
    @posts = Post.all.limit(20)
  end
end

# View: app/views/posts/index.html.erb
&lt;% @posts.each do |post| %&gt;
  &lt;h2&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
  &lt;p&gt;By &lt;%= post.author.name %&gt;&lt;/p&gt;  &lt;!-- N+1! --&gt;
  &lt;p&gt;&lt;%= post.comments.count %&gt; comments&lt;/p&gt;  &lt;!-- N+1! --&gt;
  &lt;% post.tags.each do |tag| %&gt;  &lt;!-- N+1! --&gt;
    &lt;span&gt;&lt;%= tag.name %&gt;&lt;/span&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

# Queries executed:
# 1. SELECT * FROM posts LIMIT 20
# 2-21. SELECT * FROM users WHERE id = ? (20 queries)
# 22-41. SELECT COUNT(*) FROM comments WHERE post_id = ? (20 queries)
# 42-61. SELECT * FROM tags JOIN posts_tags WHERE post_id = ? (20 queries)
# Total: 61 queries! 🐌

# ✅ AFTER: Eager Loading
class PostsController &lt; ApplicationController
  def index
    @posts = Post.includes(:author, :tags)
                 .left_joins(:comments)
                 .select(&#39;posts.*, COUNT(comments.id) as comments_count&#39;)
                 .group(&#39;posts.id&#39;)
                 .limit(20)
  end
end

# Queries executed:
# 1. SELECT posts.*, COUNT(comments.id) as comments_count FROM posts ...
# 2. SELECT * FROM users WHERE id IN (1,2,3...)
# 3. SELECT * FROM tags JOIN posts_tags WHERE post_id IN (1,2,3...)
# Total: 3 queries! ⚡ (20x faster)

# Time improvement:
# Before: 1,800ms (61 queries)
# After: 90ms (3 queries)
# Improvement: 95% faster! 🚀

# ============================================
# STEP 3: ADD DATABASE INDEXES
# ============================================

# Check slow queries
# log/development.log or use pg_stat_statements

# Slow query example:
# SELECT * FROM posts WHERE user_id = 123 AND published = true
# ORDER BY created_at DESC
# Time: 800ms

# Check if indexes exist
# rails dbconsole
# \d posts

# Add appropriate indexes
class AddIndexesToPosts &lt; ActiveRecord::Migration[7.0]
  def change
    # Single column indexes
    add_index :posts, :user_id
    add_index :posts, :published
    add_index :posts, :created_at
    
    # Composite index (order matters!)
    # For: WHERE user_id = ? AND published = ? ORDER BY created_at
    add_index :posts, [:user_id, :published, :created_at]
    
    # Partial index (PostgreSQL)
    add_index :posts, :created_at, 
              where: &quot;published = true&quot;,
              name: &#39;index_posts_on_created_at_where_published&#39;
  end
end

# After indexes:
# Same query: 12ms (67x faster!)

# ============================================
# STEP 4: IMPLEMENT CACHING
# ============================================

# A. Fragment Caching (View Level)
# app/views/posts/index.html.erb
&lt;% cache [&#39;posts-index&#39;, @posts.maximum(:updated_at)] do %&gt;
  &lt;div class=&quot;posts&quot;&gt;
    &lt;% @posts.each do |post| %&gt;
      &lt;% cache post do %&gt;
        &lt;%= render post %&gt;
      &lt;% end %&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
&lt;% end %&gt;

# First request: 600ms (renders view)
# Subsequent requests: 15ms (reads from cache)
# Improvement: 97% faster! 🚀

# B. Query Result Caching
class Post &lt; ApplicationRecord
  def self.trending
    Rails.cache.fetch(&#39;trending_posts&#39;, expires_in: 5.minutes) do
      where(&#39;created_at &gt; ?&#39;, 1.week.ago)
        .order(views: :desc)
        .limit(10)
        .to_a  # Load into memory
    end
  end
end

# First call: 150ms (database query)
# Cached calls: 2ms (Redis read)
# Improvement: 99% faster! 🚀

# C. HTTP Caching
class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    
    # Set ETag and Last-Modified
    fresh_when(etag: @post, last_modified: @post.updated_at, public: true)
    
    # Or set Cache-Control header
    expires_in 5.minutes, public: true
  end
end

# Browser caches response:
# First request: 200ms
# Cached requests: 0ms (browser cache) 304 Not Modified
# Improvement: 100% faster! 🚀

# ============================================
# STEP 5: OPTIMIZE ASSETS
# ============================================

# A. Enable Asset Compression
# config/environments/production.rb
config.assets.compress = true
config.assets.js_compressor = :terser
config.assets.css_compressor = :sass

# B. Use CDN
config.asset_host = &#39;https://cdn.example.com&#39;

# C. Lazy Load Images
# app/views/posts/_post.html.erb
&lt;%= image_tag post.image_url, 
    loading: &#39;lazy&#39;,
    class: &#39;post-image&#39; %&gt;

# D. Minify and Bundle
# application.js is automatically bundled and minified

# E. Use WebP Images
class Post &lt; ApplicationRecord
  has_one_attached :image
  
  def optimized_image_url(size: &#39;800x600&#39;)
    return nil unless image.attached?
    
    Rails.cache.fetch(&quot;post/#{id}/image/#{size}&quot;, expires_in: 1.day) do
      image.variant(resize_to_limit: size.split(&#39;x&#39;).map(&amp;:to_i), format: :webp)
           .processed
           .url
    end
  end
end

# Asset size reduction:
# Before: 2.5MB total assets
# After: 600KB total assets
# Improvement: 76% smaller! 🚀

# ============================================
# STEP 6: MOVE TO BACKGROUND JOBS
# ============================================

# ❌ BEFORE: Blocking operations
class PostsController &lt; ApplicationController
  def create
    @post = Post.create!(post_params)
    
    # These block the response
    notify_subscribers(@post)          # 800ms
    generate_thumbnail(@post)          # 1,200ms
    update_search_index(@post)         # 500ms
    post_to_social_media(@post)        # 1,500ms
    
    redirect_to @post
    # Total: 4 seconds! 🐌
  end
end

# ✅ AFTER: Background jobs
class PostsController &lt; ApplicationController
  def create
    @post = Post.create!(post_params)
    
    # Move to background
    NotifySubscribersJob.perform_later(@post.id)
    GenerateThumbnailJob.perform_later(@post.id)
    UpdateSearchIndexJob.perform_later(@post.id)
    PostToSocialMediaJob.perform_later(@post.id)
    
    redirect_to @post
    # Total: 50ms ⚡ (80x faster!)
  end
end

# ============================================
# STEP 7: DATABASE QUERY OPTIMIZATION
# ============================================

# A. Select Only Needed Columns
# ❌ BAD: Loads all columns
@users = User.all

# ✅ GOOD: Loads only needed columns
@users = User.select(:id, :name, :email, :created_at)

# Reduction: 10KB → 2KB per user (80% less data)

# B. Use Counter Caches
class Post &lt; ApplicationRecord
  has_many :comments
end

class Comment &lt; ApplicationRecord
  belongs_to :post, counter_cache: true
end

# Add migration
add_column :posts, :comments_count, :integer, default: 0

# ❌ BEFORE
post.comments.count  # SELECT COUNT(*) FROM comments... (50ms)

# ✅ AFTER
post.comments_count  # Reads from column (1ms)

# C. Paginate Large Results
# ❌ BAD
@posts = Post.all  # Loads 10,000 records

# ✅ GOOD
@posts = Post.page(params[:page]).per(20)  # Loads 20 records

# D. Use Database Views for Complex Queries
# db/migrate/xxx_create_trending_posts_view.rb
class CreateTrendingPostsView &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE VIEW trending_posts AS
      SELECT posts.*, COUNT(views.id) as view_count
      FROM posts
      LEFT JOIN views ON views.post_id = posts.id
      WHERE posts.created_at &gt; NOW() - INTERVAL &#39;7 days&#39;
      GROUP BY posts.id
      ORDER BY view_count DESC
    SQL
  end
  
  def down
    execute &quot;DROP VIEW trending_posts&quot;
  end
end

# Model
class TrendingPost &lt; ApplicationRecord
  self.primary_key = &#39;id&#39;
  
  def readonly?
    true
  end
end

# Usage (fast!)
TrendingPost.limit(10)

# ============================================
# STEP 8: REDUCE VIEW RENDERING TIME
# ============================================

# A. Avoid Complex Logic in Views
# ❌ BAD
&lt;% @posts.each do |post| %&gt;
  &lt;% if post.published? &amp;&amp; post.author.premium? &amp;&amp; post.views &gt; 1000 %&gt;
    &lt;%= render post %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

# ✅ GOOD: Move to query
@posts = Post.published
             .joins(:author)
             .where(authors: { premium: true })
             .where(&#39;posts.views &gt; ?&#39;, 1000)

&lt;% @posts.each do |post| %&gt;
  &lt;%= render post %&gt;
&lt;% end %&gt;

# B. Use Jbuilder for JSON (faster than to_json)
# app/views/api/posts/index.json.jbuilder
json.array! @posts do |post|
  json.id post.id
  json.title post.title
  json.author do
    json.name post.author.name
  end
end

# C. Cache Partials
# app/views/posts/_post.html.erb
&lt;% cache post do %&gt;
  &lt;div class=&quot;post&quot;&gt;
    &lt;h2&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;%= post.body %&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>
<hr>
<h3>Real-World Optimization Example</h3>
<pre><code class="language-ruby"># ============================================
# CASE STUDY: Slow Dashboard Page
# ============================================

# Initial Performance:
# Page load: 3,200ms
# Database: 2,400ms (75%)
# Rendering: 700ms (22%)
# Other: 100ms (3%)

# ❌ BEFORE CODE
class DashboardController &lt; ApplicationController
  def index
    @user = current_user
    @posts = @user.posts.order(created_at: :desc)
    @notifications = @user.notifications.unread
    @stats = {
      total_posts: @user.posts.count,
      total_views: @user.posts.sum(:views),
      total_comments: Comment.where(post_id: @user.posts.pluck(:id)).count,
      followers: @user.followers.count
    }
  end
end

# Queries executed: 50+
# Time: 2,400ms

# ✅ AFTER CODE (Optimized)
class DashboardController &lt; ApplicationController
  def index
    @user = current_user
    
    # Eager load associations
    @posts = @user.posts
                  .includes(:category, :tags)
                  .order(created_at: :desc)
                  .limit(10)
    
    @notifications = @user.notifications
                          .unread
                          .order(created_at: :desc)
                          .limit(5)
    
    # Cache expensive stats
    @stats = Rails.cache.fetch(&quot;dashboard_stats/#{@user.id}&quot;, expires_in: 5.minutes) do
      {
        total_posts: @user.posts_count,  # counter_cache
        total_views: @user.total_views,  # cached column
        total_comments: @user.total_comments,  # cached column
        followers: @user.followers_count  # counter_cache
      }
    end
  end
end

# Add counter caches and cached columns
class AddCachedColumnsToPosts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :posts_count, :integer, default: 0
    add_column :users, :followers_count, :integer, default: 0
    add_column :users, :total_views, :integer, default: 0
    add_column :users, :total_comments, :integer, default: 0
    
    # Update existing records
    User.find_each do |user|
      User.reset_counters(user.id, :posts, :followers)
      user.update_columns(
        total_views: user.posts.sum(:views),
        total_comments: Comment.where(post_id: user.posts.pluck(:id)).count
      )
    end
  end
end

# View caching
# app/views/dashboard/index.html.erb
&lt;% cache [&#39;dashboard&#39;, @user, @posts.maximum(:updated_at)] do %&gt;
  &lt;div class=&quot;dashboard&quot;&gt;
    &lt;%= render &#39;stats&#39;, stats: @stats %&gt;
    
    &lt;% cache [&#39;posts&#39;, @posts.map(&amp;:cache_key)] do %&gt;
      &lt;%= render @posts %&gt;
    &lt;% end %&gt;
    
    &lt;% cache [&#39;notifications&#39;, @notifications.maximum(:updated_at)] do %&gt;
      &lt;%= render @notifications %&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
&lt;% end %&gt;

# RESULTS:
# Queries: 50+ → 4
# Database time: 2,400ms → 80ms (97% faster)
# Rendering: 700ms → 20ms (cached)
# Total: 3,200ms → 100ms (97% faster!)

# Performance Budget Met:
# Target: &lt; 200ms ✓
# Actual: 100ms ✓
</code></pre>
<hr>
<h3>Performance Monitoring</h3>
<pre><code class="language-ruby"># Set up continuous monitoring

# config/initializers/performance_monitoring.rb
ActiveSupport::Notifications.subscribe(&#39;process_action.action_controller&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  
  # Log slow requests
  if event.duration &gt; 200
    Rails.logger.warn({
      event: &#39;slow_request&#39;,
      controller: event.payload[:controller],
      action: event.payload[:action],
      duration_ms: event.duration.round(2),
      db_time_ms: event.payload[:db_runtime]&amp;.round(2),
      view_time_ms: event.payload[:view_runtime]&amp;.round(2)
    }.to_json)
  end
  
  # Send to monitoring service
  StatsD.histogram(&#39;request.duration&#39;, event.duration)
  StatsD.histogram(&#39;request.db_time&#39;, event.payload[:db_runtime] || 0)
end

# Set performance budgets
class ApplicationController &lt; ActionController::Base
  around_action :check_performance_budget
  
  private
  
  def check_performance_budget
    start = Time.current
    yield
    duration = ((Time.current - start) * 1000).round(2)
    
    if duration &gt; 200
      Rails.logger.warn &quot;Performance budget exceeded: #{duration}ms&quot;
      # Alert team
      SlackNotifier.post(&quot;Page #{request.fullpath} took #{duration}ms&quot;)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Profile first</strong>: Identify bottlenecks before optimizing</li>
<li><strong>Fix N+1 queries</strong>: Use eager loading (<code>includes</code>, <code>preload</code>)</li>
<li><strong>Add indexes</strong>: Critical for query performance</li>
<li><strong>Cache aggressively</strong>: Fragment, query, and HTTP caching</li>
<li><strong>Optimize assets</strong>: Minify, compress, lazy load, use CDN</li>
<li><strong>Background jobs</strong>: Move slow operations async</li>
<li><strong>Database optimization</strong>: Select columns, counter caches, pagination</li>
<li><strong>Set budgets</strong>: Target &lt; 200ms for web pages</li>
<li><strong>Monitor continuously</strong>: Track performance over time</li>
<li><strong>Measure impact</strong>: Compare before/after metrics</li>
</ol>
<hr>
<h2>Question 316: How do you handle and manage 1-2 million data entries?</h2>
<h3>Answer</h3>
<p>Handle millions of records using <strong>database optimization</strong> (indexes, partitioning), <strong>batch processing</strong> (find_each, in_batches), <strong>pagination</strong> (cursor-based), <strong>archiving</strong> (move old data), <strong>read replicas</strong> (distribute load), and <strong>caching</strong> (reduce database hits).</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Indexes</strong>: Essential for query performance on large tables</li>
<li><strong>Batch processing</strong>: Use <code>find_each</code>, <code>in_batches</code> for iterating</li>
<li><strong>Pagination</strong>: Cursor-based for large datasets (better than offset)</li>
<li><strong>Partitioning</strong>: Split tables by date/range (PostgreSQL)</li>
<li><strong>Archiving</strong>: Move old data to separate tables/databases</li>
<li><strong>Read replicas</strong>: Distribute read load across multiple databases</li>
</ul>
<hr>
<h3>Complete Strategy</h3>
<pre><code class="language-ruby"># ============================================
# CHALLENGE: Table with 2 Million Records
# ============================================

# users table: 2,000,000 records
# orders table: 10,000,000 records
# Problem: Slow queries, high memory usage, timeouts

# ============================================
# SOLUTION 1: Proper Indexing
# ============================================

# Without indexes:
# SELECT * FROM users WHERE email = &#39;user@example.com&#39;
# Time: 2,500ms (full table scan)

# With index:
class AddIndexToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    # Single column indexes
    add_index :users, :email, unique: true
    add_index :users, :created_at
    add_index :users, :status
    
    # Composite indexes (order matters!)
    add_index :users, [:status, :created_at]
    add_index :orders, [:user_id, :status, :created_at]
    
    # Partial index (only index active users)
    add_index :users, :email, where: &quot;status = &#39;active&#39;&quot;, name: &#39;index_active_users_email&#39;
    
    # Full-text search index (PostgreSQL)
    add_index :users, :name, using: :gin, opclass: :gin_trgm_ops
  end
end

# After indexes:
# Same query: 3ms (index scan)
# Improvement: 833x faster! 🚀

# Index size monitoring:
# rails dbconsole
# SELECT 
#   schemaname,
#   tablename,
#   indexname,
#   pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
# FROM pg_stat_user_indexes
# ORDER BY pg_relation_size(indexrelid) DESC;

# ============================================
# SOLUTION 2: Batch Processing
# ============================================

# ❌ NEVER DO THIS with large tables:
User.all.each do |user|  # Loads 2M records into memory!
  process(user)
end
# Memory usage: ~2GB
# Time: 10+ minutes
# Result: Out of memory error 💥

# ✅ USE find_each (batches of 1000)
User.find_each(batch_size: 1000) do |user|
  process(user)
end
# Memory usage: ~10MB (constant)
# Time: 5 minutes
# Result: Success ✓

# How find_each works:
# Batch 1: SELECT * FROM users ORDER BY id LIMIT 1000
# Batch 2: SELECT * FROM users WHERE id &gt; 1000 ORDER BY id LIMIT 1000
# Batch 3: SELECT * FROM users WHERE id &gt; 2000 ORDER BY id LIMIT 1000
# ...

# Custom batch size for larger/smaller batches
User.find_each(batch_size: 5000) do |user|
  process(user)
end

# Start from specific record
User.find_each(start: 100000, batch_size: 1000) do |user|
  process(user)
end

# Finish at specific record
User.find_each(start: 100000, finish: 200000) do |user|
  process(user)
end

# ✅ USE in_batches (work with relations)
User.where(status: &#39;active&#39;).in_batches(of: 1000) do |batch|
  batch.update_all(last_processed_at: Time.current)
end

# in_batches yields relations, not records:
User.in_batches(of: 1000) do |batch|
  # batch is a relation, not an array
  batch.update_all(verified: true)
  batch.where(&#39;created_at &lt; ?&#39;, 1.year.ago).delete_all
end

# ============================================
# SOLUTION 3: Efficient Pagination
# ============================================

# A. Offset Pagination (BAD for large datasets)
# ❌ PROBLEM: Slow at high offsets
@users = User.limit(20).offset(100000)
# SQL: SELECT * FROM users LIMIT 20 OFFSET 100000
# Database must scan 100,020 rows! (slow)

# Page 1: 20ms
# Page 100: 50ms
# Page 5000: 2,500ms (gets slower with each page)

# B. Cursor-based Pagination (GOOD)
# ✅ SOLUTION: Use ID for pagination
class User &lt; ApplicationRecord
  def self.paginate_by_cursor(cursor: nil, limit: 20)
    scope = order(id: :asc).limit(limit)
    scope = scope.where(&#39;id &gt; ?&#39;, cursor) if cursor
    scope
  end
end

# Usage
@users = User.paginate_by_cursor(cursor: params[:cursor], limit: 20)
next_cursor = @users.last&amp;.id

# SQL: SELECT * FROM users WHERE id &gt; 100000 ORDER BY id LIMIT 20
# Always fast (uses index), regardless of position

# Page 1: 15ms
# Page 100: 15ms
# Page 5000: 15ms (consistent performance!)

# API Response
render json: {
  users: @users,
  next_cursor: next_cursor,
  has_more: @users.size == 20
}

# C. Keyset Pagination (Advanced)
class User &lt; ApplicationRecord
  def self.keyset_paginate(after_id: nil, after_created: nil, limit: 20)
    scope = order(created_at: :desc, id: :desc).limit(limit)
    
    if after_id &amp;&amp; after_created
      scope = scope.where(
        &#39;(created_at &lt; ?) OR (created_at = ? AND id &lt; ?)&#39;,
        after_created, after_created, after_id
      )
    end
    
    scope
  end
end

# ============================================
# SOLUTION 4: Table Partitioning (PostgreSQL)
# ============================================

# Partition large tables by date

# Create partitioned table
class CreatePartitionedOrders &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE TABLE orders (
        id BIGSERIAL,
        user_id INTEGER NOT NULL,
        total DECIMAL(10,2),
        status VARCHAR(50),
        created_at TIMESTAMP NOT NULL,
        updated_at TIMESTAMP NOT NULL
      ) PARTITION BY RANGE (created_at);
      
      -- Create partitions for each month
      CREATE TABLE orders_2024_01 PARTITION OF orders
        FOR VALUES FROM (&#39;2024-01-01&#39;) TO (&#39;2024-02-01&#39;);
      
      CREATE TABLE orders_2024_02 PARTITION OF orders
        FOR VALUES FROM (&#39;2024-02-01&#39;) TO (&#39;2024-03-01&#39;);
      
      CREATE TABLE orders_2024_03 PARTITION OF orders
        FOR VALUES FROM (&#39;2024-03-01&#39;) TO (&#39;2024-04-01&#39;);
      
      -- Create indexes on each partition
      CREATE INDEX idx_orders_2024_01_user_id ON orders_2024_01(user_id);
      CREATE INDEX idx_orders_2024_02_user_id ON orders_2024_02(user_id);
      CREATE INDEX idx_orders_2024_03_user_id ON orders_2024_03(user_id);
    SQL
  end
end

# Benefits:
# - Query only relevant partitions (faster)
# - Drop old partitions easily (archive)
# - Smaller indexes per partition

# Query automatically uses correct partition:
Order.where(created_at: &#39;2024-01-15&#39;..&#39;2024-01-20&#39;)
# Only scans orders_2024_01 partition!

# ============================================
# SOLUTION 5: Archiving Old Data
# ============================================

# Move old data to archive table

class ArchiveOldOrders &lt; ActiveRecord::Migration[7.0]
  def up
    # Create archive table
    create_table :orders_archived do |t|
      t.references :user, null: false
      t.decimal :total, precision: 10, scale: 2
      t.string :status
      t.timestamps
    end
    
    # Move old orders (&gt; 2 years)
    execute &lt;&lt;-SQL
      INSERT INTO orders_archived
      SELECT * FROM orders
      WHERE created_at &lt; NOW() - INTERVAL &#39;2 years&#39;;
      
      DELETE FROM orders
      WHERE created_at &lt; NOW() - INTERVAL &#39;2 years&#39;;
    SQL
  end
end

# Automated archiving job
class ArchiveOldOrdersJob &lt; ApplicationJob
  def perform
    cutoff_date = 2.years.ago
    
    # Process in batches
    Order.where(&#39;created_at &lt; ?&#39;, cutoff_date)
         .in_batches(of: 10000) do |batch|
      
      # Copy to archive
      OrderArchived.insert_all(
        batch.pluck(:id, :user_id, :total, :status, :created_at, :updated_at)
              .map { |row| Hash[OrderArchived.column_names.zip(row)] }
      )
      
      # Delete from main table
      batch.delete_all
    end
  end
end

# Schedule monthly
# config/sidekiq.yml
:schedule:
  archive_old_orders:
    cron: &#39;0 0 1 * *&#39;  # First day of month
    class: ArchiveOldOrdersJob

# ============================================
# SOLUTION 6: Read Replicas for Reporting
# ============================================

# Don&#39;t run heavy reports on primary database

# config/database.yml
production:
  primary:
    &lt;&lt;: *default
    database: myapp_production
    host: primary.db.example.com
  
  replica:
    &lt;&lt;: *default
    database: myapp_production
    host: replica.db.example.com
    replica: true

# Heavy report queries
class ReportsController &lt; ApplicationController
  def sales_report
    # Run on replica (doesn&#39;t affect production writes)
    @report = ActiveRecord::Base.connected_to(role: :reading) do
      Order.where(&#39;created_at &gt; ?&#39;, 1.month.ago)
           .group(&#39;DATE(created_at)&#39;)
           .sum(:total)
    end
  end
end

# ============================================
# SOLUTION 7: Materialized Views for Analytics
# ============================================

# Pre-compute expensive aggregations

class CreateDailySalesView &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE MATERIALIZED VIEW daily_sales AS
      SELECT 
        DATE(created_at) as sale_date,
        COUNT(*) as order_count,
        SUM(total) as total_sales,
        AVG(total) as average_order
      FROM orders
      WHERE status = &#39;completed&#39;
      GROUP BY DATE(created_at);
      
      CREATE UNIQUE INDEX ON daily_sales(sale_date);
    SQL
  end
  
  def down
    execute &quot;DROP MATERIALIZED VIEW daily_sales&quot;
  end
end

# Model
class DailySale &lt; ApplicationRecord
  self.primary_key = &#39;sale_date&#39;
  
  def readonly?
    true
  end
  
  # Refresh materialized view
  def self.refresh
    ActiveRecord::Base.connection.execute(
      &#39;REFRESH MATERIALIZED VIEW CONCURRENTLY daily_sales&#39;
    )
  end
end

# Refresh nightly
class RefreshMaterializedViewsJob &lt; ApplicationJob
  def perform
    DailySale.refresh
  end
end

# Usage (fast!)
DailySale.where(&#39;sale_date &gt; ?&#39;, 30.days.ago)
# Reads from pre-computed view (instant)

# ============================================
# SOLUTION 8: Query Optimization
# ============================================

# A. Select only needed columns
# ❌ BAD
User.all  # Loads all columns

# ✅ GOOD
User.select(:id, :name, :email)  # Loads only needed columns
# Data transfer: 10MB → 2MB (80% reduction)

# B. Use pluck for simple data
# ❌ BAD
User.all.map(&amp;:email)  # Loads full objects

# ✅ GOOD
User.pluck(:email)  # Returns array directly
# Memory: 200MB → 20MB (90% reduction)

# C. Count vs Size vs Length
# count: Always queries database
User.count  # SELECT COUNT(*) FROM users

# size: Smart (uses loaded records or count)
users = User.all
users.size  # Uses loaded records if present

# length: Loads all records
users.length  # Loads all into memory (BAD for large sets)

# D. Use EXISTS instead of COUNT
# ❌ SLOW
if User.where(status: &#39;admin&#39;).count &gt; 0

# ✅ FAST
if User.where(status: &#39;admin&#39;).exists?
# SELECT 1 FROM users WHERE status = &#39;admin&#39; LIMIT 1

# ============================================
# SOLUTION 9: Caching Strategy
# ============================================

# Cache expensive queries
class User &lt; ApplicationRecord
  def self.active_count
    Rails.cache.fetch(&#39;users/active_count&#39;, expires_in: 5.minutes) do
      where(status: &#39;active&#39;).count
    end
  end
  
  def self.stats_by_country
    Rails.cache.fetch(&#39;users/stats_by_country&#39;, expires_in: 1.hour) do
      group(:country).count
    end
  end
end

# Cache individual records
class User &lt; ApplicationRecord
  after_commit :clear_cache
  
  def self.cached_find(id)
    Rails.cache.fetch(&quot;user/#{id}&quot;, expires_in: 1.hour) do
      find(id)
    end
  end
  
  private
  
  def clear_cache
    Rails.cache.delete(&quot;user/#{id}&quot;)
  end
end
</code></pre>
<hr>
<h3>Memory Management</h3>
<pre><code class="language-ruby"># Monitor memory usage during batch processing

class ProcessUsersJob &lt; ApplicationJob
  def perform
    initial_memory = `ps -o rss= -p #{Process.pid}`.to_i
    
    User.find_each(batch_size: 1000) do |user|
      process(user)
      
      # Force garbage collection every 10,000 records
      if user.id % 10000 == 0
        GC.start
        current_memory = `ps -o rss= -p #{Process.pid}`.to_i
        Rails.logger.info(&quot;Memory: #{current_memory}KB (#{current_memory - initial_memory}KB increase)&quot;)
      end
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Indexes are critical</strong> for large tables</li>
<li><strong>Never load all records</strong> into memory</li>
<li><strong>Use find_each</strong> for iterating millions of records</li>
<li><strong>Cursor pagination</strong> for large datasets</li>
<li><strong>Partition tables</strong> by date/range (PostgreSQL)</li>
<li><strong>Archive old data</strong> to keep tables manageable</li>
<li><strong>Read replicas</strong> for heavy queries</li>
<li><strong>Materialized views</strong> for analytics</li>
<li><strong>Cache aggressively</strong> to reduce database load</li>
<li><strong>Monitor memory</strong> during batch processing</li>
</ol>
<hr>
<h2>Question 317: How do you handle large datasets efficiently in Rails?</h2>
<h3>Answer</h3>
<p>Handle large datasets efficiently using <strong>streaming</strong> (CSV, JSON), <strong>batch processing</strong> (find_each), <strong>background jobs</strong> (async processing), <strong>progress tracking</strong>, <strong>memory management</strong>, and <strong>chunked responses</strong> to avoid loading millions of records into memory.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Stream responses</strong>: Don&#39;t load all data into memory</li>
<li><strong>Batch process</strong>: Use find_each for iteration</li>
<li><strong>Background jobs</strong>: Process large datasets asynchronously</li>
<li><strong>Progress tracking</strong>: Show progress for long operations</li>
<li><strong>Chunked downloads</strong>: Break large files into chunks</li>
<li><strong>Memory limits</strong>: Monitor and manage memory usage</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<p><strong>The Problem:</strong></p>
<pre><code class="language-ruby"># ❌ DISASTER: Loading 1 million records into memory
def export_users
  @users = User.all  # Loads 1,000,000 records into RAM!
  
  csv = CSV.generate do |csv|
    csv &lt;&lt; [&#39;Name&#39;, &#39;Email&#39;, &#39;Created&#39;]
    @users.each do |user|
      csv &lt;&lt; [user.name, user.email, user.created_at]
    end
  end
  
  send_data csv, filename: &#39;users.csv&#39;
end

# Memory usage: 2-5 GB
# Time to first byte: 60+ seconds
# Server: Likely crashes with OutOfMemory error 💥
</code></pre>
<hr>
<h3>Solution 1: CSV Streaming</h3>
<pre><code class="language-ruby"># ✅ EFFICIENT: Stream CSV without loading all data

class UsersController &lt; ApplicationController
  def export
    # Set headers for streaming
    headers[&#39;Content-Type&#39;] = &#39;text/csv&#39;
    headers[&#39;Content-Disposition&#39;] = &#39;attachment; filename=&quot;users.csv&quot;&#39;
    headers[&#39;Cache-Control&#39;] = &#39;no-cache&#39;
    headers[&#39;X-Accel-Buffering&#39;] = &#39;no&#39;  # Disable nginx buffering
    
    # Stream response
    self.response_body = csv_enumerator
  end
  
  private
  
  def csv_enumerator
    Enumerator.new do |yielder|
      # Write CSV header
      yielder &lt;&lt; CSV.generate_line([&#39;ID&#39;, &#39;Name&#39;, &#39;Email&#39;, &#39;Created At&#39;])
      
      # Stream records in batches
      User.find_each(batch_size: 1000) do |user|
        yielder &lt;&lt; CSV.generate_line([
          user.id,
          user.name,
          user.email,
          user.created_at.iso8601
        ])
      end
    end
  end
end

# Memory usage: Constant ~50MB
# Time to first byte: ~100ms (immediate streaming)
# Can handle millions of records ✓

# Alternative with ActionController::Live
class UsersController &lt; ApplicationController
  include ActionController::Live
  
  def export
    response.headers[&#39;Content-Type&#39;] = &#39;text/csv&#39;
    response.headers[&#39;Content-Disposition&#39;] = &#39;attachment; filename=&quot;users.csv&quot;&#39;
    
    begin
      # Write header
      response.stream.write CSV.generate_line([&#39;ID&#39;, &#39;Name&#39;, &#39;Email&#39;])
      
      # Stream data
      User.find_each(batch_size: 1000) do |user|
        response.stream.write CSV.generate_line([user.id, user.name, user.email])
      end
    ensure
      response.stream.close
    end
  end
end
</code></pre>
<hr>
<h3>Solution 2: JSON Streaming</h3>
<pre><code class="language-ruby"># Stream large JSON responses

class Api::UsersController &lt; ApplicationController
  def index
    # Set streaming headers
    headers[&#39;Content-Type&#39;] = &#39;application/json&#39;
    headers[&#39;Cache-Control&#39;] = &#39;no-cache&#39;
    headers[&#39;X-Accel-Buffering&#39;] = &#39;no&#39;
    
    self.response_body = json_enumerator
  end
  
  private
  
  def json_enumerator
    Enumerator.new do |yielder|
      yielder &lt;&lt; &#39;{&quot;users&quot;:[&#39;
      
      first = true
      User.find_each(batch_size: 1000) do |user|
        yielder &lt;&lt; &#39;,&#39; unless first
        yielder &lt;&lt; user.to_json
        first = false
      end
      
      yielder &lt;&lt; &#39;]}&#39;
    end
  end
end

# Or use NDJSON (Newline Delimited JSON) - better for streaming
def ndjson_enumerator
  Enumerator.new do |yielder|
    User.find_each(batch_size: 1000) do |user|
      yielder &lt;&lt; user.to_json + &quot;\n&quot;
    end
  end
end

# Client can process line by line without waiting for full response
</code></pre>
<hr>
<h3>Solution 3: Background Job with Progress Tracking</h3>
<pre><code class="language-ruby"># For very large exports, process in background

# app/jobs/export_users_job.rb
class ExportUsersJob &lt; ApplicationJob
  queue_as :exports
  
  def perform(user_id, filters = {})
    user = User.find(user_id)
    export = Export.create!(
      user: user,
      status: &#39;processing&#39;,
      filters: filters
    )
    
    begin
      csv_file = generate_csv(filters, export)
      
      # Upload to S3
      s3 = Aws::S3::Resource.new
      obj = s3.bucket(ENV[&#39;S3_BUCKET&#39;]).object(&quot;exports/#{export.id}.csv&quot;)
      obj.upload_file(csv_file.path)
      
      export.update!(
        status: &#39;completed&#39;,
        file_url: obj.public_url,
        completed_at: Time.current
      )
      
      # Notify user
      ExportMailer.completed(export).deliver_now
      
    rescue =&gt; e
      export.update!(status: &#39;failed&#39;, error: e.message)
      raise
    ensure
      csv_file&amp;.close
      csv_file&amp;.unlink
    end
  end
  
  private
  
  def generate_csv(filters, export)
    file = Tempfile.new([&#39;export&#39;, &#39;.csv&#39;])
    
    total = User.where(filters).count
    processed = 0
    
    CSV.open(file.path, &#39;w&#39;) do |csv|
      csv &lt;&lt; [&#39;ID&#39;, &#39;Name&#39;, &#39;Email&#39;, &#39;Created At&#39;]
      
      User.where(filters).find_each(batch_size: 1000) do |user|
        csv &lt;&lt; [user.id, user.name, user.email, user.created_at]
        
        processed += 1
        
        # Update progress every 1000 records
        if processed % 1000 == 0
          progress = (processed.to_f / total * 100).round(2)
          export.update_column(:progress, progress)
        end
      end
    end
    
    file
  end
end

# Controller
class ExportsController &lt; ApplicationController
  def create
    ExportUsersJob.perform_later(current_user.id, export_params)
    
    render json: {
      message: &#39;Export started. You will receive an email when complete.&#39;
    }
  end
  
  def show
    export = current_user.exports.find(params[:id])
    
    render json: {
      id: export.id,
      status: export.status,
      progress: export.progress,
      file_url: export.file_url,
      created_at: export.created_at
    }
  end
end

# Frontend polls for progress
setInterval(() =&gt; {
  fetch(`/exports/${exportId}`)
    .then(res =&gt; res.json())
    .then(data =&gt; {
      if (data.status === &#39;completed&#39;) {
        window.location.href = data.file_url;
      } else {
        updateProgressBar(data.progress);
      }
    });
}, 2000);
</code></pre>
<hr>
<h3>Solution 4: Chunked File Downloads</h3>
<pre><code class="language-ruby"># For very large files, support chunked/resumable downloads

class DownloadsController &lt; ApplicationController
  def show
    file_path = Rails.root.join(&#39;tmp&#39;, &#39;large_file.zip&#39;)
    
    # Support Range requests (chunked downloads)
    if request.headers[&#39;Range&#39;]
      send_file_chunked(file_path)
    else
      send_file file_path, type: &#39;application/zip&#39;
    end
  end
  
  private
  
  def send_file_chunked(file_path)
    file_size = File.size(file_path)
    range = parse_range_header(request.headers[&#39;Range&#39;], file_size)
    
    headers[&#39;Content-Type&#39;] = &#39;application/zip&#39;
    headers[&#39;Content-Range&#39;] = &quot;bytes #{range[:start]}-#{range[:end]}/#{file_size}&quot;
    headers[&#39;Content-Length&#39;] = (range[:end] - range[:start] + 1).to_s
    headers[&#39;Accept-Ranges&#39;] = &#39;bytes&#39;
    
    self.status = 206  # Partial Content
    
    File.open(file_path, &#39;rb&#39;) do |file|
      file.seek(range[:start])
      
      self.response_body = Enumerator.new do |yielder|
        remaining = range[:end] - range[:start] + 1
        
        while remaining &gt; 0
          chunk_size = [remaining, 8192].min
          chunk = file.read(chunk_size)
          break unless chunk
          
          yielder &lt;&lt; chunk
          remaining -= chunk.bytesize
        end
      end
    end
  end
  
  def parse_range_header(range_header, file_size)
    # Parse &quot;bytes=0-1023&quot;
    match = range_header.match(/bytes=(\d+)-(\d*)/)
    
    start_byte = match[1].to_i
    end_byte = match[2].empty? ? file_size - 1 : match[2].to_i
    
    { start: start_byte, end: end_byte }
  end
end

# Client can resume interrupted downloads
</code></pre>
<hr>
<h3>Solution 5: Memory-Efficient Batch Processing</h3>
<pre><code class="language-ruby"># Process large datasets with memory management

class ProcessUsersJob &lt; ApplicationJob
  def perform
    total = User.count
    processed = 0
    batch_num = 0
    
    User.find_each(batch_size: 1000) do |user|
      process_user(user)
      processed += 1
      
      # Force garbage collection every 10,000 records
      if processed % 10000 == 0
        batch_num += 1
        GC.start
        
        memory_mb = `ps -o rss= -p #{Process.pid}`.to_i / 1024
        Rails.logger.info(
          &quot;Processed #{processed}/#{total} users &quot; \
          &quot;(#{(processed.to_f / total * 100).round(1)}%), &quot; \
          &quot;Memory: #{memory_mb}MB&quot;
        )
        
        # Pause if memory too high
        if memory_mb &gt; 1500
          Rails.logger.warn(&quot;High memory usage, pausing...&quot;)
          sleep 5
          GC.start
        end
      end
    end
  end
  
  private
  
  def process_user(user)
    # Your processing logic
    user.calculate_stats
    user.save
  end
end
</code></pre>
<hr>
<h3>Solution 6: Parallel Processing with Sidekiq</h3>
<pre><code class="language-ruby"># Split large dataset across multiple jobs

class ProcessUsersInParallelJob &lt; ApplicationJob
  def perform
    total_users = User.count
    batch_size = 10000
    num_batches = (total_users / batch_size.to_f).ceil
    
    num_batches.times do |batch_num|
      offset = batch_num * batch_size
      
      ProcessUserBatchJob.perform_later(offset, batch_size)
    end
  end
end

class ProcessUserBatchJob &lt; ApplicationJob
  def perform(offset, limit)
    User.offset(offset).limit(limit).find_each do |user|
      process_user(user)
    end
  end
  
  private
  
  def process_user(user)
    # Your logic
  end
end

# Processes 10,000 users per job in parallel
# With 10 Sidekiq workers, can process 100,000 users simultaneously
</code></pre>
<hr>
<h3>Solution 7: Database Cursor (PostgreSQL)</h3>
<pre><code class="language-ruby"># Use server-side cursor for very large results

class User &lt; ApplicationRecord
  def self.each_with_cursor(batch_size: 1000)
    connection.execute(&quot;DECLARE user_cursor CURSOR FOR SELECT * FROM users&quot;)
    
    loop do
      result = connection.execute(&quot;FETCH #{batch_size} FROM user_cursor&quot;)
      break if result.ntuples.zero?
      
      result.each do |row|
        yield new(row)
      end
    end
  ensure
    connection.execute(&quot;CLOSE user_cursor&quot;)
  end
end

# Usage
User.each_with_cursor(batch_size: 5000) do |user|
  process(user)
end

# Benefits:
# - Holds cursor on database side
# - Fetches only what&#39;s needed
# - Efficient for one-time processing
</code></pre>
<hr>
<h3>Solution 8: Pagination with ETags</h3>
<pre><code class="language-ruby"># Efficient pagination for APIs with caching

class Api::UsersController &lt; ApplicationController
  def index
    page = params[:page] || 1
    per_page = [params[:per_page].to_i, 100].min
    
    @users = User.page(page).per(per_page)
    
    # Use ETag for caching
    fresh_when(
      etag: [@users, page, per_page],
      last_modified: @users.maximum(:updated_at),
      public: true
    )
  end
end

# Client can cache pages
# 304 Not Modified if data hasn&#39;t changed
</code></pre>
<hr>
<h3>Performance Comparison</h3>
<pre><code class="language-ruby"># Comparison of different approaches for 1M records:

# Method 1: Load all into memory
# Memory: 3GB
# Time: 120 seconds
# Result: Crashes ❌

# Method 2: find_each + save to file
# Memory: 50MB
# Time: 60 seconds  
# Result: Success, but blocks request ⚠️

# Method 3: Streaming response
# Memory: 50MB
# Time to first byte: 100ms
# Total time: 60 seconds
# Result: User sees progress immediately ✓

# Method 4: Background job
# Memory: 50MB
# Time: 60 seconds (async)
# Result: Immediate response, email when done ✓✓

# Method 5: Parallel processing
# Memory: 200MB (4 workers)
# Time: 15 seconds
# Result: 4x faster ✓✓✓
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Never</strong> load all records into memory</li>
<li><strong>Stream</strong> responses for immediate feedback</li>
<li><strong>Background jobs</strong> for large exports</li>
<li><strong>Track progress</strong> for user experience</li>
<li><strong>Batch processing</strong> with find_each</li>
<li><strong>Memory management</strong> with garbage collection</li>
<li><strong>Parallel processing</strong> for speed</li>
<li><strong>Chunked downloads</strong> for large files</li>
<li><strong>Server-side cursors</strong> for one-time processing</li>
<li><strong>Cache</strong> paginated results with ETags</li>
</ol>
<hr>
<h2>Question 318: Explain Connection Pooling in ActiveRecord and its importance</h2>
<h3>Answer</h3>
<p><strong>Connection Pooling</strong> maintains a pool of reusable database connections shared across threads. Instead of opening/closing connections for each query, threads check out connections from the pool, use them, and return them, dramatically improving performance and resource usage.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Connection pool</strong>: Reusable database connections</li>
<li><strong>Pool size</strong>: Should match max threads per worker</li>
<li><strong>Checkout/checkin</strong>: Threads borrow and return connections</li>
<li><strong>Timeout</strong>: Wait time if no connections available</li>
<li><strong>Benefits</strong>: Faster queries, fewer connections, better resource usage</li>
<li><strong>Monitoring</strong>: Track pool usage and connection leaks</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<p><strong>The Problem Without Pooling:</strong></p>
<pre><code class="language-ruby"># WITHOUT CONNECTION POOLING:

# Request 1:
# 1. Open database connection (100ms)
# 2. Execute query (50ms)
# 3. Close connection (20ms)
# Total: 170ms

# Request 2:
# 1. Open database connection (100ms)
# 2. Execute query (50ms)
# 3. Close connection (20ms)
# Total: 170ms

# 1000 requests:
# - Opens 1000 connections
# - Connection overhead: 120ms × 1000 = 120 seconds wasted!
# - Database: Overwhelmed with connection handling
</code></pre>
<p><strong>WITH CONNECTION POOLING:</strong></p>
<pre><code class="language-ruby"># WITH CONNECTION POOLING:

# Initial setup:
# Create pool of 5 connections (one-time cost)

# Request 1:
# 1. Checkout connection from pool (1ms)
# 2. Execute query (50ms)
# 3. Return connection to pool (1ms)
# Total: 52ms ✓ (3x faster!)

# Request 2:
# 1. Checkout connection (reuses existing) (1ms)
# 2. Execute query (50ms)
# 3. Return connection (1ms)
# Total: 52ms ✓

# 1000 requests with 5 connections:
# - Reuses same 5 connections
# - Connection overhead: ~1ms per request
# - Database: Handles only 5 connections
</code></pre>
<hr>
<h3>How Connection Pooling Works</h3>
<pre><code class="language-ruby"># config/database.yml
production:
  adapter: postgresql
  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;
  timeout: 5000  # milliseconds
  database: myapp_production

# Connection Pool Lifecycle:

# 1. APPLICATION STARTS
# =====================
# Rails creates connection pool:
# Pool size: 5
# Creates 5 database connections (lazy)
# Ready to serve threads

# 2. REQUEST ARRIVES (Thread 1)
# ==============================
thread1_start:
  connection = ActiveRecord::Base.connection_pool.checkout
  # Checks out connection #1 from pool
  # Pool: [-, conn2, conn3, conn4, conn5]
  
  User.find(1)  # Uses connection #1
  Post.where(published: true)  # Same connection
  
  ActiveRecord::Base.connection_pool.checkin(connection)
  # Returns connection #1 to pool
  # Pool: [conn1, conn2, conn3, conn4, conn5]

# 3. CONCURRENT REQUESTS (5 threads)
# ===================================
# Thread 1: checks out conn1
# Thread 2: checks out conn2  
# Thread 3: checks out conn3
# Thread 4: checks out conn4
# Thread 5: checks out conn5
# Pool: [-, -, -, -, -] (all connections in use)

# Thread 6 arrives:
# - Pool is empty
# - Waits for connection (timeout: 5 seconds)
# - If no connection available: raises ConnectionTimeoutError

# 4. AUTOMATIC MANAGEMENT
# =======================
# Rails automatically handles checkout/checkin
# You rarely need to do it manually

def index
  # Connection automatically checked out
  @users = User.all
  @posts = Post.all
  # Connection automatically returned after action
end
</code></pre>
<hr>
<h3>Configuration</h3>
<pre><code class="language-ruby"># ============================================
# BASIC CONFIGURATION
# ============================================

# config/database.yml
production:
  adapter: postgresql
  encoding: unicode
  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;
  timeout: 5000
  
  # Database connection settings
  host: &lt;%= ENV[&#39;DATABASE_HOST&#39;] %&gt;
  database: myapp_production
  username: &lt;%= ENV[&#39;DATABASE_USERNAME&#39;] %&gt;
  password: &lt;%= ENV[&#39;DATABASE_PASSWORD&#39;] %&gt;

# Rule: pool size &gt;= max threads per worker
# 
# Puma config: 4 workers × 5 threads = 20 threads
# Database pool: 5 per worker = 20 total connections
# Perfect match ✓

# ============================================
# POOL SIZE CALCULATION
# ============================================

# Example 1: Small app
# config/puma.rb
workers 2
threads 3, 5

# config/database.yml
pool: 5  # Matches max threads

# Total connections: 2 workers × 5 = 10 connections

# Example 2: Large app
# config/puma.rb
workers 8
threads 8, 12

# config/database.yml
pool: 12  # Matches max threads

# Total connections: 8 workers × 12 = 96 connections

# Check database connection limit:
# PostgreSQL default: 100 connections
# Your app: 96 connections
# Remaining: 4 for admin/migrations
# Status: OK ✓

# ============================================
# TIMEOUT CONFIGURATION
# ============================================

# Timeout: How long to wait for connection

# config/database.yml
production:
  pool: 5
  timeout: 5000  # 5 seconds (default)

# Timeout scenarios:

# Scenario 1: Low timeout (1 second)
timeout: 1000
# Pros: Fails fast
# Cons: May timeout under normal load

# Scenario 2: High timeout (30 seconds)  
timeout: 30000
# Pros: More patient
# Cons: Requests queue up, slow user experience

# Recommended: 5-10 seconds
timeout: 5000  # Balanced
</code></pre>
<hr>
<h3>Monitoring Connection Pool</h3>
<pre><code class="language-ruby"># ============================================
# CHECK POOL STATUS
# ============================================

# In Rails console or code:
pool = ActiveRecord::Base.connection_pool

pool.size          # =&gt; 5 (total connections)
pool.connections.size  # =&gt; 3 (active connections)
pool.available_connections  # =&gt; 2 (idle connections)

# Detailed stats
stats = pool.stat
# =&gt; {
#   size: 5,           # Pool size
#   connections: 3,    # Active connections
#   busy: 2,           # Connections in use
#   dead: 0,           # Dead connections
#   idle: 1,           # Idle connections
#   waiting: 0,        # Threads waiting
#   checkout_timeout: 5  # Timeout in seconds
# }

# ============================================
# LOG CONNECTION CHECKOUTS
# ============================================

# config/initializers/connection_pool_logger.rb
ActiveSupport::Notifications.subscribe(&#39;checkout.active_record&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  
  if event.duration &gt; 100  # Slow checkout (&gt;100ms means pool exhausted)
    Rails.logger.warn({
      event: &#39;slow_connection_checkout&#39;,
      duration_ms: event.duration.round(2),
      thread_id: Thread.current.object_id
    }.to_json)
  end
end

# ============================================
# DETECT CONNECTION LEAKS
# ============================================

# Connection leak: Thread checks out but never returns

class ApplicationController &lt; ActionController::Base
  around_action :monitor_connection_pool
  
  private
  
  def monitor_connection_pool
    pool = ActiveRecord::Base.connection_pool
    before_busy = pool.stat[:busy]
    
    yield
    
    after_busy = pool.stat[:busy]
    
    if after_busy &gt; before_busy
      Rails.logger.error(&quot;Connection leak detected! Busy connections increased.&quot;)
    end
  end
end

# ============================================
# EXPOSE METRICS
# ============================================

# Prometheus metrics
class MetricsController &lt; ApplicationController
  def index
    pool = ActiveRecord::Base.connection_pool
    stats = pool.stat
    
    metrics = &lt;&lt;~METRICS
      # HELP active_record_connection_pool_size Total connection pool size
      # TYPE active_record_connection_pool_size gauge
      active_record_connection_pool_size #{stats[:size]}
      
      # HELP active_record_connection_pool_connections Active connections
      # TYPE active_record_connection_pool_connections gauge
      active_record_connection_pool_connections #{stats[:connections]}
      
      # HELP active_record_connection_pool_busy Busy connections
      # TYPE active_record_connection_pool_busy gauge
      active_record_connection_pool_busy #{stats[:busy]}
      
      # HELP active_record_connection_pool_waiting Waiting threads
      # TYPE active_record_connection_pool_waiting gauge
      active_record_connection_pool_waiting #{stats[:waiting]}
    METRICS
    
    render plain: metrics
  end
end

# Monitor with Grafana:
# - Pool utilization (busy / size)
# - Waiting threads (should be 0)
# - Connection checkout time
</code></pre>
<hr>
<h3>PgBouncer for External Connection Pooling</h3>
<pre><code class="language-ruby"># Problem: Many Rails servers = many connections

# Without PgBouncer:
# 10 Rails servers × 5 threads × 5 pool = 250 database connections
# PostgreSQL limit: 100 connections
# Result: Connection limit exceeded! ❌

# With PgBouncer:
# 10 Rails servers × 5 threads × 5 pool = 250 logical connections
# PgBouncer pools to 50 physical connections
# PostgreSQL: Only sees 50 connections ✓

# Install PgBouncer
# apt-get install pgbouncer

# /etc/pgbouncer/pgbouncer.ini
[databases]
myapp_production = host=actual-database.amazonaws.com port=5432 dbname=myapp_production

[pgbouncer]
listen_addr = 0.0.0.0
listen_port = 6432
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt

# Pooling mode
pool_mode = transaction  # Best for Rails

# Connection limits
max_client_conn = 1000   # Accept many clients
default_pool_size = 50   # But only use 50 to database
reserve_pool_size = 10   # Emergency reserve
reserve_pool_timeout = 3

# Timeouts
server_idle_timeout = 600
server_lifetime = 3600

# Rails configuration with PgBouncer
# config/database.yml
production:
  adapter: postgresql
  host: pgbouncer-host.com
  port: 6432  # PgBouncer port (not 5432!)
  pool: 5
  database: myapp_production

# Benefits:
# - 250 → 50 connections (5x reduction)
# - Database less stressed
# - Can handle more Rails servers
# - Faster connection acquisition
</code></pre>
<hr>
<h3>Connection Pool Issues</h3>
<pre><code class="language-ruby"># ============================================
# ISSUE 1: Pool Exhaustion
# ============================================

# Symptoms:
# - ActiveRecord::ConnectionTimeoutError
# - Slow response times
# - Users getting errors

# Causes:
# 1. Pool size &lt; thread count
# 2. Long-running queries
# 3. Connection leaks
# 4. Blocking operations while holding connection

# Solutions:

# Solution 1: Increase pool size
# config/database.yml
pool: 10  # Was 5, now 10

# Solution 2: Optimize long-running queries
# Add indexes, use batching

# Solution 3: Release connection during external calls
def fetch_from_api
  # Don&#39;t hold database connection during API call
  user_id = current_user.id  # Quick query
  
  ActiveRecord::Base.connection_pool.with_connection do
    # Manually manage connection
  end
  
  # Or simply close connection
  ActiveRecord::Base.connection_pool.release_connection
  
  # Make external API call (doesn&#39;t need database)
  response = HTTParty.get(&#39;https://api.example.com/data&#39;)
  
  # Reconnect when needed
  User.find(user_id)  # Auto-reconnects
end

# ============================================
# ISSUE 2: Connection Leaks
# ============================================

# Leak example:
Thread.new do
  # Checkout connection
  connection = ActiveRecord::Base.connection
  
  # Do work...
  User.all.each { |u| process(u) }
  
  # OOPS: Never returned connection!
  # Connection stays checked out forever
end

# Fix: Always return connection
Thread.new do
  ActiveRecord::Base.connection_pool.with_connection do
    User.all.each { |u| process(u) }
  end
  # Automatically returned
end

# ============================================
# ISSUE 3: Database Connection Limit
# ============================================

# Check PostgreSQL connection limit:
# psql&gt; SHOW max_connections;
# =&gt; 100

# Check current connections:
# psql&gt; SELECT count(*) FROM pg_stat_activity;
# =&gt; 95  # Dangerously close!

# Solutions:

# 1. Increase database limit
# postgresql.conf
max_connections = 200
# Restart PostgreSQL

# 2. Use PgBouncer

# 3. Reduce pool size per worker
pool: 3  # Was 5

# 4. Reduce number of workers
workers: 6  # Was 8
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Connection pooling</strong> reuses database connections (3x faster)</li>
<li><strong>Pool size</strong> must match max threads per worker</li>
<li><strong>Timeout</strong> determines wait time for connection (default 5s)</li>
<li><strong>Monitor</strong> pool utilization and waiting threads</li>
<li><strong>PgBouncer</strong> pools connections across multiple servers</li>
<li><strong>Connection leaks</strong> occur when connections not returned</li>
<li><strong>Pool exhaustion</strong> causes timeout errors</li>
<li><strong>Calculate total</strong>: workers × threads = total connections</li>
<li><strong>Database limit</strong>: Check PostgreSQL max_connections</li>
<li><strong>Release connections</strong> during external API calls</li>
</ol>
<hr>
<h2>Question 319: How do you fetch records in batches using ActiveRecord?</h2>
<h3>Answer</h3>
<p>Fetch records in batches using <strong>find_each</strong> (yields individual records), <strong>find_in_batches</strong> (yields arrays), or <strong>in_batches</strong> (yields relations). These methods prevent loading millions of records into memory by processing in smaller chunks.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>find_each</strong>: Yields individual records, batch size 1000 (default)</li>
<li><strong>find_in_batches</strong>: Yields arrays of records</li>
<li><strong>in_batches</strong>: Yields Active Record relations (most flexible)</li>
<li><strong>batch_size</strong>: Configure chunk size (default 1000)</li>
<li><strong>start/finish</strong>: Process specific ID ranges</li>
<li><strong>Use for</strong>: Processing large datasets without memory issues</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<pre><code class="language-ruby"># ============================================
# METHOD 1: find_each (Most Common)
# ============================================

# Yields individual records one at a time

# ❌ BAD: Loads all into memory
User.all.each do |user|
  user.send_email
end
# SQL: SELECT * FROM users
# Memory: Loads ALL users (could be GBs)

# ✅ GOOD: Processes in batches
User.find_each do |user|
  user.send_email
end
# SQL: 
# SELECT * FROM users ORDER BY id LIMIT 1000
# SELECT * FROM users WHERE id &gt; 1000 ORDER BY id LIMIT 1000
# SELECT * FROM users WHERE id &gt; 2000 ORDER BY id LIMIT 1000
# ...
# Memory: Only 1000 users at a time

# How find_each works:
# 1. Fetches first 1000 records (ORDER BY id)
# 2. Yields each record individually
# 3. Fetches next 1000 records (WHERE id &gt; 1000)
# 4. Repeats until no more records

# Custom batch size
User.find_each(batch_size: 5000) do |user|
  user.send_email
end
# Larger batches = fewer queries, more memory

# Start from specific ID
User.find_each(start: 10000) do |user|
  user.send_email
end
# Useful for resuming interrupted jobs

# Process ID range
User.find_each(start: 1000, finish: 5000) do |user|
  user.send_email
end
# Only processes users with IDs 1000-5000

# With conditions
User.where(active: true)
    .where(&#39;created_at &gt; ?&#39;, 1.month.ago)
    .find_each do |user|
  user.send_email
end

# Error handling
User.find_each do |user|
  begin
    user.send_email
  rescue =&gt; e
    Rails.logger.error(&quot;Failed to send email to user #{user.id}: #{e.message}&quot;)
    # Continue with next user
  end
end

# ============================================
# METHOD 2: find_in_batches
# ============================================

# Yields arrays of records (batches)

User.find_in_batches(batch_size: 1000) do |users|
  # users is an array of 1000 User objects
  puts &quot;Processing batch of #{users.size} users&quot;
  
  users.each do |user|
    user.send_email
  end
end

# Why use find_in_batches?
# - Bulk operations on batches
# - Custom batch processing logic
# - Performance metrics per batch

# Example: Bulk insert to another table
User.find_in_batches(batch_size: 5000) do |users|
  analytics_data = users.map do |user|
    {
      user_id: user.id,
      name: user.name,
      created_at: user.created_at
    }
  end
  
  # Bulk insert (fast!)
  UserAnalytics.insert_all(analytics_data)
end

# Example: Batch API calls
User.find_in_batches(batch_size: 100) do |users|
  # Send 100 users to API in one request
  user_ids = users.map(&amp;:id)
  ThirdPartyApi.sync_users(user_ids)
  
  sleep 1  # Rate limiting
end

# ============================================
# METHOD 3: in_batches (Most Flexible)
# ============================================

# Yields ActiveRecord::Relation objects

User.in_batches(of: 1000) do |relation|
  # relation is an ActiveRecord::Relation, not an array
  # Can chain more queries on it
  
  relation.update_all(processed: true)
end

# Why use in_batches?
# - Most flexible (work with relations)
# - Can use update_all, delete_all (faster)
# - Can add more conditions

# Example: Conditional batch updates
User.in_batches(of: 1000) do |relation|
  relation.where(&#39;last_login_at &lt; ?&#39;, 1.year.ago)
          .update_all(status: &#39;inactive&#39;)
end

# Example: Batch delete old records
Post.where(&#39;created_at &lt; ?&#39;, 2.years.ago)
    .in_batches(of: 10000) do |relation|
  deleted_count = relation.delete_all
  puts &quot;Deleted #{deleted_count} posts&quot;
end

# Example: Complex batch processing
Order.where(status: &#39;pending&#39;)
     .in_batches(of: 5000) do |relation|
  # Count records in batch
  count = relation.count
  
  # Process expired orders
  expired = relation.where(&#39;created_at &lt; ?&#39;, 1.hour.ago)
  expired.update_all(status: &#39;expired&#39;)
  
  # Send reminders for active orders
  active = relation.where(&#39;created_at &gt;= ?&#39;, 1.hour.ago)
  active.find_each do |order|
    OrderMailer.reminder(order).deliver_later
  end
  
  puts &quot;Processed #{count} orders&quot;
end

# Load records to manipulate them
User.in_batches(of: 1000) do |relation|
  relation.load.each do |user|
    # user is loaded ActiveRecord object
    user.complex_calculation
    user.save
  end
end

# ============================================
# COMPARISON: find_each vs find_in_batches vs in_batches
# ============================================

# Task: Update 1,000,000 users

# Approach 1: find_each
start = Time.current
User.find_each(batch_size: 1000) do |user|
  user.update(processed: true)
end
duration = Time.current - start
# Time: 120 seconds
# Why slow: 1,000,000 individual UPDATE queries

# Approach 2: find_in_batches  
start = Time.current
User.find_in_batches(batch_size: 1000) do |users|
  user_ids = users.map(&amp;:id)
  User.where(id: user_ids).update_all(processed: true)
end
duration = Time.current - start
# Time: 30 seconds (4x faster)
# Why faster: 1,000 batch UPDATE queries

# Approach 3: in_batches (FASTEST)
start = Time.current
User.in_batches(of: 10000) do |relation|
  relation.update_all(processed: true)
end
duration = Time.current - start
# Time: 10 seconds (12x faster!)
# Why fastest: 100 batch UPDATE queries, no object instantiation

# ============================================
# ADVANCED: Custom Batch Processing
# ============================================

# Batch with progress tracking
total = User.count
processed = 0
batch_num = 0

User.find_in_batches(batch_size: 1000) do |users|
  batch_num += 1
  
  users.each do |user|
    process_user(user)
    processed += 1
  end
  
  progress = (processed.to_f / total * 100).round(2)
  puts &quot;Batch #{batch_num}: #{processed}/#{total} (#{progress}%)&quot;
  
  # Force garbage collection every 10 batches
  GC.start if batch_num % 10 == 0
end

# Batch with retry logic
User.find_in_batches(batch_size: 1000) do |users|
  retries = 0
  begin
    users.each { |user| sync_to_api(user) }
  rescue ApiError =&gt; e
    retries += 1
    if retries &lt; 3
      sleep 2 ** retries  # Exponential backoff
      retry
    else
      Rails.logger.error(&quot;Batch failed after 3 retries: #{e.message}&quot;)
      # Save failed user IDs for manual processing
      FailedSync.create!(user_ids: users.map(&amp;:id), error: e.message)
    end
  end
end

# Parallel batch processing with Sidekiq
total_users = User.count
batch_size = 10000
num_batches = (total_users / batch_size.to_f).ceil

num_batches.times do |batch_num|
  offset = batch_num * batch_size
  ProcessUserBatchJob.perform_later(offset, batch_size)
end

class ProcessUserBatchJob &lt; ApplicationJob
  def perform(offset, limit)
    User.offset(offset).limit(limit).find_each do |user|
      process_user(user)
    end
  end
end

# ============================================
# PERFORMANCE OPTIMIZATION
# ============================================

# Optimize batch size based on memory

# Small records (users table: id, name, email)
# Batch size: 5000-10000
User.find_each(batch_size: 10000) do |user|
  # Fast, low memory
end

# Large records (documents table with JSONB, text fields)
# Batch size: 100-500
Document.find_each(batch_size: 500) do |doc|
  # Slower queries, more memory per record
end

# Rule of thumb:
# batch_size × average_record_size &lt; 50MB

# Monitor memory usage
def process_with_memory_monitoring(batch_size: 1000)
  initial_memory = `ps -o rss= -p #{Process.pid}`.to_i / 1024
  
  User.find_each(batch_size: batch_size) do |user|
    process_user(user)
    
    current_memory = `ps -o rss= -p #{Process.pid}`.to_i / 1024
    memory_increase = current_memory - initial_memory
    
    if memory_increase &gt; 500  # 500MB increase
      Rails.logger.warn(&quot;High memory usage: #{current_memory}MB&quot;)
      GC.start
    end
  end
end

# ============================================
# EDGE CASES AND GOTCHAS
# ============================================

# Gotcha 1: Ordering is enforced
User.order(:name).find_each do |user|
  # Ignores order(:name)
  # Always orders by primary key (id)
end

# Gotcha 2: Can&#39;t use with limit/offset
User.limit(100).find_each do |user|
  # Raises ArgumentError
  # Limit doesn&#39;t make sense with batching
end

# Gotcha 3: Requires primary key
# find_each relies on id for batching
# Non-standard primary keys need special handling

# Gotcha 4: Transaction scope
ActiveRecord::Base.transaction do
  User.find_each do |user|
    user.update(processed: true)
  end
  # Each batch is actually a separate query
  # Not truly transactional across all batches
end

# Gotcha 5: Record updates during batching
# If records are updated during iteration,
# you might miss records or process duplicates

# Safer: Use immutable ID list
user_ids = User.pluck(:id)  # Snapshot of IDs
user_ids.each_slice(1000) do |batch_ids|
  User.where(id: batch_ids).find_each do |user|
    process_user(user)
  end
end
</code></pre>
<hr>
<h3>Real-World Examples</h3>
<pre><code class="language-ruby"># ============================================
# EXAMPLE 1: Send Mass Email
# ============================================

class SendNewsletterJob &lt; ApplicationJob
  def perform(newsletter_id)
    newsletter = Newsletter.find(newsletter_id)
    total = User.where(subscribed: true).count
    sent = 0
    
    User.where(subscribed: true)
        .find_each(batch_size: 100) do |user|
      
      UserMailer.newsletter(user, newsletter).deliver_later
      sent += 1
      
      # Update progress every 100 users
      if sent % 100 == 0
        progress = (sent.to_f / total * 100).round(1)
        newsletter.update_column(:progress, progress)
      end
      
      # Rate limiting (100 emails/minute)
      sleep 0.6 if sent % 100 == 0
    end
    
    newsletter.update(status: &#39;sent&#39;, sent_at: Time.current)
  end
end

# ============================================
# EXAMPLE 2: Data Migration
# ============================================

class MigrateUserData &lt; ActiveRecord::Migration[7.0]
  def up
    say_with_time &quot;Migrating user data&quot; do
      total = User.count
      processed = 0
      
      User.in_batches(of: 5000) do |relation|
        relation.update_all(
          &quot;new_column = CONCAT(first_name, &#39; &#39;, last_name)&quot;
        )
        
        processed += relation.size
        say &quot;#{processed}/#{total} processed&quot;, true
      end
    end
  end
end

# ============================================
# EXAMPLE 3: Clean Up Old Data
# ============================================

class CleanupOldRecordsJob &lt; ApplicationJob
  def perform
    cutoff_date = 2.years.ago
    
    # Delete old posts
    Post.where(&#39;created_at &lt; ?&#39;, cutoff_date)
        .in_batches(of: 10000) do |relation|
      count = relation.delete_all
      Rails.logger.info(&quot;Deleted #{count} posts&quot;)
      sleep 1  # Don&#39;t overwhelm database
    end
    
    # Archive old orders
    Order.where(&#39;created_at &lt; ?&#39;, cutoff_date)
         .find_in_batches(batch_size: 5000) do |orders|
      # Copy to archive
      archive_data = orders.map do |order|
        order.attributes.except(&#39;id&#39;)
      end
      OrderArchive.insert_all(archive_data)
      
      # Delete from main table
      order_ids = orders.map(&amp;:id)
      Order.where(id: order_ids).delete_all
    end
  end
end

# ============================================
# EXAMPLE 4: Calculate Statistics
# ============================================

class CalculateUserStatsJob &lt; ApplicationJob
  def perform
    stats = {
      total_users: 0,
      active_users: 0,
      revenue_by_country: Hash.new(0)
    }
    
    User.find_in_batches(batch_size: 10000) do |users|
      stats[:total_users] += users.size
      stats[:active_users] += users.count(&amp;:active?)
      
      users.group_by(&amp;:country).each do |country, country_users|
        revenue = country_users.sum { |u| u.total_revenue }
        stats[:revenue_by_country][country] += revenue
      end
    end
    
    Redis.current.set(&#39;user_stats&#39;, stats.to_json, ex: 1.hour)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>find_each</strong>: Yields individual records (most common)</li>
<li><strong>find_in_batches</strong>: Yields arrays of records</li>
<li><strong>in_batches</strong>: Yields relations (most flexible, fastest)</li>
<li><strong>Default batch size</strong>: 1000 records</li>
<li><strong>Memory efficient</strong>: Doesn&#39;t load all records</li>
<li><strong>Always ordered by id</strong>: Can&#39;t use custom order</li>
<li><strong>No limit/offset</strong>: Incompatible with batching</li>
<li><strong>Start/finish options</strong>: Process ID ranges</li>
<li><strong>in_batches is fastest</strong>: For bulk updates (use update_all)</li>
<li><strong>Monitor memory</strong>: Adjust batch_size based on record size</li>
</ol>
<hr>
<h2>Question 320: How do you implement Full-Text Search using Elasticsearch?</h2>
<h3>Answer</h3>
<p>Implement Elasticsearch full-text search using <strong>Searchkick gem</strong>, which provides easy integration with Rails models, powerful search queries, relevance scoring, faceted search, autocomplete, and near-real-time indexing.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Searchkick gem</strong>: Easiest way to integrate Elasticsearch with Rails</li>
<li><strong>Index models</strong>: Add <code>searchkick</code> to model, define searchable fields</li>
<li><strong>Search queries</strong>: <code>Model.search(&quot;query&quot;)</code> with filters, facets</li>
<li><strong>Reindexing</strong>: <code>Model.reindex</code> to sync data</li>
<li><strong>Autocomplete</strong>: Built-in suggestions and autocomplete</li>
<li><strong>Production</strong>: Elasticsearch cluster, index management, monitoring</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# STEP 1: Installation and Setup
# ============================================

# Install Elasticsearch
# macOS: brew install elasticsearch
# Ubuntu: apt-get install elasticsearch
# Docker: docker run -p 9200:9200 elasticsearch:8.x

# Add to Gemfile
gem &#39;searchkick&#39;

# Install
bundle install

# Configure
# config/initializers/searchkick.rb
Searchkick.client = Elasticsearch::Client.new(
  url: ENV[&#39;ELASTICSEARCH_URL&#39;] || &#39;http://localhost:9200&#39;,
  transport_options: {request: {timeout: 30}}
)

# ============================================
# STEP 2: Make Models Searchable
# ============================================

# app/models/product.rb
class Product &lt; ApplicationRecord
  # Enable searchkick
  searchkick word_start: [:name],  # Autocomplete on name
             highlight: [:name, :description],  # Highlighting
             searchable: [:name, :description, :tags],  # Searchable fields
             filterable: [:category, :price, :in_stock]  # Filterable fields
  
  # Define search data (what gets indexed)
  def search_data
    {
      name: name,
      description: description,
      tags: tags,
      category: category,
      price: price,
      in_stock: in_stock,
      created_at: created_at,
      # Computed fields
      popularity: views_count + purchases_count,
      rating_avg: reviews.average(:rating)
    }
  end
  
  # Index data after changes
  # Automatically indexed on create/update/destroy
end

# Create index
Product.reindex

# ============================================
# STEP 3: Basic Search Queries
# ============================================

# Simple search
products = Product.search(&quot;laptop&quot;)
# Returns ActiveRecord-like relation

# Search with pagination
products = Product.search(&quot;laptop&quot;, page: 1, per_page: 20)

# Search specific fields
products = Product.search(
  &quot;gaming&quot;,
  fields: [:name, :description],
  match: :word_start  # Prefix matching
)

# Search with filters
products = Product.search(
  &quot;laptop&quot;,
  where: {
    category: &quot;Electronics&quot;,
    in_stock: true,
    price: {gte: 500, lte: 2000}  # Greater/less than
  }
)

# Multiple conditions
products = Product.search(
  &quot;laptop&quot;,
  where: {
    category: [&quot;Electronics&quot;, &quot;Computers&quot;],  # IN query
    in_stock: true
  },
  where_not: {
    brand: &quot;BrandX&quot;  # Exclude
  }
)

# Search with ordering
products = Product.search(
  &quot;laptop&quot;,
  order: {price: :asc}  # Sort by price ascending
)

# Search by location (geo search)
products = Product.search(
  &quot;*&quot;,  # All products
  where: {
    location: {near: {lat: 37.7749, lon: -122.4194}, within: &quot;10mi&quot;}
  }
)

# ============================================
# STEP 4: Advanced Search Features
# ============================================

# Faceted search (aggregations)
results = Product.search(
  &quot;laptop&quot;,
  aggs: {
    category: {},  # Count by category
    price_ranges: {
      ranges: [
        {to: 500},
        {from: 500, to: 1000},
        {from: 1000, to: 2000},
        {from: 2000}
      ]
    },
    brands: {limit: 10}  # Top 10 brands
  }
)

# Access facets
results.aggs[&quot;category&quot;]
# =&gt; {&quot;Electronics&quot; =&gt; 45, &quot;Computers&quot; =&gt; 23, ...}

results.aggs[&quot;price_ranges&quot;][&quot;buckets&quot;]
# =&gt; [
#   {key: &quot;*-500&quot;, doc_count: 12},
#   {key: &quot;500-1000&quot;, doc_count: 45},
#   ...
# ]

# Autocomplete
products = Product.search(
  &quot;lap&quot;,
  fields: [:name],
  match: :word_start,
  limit: 10,
  load: false  # Don&#39;t load records, just get data
)

# suggestions = products.map(&amp;:name)
# =&gt; [&quot;Laptop&quot;, &quot;Laptop Bag&quot;, &quot;Lap Desk&quot;, ...]

# Highlighting (show matched text)
results = Product.search(
  &quot;gaming laptop&quot;,
  highlight: {tag: &quot;&lt;mark&gt;&quot;}  # Wrap matches in &lt;mark&gt;
)

results.with_highlights.each do |product, highlights|
  puts highlights[:name]  # &quot;&lt;mark&gt;Gaming&lt;/mark&gt; &lt;mark&gt;Laptop&lt;/mark&gt;&quot;
end

# Fuzzy search (typo tolerance)
products = Product.search(
  &quot;laptp&quot;,  # Typo
  misspellings: {edit_distance: 2}  # Allow 2 character differences
)
# Finds &quot;laptop&quot;

# Synonyms
class Product &lt; ApplicationRecord
  searchkick synonyms: [
    [&quot;laptop&quot;, &quot;notebook&quot;],
    [&quot;phone&quot;, &quot;mobile&quot;, &quot;cell&quot;]
  ]
end

Product.search(&quot;notebook&quot;)  # Also finds &quot;laptop&quot;

# Boosting (relevance tuning)
products = Product.search(
  &quot;laptop&quot;,
  fields: [
    {name: :boost =&gt; 3},  # Name matches 3x more important
    {description: :boost =&gt; 1}
  ]
)

# More like this
similar = Product.search(
  &quot;*&quot;,
  similar: true,
  fields: [:name, :description],
  like: product.search_data
)

# ============================================
# STEP 5: Controller Implementation
# ============================================

class ProductsController &lt; ApplicationController
  def index
    @products = Product.search(
      params[:query] || &quot;*&quot;,
      page: params[:page] || 1,
      per_page: 20,
      where: search_filters,
      aggs: search_aggregations,
      order: search_order
    )
    
    @facets = @products.aggs
  end
  
  private
  
  def search_filters
    filters = {}
    
    filters[:category] = params[:category] if params[:category].present?
    filters[:in_stock] = true if params[:in_stock] == &quot;1&quot;
    
    if params[:min_price].present? || params[:max_price].present?
      filters[:price] = {}
      filters[:price][:gte] = params[:min_price].to_f if params[:min_price].present?
      filters[:price][:lte] = params[:max_price].to_f if params[:max_price].present?
    end
    
    filters
  end
  
  def search_aggregations
    {
      category: {},
      brands: {limit: 20},
      price_ranges: {
        ranges: [
          {to: 100},
          {from: 100, to: 500},
          {from: 500, to: 1000},
          {from: 1000}
        ]
      },
      in_stock: {}
    }
  end
  
  def search_order
    case params[:sort]
    when &#39;price_asc&#39;
      {price: :asc}
    when &#39;price_desc&#39;
      {price: :desc}
    when &#39;newest&#39;
      {created_at: :desc}
    else
      {_score: :desc}  # Relevance
    end
  end
end

# ============================================
# STEP 6: Reindexing Strategies
# ============================================

# Manual reindex
Product.reindex

# Background reindex (recommended)
Product.reindex(async: true)

# Reindex specific records
Product.where(updated_at: 1.day.ago..).reindex

# Scheduled reindexing (daily)
class ReindexProductsJob &lt; ApplicationJob
  def perform
    Product.reindex(async: true)
  end
end

# config/schedule.rb (whenever gem)
every 1.day, at: &#39;2:00 am&#39; do
  runner &quot;ReindexProductsJob.perform_later&quot;
end

# Partial reindex (only changed records)
# Searchkick automatically reindexes on save
# For bulk updates, manually reindex:
Product.where(category: &#39;Electronics&#39;).reindex

# Zero-downtime reindexing
Product.reindex(async: {refresh_interval: &quot;30s&quot;})

# ============================================
# STEP 7: Production Configuration
# ============================================

# config/initializers/searchkick.rb
Searchkick.client = Elasticsearch::Client.new(
  hosts: ENV[&#39;ELASTICSEARCH_HOSTS&#39;].split(&#39;,&#39;),
  retry_on_failure: 3,
  transport_options: {
    request: {timeout: 30},
    ssl: {verify: false}  # If using self-signed certs
  }
)

# Index settings
class Product &lt; ApplicationRecord
  searchkick \
    word_start: [:name],
    highlight: [:name, :description],
    settings: {
      number_of_shards: 3,
      number_of_replicas: 2
    },
    index_name: &quot;products_#{Rails.env}&quot;  # Separate indexes per environment
end

# Callbacks customization
class Product &lt; ApplicationRecord
  searchkick \
    callbacks: false  # Disable automatic indexing
  
  # Custom indexing
  after_commit :reindex_async, if: :should_reindex?
  
  def reindex_async
    ReindexProductJob.perform_later(id)
  end
  
  def should_reindex?
    saved_change_to_name? || saved_change_to_description?
  end
end

# Monitoring
# app/controllers/admin/elasticsearch_controller.rb
class Admin::ElasticsearchController &lt; ApplicationController
  def health
    client = Searchkick.client
    
    health = client.cluster.health
    stats = client.cluster.stats
    
    render json: {
      status: health[&#39;status&#39;],  # green, yellow, red
      number_of_nodes: health[&#39;number_of_nodes&#39;],
      active_shards: health[&#39;active_shards&#39;],
      indices: {
        products: Product.search_index.info
      }
    }
  end
end
</code></pre>
<hr>
<h3>Performance Optimization</h3>
<pre><code class="language-ruby"># ============================================
# OPTIMIZATION 1: Eager Loading
# ============================================

# Without eager loading
results = Product.search(&quot;laptop&quot;)
results.each do |product|
  puts product.category.name  # N+1 query
end

# With eager loading
results = Product.search(&quot;laptop&quot;, includes: [:category, :brand])
results.each do |product|
  puts product.category.name  # No extra queries
end

# ============================================
# OPTIMIZATION 2: Load: false (Don&#39;t load ActiveRecord)
# ============================================

# When you only need search data
results = Product.search(&quot;laptop&quot;, load: false)
results.each do |hit|
  puts hit.name  # From Elasticsearch, not database
  puts hit.price
end

# Useful for autocomplete
suggestions = Product.search(
  &quot;lap&quot;,
  fields: [:name],
  match: :word_start,
  limit: 10,
  load: false
).map { |hit| hit.name }

# ============================================
# OPTIMIZATION 3: Caching
# ============================================

def search_products(query, filters = {})
  cache_key = &quot;search/#{query}/#{filters.to_json}&quot;
  
  Rails.cache.fetch(cache_key, expires_in: 5.minutes) do
    Product.search(query, where: filters, load: false)
           .map(&amp;:attributes)
  end
end

# ============================================
# OPTIMIZATION 4: Index Optimization
# ============================================

class Product &lt; ApplicationRecord
  searchkick \
    settings: {
      analysis: {
        analyzer: {
          searchkick_keyword: {
            type: &quot;custom&quot;,
            tokenizer: &quot;keyword&quot;,
            filter: [&quot;lowercase&quot;, &quot;asciifolding&quot;]
          }
        }
      }
    }
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Searchkick gem</strong>: Easiest Elasticsearch integration for Rails</li>
<li><strong>searchkick method</strong>: Makes models searchable</li>
<li><strong>search_data</strong>: Defines what gets indexed</li>
<li><strong>Faceted search</strong>: Aggregations for filters</li>
<li><strong>Autocomplete</strong>: word_start matching</li>
<li><strong>Fuzzy search</strong>: Typo tolerance</li>
<li><strong>Reindexing</strong>: async reindexing in production</li>
<li><strong>load: false</strong>: Faster when ActiveRecord not needed</li>
<li><strong>Monitoring</strong>: Check cluster health</li>
<li><strong>Production</strong>: Multiple shards, replicas, monitoring</li>
</ol>
<hr>
<h2>Question 321: How do you implement full-text search in SQL (PostgreSQL, MySQL)?</h2>
<h3>Answer</h3>
<p>Implement SQL full-text search using <strong>PostgreSQL&#39;s tsvector/tsquery</strong> (best), <strong>PostgreSQL pg_trgm</strong> (fuzzy matching), or <strong>MySQL FULLTEXT indexes</strong>. PostgreSQL offers superior full-text capabilities with ranking, stemming, and multi-language support.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>PostgreSQL tsvector</strong>: Full-text search with ranking and stemming</li>
<li><strong>PostgreSQL pg_trgm</strong>: Fuzzy/similarity search</li>
<li><strong>GIN indexes</strong>: Fast full-text searches</li>
<li><strong>ts_rank</strong>: Relevance scoring</li>
<li><strong>MySQL FULLTEXT</strong>: Basic full-text (less powerful than PostgreSQL)</li>
<li><strong>When to use</strong>: Simple search needs, no external dependencies</li>
</ul>
<hr>
<h3>PostgreSQL Full-Text Search</h3>
<pre><code class="language-ruby"># ============================================
# SETUP: PostgreSQL Full-Text Search
# ============================================

# Enable pg_trgm extension
class EnablePgTrgm &lt; ActiveRecord::Migration[7.0]
  def change
    enable_extension &#39;pg_trgm&#39;
  end
end

# ============================================
# METHOD 1: tsvector with GIN Index (Best)
# ============================================

# Add tsvector column
class AddSearchToProducts &lt; ActiveRecord::Migration[7.0]
  def up
    # Add tsvector column
    add_column :products, :search_vector, :tsvector
    
    # Create GIN index for fast searching
    add_index :products, :search_vector, using: :gin
    
    # Create trigger to auto-update search_vector
    execute &lt;&lt;-SQL
      CREATE FUNCTION products_search_trigger() RETURNS trigger AS $$
      begin
        new.search_vector :=
          setweight(to_tsvector(&#39;english&#39;, coalesce(new.name,&#39;&#39;)), &#39;A&#39;) ||
          setweight(to_tsvector(&#39;english&#39;, coalesce(new.description,&#39;&#39;)), &#39;B&#39;) ||
          setweight(to_tsvector(&#39;english&#39;, coalesce(new.tags::text,&#39;&#39;)), &#39;C&#39;);
        return new;
      end
      $$ LANGUAGE plpgsql;
      
      CREATE TRIGGER products_search_vector_update
      BEFORE INSERT OR UPDATE ON products
      FOR EACH ROW EXECUTE FUNCTION products_search_trigger();
    SQL
    
    # Populate existing records
    execute &lt;&lt;-SQL
      UPDATE products SET search_vector = 
        setweight(to_tsvector(&#39;english&#39;, coalesce(name,&#39;&#39;)), &#39;A&#39;) ||
        setweight(to_tsvector(&#39;english&#39;, coalesce(description,&#39;&#39;)), &#39;B&#39;) ||
        setweight(to_tsvector(&#39;english&#39;, coalesce(tags::text,&#39;&#39;)), &#39;C&#39;);
    SQL
  end
  
  def down
    remove_index :products, :search_vector
    remove_column :products, :search_vector
    execute &quot;DROP TRIGGER IF EXISTS products_search_vector_update ON products&quot;
    execute &quot;DROP FUNCTION IF EXISTS products_search_trigger()&quot;
  end
end

# Model scope for searching
class Product &lt; ApplicationRecord
  # Simple search
  scope :search, -&gt;(query) {
    where(&quot;search_vector @@ plainto_tsquery(&#39;english&#39;, ?)&quot;, query)
  }
  
  # Search with ranking
  scope :search_with_rank, -&gt;(query) {
    select(&quot;products.*, ts_rank(search_vector, plainto_tsquery(&#39;english&#39;, ?)) AS rank&quot;, query)
      .where(&quot;search_vector @@ plainto_tsquery(&#39;english&#39;, ?)&quot;, query)
      .order(&#39;rank DESC&#39;)
  }
  
  # Phrase search
  scope :phrase_search, -&gt;(phrase) {
    where(&quot;search_vector @@ phraseto_tsquery(&#39;english&#39;, ?)&quot;, phrase)
  }
end

# Usage
products = Product.search(&quot;gaming laptop&quot;)
products = Product.search_with_rank(&quot;gaming laptop&quot;).limit(20)

# Advanced search with operators
# &amp; = AND, | = OR, ! = NOT
products = Product.where(
  &quot;search_vector @@ to_tsquery(&#39;english&#39;, ?)&quot;,
  &quot;gaming &amp; laptop &amp; !refurbished&quot;
)

# ============================================
# METHOD 2: ILIKE with pg_trgm (Fuzzy Search)
# ============================================

# Add trigram index
class AddTrigramIndexToProducts &lt; ActiveRecord::Migration[7.0]
  def change
    enable_extension &#39;pg_trgm&#39; unless extension_enabled?(&#39;pg_trgm&#39;)
    
    # Trigram index for fuzzy search
    add_index :products, :name, using: :gin, opclass: :gin_trgm_ops
    add_index :products, :description, using: :gin, opclass: :gin_trgm_ops
  end
end

# Model scopes
class Product &lt; ApplicationRecord
  # Fuzzy search (tolerates typos)
  scope :fuzzy_search, -&gt;(query) {
    where(&quot;name % ? OR description % ?&quot;, query, query)
      .order(Arel.sql(&quot;similarity(name, #{connection.quote(query)}) DESC&quot;))
  }
  
  # ILIKE search (case-insensitive LIKE)
  scope :ilike_search, -&gt;(query) {
    where(&quot;name ILIKE ? OR description ILIKE ?&quot;, &quot;%#{query}%&quot;, &quot;%#{query}%&quot;)
  }
  
  # Similarity search (returns similarity score)
  scope :similarity_search, -&gt;(query) {
    select(&quot;products.*, similarity(name, ?) as sim_score&quot;, query)
      .where(&quot;similarity(name, ?) &gt; 0.3&quot;, query)  # Threshold
      .order(&#39;sim_score DESC&#39;)
  }
end

# Usage
products = Product.fuzzy_search(&quot;laptp&quot;)  # Finds &quot;laptop&quot;
products = Product.ilike_search(&quot;gaming&quot;)
products = Product.similarity_search(&quot;gamming laptop&quot;)

# ============================================
# METHOD 3: Combined Approach (Most Powerful)
# ============================================

class Product &lt; ApplicationRecord
  # Full-text search with tsvector
  scope :full_text_search, -&gt;(query) {
    select(&quot;products.*, ts_rank(search_vector, query) AS rank&quot;)
      .from(&quot;products, plainto_tsquery(&#39;english&#39;, ?) query&quot;, query)
      .where(&quot;search_vector @@ query&quot;)
      .order(&#39;rank DESC&#39;)
  }
  
  # Fallback to fuzzy if no full-text results
  def self.search(query)
    results = full_text_search(query)
    
    if results.empty?
      results = fuzzy_search(query)
    end
    
    results
  end
  
  # Search with highlighting
  def self.search_with_highlights(query)
    select(
      &quot;products.*&quot;,
      &quot;ts_rank(search_vector, query) AS rank&quot;,
      &quot;ts_headline(&#39;english&#39;, name, query, &#39;MaxWords=50&#39;) AS highlighted_name&quot;,
      &quot;ts_headline(&#39;english&#39;, description, query, &#39;MaxWords=200&#39;) AS highlighted_description&quot;
    ).from(&quot;products, plainto_tsquery(&#39;english&#39;, ?) query&quot;, query)
     .where(&quot;search_vector @@ query&quot;)
     .order(&#39;rank DESC&#39;)
  end
end

# Usage
results = Product.search_with_highlights(&quot;gaming laptop&quot;)
results.each do |product|
  puts product.highlighted_name
  # =&gt; &quot;Best &lt;b&gt;Gaming&lt;/b&gt; &lt;b&gt;Laptop&lt;/b&gt; 2024&quot;
  puts product.highlighted_description
end

# ============================================
# POSTGRESQL: Advanced Features
# ============================================

# Multi-language support
class AddSearchToProductsMultiLang &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :products, :search_vector_en, :tsvector
    add_column :products, :search_vector_es, :tsvector
    
    add_index :products, :search_vector_en, using: :gin
    add_index :products, :search_vector_es, using: :gin
    
    # Triggers for each language
    execute &lt;&lt;-SQL
      CREATE TRIGGER products_search_en_update
      BEFORE INSERT OR UPDATE ON products
      FOR EACH ROW EXECUTE FUNCTION
      tsvector_update_trigger(search_vector_en, &#39;pg_catalog.english&#39;, name, description);
      
      CREATE TRIGGER products_search_es_update
      BEFORE INSERT OR UPDATE ON products
      FOR EACH ROW EXECUTE FUNCTION
      tsvector_update_trigger(search_vector_es, &#39;pg_catalog.spanish&#39;, name, description);
    SQL
  end
end

# Search by language
def self.search_by_language(query, lang = &#39;english&#39;)
  column = lang == &#39;spanish&#39; ? &#39;search_vector_es&#39; : &#39;search_vector_en&#39;
  
  where(&quot;#{column} @@ plainto_tsquery(?, ?)&quot;, lang, query)
end

# Stemming (automatic)
# Query: &quot;running&quot; finds &quot;run&quot;, &quot;runs&quot;, &quot;running&quot;, &quot;runner&quot;
Product.search(&quot;running&quot;)  # Finds all variations

# Stop words (automatic)
# Common words like &quot;the&quot;, &quot;a&quot;, &quot;is&quot; are ignored
Product.search(&quot;the best laptop&quot;)  # Ignores &quot;the&quot;

# Synonyms (custom dictionary)
execute &lt;&lt;-SQL
  CREATE TEXT SEARCH DICTIONARY synonym_dict (
    TEMPLATE = synonym,
    SYNONYMS = synonyms  # File: /usr/share/postgresql/.../synonyms.txt
  );
  
  ALTER TEXT SEARCH CONFIGURATION english
  ALTER MAPPING FOR asciiword WITH synonym_dict, english_stem;
SQL

# synonyms.txt:
# laptop, notebook
# phone, mobile, cell

# ============================================
# MYSQL: Full-Text Search
# ============================================

# Add FULLTEXT index (MySQL)
class AddFulltextToProducts &lt; ActiveRecord::Migration[7.0]
  def change
    execute &quot;ALTER TABLE products ADD FULLTEXT INDEX ft_name_desc (name, description)&quot;
  end
end

# Search (MySQL)
class Product &lt; ApplicationRecord
  scope :fulltext_search, -&gt;(query) {
    where(&quot;MATCH(name, description) AGAINST(? IN NATURAL LANGUAGE MODE)&quot;, query)
  }
  
  # Boolean mode (supports +, -, &quot;, *, etc.)
  scope :boolean_search, -&gt;(query) {
    where(&quot;MATCH(name, description) AGAINST(? IN BOOLEAN MODE)&quot;, query)
  }
  
  # With relevance score
  scope :search_with_score, -&gt;(query) {
    select(&quot;products.*, MATCH(name, description) AGAINST(?) AS score&quot;, query)
      .where(&quot;MATCH(name, description) AGAINST(?)&quot;, query)
      .order(&#39;score DESC&#39;)
  }
end

# Usage (MySQL)
products = Product.fulltext_search(&quot;gaming laptop&quot;)

# Boolean search operators:
# +word   = must include
# -word   = must not include
# &quot;phrase&quot; = exact phrase
# word*   = prefix
products = Product.boolean_search(&quot;+gaming +laptop -refurbished&quot;)

# ============================================
# COMPARISON: Elasticsearch vs PostgreSQL vs MySQL
# ============================================

# Feature                | Elasticsearch | PostgreSQL | MySQL
# -----------------------|---------------|------------|--------
# Full-text search       | Excellent     | Excellent  | Good
# Fuzzy search           | Excellent     | Good (pg_trgm) | Limited
# Multi-language         | Excellent     | Good       | Basic
# Ranking/Scoring        | Excellent     | Good       | Basic
# Faceted search         | Excellent     | Manual     | Manual
# Autocomplete           | Excellent     | Good       | Limited
# Scalability            | Excellent     | Good       | Good
# Setup complexity       | High          | Low        | Low
# Infrastructure         | External      | Built-in   | Built-in
# Performance (millions) | Excellent     | Good       | Fair

# When to use each:

# Use Elasticsearch when:
# - Need best search experience
# - Large scale (millions of documents)
# - Need faceted search, autocomplete
# - Can maintain separate search infrastructure

# Use PostgreSQL full-text when:
# - Want to keep everything in database
# - Small to medium scale (&lt; 1M records)
# - Need good search without extra infrastructure
# - Budget/simplicity matters

# Use MySQL FULLTEXT when:
# - Already using MySQL
# - Basic search needs
# - Small scale

# Performance comparison (1M records):
# 
# Simple search &quot;laptop&quot;:
# Elasticsearch: 20ms ✓✓✓
# PostgreSQL: 50ms ✓✓
# MySQL: 100ms ✓

# Complex search with filters:
# Elasticsearch: 30ms ✓✓✓
# PostgreSQL: 150ms ✓
# MySQL: 300ms ⚠
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>PostgreSQL tsvector</strong>: Best built-in full-text search</li>
<li><strong>GIN indexes</strong>: Essential for performance</li>
<li><strong>ts_rank</strong>: Relevance scoring</li>
<li><strong>pg_trgm</strong>: Fuzzy/similarity search</li>
<li><strong>Stemming</strong>: Automatic word variations</li>
<li><strong>Multi-language</strong>: Multiple tsvector columns</li>
<li><strong>MySQL FULLTEXT</strong>: Basic but functional</li>
<li><strong>Elasticsearch</strong>: Best for complex search needs</li>
<li><strong>PostgreSQL</strong>: Best balance of power and simplicity</li>
<li><strong>Choose based on</strong>: Scale, complexity, infrastructure</li>
</ol>
<hr>
<h2>Question 322: How do you handle secure file uploads in Rails?</h2>
<h3>Answer</h3>
<p>Handle secure file uploads using <strong>Active Storage</strong> with validation (type, size, content), <strong>virus scanning</strong> (ClamAV), <strong>direct uploads to S3</strong>, <strong>secure URLs</strong>, <strong>image processing</strong> (ImageMagick/libvips), and proper <strong>access control</strong>.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Active Storage</strong>: Rails&#39; built-in file upload system</li>
<li><strong>Validation</strong>: File type, size, content verification</li>
<li><strong>Virus scanning</strong>: ClamAV integration</li>
<li><strong>Direct uploads</strong>: Upload directly to S3 (bypass server)</li>
<li><strong>Secure serving</strong>: Signed URLs with expiration</li>
<li><strong>Image processing</strong>: Resize, compress, convert formats</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# STEP 1: Active Storage Setup
# ============================================

# Install Active Storage
rails active_storage:install
rails db:migrate

# Configure storage service
# config/storage.yml
local:
  service: Disk
  root: &lt;%= Rails.root.join(&quot;storage&quot;) %&gt;

amazon:
  service: S3
  access_key_id: &lt;%= ENV[&#39;AWS_ACCESS_KEY_ID&#39;] %&gt;
  secret_access_key: &lt;%= ENV[&#39;AWS_SECRET_ACCESS_KEY&#39;] %&gt;
  region: us-east-1
  bucket: &lt;%= ENV[&#39;S3_BUCKET&#39;] %&gt;
  
# config/environments/production.rb
config.active_storage.service = :amazon

# config/environments/development.rb
config.active_storage.service = :local

# ============================================
# STEP 2: Model Setup with Validations
# ============================================

# app/models/user.rb
class User &lt; ApplicationRecord
  has_one_attached :avatar
  has_many_attached :documents
  
  # File type validation
  validates :avatar, content_type: {
    in: [&#39;image/png&#39;, &#39;image/jpeg&#39;, &#39;image/gif&#39;],
    message: &#39;must be a PNG, JPEG, or GIF&#39;
  }
  
  # File size validation
  validates :avatar, size: {
    less_than: 5.megabytes,
    message: &#39;must be less than 5MB&#39;
  }
  
  # Custom validation
  validate :acceptable_avatar
  
  private
  
  def acceptable_avatar
    return unless avatar.attached?
    
    # Check file size
    if avatar.byte_size &gt; 5.megabytes
      errors.add(:avatar, &quot;is too large (maximum is 5MB)&quot;)
    end
    
    # Check content type
    acceptable_types = [&quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/gif&quot;]
    unless acceptable_types.include?(avatar.content_type)
      errors.add(:avatar, &quot;must be a JPEG, PNG, or GIF&quot;)
    end
    
    # Check dimensions (for images)
    if avatar.content_type.start_with?(&#39;image/&#39;)
      check_image_dimensions
    end
  end
  
  def check_image_dimensions
    return unless avatar.attached?
    
    image = MiniMagick::Image.read(avatar.download)
    
    if image.width &lt; 100 || image.height &lt; 100
      errors.add(:avatar, &quot;must be at least 100x100 pixels&quot;)
    end
    
    if image.width &gt; 10000 || image.height &gt; 10000
      errors.add(:avatar, &quot;is too large (maximum 10000x10000 pixels)&quot;)
    end
  rescue =&gt; e
    errors.add(:avatar, &quot;is not a valid image&quot;)
  end
end

# Document model with strict validation
class Document &lt; ApplicationRecord
  belongs_to :user
  has_one_attached :file
  
  # Allowed file types
  ALLOWED_CONTENT_TYPES = [
    &#39;application/pdf&#39;,
    &#39;application/msword&#39;,
    &#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#39;,
    &#39;image/jpeg&#39;,
    &#39;image/png&#39;
  ].freeze
  
  validates :file, attached: true,
                   content_type: {in: ALLOWED_CONTENT_TYPES},
                   size: {less_than: 10.megabytes}
  
  # Virus scan validation
  validate :virus_free
  
  private
  
  def virus_free
    return unless file.attached?
    
    scanner = VirusScanner.new(file)
    unless scanner.safe?
      errors.add(:file, &#39;contains malware or is suspicious&#39;)
    end
  end
end

# ============================================
# STEP 3: Virus Scanning (ClamAV)
# ============================================

# Install ClamAV
# Ubuntu: apt-get install clamav clamav-daemon
# macOS: brew install clamav

# Gemfile
gem &#39;clamby&#39;

# config/initializers/clamby.rb
Clamby.configure(
  check: false,  # Don&#39;t check for ClamAV on init (allows development without it)
  daemonize: true,  # Use clamd daemon
  config_file: &#39;/etc/clamav/clamd.conf&#39;,
  error_file_missing: true  # Raise error if file missing
)

# app/services/virus_scanner.rb
class VirusScanner
  def initialize(attachment)
    @attachment = attachment
  end
  
  def safe?
    return true unless Rails.env.production?  # Skip in development
    
    @attachment.open do |file|
      Clamby.safe?(file.path)
    end
  rescue =&gt; e
    Rails.logger.error(&quot;Virus scan failed: #{e.message}&quot;)
    false  # Fail closed (reject file if scan fails)
  end
end

# Background virus scanning (for large files)
class ScanUploadedFileJob &lt; ApplicationJob
  queue_as :security
  
  def perform(attachment_id)
    attachment = ActiveStorage::Attachment.find(attachment_id)
    
    scanner = VirusScanner.new(attachment.blob)
    
    unless scanner.safe?
      # Mark as infected
      attachment.blob.update(metadata: {virus_detected: true})
      
      # Notify admin
      AdminMailer.virus_detected(attachment).deliver_now
      
      # Delete file
      attachment.purge
      
      Rails.logger.warn(&quot;Virus detected in attachment #{attachment_id}, file deleted&quot;)
    else
      attachment.blob.update(metadata: {scanned: true, safe: true})
    end
  end
end

# Scan after upload
class Document &lt; ApplicationRecord
  after_commit :scan_for_viruses, on: :create
  
  private
  
  def scan_for_viruses
    return unless file.attached?
    ScanUploadedFileJob.perform_later(file.id)
  end
end

# ============================================
# STEP 4: Direct Upload to S3 (Bypass Server)
# ============================================

# Enable CORS on S3 bucket
# AWS Console → S3 → Your Bucket → Permissions → CORS
[
  {
    &quot;AllowedHeaders&quot;: [&quot;*&quot;],
    &quot;AllowedMethods&quot;: [&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;],
    &quot;AllowedOrigins&quot;: [&quot;https://yourapp.com&quot;],
    &quot;ExposeHeaders&quot;: [&quot;ETag&quot;],
    &quot;MaxAgeSeconds&quot;: 3000
  }
]

# JavaScript for direct upload
// app/javascript/direct_upload.js
import { DirectUpload } from &quot;@rails/activestorage&quot;

document.addEventListener(&#39;turbo:load&#39;, () =&gt; {
  const input = document.querySelector(&#39;input[type=file]&#39;)
  
  input.addEventListener(&#39;change&#39;, (event) =&gt; {
    const file = event.target.files[0]
    const upload = new DirectUpload(
      file,
      &#39;/rails/active_storage/direct_uploads&#39;
    )
    
    upload.create((error, blob) =&gt; {
      if (error) {
        console.error(error)
      } else {
        // Add signed_id to form
        const hiddenField = document.createElement(&#39;input&#39;)
        hiddenField.type = &#39;hidden&#39;
        hiddenField.name = &#39;user[avatar]&#39;
        hiddenField.value = blob.signed_id
        
        event.target.form.appendChild(hiddenField)
      }
    })
  })
})

# Controller receives signed_id
class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params)
    
    if @user.save
      redirect_to @user
    else
      render :new
    end
  end
  
  private
  
  def user_params
    params.require(:user).permit(:name, :email, :avatar)
  end
end

# ============================================
# STEP 5: Secure File Serving
# ============================================

# Serve files through controller (access control)
class DocumentsController &lt; ApplicationController
  before_action :authenticate_user!
  
  def download
    @document = Document.find(params[:id])
    
    # Authorization check
    authorize @document  # Pundit or CanCanCan
    
    # Redirect to signed URL
    redirect_to rails_blob_url(@document.file, disposition: &quot;attachment&quot;)
  end
end

# Generate temporary signed URL
def temporary_url
  @document.file.url(expires_in: 15.minutes)
end

# Serve through controller with access control
def serve_protected
  @document = current_user.documents.find(params[:id])
  
  # Stream file
  send_data @document.file.download,
            filename: @document.file.filename.to_s,
            type: @document.file.content_type,
            disposition: &#39;inline&#39;  # or &#39;attachment&#39; for download
end

# Use X-Accel-Redirect (nginx) for better performance
def serve_with_nginx
  @document = current_user.documents.find(params[:id])
  
  response.headers[&#39;Content-Type&#39;] = @document.file.content_type
  response.headers[&#39;Content-Disposition&#39;] = &quot;inline; filename=\&quot;#{@document.file.filename}\&quot;&quot;
  response.headers[&#39;X-Accel-Redirect&#39;] = &quot;/internal_files/#{@document.file.key}&quot;
  
  render body: nil
end

# nginx configuration
# location /internal_files/ {
#   internal;
#   alias /path/to/storage/;
# }

# ============================================
# STEP 6: Image Processing
# ============================================

# Install image processing
# Gemfile
gem &#39;image_processing&#39;

# Install ImageMagick or libvips
# Ubuntu: apt-get install imagemagick libvips-tools
# macOS: brew install imagemagick vips

# Create variants (thumbnails, different sizes)
class User &lt; ApplicationRecord
  has_one_attached :avatar do |attachable|
    attachable.variant :thumb, resize_to_limit: [100, 100]
    attachable.variant :medium, resize_to_limit: [300, 300]
    attachable.variant :large, resize_to_limit: [800, 800]
  end
end

# Use in views
&lt;%= image_tag @user.avatar.variant(:thumb) %&gt;
&lt;%= image_tag @user.avatar.variant(:medium) %&gt;

# On-demand variant creation
&lt;%= image_tag @user.avatar.variant(resize_to_limit: [500, 500]) %&gt;

# Advanced processing
class Product &lt; ApplicationRecord
  has_many_attached :images
  
  def thumbnail
    images.first.variant(
      resize_to_fill: [400, 400],
      format: :webp,
      saver: {quality: 85}
    )
  end
  
  def optimized_image
    images.first.variant(
      resize_to_limit: [1200, 1200],
      format: :webp,
      saver: {quality: 85, compression: :lossless}
    )
  end
end

# Background processing for large images
class ProcessImageJob &lt; ApplicationJob
  def perform(attachment_id)
    attachment = ActiveStorage::Attachment.find(attachment_id)
    
    # Generate variants
    [:thumb, :medium, :large].each do |variant_name|
      attachment.variant(variant_name).processed
    end
    
    # Optimize original
    optimize_image(attachment)
  end
  
  private
  
  def optimize_image(attachment)
    tempfile = Tempfile.new([&#39;optimized&#39;, &#39;.jpg&#39;])
    
    attachment.download do |original|
      image = MiniMagick::Image.read(original)
      image.strip  # Remove metadata
      image.quality 85
      image.write tempfile.path
    end
    
    attachment.blob.upload(File.open(tempfile.path))
  ensure
    tempfile.close
    tempfile.unlink
  end
end

# ============================================
# STEP 7: Upload Progress Tracking
# ============================================

# JavaScript with progress bar
// app/javascript/upload_progress.js
import { DirectUpload } from &quot;@rails/activestorage&quot;

class UploadWithProgress {
  constructor(file, input) {
    this.file = file
    this.input = input
    this.progressBar = this.createProgressBar()
  }
  
  createProgressBar() {
    const progress = document.createElement(&#39;div&#39;)
    progress.className = &#39;upload-progress&#39;
    progress.innerHTML = `
      &lt;div class=&quot;progress-bar&quot; style=&quot;width: 0%&quot;&gt;&lt;/div&gt;
      &lt;div class=&quot;progress-text&quot;&gt;0%&lt;/div&gt;
    `
    this.input.parentNode.appendChild(progress)
    return progress
  }
  
  upload() {
    const upload = new DirectUpload(
      this.file,
      &#39;/rails/active_storage/direct_uploads&#39;,
      this
    )
    
    upload.create((error, blob) =&gt; {
      if (error) {
        this.showError(error)
      } else {
        this.addSignedId(blob.signed_id)
        this.progressBar.remove()
      }
    })
  }
  
  directUploadWillStoreFileWithXHR(request) {
    request.upload.addEventListener(&#39;progress&#39;, (event) =&gt; {
      const progress = Math.round((event.loaded / event.total) * 100)
      this.updateProgress(progress)
    })
  }
  
  updateProgress(percent) {
    const bar = this.progressBar.querySelector(&#39;.progress-bar&#39;)
    const text = this.progressBar.querySelector(&#39;.progress-text&#39;)
    
    bar.style.width = `${percent}%`
    text.textContent = `${percent}%`
  }
  
  showError(error) {
    alert(`Upload failed: ${error}`)
    this.progressBar.remove()
  }
  
  addSignedId(signedId) {
    const hidden = document.createElement(&#39;input&#39;)
    hidden.type = &#39;hidden&#39;
    hidden.name = this.input.name
    hidden.value = signedId
    this.input.form.appendChild(hidden)
  }
}

# ============================================
# STEP 8: Security Best Practices
# ============================================

# 1. Content-Type validation (prevent bypass)
class SecureUploadValidator &lt; ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    return unless value.attached?
    
    # Check declared content type
    return unless allowed_content_type?(value.content_type)
    
    # Check actual file content (magic bytes)
    unless content_matches_type?(value)
      record.errors.add(attribute, &quot;file type doesn&#39;t match content&quot;)
    end
  end
  
  private
  
  def allowed_content_type?(type)
    [&#39;image/jpeg&#39;, &#39;image/png&#39;, &#39;application/pdf&#39;].include?(type)
  end
  
  def content_matches_type?(attachment)
    attachment.open do |file|
      magic_bytes = file.read(12)
      
      case attachment.content_type
      when &#39;image/jpeg&#39;
        magic_bytes.start_with?(&quot;\xFF\xD8\xFF&quot;)
      when &#39;image/png&#39;
        magic_bytes.start_with?(&quot;\x89PNG\r\n\x1A\n&quot;)
      when &#39;application/pdf&#39;
        magic_bytes.start_with?(&quot;%PDF&quot;)
      else
        false
      end
    end
  end
end

# 2. Filename sanitization
class Document &lt; ApplicationRecord
  before_save :sanitize_filename
  
  private
  
  def sanitize_filename
    return unless file.attached?
    
    # Remove special characters
    filename = file.filename.to_s
    sanitized = filename.gsub(/[^0-9A-Za-z.\-]/, &#39;_&#39;)
    
    file.blob.update(filename: sanitized) if sanitized != filename
  end
end

# 3. Rate limiting uploads
class UploadsController &lt; ApplicationController
  before_action :check_upload_limit
  
  private
  
  def check_upload_limit
    key = &quot;uploads:#{current_user.id}:#{Date.today}&quot;
    count = Redis.current.incr(key)
    
    Redis.current.expire(key, 24.hours) if count == 1
    
    if count &gt; 100
      render json: {error: &#39;Upload limit exceeded&#39;}, status: 429
    end
  end
end

# 4. Store uploads outside web root
# config/storage.yml
local:
  service: Disk
  root: &lt;%= Rails.root.join(&quot;storage&quot;) %&gt;  # Not /public !

# 5. Set appropriate permissions
# storage/ directory: 700 (owner only)
# files: 600 (owner read/write only)

# 6. Scan for embedded malware
class ScanDocumentContent &lt; ApplicationJob
  def perform(document_id)
    document = Document.find(document_id)
    
    # Extract and scan embedded content
    if document.file.content_type == &#39;application/pdf&#39;
      scan_pdf_content(document.file)
    elsif document.file.content_type.start_with?(&#39;application/vnd&#39;)
      scan_office_document(document.file)
    end
  end
  
  private
  
  def scan_pdf_content(file)
    # Extract JavaScript, scripts from PDF
    reader = PDF::Reader.new(file.download)
    
    reader.pages.each do |page|
      if page.text.match?(/javascript|script|eval/i)
        raise SecurityError, &quot;Suspicious content in PDF&quot;
      end
    end
  end
end
</code></pre>
<hr>
<h3>Security Checklist</h3>
<pre><code class="language-ruby"># Complete security checklist for file uploads:

# ✓ File Type Validation
# - Whitelist allowed MIME types
# - Check magic bytes (file content)
# - Don&#39;t trust client-declared content type

# ✓ File Size Limits
# - Set maximum file size
# - Prevent disk space exhaustion
# - Consider user quotas

# ✓ Filename Sanitization  
# - Remove special characters
# - Prevent directory traversal
# - Limit filename length

# ✓ Virus Scanning
# - Scan all uploads with ClamAV
# - Quarantine suspicious files
# - Background scanning for large files

# ✓ Storage Security
# - Store outside web root
# - Use appropriate file permissions
# - Encrypt sensitive files at rest

# ✓ Access Control
# - Authenticate before download
# - Authorize file access
# - Use signed URLs with expiration

# ✓ Rate Limiting
# - Limit uploads per user/IP
# - Prevent abuse
# - Implement quotas

# ✓ Direct Uploads
# - Upload to S3 directly
# - Bypass application server
# - Reduce server load

# ✓ Image Processing
# - Strip metadata (EXIF)
# - Resize appropriately
# - Compress images

# ✓ Monitoring
# - Log upload activity
# - Alert on suspicious patterns
# - Track storage usage
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Active Storage</strong>: Rails&#39; built-in file upload solution</li>
<li><strong>Validate</strong>: File type, size, content (magic bytes)</li>
<li><strong>Virus scan</strong>: ClamAV integration is critical</li>
<li><strong>Direct uploads</strong>: Bypass server, upload to S3 directly</li>
<li><strong>Secure serving</strong>: Signed URLs with expiration</li>
<li><strong>Image processing</strong>: Resize, compress, strip metadata</li>
<li><strong>Access control</strong>: Authenticate and authorize downloads</li>
<li><strong>Rate limiting</strong>: Prevent abuse</li>
<li><strong>Store securely</strong>: Outside web root, proper permissions</li>
<li><strong>Monitor</strong>: Track uploads, alert on suspicious activity</li>
</ol>
<h1>Architecture and Design Patterns Interview Questions (323-330)</h1>
<h2>Design Patterns</h2>
<h2>Question 323: Explain common design patterns used in Rails</h2>
<h3>Answer</h3>
<p>Rails applications commonly use <strong>Service Objects</strong> (business logic), <strong>Decorators</strong> (presentation), <strong>Form Objects</strong> (complex validations), <strong>Query Objects</strong> (complex queries), <strong>Policy Objects</strong> (authorization), <strong>Value Objects</strong> (immutable data), and <strong>Observers</strong> (side effects).</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Service Objects</strong>: Encapsulate business logic (UserRegistration)</li>
<li><strong>Decorators</strong>: Add presentation logic to models (UserDecorator)</li>
<li><strong>Form Objects</strong>: Handle complex form validations</li>
<li><strong>Query Objects</strong>: Encapsulate complex database queries</li>
<li><strong>Policy Objects</strong>: Handle authorization logic (Pundit)</li>
<li><strong>Repository Pattern</strong>: Abstract data access</li>
<li><strong>Factory Pattern</strong>: Create test data, objects</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<pre><code class="language-ruby"># ============================================
# PATTERN 1: Service Objects (Most Common)
# ============================================

# Problem: Fat controllers and models
# Solution: Extract business logic to service objects

# ❌ BAD: Fat controller
class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params)
    
    if @user.save
      # Send welcome email
      UserMailer.welcome(@user).deliver_later
      
      # Create default settings
      @user.create_settings(theme: &#39;light&#39;, notifications: true)
      
      # Subscribe to newsletter
      NewsletterService.subscribe(@user.email)
      
      # Track analytics
      Analytics.track(&#39;user_signup&#39;, user_id: @user.id)
      
      # Award signup bonus
      @user.wallet.credit(10)
      
      redirect_to @user
    else
      render :new
    end
  end
end

# ✅ GOOD: Service object
# app/services/user_registration_service.rb
class UserRegistrationService
  attr_reader :user, :errors
  
  def initialize(params)
    @params = params
    @errors = []
  end
  
  def call
    ActiveRecord::Base.transaction do
      create_user
      return false unless user.persisted?
      
      setup_defaults
      subscribe_to_newsletter
      track_analytics
      award_signup_bonus
      send_welcome_email
      
      true
    end
  rescue =&gt; e
    @errors &lt;&lt; e.message
    false
  end
  
  private
  
  def create_user
    @user = User.create(@params)
    @errors = @user.errors.full_messages unless @user.persisted?
  end
  
  def setup_defaults
    user.create_settings(theme: &#39;light&#39;, notifications: true)
  end
  
  def subscribe_to_newsletter
    NewsletterService.new(user.email).subscribe
  end
  
  def track_analytics
    Analytics.track(&#39;user_signup&#39;, user_id: user.id)
  end
  
  def award_signup_bonus
    user.wallet.credit(10, description: &#39;Signup bonus&#39;)
  end
  
  def send_welcome_email
    UserMailer.welcome(user).deliver_later
  end
end

# Controller (clean!)
class UsersController &lt; ApplicationController
  def create
    service = UserRegistrationService.new(user_params)
    
    if service.call
      redirect_to service.user, notice: &#39;Welcome!&#39;
    else
      @errors = service.errors
      render :new
    end
  end
end

# Alternative: Return result object
class UserRegistrationService
  Result = Struct.new(:success?, :user, :errors)
  
  def call
    # ... logic ...
    
    Result.new(true, user, [])
  rescue =&gt; e
    Result.new(false, user, [e.message])
  end
end

# Usage
result = UserRegistrationService.new(params).call

if result.success?
  redirect_to result.user
else
  @errors = result.errors
  render :new
end

# ============================================
# PATTERN 2: Decorators (Presentation Logic)
# ============================================

# Problem: View logic in models or views
# Solution: Decorator pattern (Draper gem)

# Gemfile
gem &#39;draper&#39;

# app/decorators/user_decorator.rb
class UserDecorator &lt; Draper::Decorator
  delegate_all  # Delegate all methods to model
  
  # Formatted name
  def full_name_with_title
    &quot;#{object.title} #{object.first_name} #{object.last_name}&quot;
  end
  
  # Avatar with fallback
  def avatar_url(size: :medium)
    if object.avatar.attached?
      h.rails_blob_url(object.avatar.variant(resize_to_limit: avatar_sizes[size]))
    else
      h.asset_path(&quot;default-avatar-#{size}.png&quot;)
    end
  end
  
  # Formatted date
  def joined_date
    object.created_at.strftime(&quot;%B %Y&quot;)
  end
  
  # Status badge HTML
  def status_badge
    h.content_tag :span, class: &quot;badge badge-#{status_color}&quot; do
      object.status.humanize
    end
  end
  
  # Bio with HTML
  def formatted_bio
    return h.content_tag(:p, &quot;No bio yet&quot;, class: &#39;text-muted&#39;) if object.bio.blank?
    
    h.simple_format(object.bio)
  end
  
  # Social links
  def social_links
    links = []
    links &lt;&lt; h.link_to(h.icon(&#39;twitter&#39;), object.twitter_url) if object.twitter_url?
    links &lt;&lt; h.link_to(h.icon(&#39;github&#39;), object.github_url) if object.github_url?
    h.safe_join(links, &#39; &#39;)
  end
  
  private
  
  def avatar_sizes
    { small: [50, 50], medium: [200, 200], large: [800, 800] }
  end
  
  def status_color
    case object.status
    when &#39;active&#39; then &#39;success&#39;
    when &#39;inactive&#39; then &#39;secondary&#39;
    when &#39;suspended&#39; then &#39;danger&#39;
    else &#39;primary&#39;
    end
  end
end

# Controller
class UsersController &lt; ApplicationController
  def show
    @user = User.find(params[:id]).decorate
  end
end

# View
&lt;div class=&quot;user-profile&quot;&gt;
  &lt;%= image_tag @user.avatar_url(size: :large) %&gt;
  &lt;h1&gt;&lt;%= @user.full_name_with_title %&gt;&lt;/h1&gt;
  &lt;p&gt;Member since &lt;%= @user.joined_date %&gt;&lt;/p&gt;
  &lt;%= @user.status_badge %&gt;
  &lt;%= @user.formatted_bio %&gt;
  &lt;%= @user.social_links %&gt;
&lt;/div&gt;

# Collection decorator
users = User.all.decorate

# ============================================
# PATTERN 3: Form Objects (Complex Forms)
# ============================================

# Problem: Complex forms with validations across multiple models
# Solution: Form objects

# app/forms/event_registration_form.rb
class EventRegistrationForm
  include ActiveModel::Model
  include ActiveModel::Attributes
  
  # Define attributes
  attribute :event_id, :integer
  attribute :user_id, :integer
  attribute :ticket_type, :string
  attribute :guests_count, :integer, default: 0
  attribute :dietary_requirements, :string
  attribute :payment_method, :string
  
  # Validations
  validates :event_id, :user_id, :ticket_type, :payment_method, presence: true
  validates :guests_count, numericality: { greater_than_or_equal_to: 0, less_than: 10 }
  validates :ticket_type, inclusion: { in: %w[general vip] }
  
  validate :event_has_capacity
  validate :user_not_already_registered
  
  def save
    return false unless valid?
    
    ActiveRecord::Base.transaction do
      create_registration
      process_payment
      send_confirmation
      true
    end
  rescue =&gt; e
    errors.add(:base, e.message)
    false
  end
  
  def total_amount
    ticket_price * (1 + guests_count)
  end
  
  private
  
  def create_registration
    @registration = Registration.create!(
      event_id: event_id,
      user_id: user_id,
      ticket_type: ticket_type,
      guests_count: guests_count,
      dietary_requirements: dietary_requirements
    )
  end
  
  def process_payment
    PaymentService.new(
      user_id: user_id,
      amount: total_amount,
      payment_method: payment_method
    ).process!
  end
  
  def send_confirmation
    RegistrationMailer.confirmation(@registration).deliver_later
  end
  
  def event_has_capacity
    event = Event.find_by(id: event_id)
    return unless event
    
    if event.remaining_capacity &lt; (1 + guests_count)
      errors.add(:base, &#39;Event is full&#39;)
    end
  end
  
  def user_not_already_registered
    if Registration.exists?(event_id: event_id, user_id: user_id)
      errors.add(:base, &#39;Already registered&#39;)
    end
  end
  
  def ticket_price
    event = Event.find(event_id)
    ticket_type == &#39;vip&#39; ? event.vip_price : event.general_price
  end
end

# Controller
class RegistrationsController &lt; ApplicationController
  def create
    @form = EventRegistrationForm.new(registration_params)
    
    if @form.save
      redirect_to event_path(@form.event_id), notice: &#39;Registered successfully!&#39;
    else
      render :new
    end
  end
  
  private
  
  def registration_params
    params.require(:registration).permit(
      :event_id, :ticket_type, :guests_count, 
      :dietary_requirements, :payment_method
    ).merge(user_id: current_user.id)
  end
end

# ============================================
# PATTERN 4: Query Objects (Complex Queries)
# ============================================

# Problem: Complex queries scattered across controllers
# Solution: Query objects

# app/queries/user_search_query.rb
class UserSearchQuery
  def initialize(relation = User.all)
    @relation = relation
  end
  
  def call(params)
    @relation
      .then { |r| by_name(r, params[:name]) }
      .then { |r| by_email(r, params[:email]) }
      .then { |r| by_status(r, params[:status]) }
      .then { |r| by_role(r, params[:role]) }
      .then { |r| by_created_date(r, params[:created_from], params[:created_to]) }
      .then { |r| with_minimum_posts(r, params[:min_posts]) }
      .then { |r| order_by(r, params[:sort], params[:direction]) }
  end
  
  private
  
  def by_name(relation, name)
    return relation if name.blank?
    relation.where(&#39;name ILIKE ?&#39;, &quot;%#{name}%&quot;)
  end
  
  def by_email(relation, email)
    return relation if email.blank?
    relation.where(&#39;email ILIKE ?&#39;, &quot;%#{email}%&quot;)
  end
  
  def by_status(relation, status)
    return relation if status.blank?
    relation.where(status: status)
  end
  
  def by_role(relation, role)
    return relation if role.blank?
    relation.where(role: role)
  end
  
  def by_created_date(relation, from, to)
    relation = relation.where(&#39;created_at &gt;= ?&#39;, from) if from.present?
    relation = relation.where(&#39;created_at &lt;= ?&#39;, to) if to.present?
    relation
  end
  
  def with_minimum_posts(relation, min_posts)
    return relation if min_posts.blank?
    
    relation
      .joins(:posts)
      .group(&#39;users.id&#39;)
      .having(&#39;COUNT(posts.id) &gt;= ?&#39;, min_posts)
  end
  
  def order_by(relation, sort, direction)
    return relation.order(created_at: :desc) if sort.blank?
    
    direction = direction&amp;.downcase == &#39;asc&#39; ? :asc : :desc
    relation.order(sort =&gt; direction)
  end
end

# Controller
class UsersController &lt; ApplicationController
  def index
    @users = UserSearchQuery.new.call(search_params).page(params[:page])
  end
  
  private
  
  def search_params
    params.permit(:name, :email, :status, :role, :created_from, :created_to, :min_posts, :sort, :direction)
  end
end

# More complex query object
class TopPerformersQuery
  def initialize(relation = User.all)
    @relation = relation.active
  end
  
  def call(time_period: 1.month, limit: 10)
    @relation
      .select(
        &#39;users.*&#39;,
        &#39;COUNT(DISTINCT posts.id) as posts_count&#39;,
        &#39;COUNT(DISTINCT comments.id) as comments_count&#39;,
        &#39;SUM(posts.views_count) as total_views&#39;,
        &#39;(COUNT(DISTINCT posts.id) * 10 + COUNT(DISTINCT comments.id) * 2) as score&#39;
      )
      .joins(:posts)
      .left_joins(posts: :comments)
      .where(&#39;posts.created_at &gt; ?&#39;, time_period.ago)
      .group(&#39;users.id&#39;)
      .order(&#39;score DESC&#39;)
      .limit(limit)
  end
end

# Usage
top_users = TopPerformersQuery.new.call(time_period: 1.week, limit: 5)

# ============================================
# PATTERN 5: Policy Objects (Authorization)
# ============================================

# Using Pundit gem

# Gemfile
gem &#39;pundit&#39;

# app/policies/post_policy.rb
class PostPolicy
  attr_reader :user, :post
  
  def initialize(user, post)
    @user = user
    @post = post
  end
  
  def index?
    true  # Anyone can view list
  end
  
  def show?
    post.published? || user_is_owner_or_admin?
  end
  
  def create?
    user.present?
  end
  
  def update?
    user_is_owner_or_admin?
  end
  
  def destroy?
    user_is_owner_or_admin?
  end
  
  def publish?
    user_is_owner_or_admin? &amp;&amp; post.draft?
  end
  
  class Scope
    attr_reader :user, :scope
    
    def initialize(user, scope)
      @user = user
      @scope = scope
    end
    
    def resolve
      if user&amp;.admin?
        scope.all
      elsif user
        scope.where(published: true).or(scope.where(user: user))
      else
        scope.published
      end
    end
  end
  
  private
  
  def user_is_owner_or_admin?
    user.present? &amp;&amp; (user == post.user || user.admin?)
  end
end

# Controller
class PostsController &lt; ApplicationController
  def index
    @posts = policy_scope(Post)
  end
  
  def show
    @post = Post.find(params[:id])
    authorize @post
  end
  
  def update
    @post = Post.find(params[:id])
    authorize @post
    
    if @post.update(post_params)
      redirect_to @post
    else
      render :edit
    end
  end
end

# ============================================
# PATTERN 6: Value Objects (Immutable Data)
# ============================================

# Problem: Primitive obsession, mutable data
# Solution: Value objects

# app/values/money.rb
class Money
  include Comparable
  
  attr_reader :amount, :currency
  
  def initialize(amount, currency = &#39;USD&#39;)
    @amount = BigDecimal(amount.to_s)
    @currency = currency.to_s.upcase
    freeze  # Make immutable
  end
  
  def +(other)
    ensure_same_currency!(other)
    Money.new(amount + other.amount, currency)
  end
  
  def -(other)
    ensure_same_currency!(other)
    Money.new(amount - other.amount, currency)
  end
  
  def *(multiplier)
    Money.new(amount * multiplier, currency)
  end
  
  def &lt;=&gt;(other)
    ensure_same_currency!(other)
    amount &lt;=&gt; other.amount
  end
  
  def to_s
    &quot;#{currency} #{format_amount}&quot;
  end
  
  def format_amount
    amount.to_f.round(2)
  end
  
  def zero?
    amount.zero?
  end
  
  private
  
  def ensure_same_currency!(other)
    unless currency == other.currency
      raise ArgumentError, &quot;Currency mismatch: #{currency} vs #{other.currency}&quot;
    end
  end
end

# Usage in models
class Product &lt; ApplicationRecord
  def price
    Money.new(read_attribute(:price_cents) / 100.0, price_currency)
  end
  
  def price=(money)
    if money.is_a?(Money)
      write_attribute(:price_cents, (money.amount * 100).to_i)
      write_attribute(:price_currency, money.currency)
    else
      write_attribute(:price_cents, (money.to_f * 100).to_i)
    end
  end
end

# Usage
product = Product.new
product.price = Money.new(19.99, &#39;USD&#39;)
product.price  # =&gt; Money(19.99, USD)
product.price.to_s  # =&gt; &quot;USD 19.99&quot;

# Calculations
total = product.price * 2  # =&gt; Money(39.98, USD)
discount = total - Money.new(5, &#39;USD&#39;)  # =&gt; Money(34.98, USD)

# Address value object
class Address
  attr_reader :street, :city, :state, :zip, :country
  
  def initialize(street:, city:, state:, zip:, country: &#39;USA&#39;)
    @street = street
    @city = city
    @state = state
    @zip = zip
    @country = country
    freeze
  end
  
  def full_address
    &quot;#{street}, #{city}, #{state} #{zip}, #{country}&quot;
  end
  
  def same_city?(other)
    city == other.city &amp;&amp; state == other.state &amp;&amp; country == other.country
  end
  
  def ==(other)
    other.is_a?(Address) &amp;&amp;
      street == other.street &amp;&amp;
      city == other.city &amp;&amp;
      state == other.state &amp;&amp;
      zip == other.zip &amp;&amp;
      country == other.country
  end
  
  alias eql? ==
  
  def hash
    [street, city, state, zip, country].hash
  end
end

# Store in database as JSON
class User &lt; ApplicationRecord
  def address
    return nil unless address_json
    
    attrs = JSON.parse(address_json, symbolize_names: true)
    Address.new(**attrs)
  end
  
  def address=(addr)
    self.address_json = addr.to_json if addr
  end
end

# ============================================
# PATTERN 7: Repository Pattern
# ============================================

# Abstract data access layer

# app/repositories/user_repository.rb
class UserRepository
  def find(id)
    User.find(id)
  end
  
  def find_by_email(email)
    User.find_by(email: email)
  end
  
  def all_active
    User.where(status: &#39;active&#39;)
  end
  
  def create(attributes)
    User.create(attributes)
  end
  
  def update(user, attributes)
    user.update(attributes)
  end
  
  def destroy(user)
    user.destroy
  end
  
  # Complex queries
  def top_contributors(limit: 10)
    User.joins(:posts)
        .group(&#39;users.id&#39;)
        .order(&#39;COUNT(posts.id) DESC&#39;)
        .limit(limit)
  end
  
  def recently_active(since: 1.week.ago)
    User.where(&#39;last_seen_at &gt; ?&#39;, since)
        .order(last_seen_at: :desc)
  end
end

# Usage in service
class UserStatisticsService
  def initialize(repository: UserRepository.new)
    @repository = repository
  end
  
  def top_users
    @repository.top_contributors(limit: 5)
  end
end

# Benefits:
# - Easy to test (mock repository)
# - Can swap data sources
# - Centralized query logic

# ============================================
# PATTERN 8: Factory Pattern (Testing)
# ============================================

# app/factories/user_factory.rb
class UserFactory
  def self.build(attributes = {})
    default_attributes.merge(attributes).then do |attrs|
      User.new(attrs)
    end
  end
  
  def self.create(attributes = {})
    build(attributes).tap(&amp;:save!)
  end
  
  def self.create_admin
    create(role: &#39;admin&#39;, permissions: %w[read write delete])
  end
  
  def self.create_with_posts(posts_count: 5)
    create.tap do |user|
      posts_count.times do
        PostFactory.create(user: user)
      end
    end
  end
  
  private
  
  def self.default_attributes
    {
      email: &quot;user-#{SecureRandom.hex(4)}@example.com&quot;,
      name: &quot;Test User&quot;,
      password: &quot;password123&quot;
    }
  end
end

# Or use FactoryBot
# Gemfile (test)
gem &#39;factory_bot_rails&#39;

# spec/factories/users.rb
FactoryBot.define do
  factory :user do
    sequence(:email) { |n| &quot;user#{n}@example.com&quot; }
    name { &quot;Test User&quot; }
    password { &quot;password123&quot; }
    
    trait :admin do
      role { &#39;admin&#39; }
    end
    
    trait :with_posts do
      transient do
        posts_count { 5 }
      end
      
      after(:create) do |user, evaluator|
        create_list(:post, evaluator.posts_count, user: user)
      end
    end
  end
end

# Usage
user = FactoryBot.create(:user)
admin = FactoryBot.create(:user, :admin)
user_with_posts = FactoryBot.create(:user, :with_posts, posts_count: 10)
</code></pre>
<hr>
<h3>Design Pattern Summary</h3>
<pre><code class="language-ruby"># When to use each pattern:

# SERVICE OBJECTS - Use when:
# ✓ Complex business logic
# ✓ Multiple model interactions
# ✓ External API calls
# ✓ Multi-step operations
# Example: UserRegistration, OrderCheckout, PaymentProcessing

# DECORATORS - Use when:
# ✓ Presentation logic
# ✓ View-specific formatting
# ✓ HTML generation
# ✓ Keeping views clean
# Example: UserDecorator, ProductDecorator

# FORM OBJECTS - Use when:
# ✓ Complex forms
# ✓ Multiple models
# ✓ Custom validations
# ✓ Virtual attributes
# Example: RegistrationForm, CheckoutForm

# QUERY OBJECTS - Use when:
# ✓ Complex database queries
# ✓ Reusable queries
# ✓ Multiple filters
# ✓ Keeping models clean
# Example: UserSearchQuery, ReportQuery

# POLICY OBJECTS - Use when:
# ✓ Authorization logic
# ✓ Complex permissions
# ✓ Role-based access
# Example: PostPolicy, CommentPolicy

# VALUE OBJECTS - Use when:
# ✓ Immutable data
# ✓ Domain concepts
# ✓ Calculated values
# Example: Money, Address, DateRange

# REPOSITORY PATTERN - Use when:
# ✓ Abstract data access
# ✓ Easy testing
# ✓ Multiple data sources
# Example: UserRepository, ProductRepository
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Service Objects</strong>: Extract complex business logic</li>
<li><strong>Decorators</strong>: Keep presentation logic out of models</li>
<li><strong>Form Objects</strong>: Handle complex form validations</li>
<li><strong>Query Objects</strong>: Encapsulate complex queries</li>
<li><strong>Policy Objects</strong>: Centralize authorization</li>
<li><strong>Value Objects</strong>: Immutable domain concepts</li>
<li><strong>Repository Pattern</strong>: Abstract data access</li>
<li><strong>Follow Rails conventions</strong>: Use patterns when they add value</li>
<li><strong>Don&#39;t over-engineer</strong>: Start simple, add patterns when needed</li>
<li><strong>Test patterns</strong>: Patterns make code more testable</li>
</ol>
<hr>
<h2>Question 324: What are AOP (Aspect-Oriented Programming) concepts in Rails?</h2>
<h3>Answer</h3>
<p><strong>AOP in Rails</strong> uses <strong>concerns</strong>, <strong>callbacks</strong>, <strong>around_action</strong>, and <strong>method wrapping</strong> to handle cross-cutting concerns like logging, caching, authorization, and transaction management without cluttering business logic.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Concerns</strong>: Mixins for shared behavior (ActiveSupport::Concern)</li>
<li><strong>Callbacks</strong>: Before/after/around hooks (before_action, after_commit)</li>
<li><strong>Around filters</strong>: Wrap actions with additional behavior</li>
<li><strong>Method decoration</strong>: Add behavior to methods (prepend, alias_method_chain)</li>
<li><strong>Cross-cutting concerns</strong>: Logging, caching, transactions, authorization</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<pre><code class="language-ruby"># ============================================
# CONCEPT 1: Concerns (Mixins)
# ============================================

# Extract shared behavior into concerns

# app/models/concerns/taggable.rb
module Taggable
  extend ActiveSupport::Concern
  
  included do
    # Runs when concern is included
    has_many :taggings, as: :taggable, dependent: :destroy
    has_many :tags, through: :taggings
    
    scope :tagged_with, -&gt;(tag_name) {
      joins(:tags).where(tags: {name: tag_name})
    }
  end
  
  # Instance methods
  def tag_list
    tags.pluck(:name).join(&#39;, &#39;)
  end
  
  def tag_list=(names)
    self.tags = names.split(&#39;,&#39;).map do |name|
      Tag.find_or_create_by(name: name.strip)
    end
  end
  
  # Class methods
  class_methods do
    def popular_tags(limit: 10)
      Tag.joins(:taggings)
         .where(taggings: {taggable_type: name})
         .group(&#39;tags.id&#39;)
         .order(&#39;COUNT(taggings.id) DESC&#39;)
         .limit(limit)
    end
  end
end

# Use in multiple models
class Post &lt; ApplicationRecord
  include Taggable
end

class Article &lt; ApplicationRecord
  include Taggable
end

# Usage
post = Post.first
post.tag_list = &quot;rails, ruby, programming&quot;
post.tags  # =&gt; [Tag(rails), Tag(ruby), Tag(programming)]
Post.tagged_with(&quot;rails&quot;)  # All posts with &quot;rails&quot; tag
Post.popular_tags(limit: 5)  # Top 5 tags

# app/models/concerns/soft_deletable.rb
module SoftDeletable
  extend ActiveSupport::Concern
  
  included do
    scope :active, -&gt; { where(deleted_at: nil) }
    scope :deleted, -&gt; { where.not(deleted_at: nil) }
    
    default_scope -&gt; { active }
  end
  
  def soft_delete
    update(deleted_at: Time.current)
  end
  
  def restore
    update(deleted_at: nil)
  end
  
  def deleted?
    deleted_at.present?
  end
end

# app/models/concerns/auditable.rb
module Auditable
  extend ActiveSupport::Concern
  
  included do
    after_create :log_creation
    after_update :log_update
    after_destroy :log_destruction
  end
  
  private
  
  def log_creation
    AuditLog.create(
      action: &#39;create&#39;,
      auditable: self,
      user: Current.user,
      changes: attributes
    )
  end
  
  def log_update
    AuditLog.create(
      action: &#39;update&#39;,
      auditable: self,
      user: Current.user,
      changes: saved_changes
    )
  end
  
  def log_destruction
    AuditLog.create(
      action: &#39;destroy&#39;,
      auditable: self,
      user: Current.user,
      changes: attributes
    )
  end
end

# ============================================
# CONCEPT 2: Controller Concerns
# ============================================

# app/controllers/concerns/authentication.rb
module Authentication
  extend ActiveSupport::Concern
  
  included do
    before_action :require_login
    helper_method :current_user, :logged_in?
  end
  
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end
  
  def logged_in?
    current_user.present?
  end
  
  def require_login
    unless logged_in?
      redirect_to login_path, alert: &#39;Please log in&#39;
    end
  end
end

# app/controllers/concerns/error_handling.rb
module ErrorHandling
  extend ActiveSupport::Concern
  
  included do
    rescue_from ActiveRecord::RecordNotFound, with: :not_found
    rescue_from ActionController::ParameterMissing, with: :bad_request
    rescue_from Pundit::NotAuthorizedError, with: :unauthorized
  end
  
  private
  
  def not_found
    render json: {error: &#39;Not found&#39;}, status: :not_found
  end
  
  def bad_request
    render json: {error: &#39;Bad request&#39;}, status: :bad_request
  end
  
  def unauthorized
    render json: {error: &#39;Unauthorized&#39;}, status: :forbidden
  end
end

# Use in controllers
class ApplicationController &lt; ActionController::Base
  include Authentication
  include ErrorHandling
end

# ============================================
# CONCEPT 3: Around Actions (Wrap Behavior)
# ============================================

# Wrap actions with additional behavior

class ApplicationController &lt; ActionController::Base
  around_action :log_request_time
  around_action :set_time_zone, if: :current_user
  
  private
  
  def log_request_time
    start = Time.current
    yield
    duration = Time.current - start
    
    Rails.logger.info({
      action: &quot;#{controller_name}##{action_name}&quot;,
      duration: duration.round(3),
      user_id: current_user&amp;.id
    }.to_json)
  end
  
  def set_time_zone
    Time.use_zone(current_user.time_zone) do
      yield
    end
  end
end

# Cache around action
class PostsController &lt; ApplicationController
  around_action :cache_action, only: :show
  
  private
  
  def cache_action
    cache_key = &quot;action_cache/#{controller_name}/#{action_name}/#{params[:id]}&quot;
    
    cached = Rails.cache.read(cache_key)
    if cached
      render html: cached.html_safe
    else
      yield
      Rails.cache.write(cache_key, response.body, expires_in: 5.minutes)
    end
  end
end

# Transaction wrapper
class OrdersController &lt; ApplicationController
  around_action :wrap_in_transaction, only: [:create, :update]
  
  private
  
  def wrap_in_transaction
    ActiveRecord::Base.transaction do
      yield
    end
  rescue =&gt; e
    Rails.logger.error(&quot;Transaction failed: #{e.message}&quot;)
    raise
  end
end

# ============================================
# CONCEPT 4: Method Decoration (prepend)
# ============================================

# Add behavior to existing methods

# app/models/user.rb
class User &lt; ApplicationRecord
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
end

# Add caching to full_name
module UserDecorations
  def full_name
    Rails.cache.fetch(&quot;user/#{id}/full_name&quot;, expires_in: 1.hour) do
      super  # Call original method
    end
  end
end

# Prepend module (preferred over alias_method_chain)
User.prepend(UserDecorations)

# Now full_name is cached
user.full_name  # First call: database + cache write
user.full_name  # Second call: cache read

# More complex example: Add logging
module LoggableDecorations
  def save(*args)
    Rails.logger.info(&quot;Saving #{self.class.name} #{id}&quot;)
    result = super
    Rails.logger.info(&quot;Saved: #{result}&quot;)
    result
  end
  
  def destroy
    Rails.logger.info(&quot;Destroying #{self.class.name} #{id}&quot;)
    result = super
    Rails.logger.info(&quot;Destroyed: #{result}&quot;)
    result
  end
end

# Apply to all models
ActiveRecord::Base.prepend(LoggableDecorations)

# ============================================
# CONCEPT 5: Callbacks (AOP in Models)
# ============================================

# Add behavior before/after methods

class Order &lt; ApplicationRecord
  # Before callbacks
  before_validation :normalize_data
  before_save :calculate_total
  before_create :generate_order_number
  
  # After callbacks
  after_create :send_confirmation
  after_update :notify_changes, if: :status_changed?
  after_commit :reindex_search, on: [:create, :update]
  
  # Around callbacks
  around_save :log_save_operation
  
  private
  
  def normalize_data
    self.email = email.downcase.strip if email
  end
  
  def calculate_total
    self.total = line_items.sum(&amp;:subtotal)
  end
  
  def generate_order_number
    self.order_number = &quot;ORD-#{Time.current.to_i}-#{SecureRandom.hex(4)}&quot;
  end
  
  def send_confirmation
    OrderMailer.confirmation(self).deliver_later
  end
  
  def notify_changes
    OrderMailer.status_update(self).deliver_later
  end
  
  def reindex_search
    ReindexOrderJob.perform_later(id)
  end
  
  def log_save_operation
    Rails.logger.info(&quot;Saving order #{id}&quot;)
    yield
    Rails.logger.info(&quot;Order #{id} saved&quot;)
  end
end

# ============================================
# CONCEPT 6: Custom AOP with ActiveSupport::Notifications
# ============================================

# Instrument any code block

class PaymentService
  def process_payment(order)
    ActiveSupport::Notifications.instrument(
      &#39;payment.process&#39;,
      order_id: order.id,
      amount: order.total
    ) do
      # Payment processing logic
      charge_credit_card(order)
    end
  end
end

# Subscribe to events
ActiveSupport::Notifications.subscribe(&#39;payment.process&#39;) do |name, start, finish, id, payload|
  duration = finish - start
  
  Rails.logger.info({
    event: name,
    order_id: payload[:order_id],
    amount: payload[:amount],
    duration_ms: (duration * 1000).round(2)
  }.to_json)
  
  # Track metrics
  StatsD.histogram(&#39;payment.duration&#39;, duration)
  StatsD.increment(&#39;payment.count&#39;)
end

# ============================================
# CONCEPT 7: Method Missing (Dynamic AOP)
# ============================================

# Intercept method calls

class DynamicFinder
  def initialize(model)
    @model = model
  end
  
  def method_missing(method_name, *args, &amp;block)
    if method_name.to_s.start_with?(&#39;find_by_&#39;)
      attribute = method_name.to_s.sub(&#39;find_by_&#39;, &#39;&#39;)
      @model.find_by(attribute =&gt; args.first)
    else
      super
    end
  end
  
  def respond_to_missing?(method_name, include_private = false)
    method_name.to_s.start_with?(&#39;find_by_&#39;) || super
  end
end

# Usage
finder = DynamicFinder.new(User)
finder.find_by_email(&#39;john@example.com&#39;)
finder.find_by_username(&#39;john&#39;)

# ============================================
# CONCEPT 8: Middleware (Rack AOP)
# ============================================

# Add behavior to request/response cycle

# app/middleware/request_logger.rb
class RequestLogger
  def initialize(app)
    @app = app
  end
  
  def call(env)
    start = Time.current
    
    # Before request
    request = Rack::Request.new(env)
    Rails.logger.info(&quot;Request: #{request.request_method} #{request.path}&quot;)
    
    # Call next middleware
    status, headers, response = @app.call(env)
    
    # After request
    duration = Time.current - start
    Rails.logger.info(&quot;Response: #{status} (#{duration}s)&quot;)
    
    [status, headers, response]
  end
end

# config/application.rb
config.middleware.use RequestLogger

# app/middleware/request_id.rb
class RequestId
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request_id = SecureRandom.uuid
    env[&#39;HTTP_X_REQUEST_ID&#39;] = request_id
    
    status, headers, response = @app.call(env)
    
    headers[&#39;X-Request-ID&#39;] = request_id
    [status, headers, response]
  end
end
</code></pre>
<hr>
<h3>Real-World AOP Examples</h3>
<pre><code class="language-ruby"># ============================================
# EXAMPLE 1: Performance Monitoring
# ============================================

module PerformanceMonitoring
  extend ActiveSupport::Concern
  
  class_methods do
    def monitor_performance(method_name)
      original_method = instance_method(method_name)
      
      define_method(method_name) do |*args, &amp;block|
        start = Time.current
        result = original_method.bind(self).call(*args, &amp;block)
        duration = Time.current - start
        
        if duration &gt; 1  # Slow query threshold
          Rails.logger.warn(
            &quot;Slow method: #{self.class}##{method_name} took #{duration}s&quot;
          )
        end
        
        result
      end
    end
  end
end

# Usage
class User &lt; ApplicationRecord
  include PerformanceMonitoring
  
  def complex_calculation
    # Expensive operation
  end
  
  monitor_performance :complex_calculation
end

# ============================================
# EXAMPLE 2: Automatic Retry
# ============================================

module Retryable
  extend ActiveSupport::Concern
  
  class_methods do
    def retry_on_failure(method_name, max_retries: 3, delay: 1)
      original_method = instance_method(method_name)
      
      define_method(method_name) do |*args, &amp;block|
        retries = 0
        begin
          original_method.bind(self).call(*args, &amp;block)
        rescue =&gt; e
          retries += 1
          if retries &lt; max_retries
            sleep(delay * retries)  # Exponential backoff
            retry
          else
            raise e
          end
        end
      end
    end
  end
end

# Usage
class ApiClient
  include Retryable
  
  def fetch_data
    HTTParty.get(&#39;https://api.example.com/data&#39;)
  end
  
  retry_on_failure :fetch_data, max_retries: 5, delay: 2
end

# ============================================
# EXAMPLE 3: Memoization
# ============================================

module Memoizable
  extend ActiveSupport::Concern
  
  class_methods do
    def memoize(method_name)
      original_method = instance_method(method_name)
      
      define_method(method_name) do |*args|
        @_memoized ||= {}
        cache_key = [method_name, args]
        
        @_memoized[cache_key] ||= original_method.bind(self).call(*args)
      end
    end
  end
end

# Usage
class Report
  include Memoizable
  
  def expensive_calculation(param)
    # Complex calculation
    sleep 2
    param * 100
  end
  
  memoize :expensive_calculation
end

report = Report.new
report.expensive_calculation(5)  # Takes 2 seconds
report.expensive_calculation(5)  # Instant (memoized)
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Concerns</strong>: Extract shared behavior (ActiveSupport::Concern)</li>
<li><strong>Callbacks</strong>: Add behavior before/after actions</li>
<li><strong>Around actions</strong>: Wrap behavior around methods</li>
<li><strong>Prepend</strong>: Cleanly extend methods</li>
<li><strong>Notifications</strong>: Instrument code blocks</li>
<li><strong>Middleware</strong>: Add behavior to request/response</li>
<li><strong>Method missing</strong>: Dynamic method interception</li>
<li><strong>Cross-cutting concerns</strong>: Logging, caching, transactions</li>
<li><strong>Don&#39;t overuse</strong>: AOP can make code harder to follow</li>
<li><strong>Use conventions</strong>: Rails provides AOP through callbacks and concerns</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Architecture Styles</h2>
<h2>Question 325: What is monolithic architecture?</h2>
<h3>Answer</h3>
<p><strong>Monolithic architecture</strong> is a traditional software design where all components (UI, business logic, data access) are built, deployed, and scaled as a single unit. A typical Rails application is monolithic by default.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Single codebase</strong>: One application, one deployment</li>
<li><strong>Shared database</strong>: All features use same database</li>
<li><strong>Tightly coupled</strong>: Components depend on each other</li>
<li><strong>Simple deployment</strong>: Deploy entire application at once</li>
<li><strong>Easier development</strong>: Single codebase, familiar patterns</li>
<li><strong>Rails default</strong>: Standard Rails app is monolithic</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<pre><code class="language-ruby"># ============================================
# MONOLITHIC RAILS APPLICATION STRUCTURE
# ============================================

# Typical Rails monolith structure:
# 
# my_app/
# ├── app/
# │   ├── controllers/    # All controllers
# │   ├── models/         # All models
# │   ├── views/          # All views
# │   ├── jobs/           # All background jobs
# │   ├── mailers/        # All mailers
# │   └── services/       # All services
# ├── db/                 # Single database
# ├── config/             # Shared configuration
# └── lib/                # Shared libraries

# Single database.yml
# config/database.yml
production:
  adapter: postgresql
  database: myapp_production
  # One database for everything

# All features in one app:
# - User management
# - Blog posts
# - E-commerce
# - Admin panel
# - API
# - Background jobs
# All deployed together

# ============================================
# MONOLITH CHARACTERISTICS
# ============================================

# 1. Single Deployment Unit
# - One application server
# - One deployment process
# - All features deployed together

# Deployment
# git push heroku main
# All code deploys at once

# 2. Shared Database
class User &lt; ApplicationRecord
  has_many :posts
  has_many :orders
  has_many :comments
end

class Post &lt; ApplicationRecord
  belongs_to :user
  has_many :comments
end

class Order &lt; ApplicationRecord
  belongs_to :user
  has_many :line_items
end

# All in same database with foreign keys

# 3. Shared Code
# app/services/notification_service.rb
class NotificationService
  def notify(user, message)
    # Used by all features
    UserMailer.notification(user, message).deliver_later
    PushNotification.send(user, message)
  end
end

# Called from everywhere:
# - Posts controller
# - Orders controller
# - Admin controller

# 4. Single Technology Stack
# - One Rails version
# - One Ruby version
# - One set of gems
# - Shared dependencies

# Gemfile (shared by all features)
gem &#39;rails&#39;, &#39;~&gt; 7.0&#39;
gem &#39;pg&#39;
gem &#39;redis&#39;
gem &#39;sidekiq&#39;
# Everyone uses same versions

# ============================================
# MONOLITH EXAMPLE: E-Commerce App
# ============================================

# app/controllers/products_controller.rb
class ProductsController &lt; ApplicationController
  def index
    @products = Product.all
  end
  
  def show
    @product = Product.find(params[:id])
    @related = @product.related_products
  end
end

# app/controllers/orders_controller.rb
class OrdersController &lt; ApplicationController
  def create
    @order = Order.new(order_params)
    @order.user = current_user
    
    if @order.save
      # Process payment (in same app)
      PaymentService.new(@order).process
      
      # Send email (in same app)
      OrderMailer.confirmation(@order).deliver_later
      
      # Update inventory (in same app)
      InventoryService.new(@order).update
      
      redirect_to @order
    else
      render :new
    end
  end
end

# app/controllers/admin/products_controller.rb
class Admin::ProductsController &lt; ApplicationController
  before_action :require_admin
  
  def index
    @products = Product.all
  end
end

# All in same codebase, same deployment

# ============================================
# MONOLITH ADVANTAGES
# ============================================

# 1. Simple Development
# - Everything in one place
# - Easy to navigate
# - Familiar Rails patterns
# - Fast local development

# 2. Easy Debugging
# - Single codebase to search
# - Complete stack traces
# - Can step through entire flow
# - Simple logs

# Example: Debug order creation
def create
  debugger  # Can step through entire flow
  @order = Order.create(order_params)
  PaymentService.process(@order)
  InventoryService.update(@order)
end

# 3. ACID Transactions
# - Database transactions work across features
# - Data consistency guaranteed

Order.transaction do
  order = Order.create!(order_params)
  Payment.create!(order: order, amount: order.total)
  Inventory.decrement!(order.product_id, order.quantity)
  # All or nothing - guaranteed consistency
end

# 4. Simple Deployment
# - One deployment
# - No service coordination
# - Easier rollbacks
# - Less infrastructure

# Deploy entire app
git push heroku main
# Everything updates together

# Rollback if needed
heroku rollback
# Everything rolls back together

# 5. Performance (Initial)
# - No network calls between features
# - Fast method calls
# - Shared cache
# - No serialization overhead

# Fast in-process call
result = PaymentService.process(order)  # Microseconds

# vs Microservice HTTP call
result = HTTParty.post(&#39;http://payment-service/process&#39;, ...)  # Milliseconds

# 6. Easier Testing
# - Test entire flow
# - No mocking external services
# - Integration tests work naturally

# test/integration/order_flow_test.rb
test &quot;complete order flow&quot; do
  product = create(:product)
  user = create(:user)
  
  # Test entire flow in one test
  login_as(user)
  visit product_path(product)
  click_button &quot;Add to Cart&quot;
  click_button &quot;Checkout&quot;
  fill_in_payment_details
  click_button &quot;Place Order&quot;
  
  assert_text &quot;Order confirmed&quot;
  # Can verify order, payment, inventory all updated
end

# ============================================
# MONOLITH CHALLENGES
# ============================================

# 1. Scaling Limitations
# - Must scale entire app
# - Can&#39;t scale individual features
# - Wastes resources

# Example: Only admin panel needs more resources
# But must scale entire app including:
# - User-facing features
# - API
# - Background jobs
# All scale together (wasteful)

# 2. Long Build/Deploy Times
# - Large codebase takes time to build
# - Tests run longer
# - Deployments slower

# Deployment timeline for large monolith:
# - Bundle install: 5 minutes
# - Asset compilation: 3 minutes
# - Database migrations: 2 minutes
# - Deploy: 2 minutes
# - Total: 12 minutes per deployment

# 3. Team Coordination
# - Multiple teams work on same codebase
# - Merge conflicts
# - Deploy coordination
# - Testing conflicts

# Team A working on feature X
# Team B working on feature Y
# Both need to coordinate deployments

# 4. Technology Lock-in
# - Stuck with same stack
# - Hard to experiment
# - Legacy code accumulates

# Want to try new tech?
# - Can&#39;t use different database for one feature
# - Can&#39;t use different language for one service
# - Must upgrade entire app at once

# 5. Database Bottleneck
# - Single database for everything
# - All features compete for connections
# - Hard to optimize for different needs

# app/models/product.rb
class Product &lt; ApplicationRecord
  # Needs read-optimized database
end

# app/models/analytics_event.rb
class AnalyticsEvent &lt; ApplicationRecord
  # Needs write-optimized database
end

# Both stuck with same database configuration

# ============================================
# MONOLITH EVOLUTION STAGES
# ============================================

# Stage 1: Small Monolith (&lt; 10K LOC)
# - Fast development
# - Easy to understand
# - Single developer/small team
# - Perfect for this stage ✓

# Stage 2: Medium Monolith (10K-50K LOC)
# - Still manageable
# - Need good organization
# - Use concerns, services
# - Performance optimization needed

# Stage 3: Large Monolith (50K-200K LOC)
# - Harder to navigate
# - Longer build times
# - Team coordination issues
# - Consider modular monolith

# Stage 4: Massive Monolith (200K+ LOC)
# - Very slow development
# - Deployment risk
# - Consider microservices
# - Or well-structured modular monolith

# ============================================
# ORGANIZING A MONOLITH
# ============================================

# Good monolith structure (by feature):

# app/
# ├── products/          # Product feature
# │   ├── controllers/
# │   ├── models/
# │   ├── services/
# │   └── views/
# ├── orders/            # Orders feature
# │   ├── controllers/
# │   ├── models/
# │   ├── services/
# │   └── views/
# └── users/             # Users feature
#     ├── controllers/
#     ├── models/
#     ├── services/
#     └── views/

# Rails doesn&#39;t support this natively
# But you can organize with namespaces:

# app/controllers/products/
# ├── products_controller.rb
# ├── reviews_controller.rb
# └── inventory_controller.rb

# app/models/products/
# ├── product.rb
# ├── review.rb
# └── inventory.rb

# app/services/products/
# ├── search_service.rb
# └── recommendation_service.rb

# ============================================
# WHEN TO USE MONOLITH
# ============================================

# ✓ Use Monolith when:
# - Starting new project
# - Small to medium team (&lt; 20 developers)
# - Rapid iteration needed
# - Requirements unclear
# - Resources limited
# - Need ACID transactions
# - Simple deployment preferred

# Examples:
# - MVP/Startup
# - Internal tools
# - Small SaaS
# - Content management
# - Most web applications

# Real examples of successful monoliths:
# - Shopify (well-organized monolith)
# - GitHub (mostly monolithic)
# - Basecamp (monolithic by choice)
# - Many successful startups
</code></pre>
<hr>
<h3>Monolith Best Practices</h3>
<pre><code class="language-ruby"># 1. Organize by feature/domain
# Not by type (models, controllers)

# 2. Use service objects
# Keep controllers thin
class OrdersController &lt; ApplicationController
  def create
    service = CreateOrderService.new(current_user, order_params)
    if service.call
      redirect_to service.order
    else
      @errors = service.errors
      render :new
    end
  end
end

# 3. Enforce boundaries
# Use modules/namespaces
module Orders
  class CreateService
    # Order-related logic only
  end
end

module Products
  class SearchService
    # Product-related logic only
  end
end

# 4. Keep models focused
# Extract to service objects when needed

# 5. Use background jobs
# Don&#39;t block web requests
class OrdersController &lt; ApplicationController
  def create
    @order = Order.create!(order_params)
    ProcessOrderJob.perform_later(@order.id)
    redirect_to @order
  end
end

# 6. Monitor and optimize
# - Track slow queries
# - Monitor memory usage
# - Profile regularly

# 7. Database optimization
# - Proper indexes
# - Query optimization
# - Connection pooling

# 8. Caching strategy
# - Fragment caching
# - Query caching
# - HTTP caching
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Monolith</strong>: Single codebase, single deployment</li>
<li><strong>Rails default</strong>: Standard Rails app is monolithic</li>
<li><strong>Advantages</strong>: Simple, fast development, easy debugging</li>
<li><strong>Challenges</strong>: Scaling, deployment time, team coordination</li>
<li><strong>Best for</strong>: Small/medium teams, rapid iteration</li>
<li><strong>Not inherently bad</strong>: Many successful companies use monoliths</li>
<li><strong>Organize well</strong>: Use services, concerns, namespaces</li>
<li><strong>Scale vertically</strong>: Most monoliths never outgrow single server</li>
<li><strong>Consider modular</strong>: Before microservices</li>
<li><strong>Start simple</strong>: Monolith is the right choice for most new projects</li>
</ol>
<hr>
<h2>Question 326: What is microservice architecture?</h2>
<h3>Answer</h3>
<p><strong>Microservice architecture</strong> is a design where an application is split into small, independent services that communicate over network protocols. Each service owns its data, can be deployed independently, and focuses on a single business capability.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Multiple services</strong>: Each service is separate application</li>
<li><strong>Independent deployment</strong>: Deploy services separately</li>
<li><strong>Own database</strong>: Each service has its own database</li>
<li><strong>Network communication</strong>: Services talk via HTTP/gRPC/messaging</li>
<li><strong>Technology freedom</strong>: Each service can use different stack</li>
<li><strong>Complexity</strong>: More infrastructure, harder to debug</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# MICROSERVICES ARCHITECTURE
# ============================================

# Application split into services:
# 
# ┌─────────────────┐
# │   API Gateway   │
# └────────┬────────┘
#          │
#    ┌─────┴─────┐
#    │           │
# ┌──▼──┐    ┌──▼──┐    ┌──────┐    ┌──────┐
# │Users│    │Posts│    │Orders│    │Payment│
# │Service   │Service   │Service    │Service│
# └──┬──┘    └──┬──┘    └──┬───┘    └──┬───┘
#    │          │           │            │
# ┌──▼──┐    ┌─▼───┐    ┌──▼───┐    ┌──▼───┐
# │Users│    │Posts│    │Orders│    │Payment│
# │ DB  │    │ DB  │    │  DB  │    │  DB  │
# └─────┘    └─────┘    └──────┘    └──────┘

# Each service:
# - Separate Rails application
# - Own database
# - Independent deployment
# - Network communication

# ============================================
# SERVICE 1: User Service
# ============================================

# users-service/
# ├── app/
# │   ├── controllers/
# │   │   └── api/
# │   │       └── users_controller.rb
# │   └── models/
# │       └── user.rb
# ├── config/
# │   └── database.yml
# └── Gemfile

# config/database.yml (User Service)
production:
  adapter: postgresql
  database: users_service_production
  # Separate database

# app/controllers/api/users_controller.rb
module Api
  class UsersController &lt; ApplicationController
    # GET /api/users/:id
    def show
      @user = User.find(params[:id])
      render json: @user
    end
    
    # POST /api/users
    def create
      @user = User.new(user_params)
      
      if @user.save
        render json: @user, status: :created
      else
        render json: {errors: @user.errors}, status: :unprocessable_entity
      end
    end
    
    # GET /api/users/:id/profile
    def profile
      @user = User.find(params[:id])
      
      render json: {
        id: @user.id,
        name: @user.name,
        email: @user.email,
        created_at: @user.created_at
      }
    end
  end
end

# app/models/user.rb
class User &lt; ApplicationRecord
  # Only user data, no associations to other services
  validates :email, presence: true, uniqueness: true
  validates :name, presence: true
end

# Deploy: Separate deployment
# Runs on: users-service.example.com

# ============================================
# SERVICE 2: Posts Service
# ============================================

# posts-service/
# config/database.yml (Posts Service)
production:
  adapter: postgresql
  database: posts_service_production
  # Different database

# app/controllers/api/posts_controller.rb
module Api
  class PostsController &lt; ApplicationController
    def index
      @posts = Post.all
      
      # Fetch user data from User Service
      user_ids = @posts.pluck(:user_id).uniq
      users = fetch_users(user_ids)
      
      render json: @posts.map { |post|
        {
          id: post.id,
          title: post.title,
          body: post.body,
          user: users[post.user_id]  # User data from other service
        }
      }
    end
    
    def create
      # Verify user exists (call User Service)
      user = fetch_user(params[:user_id])
      return render json: {error: &#39;User not found&#39;}, status: :not_found unless user
      
      @post = Post.new(post_params)
      
      if @post.save
        render json: @post, status: :created
      else
        render json: {errors: @post.errors}, status: :unprocessable_entity
      end
    end
    
    private
    
    def fetch_users(user_ids)
      response = HTTParty.get(
        &quot;#{ENV[&#39;USERS_SERVICE_URL&#39;]}/api/users&quot;,
        query: {ids: user_ids}
      )
      
      response.parsed_response.index_by { |u| u[&#39;id&#39;] }
    rescue =&gt; e
      Rails.logger.error(&quot;Failed to fetch users: #{e.message}&quot;)
      {}
    end
    
    def fetch_user(user_id)
      response = HTTParty.get(&quot;#{ENV[&#39;USERS_SERVICE_URL&#39;]}/api/users/#{user_id}&quot;)
      response.parsed_response
    rescue =&gt; e
      Rails.logger.error(&quot;Failed to fetch user: #{e.message}&quot;)
      nil
    end
  end
end

# app/models/post.rb
class Post &lt; ApplicationRecord
  # Only stores user_id, not actual user object
  validates :user_id, presence: true
  validates :title, presence: true
end

# Deploy: Separate deployment
# Runs on: posts-service.example.com

# ============================================
# SERVICE 3: Orders Service
# ============================================

# orders-service/
# config/database.yml (Orders Service)
production:
  adapter: postgresql
  database: orders_service_production

# app/controllers/api/orders_controller.rb
module Api
  class OrdersController &lt; ApplicationController
    def create
      # Call User Service to verify user
      user = fetch_user(params[:user_id])
      return render json: {error: &#39;User not found&#39;}, status: :not_found unless user
      
      # Call Product Service to get product details
      product = fetch_product(params[:product_id])
      return render json: {error: &#39;Product not found&#39;}, status: :not_found unless product
      
      @order = Order.new(
        user_id: params[:user_id],
        product_id: params[:product_id],
        quantity: params[:quantity],
        price: product[&#39;price&#39;]
      )
      
      if @order.save
        # Call Payment Service asynchronously
        ProcessPaymentJob.perform_later(@order.id)
        
        render json: @order, status: :created
      else
        render json: {errors: @order.errors}, status: :unprocessable_entity
      end
    end
    
    private
    
    def fetch_user(user_id)
      response = HTTParty.get(&quot;#{ENV[&#39;USERS_SERVICE_URL&#39;]}/api/users/#{user_id}&quot;)
      response.parsed_response
    rescue =&gt; e
      nil
    end
    
    def fetch_product(product_id)
      response = HTTParty.get(&quot;#{ENV[&#39;PRODUCTS_SERVICE_URL&#39;]}/api/products/#{product_id}&quot;)
      response.parsed_response
    rescue =&gt; e
      nil
    end
  end
end

# app/jobs/process_payment_job.rb
class ProcessPaymentJob &lt; ApplicationJob
  def perform(order_id)
    order = Order.find(order_id)
    
    # Call Payment Service
    response = HTTParty.post(
      &quot;#{ENV[&#39;PAYMENT_SERVICE_URL&#39;]}/api/payments&quot;,
      body: {
        order_id: order.id,
        amount: order.total,
        user_id: order.user_id
      }.to_json,
      headers: {&#39;Content-Type&#39; =&gt; &#39;application/json&#39;}
    )
    
    if response.success?
      order.update(status: &#39;paid&#39;, payment_id: response[&#39;id&#39;])
    else
      order.update(status: &#39;payment_failed&#39;)
    end
  end
end

# ============================================
# SERVICE 4: Payment Service
# ============================================

# payment-service/
# config/database.yml (Payment Service)
production:
  adapter: postgresql
  database: payment_service_production

# app/controllers/api/payments_controller.rb
module Api
  class PaymentsController &lt; ApplicationController
    def create
      @payment = Payment.new(payment_params)
      
      if @payment.save
        # Process with Stripe
        charge = Stripe::Charge.create(
          amount: (@payment.amount * 100).to_i,
          currency: &#39;usd&#39;,
          source: @payment.token
        )
        
        @payment.update(
          status: &#39;completed&#39;,
          stripe_charge_id: charge.id
        )
        
        render json: @payment, status: :created
      else
        render json: {errors: @payment.errors}, status: :unprocessable_entity
      end
    rescue Stripe::CardError =&gt; e
      @payment.update(status: &#39;failed&#39;, error: e.message)
      render json: {error: e.message}, status: :unprocessable_entity
    end
  end
end

# ============================================
# API GATEWAY (Routes requests to services)
# ============================================

# api-gateway/
# app/controllers/gateway_controller.rb
class GatewayController &lt; ApplicationController
  # Route to appropriate service
  
  def handle_request
    service_url = determine_service(request.path)
    
    response = HTTParty.send(
      request.method.downcase,
      &quot;#{service_url}#{request.path}&quot;,
      body: request.body.read,
      headers: forward_headers
    )
    
    render json: response.parsed_response, status: response.code
  end
  
  private
  
  def determine_service(path)
    case path
    when %r{^/api/users}
      ENV[&#39;USERS_SERVICE_URL&#39;]
    when %r{^/api/posts}
      ENV[&#39;POSTS_SERVICE_URL&#39;]
    when %r{^/api/orders}
      ENV[&#39;ORDERS_SERVICE_URL&#39;]
    when %r{^/api/payments}
      ENV[&#39;PAYMENT_SERVICE_URL&#39;]
    else
      raise &quot;Unknown service for path: #{path}&quot;
    end
  end
  
  def forward_headers
    {
      &#39;Content-Type&#39; =&gt; request.content_type,
      &#39;Authorization&#39; =&gt; request.headers[&#39;Authorization&#39;]
    }
  end
end

# ============================================
# SERVICE DISCOVERY
# ============================================

# Use Consul, Eureka, or simple config

# config/services.yml
services:
  users:
    url: https://users-service.example.com
    health_check: /health
  posts:
    url: https://posts-service.example.com
    health_check: /health
  orders:
    url: https://orders-service.example.com
    health_check: /health
  payments:
    url: https://payments-service.example.com
    health_check: /health

# lib/service_registry.rb
class ServiceRegistry
  def self.url_for(service_name)
    services = YAML.load_file(Rails.root.join(&#39;config/services.yml&#39;))
    services[&#39;services&#39;][service_name.to_s][&#39;url&#39;]
  end
  
  def self.healthy?(service_name)
    url = url_for(service_name)
    health_check = services[&#39;services&#39;][service_name.to_s][&#39;health_check&#39;]
    
    response = HTTParty.get(&quot;#{url}#{health_check}&quot;, timeout: 2)
    response.success?
  rescue
    false
  end
end

# Usage
ServiceRegistry.url_for(:users)  # =&gt; &quot;https://users-service.example.com&quot;
ServiceRegistry.healthy?(:users)  # =&gt; true/false
</code></pre>
<hr>
<h3>Service Communication Patterns</h3>
<pre><code class="language-ruby"># ============================================
# PATTERN 1: Synchronous HTTP (REST)
# ============================================

# Simple but creates coupling
class PostsService
  def create_post(user_id, title, body)
    # Synchronous call to User Service
    user = HTTParty.get(&quot;#{USERS_SERVICE_URL}/api/users/#{user_id}&quot;)
    
    return {error: &#39;User not found&#39;} unless user.success?
    
    # Create post
    post = Post.create!(user_id: user_id, title: title, body: body)
    
    # Notify User Service (fire and forget)
    HTTParty.post(&quot;#{USERS_SERVICE_URL}/api/users/#{user_id}/increment_posts&quot;)
    
    post
  end
end

# ============================================
# PATTERN 2: Asynchronous Messaging (Recommended)
# ============================================

# Using RabbitMQ/Kafka
gem &#39;bunny&#39;  # RabbitMQ client

# Publish event
class Order &lt; ApplicationRecord
  after_create :publish_order_created_event
  
  private
  
  def publish_order_created_event
    EventPublisher.publish(
      &#39;order.created&#39;,
      {
        order_id: id,
        user_id: user_id,
        total: total,
        created_at: created_at
      }
    )
  end
end

# lib/event_publisher.rb
class EventPublisher
  def self.publish(event_type, data)
    connection = Bunny.new(ENV[&#39;RABBITMQ_URL&#39;])
    connection.start
    
    channel = connection.create_channel
    exchange = channel.topic(&#39;events&#39;, durable: true)
    
    exchange.publish(
      data.to_json,
      routing_key: event_type,
      persistent: true
    )
    
    connection.close
  end
end

# Subscribe to events in other services
# payment-service/app/jobs/event_consumer_job.rb
class EventConsumerJob &lt; ApplicationJob
  def perform
    connection = Bunny.new(ENV[&#39;RABBITMQ_URL&#39;])
    connection.start
    
    channel = connection.create_channel
    exchange = channel.topic(&#39;events&#39;, durable: true)
    queue = channel.queue(&#39;payment-service&#39;, durable: true)
    
    queue.bind(exchange, routing_key: &#39;order.created&#39;)
    
    queue.subscribe(block: true) do |delivery_info, properties, body|
      data = JSON.parse(body)
      handle_order_created(data)
    end
  end
  
  private
  
  def handle_order_created(data)
    # Process payment for order
    ProcessPaymentJob.perform_later(data[&#39;order_id&#39;])
  end
end

# ============================================
# PATTERN 3: Event Sourcing
# ============================================

# Store all events, rebuild state from events
class Event &lt; ApplicationRecord
  serialize :data, JSON
end

# Publish event
Event.create!(
  event_type: &#39;OrderCreated&#39;,
  aggregate_id: order.id,
  data: {
    user_id: order.user_id,
    total: order.total
  }
)

# Rebuild state from events
class OrderProjection
  def self.rebuild(order_id)
    events = Event.where(aggregate_id: order_id).order(:created_at)
    
    order = Order.new
    events.each do |event|
      apply_event(order, event)
    end
    order
  end
  
  def self.apply_event(order, event)
    case event.event_type
    when &#39;OrderCreated&#39;
      order.assign_attributes(event.data)
    when &#39;OrderPaid&#39;
      order.status = &#39;paid&#39;
    when &#39;OrderShipped&#39;
      order.status = &#39;shipped&#39;
    end
  end
end
</code></pre>
<hr>
<h3>Microservices Challenges</h3>
<pre><code class="language-ruby"># ============================================
# CHALLENGE 1: Distributed Transactions
# ============================================

# Problem: Can&#39;t use database transactions across services

# ❌ This doesn&#39;t work across services:
ActiveRecord::Base.transaction do
  # In Orders Service
  order = Order.create!(order_params)
  
  # In Payment Service (different database!)
  payment = PaymentService.create_payment(order)  # HTTP call
  
  # In Inventory Service (different database!)
  InventoryService.decrement_stock(order)  # HTTP call
end
# If payment/inventory fails, order is already created!

# ✅ Solution: Saga Pattern (see Q330)

# ============================================
# CHALLENGE 2: Data Consistency
# ============================================

# Problem: Data out of sync between services

# User Service has: user.name = &quot;John&quot;
# Posts Service cached: user.name = &quot;Johnny&quot; (old)

# Solution: Event-driven updates
# User Service publishes: UserUpdated event
# Posts Service subscribes and updates cache

# ============================================
# CHALLENGE 3: Testing
# ============================================

# Problem: Can&#39;t test across services easily

# ❌ Integration test doesn&#39;t work:
test &quot;create order&quot; do
  # Needs Users Service running
  # Needs Products Service running
  # Needs Payment Service running
  post orders_path, params: {...}
end

# ✅ Solution: Contract testing
# Use Pact or similar
# Or extensive mocking

# ============================================
# CHALLENGE 4: Debugging
# ============================================

# Problem: Error spans multiple services

# Request flow:
# API Gateway → User Service → Order Service → Payment Service
#                                                      ↓ (fails here)

# Hard to debug:
# - Which service failed?
# - What was the request data?
# - Where did it start?

# Solution: Distributed tracing
# Use Jaeger, Zipkin, or similar

# Add request ID to all logs
class ApplicationController &lt; ActionController::Base
  before_action :set_request_id
  
  private
  
  def set_request_id
    RequestStore.store[:request_id] = request.headers[&#39;X-Request-ID&#39;] || SecureRandom.uuid
  end
end

# Pass request ID to other services
HTTParty.get(url, headers: {&#39;X-Request-ID&#39; =&gt; RequestStore.store[:request_id]})

# ============================================
# CHALLENGE 5: Deployment Complexity
# ============================================

# 10 services = 10 deployments
# Need:
# - CI/CD for each service
# - Monitoring for each service
# - Logging for each service
# - Database migrations coordination

# Example deployment pipeline:
# 1. Run tests for service
# 2. Build Docker image
# 3. Push to registry
# 4. Update Kubernetes deployment
# 5. Run database migrations
# 6. Health check
# 7. Rollback if failed

# × 10 services = complex!
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Microservices</strong>: Multiple small services</li>
<li><strong>Independent</strong>: Each service deployed separately</li>
<li><strong>Own database</strong>: No shared database</li>
<li><strong>Network calls</strong>: Services communicate over network</li>
<li><strong>Complexity</strong>: Much more complex than monolith</li>
<li><strong>When to use</strong>: Large teams, different scaling needs</li>
<li><strong>Challenges</strong>: Distributed transactions, debugging, testing</li>
<li><strong>Not always better</strong>: Most apps don&#39;t need microservices</li>
<li><strong>Start monolith</strong>: Can split later if needed</li>
<li><strong>Consider modular monolith</strong>: Middle ground option</li>
</ol>
<hr>
<h2>Question 327: What is the difference between monolithic and microservice?</h2>
<h3>Answer</h3>
<p>The main differences are <strong>deployment</strong> (single vs multiple), <strong>database</strong> (shared vs separate), <strong>scaling</strong> (all-together vs independent), <strong>technology</strong> (unified vs diverse), <strong>complexity</strong> (simple vs complex), and <strong>team structure</strong> (centralized vs distributed).</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Deployment</strong>: Monolith = one unit, Microservices = many units</li>
<li><strong>Database</strong>: Monolith = shared DB, Microservices = DB per service</li>
<li><strong>Scaling</strong>: Monolith = scale all, Microservices = scale individually</li>
<li><strong>Complexity</strong>: Monolith = simpler, Microservices = more complex</li>
<li><strong>Team size</strong>: Monolith = small teams, Microservices = large teams</li>
<li><strong>Transaction</strong>: Monolith = ACID easy, Microservices = distributed transactions</li>
</ul>
<hr>
<h3>Detailed Comparison</h3>
<pre><code class="language-ruby"># ============================================
# COMPARISON TABLE
# ============================================

# Aspect          | Monolithic           | Microservices
# ----------------|---------------------|----------------------
# Codebase        | Single repo         | Multiple repos
# Deployment      | One deployment      | Many deployments
# Database        | Shared database     | Database per service
# Scaling         | Scale entire app    | Scale services independently
# Technology      | One stack           | Multiple stacks possible
# Communication   | Method calls        | Network calls (HTTP/RPC)
# Transactions    | ACID guaranteed     | Eventual consistency
# Development     | Faster initially    | Slower initially
# Testing         | Easy integration    | Complex integration
# Debugging       | Simple              | Complex (distributed)
# Infrastructure  | Simple              | Complex (orchestration)
# Team structure  | Centralized         | Distributed by service
# Best for        | Small/medium teams  | Large teams (50+)
# Cost            | Lower initially     | Higher (infrastructure)

# ============================================
# DETAILED COMPARISONS
# ============================================

# 1. CODEBASE &amp; DEPLOYMENT
# ========================

# MONOLITH
# Single repository
my-app/
  app/
    controllers/
    models/
    services/

# Deploy once
git push heroku main
# Everything deploys together
# All or nothing

# MICROSERVICES
# Multiple repositories
users-service/
posts-service/
orders-service/
payment-service/

# Deploy separately
git push heroku main (users-service)
git push heroku main (posts-service)
# Independent deployments
# Can deploy one without affecting others

# 2. DATABASE ARCHITECTURE
# =========================

# MONOLITH - Shared Database
class User &lt; ApplicationRecord
  has_many :posts
  has_many :orders
end

class Post &lt; ApplicationRecord
  belongs_to :user  # Direct foreign key
end

class Order &lt; ApplicationRecord
  belongs_to :user  # Direct foreign key
end

# All in same database:
# users table
# posts table (with user_id FK)
# orders table (with user_id FK)

# Can use JOINs:
User.joins(:posts).where(posts: {published: true})

# MICROSERVICES - Separate Databases
# Users Service
class User &lt; ApplicationRecord
  # No associations to other services
end
# Database: users_service_db

# Posts Service
class Post &lt; ApplicationRecord
  # Only stores user_id (no foreign key!)
  # Can&#39;t join to users table
end
# Database: posts_service_db

# Orders Service
class Order &lt; ApplicationRecord
  # Only stores user_id (no foreign key!)
end
# Database: orders_service_db

# Must fetch user separately:
post = Post.find(1)
user = HTTParty.get(&quot;#{USER_SERVICE_URL}/users/#{post.user_id}&quot;)

# 3. SCALING
# ===========

# MONOLITH - Scale Everything Together
# Need more capacity?
# Must scale entire application

# Before: 2 servers
# - Serving: Users, Posts, Orders, Admin
# - Memory: 500MB each
# - CPU: 50% each

# After scaling: 6 servers
# - Still serving: Users, Posts, Orders, Admin
# - Memory: 500MB each
# - CPU: 50% each
# Problem: Scaled admin panel even though only users needed more capacity

# Cost: 2 servers → 6 servers (3x cost)
# Wasted: 4 extra servers running admin panel unnecessarily

# MICROSERVICES - Scale Independently
# Before:
# Users Service: 2 servers (high load)
# Posts Service: 2 servers (medium load)
# Orders Service: 1 server (low load)
# Admin Service: 1 server (low load)

# After scaling only Users Service:
# Users Service: 6 servers (scaled for high load)
# Posts Service: 2 servers (unchanged)
# Orders Service: 1 server (unchanged)
# Admin Service: 1 server (unchanged)

# Cost: 6 servers → 10 servers
# Efficient: Only scaled what needed scaling

# 4. TECHNOLOGY CHOICES
# ======================

# MONOLITH - Single Stack
# Gemfile
gem &#39;rails&#39;, &#39;7.0&#39;
gem &#39;pg&#39;
gem &#39;redis&#39;
# Everyone uses same versions

# Want to try new database?
# Must change entire app

# Want to use different language?
# Can&#39;t (everything is Ruby)

# MICROSERVICES - Technology Freedom
# Users Service:
# - Ruby on Rails 7.0
# - PostgreSQL
# - Redis

# Analytics Service:
# - Python (better for data processing)
# - Cassandra (better for time-series)
# - No Redis needed

# Recommendations Service:
# - Node.js (good for real-time)
# - Neo4j (graph database)
# - Redis

# Each service picks best technology for its needs

# 5. COMMUNICATION
# =================

# MONOLITH - In-Process Calls
class OrdersController &lt; ApplicationController
  def create
    @order = Order.create!(order_params)
    
    # In-process method call (fast!)
    PaymentService.process(@order)  # Microseconds
    EmailService.send_confirmation(@order)  # Microseconds
    
    redirect_to @order
  end
end

# Fast: Direct method calls
# Simple: Same memory space
# Synchronous: Immediate response

# MICROSERVICES - Network Calls
class OrdersController &lt; ApplicationController
  def create
    # Call User Service (network)
    user = HTTParty.get(&quot;#{USER_SERVICE_URL}/users/#{params[:user_id]}&quot;)
    return render_error unless user.success?
    
    # Create order
    @order = Order.create!(order_params)
    
    # Call Payment Service (network)
    payment = HTTParty.post(
      &quot;#{PAYMENT_SERVICE_URL}/payments&quot;,
      body: {order_id: @order.id, amount: @order.total}.to_json
    )
    
    # Call Email Service (network)
    HTTParty.post(
      &quot;#{EMAIL_SERVICE_URL}/emails/send&quot;,
      body: {type: &#39;order_confirmation&#39;, order_id: @order.id}.to_json
    )
    
    redirect_to @order
  end
end

# Slower: Network latency (10-100ms per call)
# Complex: Handle network failures
# Requires: Retry logic, timeouts, circuit breakers

# 6. TRANSACTIONS
# ================

# MONOLITH - ACID Transactions
Order.transaction do
  order = Order.create!(order_params)
  payment = Payment.create!(order: order, amount: order.total)
  Inventory.decrement!(order.product_id, order.quantity)
  
  # All or nothing - guaranteed!
  # If any fails, all rolls back
end

# Simple: Database handles it
# Consistent: Data always valid
# Reliable: ACID guarantees

# MICROSERVICES - Distributed Transactions
# 1. Create order (Orders Service)
order = Order.create!(order_params)

# 2. Process payment (Payment Service)
payment = HTTParty.post(&quot;#{PAYMENT_SERVICE_URL}/payments&quot;, ...)
# What if this fails? Order already created!

# 3. Update inventory (Inventory Service)
inventory = HTTParty.post(&quot;#{INVENTORY_SERVICE_URL}/decrement&quot;, ...)
# What if this fails? Order created, payment processed!

# Problem: No ACID transactions across services
# Solution: Saga pattern (see Q330)

# 7. DEVELOPMENT SPEED
# =====================

# MONOLITH - Faster Initially
# Day 1: rails new myapp
# Day 2: Add users, posts, orders
# Day 3: Deploy to production
# ✓ Fast: Everything in one place
# ✓ Simple: Standard Rails
# ✓ Productive: Focus on features

# MICROSERVICES - Slower Initially
# Week 1: Set up infrastructure
# - Kubernetes cluster
# - Service mesh
# - API gateway
# - Service discovery
# - Distributed tracing

# Week 2: Create first service
# Week 3: Create second service
# Week 4: Set up inter-service communication
# ✗ Slow: Much infrastructure needed
# ✗ Complex: Many moving parts
# ✗ Overhead: Focus on infrastructure

# 8. TESTING
# ===========

# MONOLITH - Easy Integration Testing
test &quot;complete order flow&quot; do
  user = create(:user)
  product = create(:product)
  
  # Test entire flow in one test
  login_as(user)
  visit product_path(product)
  click_button &quot;Add to Cart&quot;
  click_button &quot;Checkout&quot;
  fill_in_payment_details
  click_button &quot;Place Order&quot;
  
  # Verify everything
  assert Order.exists?(user: user)
  assert Payment.exists?(order: Order.last)
  assert_equal product.quantity - 1, product.reload.quantity
end

# Simple: Everything in one test
# Fast: No network calls
# Reliable: Consistent environment

# MICROSERVICES - Complex Testing
# Problem: How to test across services?

# Option 1: Contract Testing (Pact)
# Each service defines contract
# Tests verify contract compliance

# Option 2: Mock External Services
test &quot;create order&quot; do
  # Mock User Service
  stub_request(:get, &quot;#{USER_SERVICE_URL}/users/1&quot;)
    .to_return(status: 200, body: {id: 1, name: &#39;John&#39;}.to_json)
  
  # Mock Payment Service
  stub_request(:post, &quot;#{PAYMENT_SERVICE_URL}/payments&quot;)
    .to_return(status: 201, body: {id: 1, status: &#39;success&#39;}.to_json)
  
  # Test
  post orders_path, params: {user_id: 1, ...}
  assert_response :success
end

# Complex: Must mock everything
# Fragile: Mocks can diverge from reality

# Option 3: End-to-End Testing
# Spin up all services
# Run tests against real services
# ✗ Slow: Starting all services takes time
# ✗ Flaky: Network issues, race conditions
# ✗ Expensive: Need test environment for all services

# 9. DEBUGGING
# =============

# MONOLITH - Simple Debugging
# Error in production:
# 1. Check logs (one place)
# 2. Find error
# 3. See complete stack trace
# 4. Reproduce locally
# 5. Fix and deploy

# Example log:
# [2025-01-15 10:00:00] ERROR: Payment failed
#   app/services/payment_service.rb:45:in `process&#39;
#   app/controllers/orders_controller.rb:23:in `create&#39;
# Complete stack trace in one log file!

# MICROSERVICES - Complex Debugging
# Error in production:
# 1. Check API Gateway logs - Request came in
# 2. Check Orders Service logs - Created order
# 3. Check Payment Service logs - Payment failed here!
# 4. But why? Check network logs
# 5. Check request ID to trace across services
# 6. Reproduce? Need all services running

# Need:
# - Distributed tracing (Jaeger, Zipkin)
# - Centralized logging (ELK stack)
# - Request ID propagation
# - Service mesh for observability

# 10. INFRASTRUCTURE COST
# ========================

# MONOLITH - Lower Cost Initially
# 1 application server: $100/month
# 1 database: $50/month
# 1 Redis: $20/month
# Total: $170/month

# At scale (100K users):
# 5 application servers: $500/month
# 1 large database: $200/month
# 1 Redis cluster: $100/month
# Total: $800/month

# MICROSERVICES - Higher Cost
# Infrastructure:
# - Kubernetes cluster: $300/month (minimum)
# - Service mesh: $100/month
# - API Gateway: $50/month
# - Monitoring (Datadog): $200/month

# Services:
# - 10 services × $50/server = $500/month
# - 10 databases × $30/db = $300/month
# - Message queue: $100/month

# Total: $1,550/month (minimum)

# At scale (100K users):
# - Infrastructure: $1,000/month
# - 30 service instances: $1,500/month
# - 10 databases: $1,000/month
# - Message queue: $300/month
# Total: $3,800/month

# Microservices cost ~5x more!
</code></pre>
<hr>
<h3>When to Choose Each</h3>
<pre><code class="language-ruby"># ============================================
# CHOOSE MONOLITH WHEN:
# ============================================

# ✅ Starting new project
# - Uncertain requirements
# - Need rapid iteration
# - Want to validate idea quickly

# ✅ Small to medium team (&lt; 20 developers)
# - Team can coordinate easily
# - Everyone knows the codebase
# - Simple communication

# ✅ Simple deployment needs
# - Deploy once a day is fine
# - Don&#39;t need zero-downtime deployments
# - Simple rollback is acceptable

# ✅ Budget constraints
# - Limited resources
# - Can&#39;t afford complex infrastructure
# - Want to focus on product, not infrastructure

# ✅ Need strong consistency
# - ACID transactions important
# - Data integrity critical
# - Can&#39;t tolerate eventual consistency

# ✅ Uniform scaling needs
# - All features scale similarly
# - No individual scaling requirements
# - Traffic patterns uniform

# Examples:
# - MVP/Startup
# - Internal tools
# - Small SaaS
# - Content management
# - E-commerce (small/medium)

# Real companies using monoliths:
# - Basecamp (by choice, philosophy)
# - GitHub (mostly monolithic)
# - Shopify (well-organized monolith)

# ============================================
# CHOOSE MICROSERVICES WHEN:
# ============================================

# ✅ Large organization (50+ developers)
# - Multiple teams
# - Need independent development
# - Team autonomy important

# ✅ Different scaling needs
# - Some features need more resources
# - Scaling patterns vary widely
# - Cost optimization important

# Example:
# - User service: Low traffic, small instances
# - Analytics service: High CPU, large instances
# - Image processing: High memory, GPUs

# ✅ Technology diversity needed
# - Different problems need different tools
# - Want to experiment with new tech
# - Legacy systems to integrate

# Example:
# - User service: Ruby on Rails
# - Recommendations: Python (ML libraries)
# - Real-time chat: Node.js (WebSockets)

# ✅ Independent deployment critical
# - Deploy multiple times per day
# - Zero-downtime required
# - Rolling deployments needed
# - Quick rollbacks important

# ✅ Team distribution
# - Multiple locations
# - Remote teams
# - Team per service

# ✅ Resilience requirements
# - Failure isolation needed
# - One service failing shouldn&#39;t kill all
# - Circuit breakers required

# Examples:
# - Large enterprises
# - High-traffic platforms
# - Complex domains
# - Global applications

# Real companies using microservices:
# - Netflix (hundreds of services)
# - Uber (2000+ services)
# - Amazon (service-oriented from start)
# - Spotify (hundreds of services)

# ============================================
# MIGRATION PATH
# ============================================

# Start: Monolith
# - Build MVP
# - Validate product
# - Learn domain

# When to consider migration:
# 1. Team size &gt; 20 developers
# 2. Deployment bottleneck (&gt; 1 hour)
# 3. Scaling pain (must scale all for one feature)
# 4. Multiple teams blocking each other

# Don&#39;t migrate to microservices because:
# ✗ &quot;It&#39;s the modern way&quot;
# ✗ &quot;Everyone else is doing it&quot;
# ✗ &quot;Looks good on resume&quot;
# ✗ &quot;Want to learn new tech&quot;

# Migrate when:
# ✓ Clear business need
# ✓ Team has capacity
# ✓ Budget available
# ✓ Benefits outweigh costs

# Migration strategy:
# 1. Identify bounded contexts
# 2. Extract one service at a time
# 3. Start with least coupled feature
# 4. Keep monolith as core
# 5. Gradually extract more

# Example migration:
# Year 1: Monolith (0-20 devs)
# Year 2: Extract email service (20-30 devs)
# Year 3: Extract analytics service (30-50 devs)
# Year 4: Extract payment service (50-70 devs)
# Year 5: Extract more as needed (70+ devs)

# Consider intermediate step:
# Modular Monolith (see Q328)
# - Better organization
# - Clear boundaries
# - Still single deployment
# - Can extract services later if needed
</code></pre>
<hr>
<h3>Decision Matrix</h3>
<pre><code class="language-ruby"># Quick decision guide:

# Team Size | Deployment Frequency | Scaling Needs | Choose
# ----------|---------------------|---------------|----------
# 1-10      | Daily               | Uniform       | Monolith
# 10-20     | Daily               | Uniform       | Monolith
# 20-50     | Multiple/day        | Some variance | Modular Monolith
# 50+       | Multiple/day        | Varies widely | Microservices

# Factors to consider:

# Factor              | Weight | Monolith | Microservices
# --------------------|--------|----------|---------------
# Team size           | High   | &lt; 20     | 50+
# Budget              | High   | Limited  | Generous
# Timeline            | High   | Fast     | Can wait
# Scaling needs       | Medium | Uniform  | Varies
# Technology needs    | Medium | Single   | Multiple
# Deployment needs    | Medium | Once/day | Many/day
# Data consistency    | Low    | Critical | Can be eventual

# Score each factor (1-5)
# Multiply by weight
# Higher total = better fit

# Most projects should start with monolith!
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Monolith</strong>: Single unit, shared database, simpler</li>
<li><strong>Microservices</strong>: Multiple services, separate databases, complex</li>
<li><strong>Start monolith</strong>: Right choice for 90% of projects</li>
<li><strong>Microservices when needed</strong>: Large teams, different scaling needs</li>
<li><strong>Cost difference</strong>: Microservices 3-5x more expensive</li>
<li><strong>Complexity</strong>: Microservices need sophisticated infrastructure</li>
<li><strong>Transactions</strong>: Easy in monolith, hard in microservices</li>
<li><strong>Testing</strong>: Simple in monolith, complex in microservices</li>
<li><strong>Migration path</strong>: Monolith → Modular Monolith → Microservices</li>
<li><strong>Don&#39;t migrate early</strong>: Wait until clear need</li>
</ol>
<hr>
<h2>Question 328: How do you implement Modular Monolith Architecture in Rails?</h2>
<h3>Answer</h3>
<p><strong>Modular Monolith</strong> organizes a monolithic Rails app into well-defined modules with clear boundaries, using <strong>Rails Engines</strong>, <strong>namespaces</strong>, <strong>dependency management</strong>, and <strong>enforced boundaries</strong> while maintaining single deployment and shared database benefits.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Rails Engines</strong>: Create isolated modules within monolith</li>
<li><strong>Bounded contexts</strong>: Clear domain boundaries</li>
<li><strong>Dependency rules</strong>: Modules have explicit dependencies</li>
<li><strong>Single deployment</strong>: Still deploy as one unit</li>
<li><strong>Shared database</strong>: Can use same database (or separate)</li>
<li><strong>Best of both</strong>: Organization of microservices, simplicity of monolith</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# MODULAR MONOLITH STRUCTURE
# ============================================

# Traditional monolith (messy):
# app/
#   controllers/
#     users_controller.rb
#     posts_controller.rb
#     orders_controller.rb
#     payments_controller.rb
#   models/
#     user.rb
#     post.rb
#     order.rb
#     payment.rb

# Modular monolith (organized):
# engines/
#   users/
#     app/
#       controllers/
#       models/
#       services/
#     lib/users.rb
#     users.gemspec
#   posts/
#     app/
#       controllers/
#       models/
#       services/
#     lib/posts.rb
#     posts.gemspec
#   orders/
#     app/
#       controllers/
#       models/
#       services/
#     lib/orders.rb
#     orders.gemspec
#   payments/
#     app/
#       controllers/
#       models/
#       services/
#     lib/payments.rb
#     payments.gemspec

# ============================================
# STEP 1: Create Rails Engine (Module)
# ============================================

# Generate engine
# rails plugin new engines/users --mountable

# engines/users/users.gemspec
Gem::Specification.new do |spec|
  spec.name        = &quot;users&quot;
  spec.version     = &quot;1.0.0&quot;
  spec.authors     = [&quot;Your Name&quot;]
  spec.summary     = &quot;User management module&quot;
  
  spec.files = Dir[&quot;{app,config,db,lib}/**/*&quot;]
  
  spec.add_dependency &quot;rails&quot;, &quot;~&gt; 7.0&quot;
end

# engines/users/lib/users.rb
require &quot;users/engine&quot;

module Users
  # Module configuration
  class &lt;&lt; self
    attr_accessor :configuration
  end
  
  def self.configure
    self.configuration ||= Configuration.new
    yield(configuration)
  end
  
  class Configuration
    attr_accessor :allow_self_registration
    
    def initialize
      @allow_self_registration = true
    end
  end
end

# engines/users/lib/users/engine.rb
module Users
  class Engine &lt; ::Rails::Engine
    isolate_namespace Users
    
    config.generators do |g|
      g.test_framework :rspec
      g.fixture_replacement :factory_bot
    end
    
    # Load engine routes
    initializer &quot;users.routes&quot; do |app|
      app.routes.prepend do
        mount Users::Engine =&gt; &quot;/users&quot;
      end
    end
  end
end

# ============================================
# STEP 2: Define Module Structure
# ============================================

# engines/users/app/controllers/users/users_controller.rb
module Users
  class UsersController &lt; ApplicationController
    def index
      @users = User.all
    end
    
    def show
      @user = User.find(params[:id])
    end
    
    def create
      @user = User.new(user_params)
      
      if @user.save
        render json: @user, status: :created
      else
        render json: {errors: @user.errors}, status: :unprocessable_entity
      end
    end
    
    private
    
    def user_params
      params.require(:user).permit(:email, :name, :password)
    end
  end
end

# engines/users/app/models/users/user.rb
module Users
  class User &lt; ApplicationRecord
    self.table_name = &quot;users&quot;
    
    validates :email, presence: true, uniqueness: true
    validates :name, presence: true
    
    has_secure_password
    
    # Public interface for other modules
    def self.find_by_email(email)
      find_by(email: email)
    end
    
    def active?
      status == &#39;active&#39;
    end
  end
end

# engines/users/app/services/users/registration_service.rb
module Users
  class RegistrationService
    def initialize(params)
      @params = params
    end
    
    def call
      user = User.new(@params)
      
      if user.save
        send_welcome_email(user)
        Result.success(user)
      else
        Result.failure(user.errors.full_messages)
      end
    end
    
    private
    
    def send_welcome_email(user)
      Users::WelcomeMailer.welcome(user).deliver_later
    end
  end
  
  Result = Struct.new(:success?, :data, :errors) do
    def self.success(data)
      new(true, data, [])
    end
    
    def self.failure(errors)
      new(false, nil, errors)
    end
  end
end

# ============================================
# STEP 3: Define Public Interface
# ============================================

# engines/users/lib/users/api.rb
module Users
  # Public API for other modules
  module API
    # Find user by ID
    def self.find_user(id)
      User.find_by(id: id)
    end
    
    # Find user by email
    def self.find_by_email(email)
      User.find_by_email(email)
    end
    
    # Register new user
    def self.register(params)
      RegistrationService.new(params).call
    end
    
    # Check if user exists
    def self.exists?(id)
      User.exists?(id: id)
    end
    
    # Get user stats
    def self.stats(user_id)
      user = User.find(user_id)
      {
        id: user.id,
        name: user.name,
        email: user.email,
        created_at: user.created_at,
        active: user.active?
      }
    end
  end
end

# ============================================
# STEP 4: Create Posts Module (Depends on Users)
# ============================================

# engines/posts/posts.gemspec
Gem::Specification.new do |spec|
  spec.name        = &quot;posts&quot;
  spec.version     = &quot;1.0.0&quot;
  
  # Declare dependency on users module
  spec.add_dependency &quot;users&quot;
  spec.add_dependency &quot;rails&quot;, &quot;~&gt; 7.0&quot;
end

# engines/posts/app/controllers/posts/posts_controller.rb
module Posts
  class PostsController &lt; ApplicationController
    def create
      # Use Users module public API
      user = Users::API.find_user(params[:user_id])
      return render_not_found unless user
      
      @post = Post.new(post_params.merge(user_id: user.id))
      
      if @post.save
        render json: @post, status: :created
      else
        render json: {errors: @post.errors}, status: :unprocessable_entity
      end
    end
    
    def index
      @posts = Post.includes(:user).all
      
      # Enrich with user data
      posts_data = @posts.map do |post|
        user_data = Users::API.stats(post.user_id)
        
        {
          id: post.id,
          title: post.title,
          body: post.body,
          user: user_data
        }
      end
      
      render json: posts_data
    end
  end
end

# engines/posts/app/models/posts/post.rb
module Posts
  class Post &lt; ApplicationRecord
    self.table_name = &quot;posts&quot;
    
    # Don&#39;t use belongs_to :user (cross-module)
    # Store user_id but don&#39;t create association
    validates :user_id, presence: true
    validates :title, presence: true
    
    # Validate user exists through API
    validate :user_must_exist
    
    private
    
    def user_must_exist
      unless Users::API.exists?(user_id)
        errors.add(:user_id, &quot;must exist&quot;)
      end
    end
  end
end

# ============================================
# STEP 5: Create Orders Module
# ============================================

# engines/orders/orders.gemspec
Gem::Specification.new do |spec|
  spec.name        = &quot;orders&quot;
  
  # Depends on both users and posts
  spec.add_dependency &quot;users&quot;
  spec.add_dependency &quot;payments&quot;  # Another module
end

# engines/orders/app/services/orders/create_service.rb
module Orders
  class CreateService
    def initialize(user_id, product_id, quantity)
      @user_id = user_id
      @product_id = product_id
      @quantity = quantity
    end
    
    def call
      # Verify user exists (through Users API)
      user = Users::API.find_user(@user_id)
      return Result.failure(&quot;User not found&quot;) unless user
      
      # Create order
      order = Order.create!(
        user_id: @user_id,
        product_id: @product_id,
        quantity: @quantity,
        total: calculate_total
      )
      
      # Process payment (through Payments API)
      payment_result = Payments::API.process(
        order_id: order.id,
        amount: order.total,
        user_id: @user_id
      )
      
      if payment_result.success?
        order.update!(status: &#39;paid&#39;)
        Result.success(order)
      else
        order.update!(status: &#39;payment_failed&#39;)
        Result.failure(payment_result.errors)
      end
    end
    
    private
    
    def calculate_total
      @quantity * 100  # Simplified
    end
  end
end

# ============================================
# STEP 6: Main Application Configuration
# ============================================

# Main app Gemfile
gem &#39;users&#39;, path: &#39;engines/users&#39;
gem &#39;posts&#39;, path: &#39;engines/posts&#39;
gem &#39;orders&#39;, path: &#39;engines/orders&#39;
gem &#39;payments&#39;, path: &#39;engines/payments&#39;

# config/application.rb
module MyApp
  class Application &lt; Rails::Application
    # Load engines
    config.load_defaults 7.0
  end
end

# config/routes.rb
Rails.application.routes.draw do
  mount Users::Engine =&gt; &quot;/users&quot;
  mount Posts::Engine =&gt; &quot;/posts&quot;
  mount Orders::Engine =&gt; &quot;/orders&quot;
  mount Payments::Engine =&gt; &quot;/payments&quot;
end

# ============================================
# STEP 7: Enforce Boundaries with Packwerk
# ============================================

# Gemfile
gem &#39;packwerk&#39;

# Install
bundle exec packwerk init

# package.yml (for each module)
# engines/posts/package.yml
enforce_dependencies: true
enforce_privacy: true
dependencies:
  - users  # Posts can depend on Users
# Cannot access other modules without declaring

# engines/users/package.yml
enforce_dependencies: true
enforce_privacy: true
dependencies: []  # Users doesn&#39;t depend on anything

# Validate dependencies
bundle exec packwerk check

# This will fail:
# engines/posts/app/models/post.rb
class Post &lt; ApplicationRecord
  # ❌ ERROR: Cannot access Payments module
  # Not declared in dependencies
  Payments::API.something
end

# ============================================
# STEP 8: Database Schema
# ============================================

# Option 1: Shared Database (Simpler)
# All modules use same database
# But tables namespaced logically

# db/schema.rb
create_table &quot;users&quot;, force: :cascade do |t|
  t.string &quot;email&quot;
  t.string &quot;name&quot;
  t.timestamps
end

create_table &quot;posts&quot;, force: :cascade do |t|
  t.integer &quot;user_id&quot;  # No FK constraint
  t.string &quot;title&quot;
  t.timestamps
end

create_table &quot;orders&quot;, force: :cascade do |t|
  t.integer &quot;user_id&quot;  # No FK constraint
  t.integer &quot;product_id&quot;
  t.timestamps
end

# No foreign key constraints between modules!
# This allows modules to be independent

# Option 2: Separate Schemas (More Isolation)
# Each module has own schema

# config/database.yml
production:
  users:
    database: myapp_production
    schema_search_path: users_schema
  posts:
    database: myapp_production
    schema_search_path: posts_schema
  orders:
    database: myapp_production
    schema_search_path: orders_schema

# Still same database, but separate schemas
# Provides namespace isolation

# Option 3: Separate Databases (Maximum Isolation)
# Each module has own database (like microservices)

# config/database.yml
production:
  users:
    database: users_db
  posts:
    database: posts_db
  orders:
    database: orders_db

# Maximum isolation
# Can later split into microservices easily

# ============================================
# STEP 9: Testing Modules
# ============================================

# Each module has own tests
# engines/users/spec/services/registration_service_spec.rb
RSpec.describe Users::RegistrationService do
  describe &quot;#call&quot; do
    it &quot;creates user successfully&quot; do
      result = described_class.new(
        email: &#39;test@example.com&#39;,
        name: &#39;Test User&#39;,
        password: &#39;password&#39;
      ).call
      
      expect(result.success?).to be true
      expect(result.data).to be_a(Users::User)
    end
    
    it &quot;returns errors on failure&quot; do
      result = described_class.new(email: &#39;&#39;).call
      
      expect(result.success?).to be false
      expect(result.errors).to include(/email/i)
    end
  end
end

# Test module boundaries
# engines/posts/spec/controllers/posts_controller_spec.rb
RSpec.describe Posts::PostsController do
  describe &quot;POST #create&quot; do
    it &quot;creates post when user exists&quot; do
      # Stub Users API (boundary)
      allow(Users::API).to receive(:find_user).and_return(
        double(id: 1, email: &#39;test@example.com&#39;)
      )
      
      post :create, params: {user_id: 1, title: &#39;Test&#39;}
      
      expect(response).to have_http_status(:created)
    end
    
    it &quot;fails when user doesn&#39;t exist&quot; do
      allow(Users::API).to receive(:find_user).and_return(nil)
      
      post :create, params: {user_id: 999, title: &#39;Test&#39;}
      
      expect(response).to have_http_status(:not_found)
    end
  end
end

# ============================================
# STEP 10: Module Communication Events
# ============================================

# Use events for loose coupling

# engines/users/app/models/users/user.rb
module Users
  class User &lt; ApplicationRecord
    after_create :publish_created_event
    
    private
    
    def publish_created_event
      EventBus.publish(&#39;users.created&#39;, {
        user_id: id,
        email: email,
        name: name
      })
    end
  end
end

# Other modules subscribe
# engines/posts/config/initializers/event_subscribers.rb
EventBus.subscribe(&#39;users.created&#39;) do |data|
  # React to user creation
  Rails.logger.info(&quot;New user created: #{data[:user_id]}&quot;)
  # Could create default posts, etc.
end

# lib/event_bus.rb
class EventBus
  @subscribers = Hash.new { |h, k| h[k] = [] }
  
  def self.subscribe(event_type, &amp;block)
    @subscribers[event_type] &lt;&lt; block
  end
  
  def self.publish(event_type, data)
    @subscribers[event_type].each do |subscriber|
      subscriber.call(data)
    end
  end
end
</code></pre>
<hr>
<h3>Benefits of Modular Monolith</h3>
<pre><code class="language-ruby"># 1. Clear Boundaries
# - Each module focused on one domain
# - Explicit dependencies
# - Easy to understand

# 2. Team Scalability
# - Teams own modules
# - Less coordination needed
# - Clear responsibilities

# 3. Code Reuse
# - Modules have public APIs
# - Enforced interfaces
# - No accidental coupling

# 4. Testing
# - Test modules independently
# - Mock boundaries easily
# - Faster test suite

# 5. Future Migration
# - Modules already isolated
# - Can extract to microservice later
# - No big rewrite needed

# 6. Single Deployment
# - Still deploy as one
# - No distributed system complexity
# - Simple operations

# 7. Performance
# - No network calls
# - In-process communication
# - Shared memory cache
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Modular monolith</strong>: Organized monolith with clear boundaries</li>
<li><strong>Rails Engines</strong>: Create isolated modules</li>
<li><strong>Public APIs</strong>: Explicit interfaces between modules</li>
<li><strong>Dependency rules</strong>: Declare and enforce dependencies</li>
<li><strong>Still monolith</strong>: Single deployment, can share database</li>
<li><strong>Best practices</strong>: Packwerk for boundaries, events for communication</li>
<li><strong>Team scaling</strong>: Multiple teams can work independently</li>
<li><strong>Migration path</strong>: Can extract to microservices later</li>
<li><strong>Middle ground</strong>: Organization without microservices complexity</li>
<li><strong>Recommended</strong>: Better than both pure monolith and microservices for most</li>
</ol>
<hr>
<h2>Question 329: How do you design event-driven architecture in Rails applications?</h2>
<h3>Answer</h3>
<p><strong>Event-driven architecture</strong> uses <strong>events</strong> to trigger actions across the system, implementing <strong>pub/sub patterns</strong>, <strong>event sourcing</strong>, <strong>CQRS</strong>, and <strong>message queues</strong> (RabbitMQ, Kafka) for asynchronous, loosely coupled communication.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Events</strong>: Things that happened (UserCreated, OrderPlaced)</li>
<li><strong>Publishers</strong>: Emit events when actions occur</li>
<li><strong>Subscribers</strong>: React to events asynchronously</li>
<li><strong>Message queue</strong>: RabbitMQ, Kafka, Redis Streams</li>
<li><strong>Event sourcing</strong>: Store all events as source of truth</li>
<li><strong>CQRS</strong>: Separate read and write models</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# PATTERN 1: Simple Event Bus (In-Process)
# ============================================

# lib/event_bus.rb
class EventBus
  @subscribers = Hash.new { |h, k| h[k] = [] }
  
  def self.subscribe(event_type, &amp;block)
    @subscribers[event_type] &lt;&lt; block
  end
  
  def self.publish(event_type, data)
    @subscribers[event_type].each do |subscriber|
      # Execute asynchronously
      EventHandlerJob.perform_later(subscriber, data)
    end
  end
  
  def self.publish_sync(event_type, data)
    @subscribers[event_type].each do |subscriber|
      subscriber.call(data)
    end
  end
end

# app/models/user.rb
class User &lt; ApplicationRecord
  after_create :publish_created_event
  after_update :publish_updated_event
  
  private
  
  def publish_created_event
    EventBus.publish(&#39;user.created&#39;, {
      id: id,
      email: email,
      name: name,
      created_at: created_at
    })
  end
  
  def publish_updated_event
    if saved_change_to_email?
      EventBus.publish(&#39;user.email_changed&#39;, {
        id: id,
        old_email: email_before_last_save,
        new_email: email
      })
    end
  end
end

# Subscribe to events
# config/initializers/event_subscribers.rb

# Send welcome email
EventBus.subscribe(&#39;user.created&#39;) do |data|
  UserMailer.welcome(data[:id]).deliver_now
end

# Track analytics
EventBus.subscribe(&#39;user.created&#39;) do |data|
  Analytics.track(&#39;user_signup&#39;, {
    user_id: data[:id],
    email: data[:email]
  })
end

# Update search index
EventBus.subscribe(&#39;user.created&#39;) do |data|
  User.find(data[:id]).reindex
end

# Email change notification
EventBus.subscribe(&#39;user.email_changed&#39;) do |data|
  UserMailer.email_changed_notification(
    data[:id],
    data[:old_email],
    data[:new_email]
  ).deliver_now
end

# ============================================
# PATTERN 2: RabbitMQ Event Bus (Distributed)
# ============================================

# Gemfile
gem &#39;bunny&#39;  # RabbitMQ client

# lib/event_publisher.rb
class EventPublisher
  def self.publish(event_type, data)
    connection = Bunny.new(ENV[&#39;RABBITMQ_URL&#39;])
    connection.start
    
    channel = connection.create_channel
    exchange = channel.topic(&#39;events&#39;, durable: true)
    
    event = {
      type: event_type,
      data: data,
      published_at: Time.current.iso8601,
      event_id: SecureRandom.uuid
    }
    
    exchange.publish(
      event.to_json,
      routing_key: event_type,
      persistent: true,
      content_type: &#39;application/json&#39;
    )
    
    Rails.logger.info(&quot;Published event: #{event_type}&quot;)
  ensure
    connection.close if connection
  end
end

# app/models/order.rb
class Order &lt; ApplicationRecord
  after_create :publish_created_event
  after_update :publish_status_changed_event, if: :saved_change_to_status?
  
  private
  
  def publish_created_event
    EventPublisher.publish(&#39;order.created&#39;, {
      order_id: id,
      user_id: user_id,
      total: total.to_f,
      items: line_items.map { |item|
        {product_id: item.product_id, quantity: item.quantity}
      }
    })
  end
  
  def publish_status_changed_event
    EventPublisher.publish(&#39;order.status_changed&#39;, {
      order_id: id,
      old_status: status_before_last_save,
      new_status: status,
      changed_at: updated_at
    })
  end
end

# app/jobs/event_consumer_job.rb
class EventConsumerJob &lt; ApplicationJob
  queue_as :events
  
  def perform
    connection = Bunny.new(ENV[&#39;RABBITMQ_URL&#39;])
    connection.start
    
    channel = connection.create_channel
    exchange = channel.topic(&#39;events&#39;, durable: true)
    queue = channel.queue(&#39;order_events&#39;, durable: true)
    
    # Subscribe to order events
    queue.bind(exchange, routing_key: &#39;order.*&#39;)
    
    Rails.logger.info(&quot;Listening for order events...&quot;)
    
    queue.subscribe(block: true, manual_ack: true) do |delivery_info, properties, body|
      begin
        event = JSON.parse(body, symbolize_names: true)
        handle_event(event)
        
        # Acknowledge message
        channel.ack(delivery_info.delivery_tag)
      rescue =&gt; e
        Rails.logger.error(&quot;Event processing failed: #{e.message}&quot;)
        # Reject and requeue
        channel.nack(delivery_info.delivery_tag, false, true)
      end
    end
  end
  
  private
  
  def handle_event(event)
    case event[:type]
    when &#39;order.created&#39;
      handle_order_created(event[:data])
    when &#39;order.status_changed&#39;
      handle_order_status_changed(event[:data])
    end
  end
  
  def handle_order_created(data)
    # Send confirmation email
    OrderMailer.confirmation(data[:order_id]).deliver_later
    
    # Update inventory
    UpdateInventoryJob.perform_later(data[:order_id])
    
    # Track analytics
    Analytics.track(&#39;order_created&#39;, data)
  end
  
  def handle_order_status_changed(data)
    if data[:new_status] == &#39;paid&#39;
      # Trigger fulfillment
      FulfillOrderJob.perform_later(data[:order_id])
    elsif data[:new_status] == &#39;shipped&#39;
      # Send shipping notification
      OrderMailer.shipped(data[:order_id]).deliver_later
    end
  end
end

# Start consumer
# rails runner EventConsumerJob.perform_now

# ============================================
# PATTERN 3: Event Sourcing
# ============================================

# Store all events as source of truth
# Rebuild state from events

# app/models/event.rb
class Event &lt; ApplicationRecord
  serialize :data, JSON
  
  validates :event_type, :aggregate_type, :aggregate_id, presence: true
  
  # Find all events for an aggregate
  scope :for_aggregate, -&gt;(type, id) {
    where(aggregate_type: type, aggregate_id: id)
      .order(:version)
  }
end

# db/migrate/xxx_create_events.rb
class CreateEvents &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :events do |t|
      t.string :event_id, null: false, index: {unique: true}
      t.string :event_type, null: false
      t.string :aggregate_type, null: false
      t.string :aggregate_id, null: false
      t.integer :version, null: false
      t.jsonb :data, null: false
      t.jsonb :metadata
      t.datetime :occurred_at, null: false
      
      t.index [:aggregate_type, :aggregate_id, :version], unique: true
    end
  end
end

# app/models/order_aggregate.rb
class OrderAggregate
  attr_reader :id, :user_id, :status, :total, :items, :version
  
  def initialize(id)
    @id = id
    @version = 0
    @uncommitted_events = []
    
    # Rebuild from events
    load_from_events
  end
  
  # Commands (write side)
  def place_order(user_id, items)
    raise &quot;Order already placed&quot; if @status
    
    total = items.sum { |item| item[:price] * item[:quantity] }
    
    apply_event(&#39;OrderPlaced&#39;, {
      user_id: user_id,
      items: items,
      total: total,
      placed_at: Time.current
    })
  end
  
  def pay_order(payment_id)
    raise &quot;Order not placed&quot; unless @status == &#39;placed&#39;
    raise &quot;Order already paid&quot; if @status == &#39;paid&#39;
    
    apply_event(&#39;OrderPaid&#39;, {
      payment_id: payment_id,
      paid_at: Time.current
    })
  end
  
  def ship_order(tracking_number)
    raise &quot;Order not paid&quot; unless @status == &#39;paid&#39;
    
    apply_event(&#39;OrderShipped&#39;, {
      tracking_number: tracking_number,
      shipped_at: Time.current
    })
  end
  
  # Save all uncommitted events
  def save
    @uncommitted_events.each do |event_data|
      @version += 1
      
      Event.create!(
        event_id: SecureRandom.uuid,
        event_type: event_data[:type],
        aggregate_type: &#39;Order&#39;,
        aggregate_id: @id,
        version: @version,
        data: event_data[:data],
        occurred_at: Time.current
      )
    end
    
    @uncommitted_events.clear
  end
  
  private
  
  def load_from_events
    events = Event.for_aggregate(&#39;Order&#39;, @id)
    
    events.each do |event|
      apply_event_to_state(event.event_type, event.data)
      @version = event.version
    end
  end
  
  def apply_event(event_type, data)
    apply_event_to_state(event_type, data)
    @uncommitted_events &lt;&lt; {type: event_type, data: data}
  end
  
  def apply_event_to_state(event_type, data)
    case event_type
    when &#39;OrderPlaced&#39;
      @user_id = data[&#39;user_id&#39;]
      @items = data[&#39;items&#39;]
      @total = data[&#39;total&#39;]
      @status = &#39;placed&#39;
    when &#39;OrderPaid&#39;
      @status = &#39;paid&#39;
    when &#39;OrderShipped&#39;
      @status = &#39;shipped&#39;
      @tracking_number = data[&#39;tracking_number&#39;]
    end
  end
end

# Usage
order = OrderAggregate.new(&#39;order-123&#39;)
order.place_order(user_id: 1, items: [{product_id: 1, quantity: 2, price: 10}])
order.pay_order(&#39;payment-456&#39;)
order.save  # Persist events

# Rebuild from events
order = OrderAggregate.new(&#39;order-123&#39;)
# State rebuilt from events automatically

# ============================================
# PATTERN 4: CQRS (Command Query Responsibility Segregation)
# ============================================

# Separate write model (commands) and read model (queries)

# Write side (commands)
# app/commands/create_order_command.rb
class CreateOrderCommand
  def initialize(user_id, items)
    @user_id = user_id
    @items = items
  end
  
  def execute
    order = OrderAggregate.new(SecureRandom.uuid)
    order.place_order(@user_id, @items)
    order.save
    
    # Publish event for read model
    EventPublisher.publish(&#39;order.created&#39;, {
      order_id: order.id,
      user_id: order.user_id,
      total: order.total
    })
    
    order.id
  end
end

# Read side (queries)
# app/models/order_read_model.rb
class OrderReadModel &lt; ApplicationRecord
  self.table_name = &#39;orders_read&#39;
  
  # Optimized for reads
  belongs_to :user
  has_many :line_items
  
  # Denormalized data
  # - user_name (from users table)
  # - user_email (from users table)
  # - items_count
  # - total_amount
end

# app/queries/order_query.rb
class OrderQuery
  def find(id)
    OrderReadModel.includes(:user, :line_items).find(id)
  end
  
  def for_user(user_id)
    OrderReadModel.where(user_id: user_id)
                   .order(created_at: :desc)
  end
  
  def recent
    OrderReadModel.order(created_at: :desc).limit(10)
  end
end

# Projector: Updates read model from events
# app/projectors/order_projector.rb
class OrderProjector
  def self.handle(event)
    case event[:type]
    when &#39;order.created&#39;
      create_read_model(event[:data])
    when &#39;order.paid&#39;
      update_status(event[:data][:order_id], &#39;paid&#39;)
    when &#39;order.shipped&#39;
      update_status(event[:data][:order_id], &#39;shipped&#39;)
    end
  end
  
  private
  
  def self.create_read_model(data)
    user = User.find(data[:user_id])
    
    OrderReadModel.create!(
      id: data[:order_id],
      user_id: data[:user_id],
      user_name: user.name,
      user_email: user.email,
      items_count: data[:items].size,
      total_amount: data[:total],
      status: &#39;placed&#39;
    )
  end
  
  def self.update_status(order_id, status)
    OrderReadModel.find(order_id).update!(status: status)
  end
end

# Subscribe projector to events
EventBus.subscribe(&#39;order.*&#39;) do |data|
  OrderProjector.handle(data)
end

# Usage in controllers
class OrdersController &lt; ApplicationController
  # Write (command)
  def create
    order_id = CreateOrderCommand.new(
      current_user.id,
      order_params[:items]
    ).execute
    
    render json: {order_id: order_id}, status: :created
  end
  
  # Read (query)
  def show
    @order = OrderQuery.new.find(params[:id])
    render json: @order
  end
  
  def index
    @orders = OrderQuery.new.for_user(current_user.id)
    render json: @orders
  end
end

# ============================================
# PATTERN 5: Kafka Event Streaming
# ============================================

# Gemfile
gem &#39;ruby-kafka&#39;

# lib/kafka_producer.rb
class KafkaProducer
  def self.publish(topic, event)
    kafka = Kafka.new([ENV[&#39;KAFKA_URL&#39;]])
    
    kafka.deliver_message(
      event.to_json,
      topic: topic,
      key: event[:aggregate_id]
    )
  ensure
    kafka&amp;.close
  end
end

# app/models/order.rb
class Order &lt; ApplicationRecord
  after_create :publish_to_kafka
  
  private
  
  def publish_to_kafka
    KafkaProducer.publish(&#39;orders&#39;, {
      event_type: &#39;order.created&#39;,
      aggregate_id: id,
      data: {
        order_id: id,
        user_id: user_id,
        total: total
      },
      timestamp: created_at.to_i
    })
  end
end

# app/jobs/kafka_consumer_job.rb
class KafkaConsumerJob &lt; ApplicationJob
  def perform
    kafka = Kafka.new([ENV[&#39;KAFKA_URL&#39;]])
    consumer = kafka.consumer(group_id: &#39;order-processor&#39;)
    
    consumer.subscribe(&#39;orders&#39;)
    
    consumer.each_message do |message|
      event = JSON.parse(message.value, symbolize_names: true)
      process_event(event)
    end
  end
  
  private
  
  def process_event(event)
    case event[:event_type]
    when &#39;order.created&#39;
      # Process order
      ProcessOrderJob.perform_later(event[:data][:order_id])
    end
  end
end
</code></pre>
<hr>
<h3>Event-Driven Patterns</h3>
<pre><code class="language-ruby"># ============================================
# PATTERN: Event Notification
# ============================================

# Simple notification: &quot;Something happened&quot;
EventBus.publish(&#39;user.created&#39;, {user_id: 1})

# Subscribers react
EventBus.subscribe(&#39;user.created&#39;) do |data|
  # Send email
  # Update cache
  # Track analytics
end

# ============================================
# PATTERN: Event-Carried State Transfer
# ============================================

# Event contains all necessary data
EventBus.publish(&#39;order.completed&#39;, {
  order_id: 1,
  user_id: 5,
  user_email: &#39;john@example.com&#39;,
  user_name: &#39;John Doe&#39;,
  total: 99.99,
  items: [{product_id: 1, name: &#39;Widget&#39;, quantity: 2}],
  completed_at: Time.current
})

# Subscriber doesn&#39;t need to fetch data
EventBus.subscribe(&#39;order.completed&#39;) do |data|
  # Has everything needed
  send_confirmation_email(
    data[:user_email],
    data[:order_id],
    data[:total]
  )
end

# ============================================
# PATTERN: Domain Events
# ============================================

# Events represent business occurrences
class Order &lt; ApplicationRecord
  def complete
    # Business logic
    update!(status: &#39;completed&#39;, completed_at: Time.current)
    
    # Emit domain event
    emit_event(&#39;OrderCompleted&#39;, {
      order_id: id,
      total: total,
      completed_at: completed_at
    })
  end
  
  private
  
  def emit_event(event_type, data)
    DomainEvents.emit(event_type, data)
  end
end

# ============================================
# PATTERN: Saga / Process Manager
# ============================================

# Coordinate long-running business processes
class OrderSaga
  def initialize(order_id)
    @order_id = order_id
  end
  
  def handle(event)
    case event[:type]
    when &#39;order.created&#39;
      # Step 1: Reserve inventory
      InventoryService.reserve(@order_id)
    when &#39;inventory.reserved&#39;
      # Step 2: Process payment
      PaymentService.process(@order_id)
    when &#39;payment.completed&#39;
      # Step 3: Ship order
      ShippingService.ship(@order_id)
    when &#39;shipping.completed&#39;
      # Done!
      complete_order
    when &#39;inventory.reservation_failed&#39;
      # Compensate: Cancel order
      cancel_order(&#39;Inventory unavailable&#39;)
    when &#39;payment.failed&#39;
      # Compensate: Release inventory
      InventoryService.release(@order_id)
      cancel_order(&#39;Payment failed&#39;)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Event-driven</strong>: React to events asynchronously</li>
<li><strong>Loose coupling</strong>: Publishers don&#39;t know subscribers</li>
<li><strong>Scalability</strong>: Process events independently</li>
<li><strong>Event sourcing</strong>: Store events as source of truth</li>
<li><strong>CQRS</strong>: Separate reads and writes</li>
<li><strong>Message queues</strong>: RabbitMQ, Kafka for distributed systems</li>
<li><strong>Sagas</strong>: Coordinate long-running processes</li>
<li><strong>Projections</strong>: Build read models from events</li>
<li><strong>Idempotency</strong>: Handle duplicate events</li>
<li><strong>Testing</strong>: Test event handlers independently</li>
</ol>
<hr>
<h2>Question 330: How do you handle distributed transactions in Rails microservices?</h2>
<h3>Answer</h3>
<p>Handle distributed transactions using the <strong>Saga pattern</strong> (orchestration or choreography), <strong>two-phase commit</strong> (2PC), <strong>eventual consistency</strong>, <strong>compensating transactions</strong>, and <strong>idempotent operations</strong> since traditional ACID transactions don&#39;t work across services.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Problem</strong>: Can&#39;t use database transactions across services</li>
<li><strong>Saga pattern</strong>: Break into steps with compensation</li>
<li><strong>Orchestration</strong>: Central coordinator manages saga</li>
<li><strong>Choreography</strong>: Services react to events</li>
<li><strong>Compensation</strong>: Undo operations if step fails</li>
<li><strong>Eventual consistency</strong>: Accept temporary inconsistency</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# THE PROBLEM: Distributed Transactions
# ============================================

# In monolith (works):
Order.transaction do
  order = Order.create!(order_params)
  payment = Payment.create!(order: order)
  Inventory.decrement!(product_id, quantity)
  # All or nothing ✓
end

# In microservices (doesn&#39;t work):
# Orders Service
order = Order.create!(order_params)

# Payment Service (HTTP call)
payment = PaymentService.process(order)  # What if this fails?

# Inventory Service (HTTP call)
InventoryService.decrement(product)  # What if this fails?

# Problems:
# 1. Order created but payment failed → Inconsistent!
# 2. Payment succeeded but inventory failed → Inconsistent!
# 3. Can&#39;t rollback across services

# ============================================
# SOLUTION 1: Saga Pattern (Orchestration)
# ============================================

# Central orchestrator manages the saga

# app/sagas/order_saga.rb
class OrderSaga
  attr_reader :order_id, :state, :context
  
  def initialize(order_id)
    @order_id = order_id
    @state = &#39;pending&#39;
    @context = {}
    @compensations = []
  end
  
  def execute
    ActiveRecord::Base.transaction do
      saga = SagaExecution.create!(
        saga_type: &#39;OrderSaga&#39;,
        aggregate_id: order_id,
        state: &#39;started&#39;
      )
      @saga_id = saga.id
    end
    
    begin
      # Step 1: Create Order
      create_order
      
      # Step 2: Reserve Inventory
      reserve_inventory
      
      # Step 3: Process Payment
      process_payment
      
      # Step 4: Update Order Status
      complete_order
      
      # Success!
      mark_saga_complete
      
    rescue =&gt; e
      # Failure - run compensations
      Rails.logger.error(&quot;Saga failed: #{e.message}&quot;)
      compensate
      mark_saga_failed(e.message)
      raise
    end
  end
  
  private
  
  # Step 1: Create Order
  def create_order
    response = HTTParty.post(
      &quot;#{ENV[&#39;ORDERS_SERVICE_URL&#39;]}/api/orders&quot;,
      body: {
        order_id: order_id,
        user_id: context[:user_id],
        items: context[:items]
      }.to_json,
      headers: {&#39;Content-Type&#39; =&gt; &#39;application/json&#39;},
      timeout: 5
    )
    
    unless response.success?
      raise &quot;Failed to create order: #{response.body}&quot;
    end
    
    @context[:order_id] = response[&#39;id&#39;]
    record_step(&#39;order_created&#39;)
    
    # Register compensation
    @compensations &lt;&lt; -&gt; { cancel_order }
  end
  
  # Step 2: Reserve Inventory
  def reserve_inventory
    response = HTTParty.post(
      &quot;#{ENV[&#39;INVENTORY_SERVICE_URL&#39;]}/api/inventory/reserve&quot;,
      body: {
        order_id: order_id,
        items: context[:items]
      }.to_json,
      headers: {&#39;Content-Type&#39; =&gt; &#39;application/json&#39;},
      timeout: 5
    )
    
    unless response.success?
      raise &quot;Failed to reserve inventory: #{response.body}&quot;
    end
    
    @context[:reservation_id] = response[&#39;reservation_id&#39;]
    record_step(&#39;inventory_reserved&#39;)
    
    # Register compensation
    @compensations &lt;&lt; -&gt; { release_inventory }
  end
  
  # Step 3: Process Payment
  def process_payment
    response = HTTParty.post(
      &quot;#{ENV[&#39;PAYMENT_SERVICE_URL&#39;]}/api/payments&quot;,
      body: {
        order_id: order_id,
        amount: context[:total],
        user_id: context[:user_id]
      }.to_json,
      headers: {&#39;Content-Type&#39; =&gt; &#39;application/json&#39;},
      timeout: 10
    )
    
    unless response.success?
      raise &quot;Payment failed: #{response.body}&quot;
    end
    
    @context[:payment_id] = response[&#39;payment_id&#39;]
    record_step(&#39;payment_processed&#39;)
    
    # Register compensation
    @compensations &lt;&lt; -&gt; { refund_payment }
  end
  
  # Step 4: Complete Order
  def complete_order
    response = HTTParty.patch(
      &quot;#{ENV[&#39;ORDERS_SERVICE_URL&#39;]}/api/orders/#{order_id}&quot;,
      body: {status: &#39;completed&#39;}.to_json,
      headers: {&#39;Content-Type&#39; =&gt; &#39;application/json&#39;}
    )
    
    unless response.success?
      raise &quot;Failed to complete order&quot;
    end
    
    record_step(&#39;order_completed&#39;)
  end
  
  # Compensations (run in reverse order)
  def compensate
    Rails.logger.info(&quot;Running compensations for saga #{@saga_id}&quot;)
    
    @compensations.reverse.each do |compensation|
      begin
        compensation.call
      rescue =&gt; e
        Rails.logger.error(&quot;Compensation failed: #{e.message}&quot;)
        # Continue with other compensations
      end
    end
  end
  
  def cancel_order
    HTTParty.delete(&quot;#{ENV[&#39;ORDERS_SERVICE_URL&#39;]}/api/orders/#{order_id}&quot;)
    record_compensation(&#39;order_cancelled&#39;)
  end
  
  def release_inventory
    return unless @context[:reservation_id]
    
    HTTParty.post(
      &quot;#{ENV[&#39;INVENTORY_SERVICE_URL&#39;]}/api/inventory/release&quot;,
      body: {reservation_id: @context[:reservation_id]}.to_json,
      headers: {&#39;Content-Type&#39; =&gt; &#39;application/json&#39;}
    )
    record_compensation(&#39;inventory_released&#39;)
  end
  
  def refund_payment
    return unless @context[:payment_id]
    
    HTTParty.post(
      &quot;#{ENV[&#39;PAYMENT_SERVICE_URL&#39;]}/api/payments/#{@context[:payment_id]}/refund&quot;,
      headers: {&#39;Content-Type&#39; =&gt; &#39;application/json&#39;}
    )
    record_compensation(&#39;payment_refunded&#39;)
  end
  
  # Saga tracking
  def record_step(step_name)
    SagaStep.create!(
      saga_execution_id: @saga_id,
      step_name: step_name,
      status: &#39;completed&#39;,
      context: @context
    )
  end
  
  def record_compensation(step_name)
    SagaStep.create!(
      saga_execution_id: @saga_id,
      step_name: step_name,
      status: &#39;compensated&#39;,
      context: @context
    )
  end
  
  def mark_saga_complete
    SagaExecution.find(@saga_id).update!(
      state: &#39;completed&#39;,
      completed_at: Time.current
    )
  end
  
  def mark_saga_failed(error_message)
    SagaExecution.find(@saga_id).update!(
      state: &#39;failed&#39;,
      error_message: error_message,
      failed_at: Time.current
    )
  end
end

# Database tables
# db/migrate/xxx_create_saga_tables.rb
class CreateSagaTables &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :saga_executions do |t|
      t.string :saga_type, null: false
      t.string :aggregate_id, null: false
      t.string :state, null: false
      t.text :error_message
      t.datetime :completed_at
      t.datetime :failed_at
      t.timestamps
    end
    
    create_table :saga_steps do |t|
      t.references :saga_execution, null: false
      t.string :step_name, null: false
      t.string :status, null: false
      t.jsonb :context
      t.timestamps
    end
  end
end

# Usage
class OrdersController &lt; ApplicationController
  def create
    saga = OrderSaga.new(SecureRandom.uuid)
    saga.context = {
      user_id: current_user.id,
      items: order_params[:items],
      total: calculate_total(order_params[:items])
    }
    
    begin
      saga.execute
      render json: {order_id: saga.order_id}, status: :created
    rescue =&gt; e
      render json: {error: e.message}, status: :unprocessable_entity
    end
  end
end

# ============================================
# SOLUTION 2: Saga Pattern (Choreography)
# ============================================

# Services react to events (no central coordinator)

# Orders Service
class Order &lt; ApplicationRecord
  after_create :publish_created_event
  
  def publish_created_event
    EventPublisher.publish(&#39;order.created&#39;, {
      order_id: id,
      user_id: user_id,
      items: items,
      total: total
    })
  end
end

# Inventory Service listens
class InventoryEventHandler
  def self.handle(event)
    case event[:type]
    when &#39;order.created&#39;
      handle_order_created(event[:data])
    when &#39;payment.failed&#39;
      handle_payment_failed(event[:data])
    end
  end
  
  def self.handle_order_created(data)
    # Try to reserve inventory
    reservation = Reservation.create(
      order_id: data[:order_id],
      items: data[:items]
    )
    
    if reservation.persisted?
      # Success - publish event
      EventPublisher.publish(&#39;inventory.reserved&#39;, {
        order_id: data[:order_id],
        reservation_id: reservation.id
      })
    else
      # Failed - publish event
      EventPublisher.publish(&#39;inventory.reservation_failed&#39;, {
        order_id: data[:order_id],
        reason: reservation.errors.full_messages.join(&#39;, &#39;)
      })
    end
  end
  
  def self.handle_payment_failed(data)
    # Compensate: Release inventory
    reservation = Reservation.find_by(order_id: data[:order_id])
    reservation&amp;.release!
    
    EventPublisher.publish(&#39;inventory.released&#39;, {
      order_id: data[:order_id]
    })
  end
end

# Payment Service listens
class PaymentEventHandler
  def self.handle(event)
    case event[:type]
    when &#39;inventory.reserved&#39;
      handle_inventory_reserved(event[:data])
    when &#39;order.cancelled&#39;
      handle_order_cancelled(event[:data])
    end
  end
  
  def self.handle_inventory_reserved(data)
    # Process payment
    payment = Payment.process(
      order_id: data[:order_id],
      amount: data[:amount]
    )
    
    if payment.success?
      EventPublisher.publish(&#39;payment.completed&#39;, {
        order_id: data[:order_id],
        payment_id: payment.id
      })
    else
      EventPublisher.publish(&#39;payment.failed&#39;, {
        order_id: data[:order_id],
        reason: payment.error_message
      })
    end
  end
  
  def self.handle_order_cancelled(data)
    # Compensate: Refund payment
    payment = Payment.find_by(order_id: data[:order_id])
    payment&amp;.refund!
  end
end

# Orders Service listens for completion/failure
class OrderEventHandler
  def self.handle(event)
    case event[:type]
    when &#39;payment.completed&#39;
      handle_payment_completed(event[:data])
    when &#39;inventory.reservation_failed&#39;, &#39;payment.failed&#39;
      handle_failure(event[:data])
    end
  end
  
  def self.handle_payment_completed(data)
    order = Order.find(data[:order_id])
    order.update!(status: &#39;completed&#39;)
    
    EventPublisher.publish(&#39;order.completed&#39;, {
      order_id: order.id
    })
  end
  
  def self.handle_failure(data)
    order = Order.find(data[:order_id])
    order.update!(status: &#39;failed&#39;, failure_reason: data[:reason])
    
    EventPublisher.publish(&#39;order.cancelled&#39;, {
      order_id: order.id
    })
  end
end

# ============================================
# SOLUTION 3: Two-Phase Commit (2PC)
# ============================================

# Note: Rarely used, complex and slow
# Only use if ACID is absolutely required

class TwoPhaseCommitCoordinator
  def initialize
    @participants = []
  end
  
  def add_participant(service)
    @participants &lt;&lt; service
  end
  
  def execute
    transaction_id = SecureRandom.uuid
    
    # Phase 1: Prepare
    prepare_results = @participants.map do |participant|
      participant.prepare(transaction_id)
    end
    
    # Check if all prepared successfully
    if prepare_results.all?(&amp;:success?)
      # Phase 2: Commit
      @participants.each do |participant|
        participant.commit(transaction_id)
      end
      true
    else
      # Phase 2: Abort
      @participants.each do |participant|
        participant.abort(transaction_id)
      end
      false
    end
  end
end

# Participant service
class PaymentServiceParticipant
  def prepare(transaction_id)
    # Lock resources, prepare to commit
    # Don&#39;t actually commit yet
    @prepared_payments[transaction_id] = Payment.new(...)
    Result.new(true)
  end
  
  def commit(transaction_id)
    # Actually commit the payment
    payment = @prepared_payments[transaction_id]
    payment.save!
    @prepared_payments.delete(transaction_id)
  end
  
  def abort(transaction_id)
    # Release locks, rollback
    @prepared_payments.delete(transaction_id)
  end
end

# ============================================
# SOLUTION 4: Eventual Consistency
# ============================================

# Accept temporary inconsistency

class OrdersController &lt; ApplicationController
  def create
    # Create order immediately
    @order = Order.create!(order_params)
    @order.update!(status: &#39;pending&#39;)
    
    # Process asynchronously
    ProcessOrderJob.perform_later(@order.id)
    
    # Return immediately (order is &quot;pending&quot;)
    render json: @order, status: :created
  end
end

class ProcessOrderJob &lt; ApplicationJob
  def perform(order_id)
    order = Order.find(order_id)
    
    # Try to reserve inventory
    inventory = reserve_inventory(order)
    return mark_failed(order, &#39;Inventory unavailable&#39;) unless inventory
    
    # Try to process payment
    payment = process_payment(order)
    unless payment.success?
      release_inventory(inventory)
      return mark_failed(order, &#39;Payment failed&#39;)
    end
    
    # Success!
    order.update!(status: &#39;completed&#39;)
  end
  
  private
  
  def mark_failed(order, reason)
    order.update!(status: &#39;failed&#39;, failure_reason: reason)
  end
end

# User sees:
# 1. Order created (status: pending)
# 2. Wait a few seconds
# 3. Order status updated (completed or failed)

# ============================================
# BEST PRACTICES
# ============================================

# 1. Idempotency
# Make operations safe to retry
class PaymentService
  def process(order_id, amount, idempotency_key)
    # Check if already processed
    existing = Payment.find_by(idempotency_key: idempotency_key)
    return existing if existing
    
    # Process payment
    payment = Payment.create!(
      order_id: order_id,
      amount: amount,
      idempotency_key: idempotency_key
    )
    
    payment
  end
end

# 2. Timeouts
# Don&#39;t wait forever for services
HTTParty.post(
  url,
  body: data,
  timeout: 5  # 5 seconds max
)

# 3. Retries with Exponential Backoff
def call_service_with_retry(url, data, max_retries: 3)
  retries = 0
  
  begin
    HTTParty.post(url, body: data, timeout: 5)
  rescue =&gt; e
    retries += 1
    if retries &lt; max_retries
      sleep(2 ** retries)  # 2, 4, 8 seconds
      retry
    else
      raise
    end
  end
end

# 4. Circuit Breaker
# Stop calling failing services
class CircuitBreaker
  def initialize(service_name, threshold: 5, timeout: 60)
    @service_name = service_name
    @threshold = threshold
    @timeout = timeout
    @failures = 0
    @last_failure_time = nil
    @state = :closed  # :closed, :open, :half_open
  end
  
  def call
    if @state == :open
      if Time.current - @last_failure_time &gt; @timeout
        @state = :half_open
      else
        raise CircuitBreakerOpenError, &quot;Circuit breaker open for #{@service_name}&quot;
      end
    end
    
    begin
      result = yield
      success!
      result
    rescue =&gt; e
      failure!
      raise
    end
  end
  
  private
  
  def success!
    @failures = 0
    @state = :closed
  end
  
  def failure!
    @failures += 1
    @last_failure_time = Time.current
    
    if @failures &gt;= @threshold
      @state = :open
      Rails.logger.error(&quot;Circuit breaker opened for #{@service_name}&quot;)
    end
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>No ACID across services</strong>: Traditional transactions don&#39;t work</li>
<li><strong>Saga pattern</strong>: Best solution for most cases</li>
<li><strong>Orchestration</strong>: Central coordinator (simpler to understand)</li>
<li><strong>Choreography</strong>: Event-driven (more scalable)</li>
<li><strong>Compensations</strong>: Undo operations when steps fail</li>
<li><strong>Eventual consistency</strong>: Accept temporary inconsistency</li>
<li><strong>Idempotency</strong>: Make operations safe to retry</li>
<li><strong>Timeouts</strong>: Don&#39;t wait forever</li>
<li><strong>Circuit breakers</strong>: Stop calling failing services</li>
<li><strong>2PC</strong>: Avoid unless absolutely necessary</li>
</ol>
<h1>CQRS, Event Sourcing &amp; Advanced Databases (331-335)</h1>
<h2>CQRS and Event Sourcing</h2>
<h2>Question 331: What are CQRS (Command Query Responsibility Segregation) patterns?</h2>
<h3>Answer</h3>
<p><strong>CQRS</strong> separates <strong>write operations</strong> (commands) from <strong>read operations</strong> (queries) using different models, allowing independent optimization, scaling, and evolution of each side. Commands change state, queries return data.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Separation</strong>: Different models for reads and writes</li>
<li><strong>Commands</strong>: Change state (CreateOrder, UpdateUser)</li>
<li><strong>Queries</strong>: Read data (GetOrders, FindUser)</li>
<li><strong>Write model</strong>: Optimized for consistency and validation</li>
<li><strong>Read model</strong>: Optimized for queries and performance</li>
<li><strong>Benefits</strong>: Scale independently, optimize separately</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<pre><code class="language-ruby"># ============================================
# TRADITIONAL APPROACH (No CQRS)
# ============================================

# Same model for reads and writes
class OrdersController &lt; ApplicationController
  # Write operation
  def create
    @order = Order.new(order_params)
    @order.user = current_user
    
    if @order.save
      redirect_to @order
    else
      render :new
    end
  end
  
  # Read operation
  def show
    @order = Order.includes(:user, :line_items, :payment).find(params[:id])
  end
  
  # Read operation
  def index
    @orders = Order.includes(:user)
                   .where(user: current_user)
                   .order(created_at: :desc)
  end
end

# Single model for everything
class Order &lt; ApplicationRecord
  belongs_to :user
  has_many :line_items
  has_one :payment
  
  validates :total, presence: true
  
  # Used for both reads and writes
end

# Problems:
# - Same structure for reads and writes
# - Can&#39;t optimize independently
# - Complex queries slow down writes
# - Write model constraints affect reads

# ============================================
# CQRS APPROACH
# ============================================

# Separate commands and queries

# ============================================
# WRITE SIDE (Commands)
# ============================================

# app/commands/create_order_command.rb
class CreateOrderCommand
  include ActiveModel::Model
  
  attr_accessor :user_id, :items, :shipping_address
  
  validates :user_id, :items, :shipping_address, presence: true
  validate :items_available
  validate :user_exists
  
  def execute
    return Result.failure(errors.full_messages) unless valid?
    
    order = nil
    
    ApplicationRecord.transaction do
      # Create write model
      order = OrderWrite.create!(
        user_id: user_id,
        status: &#39;pending&#39;,
        total: calculate_total,
        shipping_address: shipping_address
      )
      
      items.each do |item|
        OrderLineWrite.create!(
          order_write: order,
          product_id: item[:product_id],
          quantity: item[:quantity],
          price: item[:price]
        )
      end
      
      # Publish event for read model
      publish_order_created_event(order)
    end
    
    Result.success(order.id)
  end
  
  private
  
  def calculate_total
    items.sum { |item| item[:price] * item[:quantity] }
  end
  
  def items_available
    items.each do |item|
      product = Product.find_by(id: item[:product_id])
      if product.nil? || product.stock &lt; item[:quantity]
        errors.add(:items, &quot;Product #{item[:product_id]} not available&quot;)
      end
    end
  end
  
  def user_exists
    errors.add(:user_id, &quot;doesn&#39;t exist&quot;) unless User.exists?(user_id)
  end
  
  def publish_order_created_event(order)
    OrderEvents.publish(&#39;OrderCreated&#39;, {
      order_id: order.id,
      user_id: order.user_id,
      total: order.total,
      items: order.line_items.map { |item|
        {
          product_id: item.product_id,
          quantity: item.quantity,
          price: item.price
        }
      }
    })
  end
  
  Result = Struct.new(:success?, :data, :errors) do
    def self.success(data)
      new(true, data, [])
    end
    
    def self.failure(errors)
      new(false, nil, errors)
    end
  end
end

# app/commands/update_order_status_command.rb
class UpdateOrderStatusCommand
  def initialize(order_id, new_status)
    @order_id = order_id
    @new_status = new_status
  end
  
  def execute
    order = OrderWrite.find(@order_id)
    old_status = order.status
    
    order.update!(status: @new_status)
    
    # Publish event
    OrderEvents.publish(&#39;OrderStatusChanged&#39;, {
      order_id: order.id,
      old_status: old_status,
      new_status: @new_status
    })
    
    Result.success(order.id)
  end
end

# Write models (normalized, focused on consistency)
# app/models/order_write.rb
class OrderWrite &lt; ApplicationRecord
  self.table_name = &#39;orders_write&#39;
  
  belongs_to :user
  has_many :line_items, class_name: &#39;OrderLineWrite&#39;, foreign_key: :order_write_id
  
  validates :user_id, :status, :total, presence: true
  validates :status, inclusion: {in: %w[pending paid shipped delivered cancelled]}
  
  # Write-optimized: Strict validations, referential integrity
end

# app/models/order_line_write.rb
class OrderLineWrite &lt; ApplicationRecord
  self.table_name = &#39;order_lines_write&#39;
  
  belongs_to :order_write
  belongs_to :product
  
  validates :product_id, :quantity, :price, presence: true
  validates :quantity, numericality: {greater_than: 0}
end

# ============================================
# READ SIDE (Queries)
# ============================================

# app/queries/order_query.rb
class OrderQuery
  # Find single order with all details
  def find(order_id)
    OrderRead.find(order_id)
  end
  
  # User&#39;s orders
  def for_user(user_id)
    OrderRead.where(user_id: user_id)
              .order(created_at: :desc)
  end
  
  # Recent orders
  def recent(limit: 10)
    OrderRead.order(created_at: :desc).limit(limit)
  end
  
  # Orders by status
  def by_status(status)
    OrderRead.where(status: status)
  end
  
  # Complex query: User&#39;s orders with totals
  def user_summary(user_id)
    OrderRead.where(user_id: user_id)
              .select(
                &#39;COUNT(*) as total_orders&#39;,
                &#39;SUM(total) as total_spent&#39;,
                &#39;AVG(total) as average_order&#39;
              )
              .first
  end
  
  # Search orders
  def search(params)
    scope = OrderRead.all
    
    scope = scope.where(&#39;order_number LIKE ?&#39;, &quot;%#{params[:query]}%&quot;) if params[:query]
    scope = scope.where(status: params[:status]) if params[:status]
    scope = scope.where(&#39;created_at &gt;= ?&#39;, params[:from]) if params[:from]
    scope = scope.where(&#39;created_at &lt;= ?&#39;, params[:to]) if params[:to]
    
    scope
  end
end

# Read model (denormalized, optimized for queries)
# app/models/order_read.rb
class OrderRead &lt; ApplicationRecord
  self.table_name = &#39;orders_read&#39;
  
  # No associations - all data denormalized
  # Read-only
  def readonly?
    true
  end
  
  # Denormalized fields:
  # - user_name (from users table)
  # - user_email (from users table)
  # - items_json (all line items as JSON)
  # - product_names (comma-separated)
  # - total_items (count)
end

# Read model projector (updates read model from events)
# app/projectors/order_projector.rb
class OrderProjector
  def self.handle_event(event)
    case event[:type]
    when &#39;OrderCreated&#39;
      create_read_model(event[:data])
    when &#39;OrderStatusChanged&#39;
      update_status(event[:data])
    end
  end
  
  private
  
  def self.create_read_model(data)
    user = User.find(data[:user_id])
    
    # Get product names
    product_ids = data[:items].map { |item| item[:product_id] }
    products = Product.where(id: product_ids).index_by(&amp;:id)
    product_names = data[:items].map { |item| 
      products[item[:product_id]]&amp;.name 
    }.compact.join(&#39;, &#39;)
    
    OrderRead.create!(
      id: data[:order_id],
      order_number: generate_order_number(data[:order_id]),
      user_id: data[:user_id],
      user_name: user.name,
      user_email: user.email,
      status: &#39;pending&#39;,
      total: data[:total],
      items_json: data[:items].to_json,
      product_names: product_names,
      total_items: data[:items].sum { |i| i[:quantity] },
      created_at: Time.current
    )
  end
  
  def self.update_status(data)
    order = OrderRead.find(data[:order_id])
    order.update_columns(
      status: data[:new_status],
      updated_at: Time.current
    )
  end
  
  def self.generate_order_number(order_id)
    &quot;ORD-#{Time.current.year}-#{order_id.to_s.rjust(8, &#39;0&#39;)}&quot;
  end
end

# Subscribe to events
OrderEvents.subscribe do |event|
  OrderProjector.handle_event(event)
end

# ============================================
# CONTROLLERS
# ============================================

# Commands controller (write operations)
class OrderCommandsController &lt; ApplicationController
  # Create order (command)
  def create
    command = CreateOrderCommand.new(
      user_id: current_user.id,
      items: order_params[:items],
      shipping_address: order_params[:shipping_address]
    )
    
    result = command.execute
    
    if result.success?
      render json: {order_id: result.data}, status: :created
    else
      render json: {errors: result.errors}, status: :unprocessable_entity
    end
  end
  
  # Update order status (command)
  def update_status
    command = UpdateOrderStatusCommand.new(params[:id], params[:status])
    result = command.execute
    
    if result.success?
      head :ok
    else
      render json: {errors: result.errors}, status: :unprocessable_entity
    end
  end
  
  # Cancel order (command)
  def cancel
    command = CancelOrderCommand.new(params[:id])
    result = command.execute
    
    if result.success?
      head :ok
    else
      render json: {errors: result.errors}, status: :unprocessable_entity
    end
  end
end

# Queries controller (read operations)
class OrderQueriesController &lt; ApplicationController
  # Get order (query)
  def show
    @order = OrderQuery.new.find(params[:id])
    render json: @order
  end
  
  # List orders (query)
  def index
    @orders = OrderQuery.new.for_user(current_user.id)
    render json: @orders
  end
  
  # Search orders (query)
  def search
    @orders = OrderQuery.new.search(search_params)
    render json: @orders
  end
  
  # User summary (query)
  def summary
    @summary = OrderQuery.new.user_summary(current_user.id)
    render json: @summary
  end
end

# Routes
Rails.application.routes.draw do
  # Commands (POST, PATCH, DELETE)
  namespace :order_commands do
    resources :orders, only: [:create] do
      member do
        patch :update_status
        delete :cancel
      end
    end
  end
  
  # Queries (GET)
  namespace :order_queries do
    resources :orders, only: [:show, :index] do
      collection do
        get :search
        get :summary
      end
    end
  end
end

# ============================================
# DATABASE SCHEMA
# ============================================

# Write side tables (normalized)
create_table &quot;orders_write&quot;, force: :cascade do |t|
  t.bigint &quot;user_id&quot;, null: false
  t.string &quot;status&quot;, null: false
  t.decimal &quot;total&quot;, precision: 10, scale: 2, null: false
  t.text &quot;shipping_address&quot;
  t.timestamps
  
  t.index [&quot;user_id&quot;]
  t.foreign_key &quot;users&quot;
end

create_table &quot;order_lines_write&quot;, force: :cascade do |t|
  t.bigint &quot;order_write_id&quot;, null: false
  t.bigint &quot;product_id&quot;, null: false
  t.integer &quot;quantity&quot;, null: false
  t.decimal &quot;price&quot;, precision: 10, scale: 2, null: false
  t.timestamps
  
  t.index [&quot;order_write_id&quot;]
  t.index [&quot;product_id&quot;]
  t.foreign_key &quot;orders_write&quot;
  t.foreign_key &quot;products&quot;
end

# Read side tables (denormalized)
create_table &quot;orders_read&quot;, force: :cascade do |t|
  t.string &quot;order_number&quot;, null: false
  t.bigint &quot;user_id&quot;, null: false
  t.string &quot;user_name&quot;, null: false
  t.string &quot;user_email&quot;, null: false
  t.string &quot;status&quot;, null: false
  t.decimal &quot;total&quot;, precision: 10, scale: 2, null: false
  t.jsonb &quot;items_json&quot;, null: false
  t.text &quot;product_names&quot;
  t.integer &quot;total_items&quot;
  t.datetime &quot;created_at&quot;, null: false
  t.datetime &quot;updated_at&quot;, null: false
  
  t.index [&quot;order_number&quot;], unique: true
  t.index [&quot;user_id&quot;]
  t.index [&quot;status&quot;]
  t.index [&quot;created_at&quot;]
  
  # No foreign keys - read model is independent
end

# ============================================
# EVENTUAL CONSISTENCY
# ============================================

# Write and read models are eventually consistent

# Time    | Write Model           | Read Model
# --------|----------------------|----------------------
# T+0ms   | Order created        | (empty)
# T+10ms  | (committed)          | Event published
# T+20ms  | -                    | Event received
# T+30ms  | -                    | Read model updated
# T+40ms  | -                    | Read model available

# Handle eventual consistency
class OrdersController &lt; ApplicationController
  def create
    # Create order (write model)
    result = CreateOrderCommand.new(order_params).execute
    
    if result.success?
      # Return immediately with order_id
      # Read model might not be ready yet
      render json: {
        order_id: result.data,
        message: &#39;Order created, details will be available shortly&#39;
      }, status: :created
    else
      render json: {errors: result.errors}, status: :unprocessable_entity
    end
  end
  
  def show
    # Try to get from read model
    @order = OrderRead.find_by(id: params[:id])
    
    if @order
      render json: @order
    else
      # Not yet in read model, return 202 Accepted
      render json: {
        message: &#39;Order is being processed&#39;
      }, status: :accepted
    end
  end
end

# ============================================
# BENEFITS OF CQRS
# ============================================

# 1. Independent Scaling
# - Scale read model separately (more reads than writes)
# - 10 read replicas, 1 write instance

# 2. Optimized Data Models
# Write model:
# - Normalized (3NF)
# - Foreign keys
# - Strict validations
# - ACID transactions

# Read model:
# - Denormalized
# - No foreign keys
# - Pre-computed aggregations
# - Fast queries

# 3. Multiple Read Models
# Different views of same data

# app/models/order_read_list.rb
# Optimized for listing
class OrderReadList &lt; ApplicationRecord
  # Minimal fields for lists
end

# app/models/order_read_detail.rb
# All details for single order
class OrderReadDetail &lt; ApplicationRecord
  # All fields including items
end

# app/models/order_read_analytics.rb
# Optimized for analytics
class OrderReadAnalytics &lt; ApplicationRecord
  # Aggregated data
end

# 4. Technology Freedom
# Write side: PostgreSQL (ACID)
# Read side: MongoDB (fast reads), Elasticsearch (search)

# 5. Performance
# Queries don&#39;t lock write operations
# Complex queries don&#39;t slow down writes
</code></pre>
<hr>
<h3>CQRS Implementation Patterns</h3>
<pre><code class="language-ruby"># ============================================
# PATTERN 1: Simple CQRS (Same Database)
# ============================================

# Separate models, same database
class OrderWrite &lt; ApplicationRecord
  self.table_name = &#39;orders&#39;
end

class OrderRead &lt; ApplicationRecord
  self.table_name = &#39;orders&#39;
  
  def readonly?
    true
  end
end

# Use write model for commands
def create_order
  OrderWrite.create!(order_params)
end

# Use read model for queries
def list_orders
  OrderRead.where(user_id: current_user.id)
end

# ============================================
# PATTERN 2: Separate Tables (Same Database)
# ============================================

# Different tables, same database
# Write: orders_write table
# Read: orders_read table (denormalized)

# Synchronize with callbacks or events

# ============================================
# PATTERN 3: Separate Databases
# ============================================

# Write: PostgreSQL (ACID)
# Read: MongoDB (fast queries)

# config/database.yml
production:
  write:
    adapter: postgresql
    database: orders_write
  read:
    adapter: mongodb
    database: orders_read

# Synchronize with message queue

# ============================================
# PATTERN 4: CQRS with Event Sourcing
# ============================================

# Store all events
# Rebuild read model from events

class OrderAggregate
  def initialize(order_id)
    @id = order_id
    @events = []
    load_from_events
  end
  
  def place_order(data)
    apply_event(&#39;OrderPlaced&#39;, data)
  end
  
  def save
    @events.each do |event|
      EventStore.append(event)
    end
    
    # Update read model
    rebuild_read_model
  end
end
</code></pre>
<hr>
<h3>When to Use CQRS</h3>
<pre><code class="language-ruby"># ✅ Use CQRS when:
# - Read/write patterns very different
# - Need to scale reads independently
# - Complex queries slow down writes
# - Multiple views of same data needed
# - High read/write ratio (90% reads)

# Examples:
# - E-commerce orders (many reads, few writes)
# - Analytics dashboards (heavy reads)
# - Reporting systems (complex queries)

# ❌ Don&#39;t use CQRS when:
# - Simple CRUD application
# - Read/write patterns similar
# - Small scale (&lt; 1000 users)
# - Team inexperienced with CQRS
# - Complexity not justified

# Examples:
# - Simple blog
# - Internal tools
# - Small SaaS MVP
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>CQRS</strong>: Separate read and write models</li>
<li><strong>Commands</strong>: Change state (CreateOrder)</li>
<li><strong>Queries</strong>: Return data (GetOrder)</li>
<li><strong>Write model</strong>: Normalized, strict validations</li>
<li><strong>Read model</strong>: Denormalized, optimized for queries</li>
<li><strong>Eventual consistency</strong>: Read model updated asynchronously</li>
<li><strong>Independent scaling</strong>: Scale reads separately from writes</li>
<li><strong>Multiple views</strong>: Different read models for different needs</li>
<li><strong>Complexity</strong>: More complex than traditional approach</li>
<li><strong>When to use</strong>: High read/write ratio, complex queries</li>
</ol>
<hr>
<h2>Question 332: What is Event Sourcing, and how does it relate to Rails applications?</h2>
<h3>Answer</h3>
<p><strong>Event Sourcing</strong> stores all changes as a sequence of <strong>immutable events</strong> rather than current state. Instead of updating records, you append events. The current state is derived by replaying all events. This provides complete audit trail, time travel, and event-driven architecture.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Store events</strong>: Not current state, but all changes</li>
<li><strong>Immutable</strong>: Events never change or delete</li>
<li><strong>Replay</strong>: Rebuild state by replaying events</li>
<li><strong>Audit trail</strong>: Complete history of all changes</li>
<li><strong>Event store</strong>: Database of all events</li>
<li><strong>Projections</strong>: Build read models from events</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# TRADITIONAL APPROACH (State-Based)
# ============================================

# Store current state
class Order &lt; ApplicationRecord
  def update_status(new_status)
    update!(status: new_status)
    # Old status is lost!
  end
end

# Database has only current state:
# orders table:
# id | user_id | status    | total | updated_at
# 1  | 5       | shipped   | 99.99 | 2025-01-15

# Lost information:
# - When was order created?
# - When was it paid?
# - When was it shipped?
# - Who made each change?

# ============================================
# EVENT SOURCING APPROACH
# ============================================

# Store all events
# events table:
# id | event_type      | aggregate_id | version | data                    | occurred_at
# 1  | OrderCreated    | order-1      | 1       | {user_id: 5, ...}      | 2025-01-10
# 2  | OrderPaid       | order-1      | 2       | {payment_id: &#39;p1&#39;}     | 2025-01-12
# 3  | OrderShipped    | order-1      | 3       | {tracking: &#39;TR123&#39;}    | 2025-01-15

# Current state = replay all events

# ============================================
# STEP 1: Event Store
# ============================================

# db/migrate/xxx_create_events.rb
class CreateEvents &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :events do |t|
      t.string :event_id, null: false
      t.string :event_type, null: false
      t.string :aggregate_type, null: false
      t.string :aggregate_id, null: false
      t.integer :version, null: false
      t.jsonb :data, null: false, default: {}
      t.jsonb :metadata, default: {}
      t.datetime :occurred_at, null: false
      
      t.index :event_id, unique: true
      t.index [:aggregate_type, :aggregate_id]
      t.index [:aggregate_type, :aggregate_id, :version], unique: true
      t.index :occurred_at
    end
  end
end

# app/models/event.rb
class Event &lt; ApplicationRecord
  validates :event_id, :event_type, :aggregate_type, :aggregate_id, :version, presence: true
  validates :event_id, uniqueness: true
  validates :version, uniqueness: {scope: [:aggregate_type, :aggregate_id]}
  
  before_validation :set_defaults, on: :create
  
  # Find all events for an aggregate
  scope :for_aggregate, -&gt;(type, id) {
    where(aggregate_type: type, aggregate_id: id).order(:version)
  }
  
  # Events after a specific version
  scope :after_version, -&gt;(version) {
    where(&#39;version &gt; ?&#39;, version).order(:version)
  }
  
  private
  
  def set_defaults
    self.event_id ||= SecureRandom.uuid
    self.occurred_at ||= Time.current
  end
end

# ============================================
# STEP 2: Event Store Service
# ============================================

# app/services/event_store.rb
class EventStore
  class &lt;&lt; self
    # Append event to stream
    def append(aggregate_type, aggregate_id, event_type, data, expected_version: nil)
      current_version = Event.where(
        aggregate_type: aggregate_type,
        aggregate_id: aggregate_id
      ).maximum(:version) || 0
      
      # Optimistic concurrency check
      if expected_version &amp;&amp; current_version != expected_version
        raise ConcurrencyError, 
          &quot;Expected version #{expected_version}, got #{current_version}&quot;
      end
      
      event = Event.create!(
        event_type: event_type,
        aggregate_type: aggregate_type,
        aggregate_id: aggregate_id,
        version: current_version + 1,
        data: data,
        metadata: build_metadata
      )
      
      # Publish event for subscribers
      EventBus.publish(event)
      
      event
    end
    
    # Load all events for aggregate
    def load_events(aggregate_type, aggregate_id)
      Event.for_aggregate(aggregate_type, aggregate_id)
    end
    
    # Load events after version (for catch-up subscriptions)
    def load_events_after(aggregate_type, aggregate_id, version)
      Event.for_aggregate(aggregate_type, aggregate_id)
           .after_version(version)
    end
    
    # Get all events (for rebuilding projections)
    def all_events(limit: 1000, offset: 0)
      Event.order(:id).limit(limit).offset(offset)
    end
    
    private
    
    def build_metadata
      {
        user_id: Current.user&amp;.id,
        ip_address: Current.ip_address,
        user_agent: Current.user_agent,
        timestamp: Time.current.iso8601
      }
    end
  end
  
  class ConcurrencyError &lt; StandardError; end
end

# ============================================
# STEP 3: Aggregate Root (Domain Entity)
# ============================================

# app/aggregates/order_aggregate.rb
class OrderAggregate
  attr_reader :id, :version, :user_id, :status, :total, :items,
              :payment_id, :tracking_number
  
  def initialize(id)
    @id = id
    @version = 0
    @uncommitted_events = []
    
    # Load state from events
    load_from_history
  end
  
  # === Commands (Business Logic) ===
  
  def create(user_id, items, shipping_address)
    raise &quot;Order already exists&quot; if @version &gt; 0
    
    total = items.sum { |item| item[:price] * item[:quantity] }
    
    apply_event(&#39;OrderCreated&#39;, {
      user_id: user_id,
      items: items,
      total: total,
      shipping_address: shipping_address,
      created_at: Time.current.iso8601
    })
  end
  
  def pay(payment_id, amount)
    raise &quot;Order not created&quot; if @status.nil?
    raise &quot;Order already paid&quot; if @status == &#39;paid&#39;
    raise &quot;Invalid amount&quot; if amount != @total
    
    apply_event(&#39;OrderPaid&#39;, {
      payment_id: payment_id,
      amount: amount,
      paid_at: Time.current.iso8601
    })
  end
  
  def ship(tracking_number, carrier)
    raise &quot;Order not paid&quot; unless @status == &#39;paid&#39;
    raise &quot;Order already shipped&quot; if @status == &#39;shipped&#39;
    
    apply_event(&#39;OrderShipped&#39;, {
      tracking_number: tracking_number,
      carrier: carrier,
      shipped_at: Time.current.iso8601
    })
  end
  
  def cancel(reason)
    raise &quot;Cannot cancel shipped order&quot; if @status == &#39;shipped&#39;
    raise &quot;Cannot cancel delivered order&quot; if @status == &#39;delivered&#39;
    
    apply_event(&#39;OrderCancelled&#39;, {
      reason: reason,
      cancelled_at: Time.current.iso8601
    })
  end
  
  # === Save (Persist Events) ===
  
  def save
    @uncommitted_events.each do |event_data|
      EventStore.append(
        &#39;Order&#39;,
        @id,
        event_data[:type],
        event_data[:data],
        expected_version: @version
      )
      
      @version += 1
    end
    
    @uncommitted_events.clear
  end
  
  # === Event Sourcing Core ===
  
  private
  
  def load_from_history
    events = EventStore.load_events(&#39;Order&#39;, @id)
    
    events.each do |event|
      apply_event_to_state(event.event_type, event.data)
      @version = event.version
    end
  end
  
  def apply_event(event_type, data)
    # Apply to in-memory state
    apply_event_to_state(event_type, data)
    
    # Track for persistence
    @uncommitted_events &lt;&lt; {type: event_type, data: data}
  end
  
  def apply_event_to_state(event_type, data)
    case event_type
    when &#39;OrderCreated&#39;
      @user_id = data[&#39;user_id&#39;]
      @items = data[&#39;items&#39;]
      @total = data[&#39;total&#39;]
      @shipping_address = data[&#39;shipping_address&#39;]
      @status = &#39;created&#39;
      
    when &#39;OrderPaid&#39;
      @payment_id = data[&#39;payment_id&#39;]
      @status = &#39;paid&#39;
      
    when &#39;OrderShipped&#39;
      @tracking_number = data[&#39;tracking_number&#39;]
      @carrier = data[&#39;carrier&#39;]
      @status = &#39;shipped&#39;
      
    when &#39;OrderCancelled&#39;
      @cancellation_reason = data[&#39;reason&#39;]
      @status = &#39;cancelled&#39;
    end
  end
end

# ============================================
# STEP 4: Commands (Application Layer)
# ============================================

# app/commands/create_order_command.rb
class CreateOrderCommand
  def initialize(user_id, items, shipping_address)
    @user_id = user_id
    @items = items
    @shipping_address = shipping_address
  end
  
  def execute
    order_id = SecureRandom.uuid
    order = OrderAggregate.new(order_id)
    
    order.create(@user_id, @items, @shipping_address)
    order.save
    
    Result.success(order_id)
  rescue =&gt; e
    Result.failure(e.message)
  end
end

# app/commands/pay_order_command.rb
class PayOrderCommand
  def initialize(order_id, payment_id, amount)
    @order_id = order_id
    @payment_id = payment_id
    @amount = amount
  end
  
  def execute
    order = OrderAggregate.new(@order_id)
    order.pay(@payment_id, @amount)
    order.save
    
    Result.success(@order_id)
  rescue =&gt; e
    Result.failure(e.message)
  end
end

# ============================================
# STEP 5: Projections (Read Models)
# ============================================

# app/models/order_projection.rb
class OrderProjection &lt; ApplicationRecord
  self.table_name = &#39;order_projections&#39;
  
  def readonly?
    true
  end
end

# app/projectors/order_projector.rb
class OrderProjector
  def self.project_all
    # Rebuild from scratch
    OrderProjection.delete_all
    
    # Get all events
    offset = 0
    loop do
      events = EventStore.all_events(limit: 1000, offset: offset)
      break if events.empty?
      
      events.each do |event|
        next unless event.aggregate_type == &#39;Order&#39;
        handle_event(event)
      end
      
      offset += 1000
    end
  end
  
  def self.handle_event(event)
    case event.event_type
    when &#39;OrderCreated&#39;
      create_projection(event)
    when &#39;OrderPaid&#39;
      update_status(event.aggregate_id, &#39;paid&#39;)
    when &#39;OrderShipped&#39;
      update_shipped(event)
    when &#39;OrderCancelled&#39;
      update_status(event.aggregate_id, &#39;cancelled&#39;)
    end
  end
  
  private
  
  def self.create_projection(event)
    data = event.data
    
    OrderProjection.create!(
      id: event.aggregate_id,
      user_id: data[&#39;user_id&#39;],
      status: &#39;created&#39;,
      total: data[&#39;total&#39;],
      items_count: data[&#39;items&#39;].size,
      created_at: data[&#39;created_at&#39;]
    )
  end
  
  def self.update_status(order_id, status)
    projection = OrderProjection.find_by(id: order_id)
    return unless projection
    
    projection.update_columns(
      status: status,
      updated_at: Time.current
    )
  end
  
  def self.update_shipped(event)
    projection = OrderProjection.find_by(id: event.aggregate_id)
    return unless projection
    
    projection.update_columns(
      status: &#39;shipped&#39;,
      tracking_number: event.data[&#39;tracking_number&#39;],
      shipped_at: event.data[&#39;shipped_at&#39;],
      updated_at: Time.current
    )
  end
end

# Subscribe to events for real-time updates
EventBus.subscribe do |event|
  OrderProjector.handle_event(event) if event.aggregate_type == &#39;Order&#39;
end

# ============================================
# STEP 6: Controllers
# ============================================

class OrdersController &lt; ApplicationController
  # Create order
  def create
    result = CreateOrderCommand.new(
      current_user.id,
      order_params[:items],
      order_params[:shipping_address]
    ).execute
    
    if result.success?
      render json: {order_id: result.data}, status: :created
    else
      render json: {error: result.errors}, status: :unprocessable_entity
    end
  end
  
  # Get order (from projection)
  def show
    @order = OrderProjection.find(params[:id])
    render json: @order
  end
  
  # Get order history (all events)
  def history
    events = EventStore.load_events(&#39;Order&#39;, params[:id])
    
    render json: events.map { |e|
      {
        event_type: e.event_type,
        data: e.data,
        occurred_at: e.occurred_at,
        version: e.version
      }
    }
  end
  
  # Time travel: Get order state at specific time
  def state_at
    timestamp = params[:timestamp].to_datetime
    order = OrderAggregate.new(params[:id])
    
    # Replay events up to timestamp
    events = EventStore.load_events(&#39;Order&#39;, params[:id])
                      .where(&#39;occurred_at &lt;= ?&#39;, timestamp)
    
    # Build state from filtered events
    state = {}
    events.each do |event|
      # Apply event to state
      apply_event_to_state(state, event)
    end
    
    render json: state
  end
end

# ============================================
# STEP 7: Event Bus (Pub/Sub)
# ============================================

# lib/event_bus.rb
class EventBus
  @subscribers = []
  
  def self.subscribe(&amp;block)
    @subscribers &lt;&lt; block
  end
  
  def self.publish(event)
    @subscribers.each do |subscriber|
      EventHandlerJob.perform_later(subscriber, event)
    end
  end
end

# app/jobs/event_handler_job.rb
class EventHandlerJob &lt; ApplicationJob
  def perform(handler, event)
    handler.call(event)
  end
end
</code></pre>
<hr>
<h3>Event Sourcing Benefits</h3>
<pre><code class="language-ruby"># ============================================
# BENEFIT 1: Complete Audit Trail
# ============================================

# Every change is recorded
events = EventStore.load_events(&#39;Order&#39;, order_id)

events.each do |event|
  puts &quot;#{event.occurred_at}: #{event.event_type}&quot;
  puts &quot;By user: #{event.metadata[&#39;user_id&#39;]}&quot;
  puts &quot;Data: #{event.data}&quot;
end

# Output:
# 2025-01-10 10:00: OrderCreated
# By user: 5
# Data: {user_id: 5, total: 99.99}
#
# 2025-01-12 14:30: OrderPaid
# By user: 5
# Data: {payment_id: &#39;p1&#39;, amount: 99.99}
#
# 2025-01-15 09:00: OrderShipped
# By user: 10 (admin)
# Data: {tracking: &#39;TR123&#39;, carrier: &#39;UPS&#39;}

# ============================================
# BENEFIT 2: Time Travel
# ============================================

# What was order status on January 13?
def order_state_at(order_id, timestamp)
  order = OrderAggregate.new(order_id)
  
  # Get events up to that time
  events = Event.where(aggregate_id: order_id)
                .where(&#39;occurred_at &lt;= ?&#39;, timestamp)
                .order(:version)
  
  # Replay events
  state = {}
  events.each do |event|
    apply_event_to_state(state, event)
  end
  
  state
end

order_state_at(&#39;order-1&#39;, &#39;2025-01-13&#39;.to_datetime)
# =&gt; {status: &#39;paid&#39;, total: 99.99}  (before shipping)

# ============================================
# BENEFIT 3: Replay Events
# ============================================

# Rebuild projections from events
def rebuild_all_projections
  OrderProjection.delete_all
  
  Event.where(aggregate_type: &#39;Order&#39;).find_each do |event|
    OrderProjector.handle_event(event)
  end
end

# Fix bugs in projection logic
# 1. Fix the bug in projector code
# 2. Rebuild projections
# 3. All fixed!

# ============================================
# BENEFIT 4: Multiple Projections
# ============================================

# Same events, different views

# Projection 1: Current order list
class OrderListProjection &lt; ApplicationRecord
  # Minimal data for listing
end

# Projection 2: Order details
class OrderDetailProjection &lt; ApplicationRecord
  # All data for details page
end

# Projection 3: Analytics
class OrderAnalyticsProjection &lt; ApplicationRecord
  # Aggregated data for reporting
end

# All from same events!

# ============================================
# BENEFIT 5: Event-Driven Architecture
# ============================================

# Other services subscribe to events

# Email service
EventBus.subscribe do |event|
  case event.event_type
  when &#39;OrderCreated&#39;
    OrderMailer.confirmation(event.aggregate_id).deliver_later
  when &#39;OrderShipped&#39;
    OrderMailer.shipping(event.aggregate_id).deliver_later
  end
end

# Analytics service
EventBus.subscribe do |event|
  case event.event_type
  when &#39;OrderCreated&#39;
    Analytics.track(&#39;order_created&#39;, event.data)
  when &#39;OrderPaid&#39;
    Analytics.track(&#39;payment_received&#39;, event.data)
  end
end

# Inventory service
EventBus.subscribe do |event|
  case event.event_type
  when &#39;OrderCreated&#39;
    Inventory.reserve(event.data[&#39;items&#39;])
  when &#39;OrderCancelled&#39;
    Inventory.release(event.data[&#39;items&#39;])
  end
end
</code></pre>
<hr>
<h3>Event Sourcing Challenges</h3>
<pre><code class="language-ruby"># ============================================
# CHALLENGE 1: Event Schema Evolution
# ============================================

# Old event structure:
# OrderCreated: {user_id: 5, items: [...]}

# New event structure (added field):
# OrderCreated: {user_id: 5, items: [...], currency: &#39;USD&#39;}

# Solution: Event upcasting
class EventUpcaster
  def self.upcast(event)
    case event.event_type
    when &#39;OrderCreated&#39;
      upcast_order_created(event)
    else
      event
    end
  end
  
  private
  
  def self.upcast_order_created(event)
    data = event.data
    
    # Add currency if missing
    data[&#39;currency&#39;] ||= &#39;USD&#39;
    
    event.data = data
    event
  end
end

# Use when loading events
def load_events(aggregate_id)
  Event.for_aggregate(&#39;Order&#39;, aggregate_id).map do |event|
    EventUpcaster.upcast(event)
  end
end

# ============================================
# CHALLENGE 2: Performance
# ============================================

# Loading 10,000 events for one order is slow

# Solution 1: Snapshots
class Snapshot &lt; ApplicationRecord
  # Store aggregate state at specific version
end

def load_with_snapshot(aggregate_id)
  # Load latest snapshot
  snapshot = Snapshot.where(aggregate_id: aggregate_id)
                    .order(version: :desc)
                    .first
  
  if snapshot
    # Load from snapshot + events after
    order = OrderAggregate.from_snapshot(snapshot)
    events = Event.for_aggregate(&#39;Order&#39;, aggregate_id)
                  .after_version(snapshot.version)
    events.each { |e| order.apply_event_from_history(e) }
  else
    # Load all events
    order = OrderAggregate.new(aggregate_id)
  end
  
  order
end

# Create snapshot every 100 events
def create_snapshot_if_needed(aggregate)
  if aggregate.version % 100 == 0
    Snapshot.create!(
      aggregate_type: &#39;Order&#39;,
      aggregate_id: aggregate.id,
      version: aggregate.version,
      state: aggregate.to_snapshot_data
    )
  end
end

# Solution 2: Caching
def load_cached(aggregate_id)
  cache_key = &quot;aggregate/Order/#{aggregate_id}&quot;
  
  Rails.cache.fetch(cache_key, expires_in: 5.minutes) do
    OrderAggregate.new(aggregate_id)
  end
end

# ============================================
# CHALLENGE 3: Querying
# ============================================

# Can&#39;t query events directly
# &quot;Find all orders for user 5&quot; - need to replay all events!

# Solution: Projections (covered above)
# Build read models from events

# ============================================
# CHALLENGE 4: Complexity
# ============================================

# More complex than CRUD
# - Event store
# - Aggregates
# - Projections
# - Event handlers

# Only use when benefits outweigh complexity
</code></pre>
<hr>
<h3>When to Use Event Sourcing</h3>
<pre><code class="language-ruby"># ✅ Use Event Sourcing when:
# - Need complete audit trail
# - Compliance requirements (financial, medical)
# - Time travel needed (undo, replay)
# - Complex business logic
# - Event-driven architecture
# - Multiple views of data

# Examples:
# - Banking/Financial systems
# - E-commerce orders
# - Inventory management
# - Medical records
# - Legal documents

# ❌ Don&#39;t use Event Sourcing when:
# - Simple CRUD
# - No audit requirements
# - Small scale
# - Team inexperienced
# - Performance critical (without optimization)

# Examples:
# - Simple blog
# - Todo list
# - Contact forms
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Event sourcing</strong>: Store all changes as events</li>
<li><strong>Immutable</strong>: Events never change</li>
<li><strong>Replay</strong>: Rebuild state from events</li>
<li><strong>Audit trail</strong>: Complete history</li>
<li><strong>Time travel</strong>: See state at any point</li>
<li><strong>Projections</strong>: Build read models from events</li>
<li><strong>Event store</strong>: Database of all events</li>
<li><strong>Aggregates</strong>: Domain entities that apply events</li>
<li><strong>Complexity</strong>: More complex than CRUD</li>
<li><strong>When to use</strong>: Audit trail, compliance, event-driven architecture</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Databases</h2>
<h2>Question 333: What is ACID vs BASE databases and their impact on scalability?</h2>
<h3>Answer</h3>
<p><strong>ACID</strong> databases prioritize <strong>consistency</strong> and <strong>reliability</strong> (PostgreSQL, MySQL) with strong guarantees but limited scalability. <strong>BASE</strong> databases prioritize <strong>availability</strong> and <strong>partition tolerance</strong> (MongoDB, Cassandra) with eventual consistency but better scalability.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>ACID</strong>: Atomicity, Consistency, Isolation, Durability</li>
<li><strong>BASE</strong>: Basically Available, Soft state, Eventually consistent</li>
<li><strong>ACID</strong>: Strong consistency, limited scale (vertical scaling)</li>
<li><strong>BASE</strong>: Eventual consistency, high scale (horizontal scaling)</li>
<li><strong>Trade-off</strong>: Consistency vs Availability (CAP theorem)</li>
<li><strong>Rails default</strong>: ACID (PostgreSQL, MySQL)</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<pre><code class="language-ruby"># ============================================
# ACID DATABASES
# ============================================

# A = Atomicity
# C = Consistency
# I = Isolation
# D = Durability

# ==================
# A: Atomicity
# ==================
# All or nothing - transaction succeeds completely or fails completely

# Example: Bank transfer
Order.transaction do
  account_from.withdraw(100)  # Step 1
  account_to.deposit(100)      # Step 2
  
  # If Step 2 fails, Step 1 rolls back
  # Money never disappears!
end

# Without atomicity:
account_from.withdraw(100)  # ✓ Success
account_to.deposit(100)     # ✗ Fails (network error)
# Result: $100 disappeared! 💥

# ==================
# C: Consistency
# ==================
# Database always in valid state (constraints enforced)

class User &lt; ApplicationRecord
  validates :email, presence: true, uniqueness: true
end

# Attempt to create duplicate
User.create!(email: &#39;john@example.com&#39;)
User.create!(email: &#39;john@example.com&#39;)
# =&gt; ActiveRecord::RecordInvalid: Validation failed: Email has already been taken

# Database enforces uniqueness
# Data always consistent ✓

# Database constraints
create_table :users do |t|
  t.string :email, null: false  # NOT NULL constraint
  t.index :email, unique: true   # UNIQUE constraint
  t.foreign_key :posts, :user_id # FOREIGN KEY constraint
end

# Constraints enforced at database level
# Can&#39;t insert invalid data

# ==================
# I: Isolation
# ==================
# Concurrent transactions don&#39;t interfere

# Transaction 1:
User.transaction do
  user = User.find(1)
  user.update!(balance: user.balance - 100)
end

# Transaction 2 (concurrent):
User.transaction do
  user = User.find(1)
  user.update!(balance: user.balance + 50)
end

# Isolation levels prevent conflicts:
# - READ UNCOMMITTED: Can see uncommitted changes (dirty reads)
# - READ COMMITTED: Only see committed changes
# - REPEATABLE READ: Same read twice = same result
# - SERIALIZABLE: Fully isolated (slowest)

# Example with SERIALIZABLE:
User.transaction(isolation: :serializable) do
  user = User.lock.find(1)  # Lock row
  user.update!(balance: user.balance - 100)
  # Other transactions wait until this completes
end

# ==================
# D: Durability
# ==================
# Once committed, data persists (even if server crashes)

user = User.create!(email: &#39;john@example.com&#39;)
# Data written to disk
# Server crashes here... 💥
# After restart:
User.find_by(email: &#39;john@example.com&#39;)  # Still there ✓

# PostgreSQL uses WAL (Write-Ahead Logging)
# MySQL uses redo logs
# Data safe even with crashes

# ============================================
# BASE DATABASES
# ============================================

# BA = Basically Available
# S = Soft state
# E = Eventually consistent

# ==================
# BA: Basically Available
# ==================
# System available even if some nodes fail

# Example: MongoDB with 3 replicas
# - Primary node fails
# - Secondary promoted to primary
# - Service continues (may be briefly unavailable)
# - System prioritizes availability

# In ACID database:
# - Primary fails
# - Service completely down until fixed
# - System prioritizes consistency

# ==================
# S: Soft State
# ==================
# State may change without input (due to eventual consistency)

# Example: User updates profile
user.update(name: &#39;New Name&#39;)
# Write goes to primary node

# Read from replica (may be stale)
user.reload
# =&gt; &quot;Old Name&quot; (not yet replicated)

# Wait a bit...
sleep 1
user.reload
# =&gt; &quot;New Name&quot; (now replicated)

# State is &quot;soft&quot; - not immediately consistent

# ==================
# E: Eventually Consistent
# ==================
# All replicas will become consistent... eventually

# Timeline:
# T+0ms:   Write to primary    (name: &#39;New Name&#39;)
# T+10ms:  Replica 1 updated   (name: &#39;New Name&#39;)
# T+50ms:  Replica 2 updated   (name: &#39;New Name&#39;)
# T+100ms: All consistent      (name: &#39;New Name&#39;)

# During 0-100ms window:
# - Different reads may return different values
# - Eventually all consistent

# ============================================
# COMPARISON
# ============================================

# Aspect              | ACID                    | BASE
# --------------------|-------------------------|-------------------------
# Consistency         | Strong (immediate)      | Eventual
# Availability        | Lower (single point)    | Higher (distributed)
# Scalability         | Vertical (bigger server)| Horizontal (more nodes)
# Transactions        | Yes (across tables)     | Limited
# Data integrity      | Guaranteed              | Eventual
# Complexity          | Simpler                 | More complex
# Use case            | Financial, critical     | Social, analytics
# Examples            | PostgreSQL, MySQL       | MongoDB, Cassandra

# ============================================
# ACID DATABASE EXAMPLE (PostgreSQL)
# ============================================

# Banking system (ACID required)
class BankAccount &lt; ApplicationRecord
  def transfer_to(other_account, amount)
    ApplicationRecord.transaction do
      # Must be atomic!
      self.withdraw(amount)
      other_account.deposit(amount)
      
      # Either both succeed or both fail
    end
  end
  
  def withdraw(amount)
    # Check constraint
    raise &quot;Insufficient funds&quot; if balance &lt; amount
    
    # Update balance
    update!(balance: balance - amount)
    
    # Create transaction record
    transactions.create!(
      type: &#39;withdrawal&#39;,
      amount: amount
    )
  end
end

# Usage
account1 = BankAccount.find(1)  # Balance: $1000
account2 = BankAccount.find(2)  # Balance: $500

account1.transfer_to(account2, 200)

# Guaranteed:
# - Both accounts updated or neither
# - Balance never negative
# - Transaction recorded
# - Money never lost

# ============================================
# BASE DATABASE EXAMPLE (MongoDB)
# ============================================

# Social media likes (eventual consistency OK)
class Post
  include Mongoid::Document
  
  field :likes_count, type: Integer, default: 0
  field :content, type: String
end

# Update likes (eventually consistent)
def like_post(post_id)
  # Increment likes
  Post.where(id: post_id).inc(likes_count: 1)
  
  # Returns immediately
  # Replicas update asynchronously
  
  # User sees:
  # - Like button clicked ✓
  # - Count updates immediately (locally)
  # - Other users see update eventually (1-100ms)
  
  # This is OK for likes!
  # Doesn&#39;t need strong consistency
end

# Reading likes
post = Post.find(id)
post.likes_count
# =&gt; 42 (might be 41 or 43 on other nodes)
# Eventually all nodes show 42

# ============================================
# SCALABILITY IMPACT
# ============================================

# ACID Database Scaling:
# 
# Vertical Scaling:
# - 1 server: 2 CPU, 4GB RAM → $100/month
# - Need more: 4 CPU, 16GB RAM → $400/month (4x price, 2x capacity)
# - Maximum: 64 CPU, 512GB RAM → $10K/month
# - Hit ceiling: Can&#39;t scale further
#
# Read Replicas (limited horizontal):
# - 1 primary (writes)
# - 5 replicas (reads)
# - Writes still bottleneck
# - Can&#39;t scale writes horizontally

# BASE Database Scaling:
#
# Horizontal Scaling:
# - 3 nodes: 2 CPU, 4GB RAM each → $300/month
# - Need more: Add 3 more nodes → $600/month (2x capacity, 2x price)
# - Keep adding: 30 nodes → $3K/month (10x capacity)
# - No ceiling: Can add indefinitely
#
# Sharding:
# - Data distributed across nodes
# - Each node handles portion of data
# - Writes scale horizontally
# - Reads scale horizontally

# ============================================
# CAP THEOREM
# ============================================

# Can only have 2 of 3:
# - Consistency (C): All nodes see same data
# - Availability (A): System always responds
# - Partition tolerance (P): Works even if network fails

# ACID databases: Choose C + A (give up P)
# - Consistent and Available
# - But: If network partitions, must sacrifice A to maintain C

# BASE databases: Choose A + P (give up C)
# - Available and Partition tolerant
# - But: May show stale data (eventual consistency)

# Real-world example:
# Network partition between datacenters:
#
# ACID (PostgreSQL):
# - Datacenter 1 (primary): Down
# - Datacenter 2 (replica): Can&#39;t promote (would lose consistency)
# - Service: DOWN ❌
# - Choice: Consistency over availability
#
# BASE (MongoDB):
# - Datacenter 1 (primary): Down
# - Datacenter 2 (secondary): Promoted to primary ✓
# - Service: UP (may have stale data temporarily)
# - Choice: Availability over consistency

# ============================================
# RAILS WITH ACID (Default)
# ============================================

# config/database.yml
production:
  adapter: postgresql
  database: myapp_production
  pool: 5
  
# Strong consistency by default
class User &lt; ApplicationRecord
  validates :email, uniqueness: true
  
  has_many :orders
end

# Transaction with rollback
User.transaction do
  user = User.create!(email: &#39;john@example.com&#39;)
  user.orders.create!(total: 99.99)
  
  # If order creation fails, user creation rolls back
end

# Guaranteed consistency ✓

# ============================================
# RAILS WITH BASE (Rare)
# ============================================

# config/mongoid.yml
production:
  clients:
    default:
      database: myapp_production
      hosts:
        - mongodb1.example.com:27017
        - mongodb2.example.com:27017
        - mongodb3.example.com:27017

# Eventual consistency
class User
  include Mongoid::Document
  
  field :email, type: String
  field :likes_count, type: Integer, default: 0
end

# Update likes (no transaction)
user.inc(likes_count: 1)  # Eventually consistent

# Different replicas may show different counts temporarily

# ============================================
# HYBRID APPROACH (Best of Both)
# ============================================

# Use ACID for critical data
# Use BASE for non-critical data

# Critical: Orders, Payments (PostgreSQL - ACID)
class Order &lt; ApplicationRecord
  # Strong consistency required
end

class Payment &lt; ApplicationRecord
  # Strong consistency required
end

# Non-critical: Likes, Views, Analytics (MongoDB - BASE)
class PostLike
  include Mongoid::Document
  # Eventual consistency OK
end

class PageView
  include Mongoid::Document
  # Eventual consistency OK
end

# Best of both worlds:
# - Strong consistency where needed
# - High scalability where acceptable
</code></pre>
<hr>
<h3>When to Choose Each</h3>
<pre><code class="language-ruby"># ========================================
# CHOOSE ACID WHEN:
# ========================================

# ✅ Financial transactions
# - Banking
# - E-commerce orders
# - Payments
# - Accounting

# ✅ Data integrity critical
# - Medical records
# - Legal documents
# - Inventory (real-time stock)

# ✅ Complex transactions
# - Multi-table updates
# - Foreign key relationships
# - Cascading deletes

# ✅ Compliance requirements
# - SOX (financial)
# - HIPAA (medical)
# - GDPR (data protection)

# Examples:
Order.transaction do
  order = Order.create!(order_params)
  Payment.create!(order: order, amount: order.total)
  Inventory.decrement!(product_id, quantity)
  # All or nothing ✓
end

# ========================================
# CHOOSE BASE WHEN:
# ========================================

# ✅ High scalability needed
# - Social media (millions of users)
# - Analytics (billions of events)
# - IoT (millions of devices)

# ✅ Eventual consistency acceptable
# - Likes/Views counts
# - Social feeds
# - Activity streams
# - Non-critical metrics

# ✅ High availability critical
# - Always-on service
# - Global distribution
# - No downtime tolerance

# ✅ Write-heavy workload
# - Logging
# - Time-series data
# - Event tracking

# Examples:
# MongoDB for social likes (eventual OK)
PostLike.create(user_id: 1, post_id: 5)
# Returns immediately
# Replicated asynchronously

# Cassandra for time-series (write-heavy)
Metric.create(
  timestamp: Time.current,
  value: cpu_usage
)
# Distributed writes
# High throughput
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>ACID</strong>: Strong consistency, limited scalability</li>
<li><strong>BASE</strong>: Eventual consistency, high scalability  </li>
<li><strong>ACID</strong>: PostgreSQL, MySQL (vertical scaling)</li>
<li><strong>BASE</strong>: MongoDB, Cassandra (horizontal scaling)</li>
<li><strong>CAP theorem</strong>: Can&#39;t have all three (C, A, P)</li>
<li><strong>Rails default</strong>: ACID (PostgreSQL)</li>
<li><strong>Financial</strong>: Always use ACID</li>
<li><strong>Social/Analytics</strong>: BASE acceptable</li>
<li><strong>Hybrid</strong>: Use both for different data</li>
<li><strong>Trade-off</strong>: Consistency vs Availability vs Scalability</li>
</ol>
<hr>
<h2>Question 334: How do you handle multiple databases in Rails 6/7?</h2>
<h3>Answer</h3>
<p>Rails 6+ supports <strong>multiple databases</strong> using <code>connects_to</code> for read replicas, horizontal sharding, or separating concerns. Configure in <code>database.yml</code>, declare connections in <code>ApplicationRecord</code>, and Rails handles routing automatically.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Multiple databases</strong>: One app, multiple DBs</li>
<li><strong>connects_to</strong>: Declare database connections in models</li>
<li><strong>Automatic routing</strong>: Rails routes queries to correct DB</li>
<li><strong>Use cases</strong>: Read replicas, sharding, separate concerns</li>
<li><strong>Configuration</strong>: database.yml with multiple databases</li>
<li><strong>Switching</strong>: connected_to block for manual switching</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# SETUP 1: Read Replicas (Most Common)
# ============================================

# config/database.yml
production:
  primary:
    &lt;&lt;: *default
    database: myapp_production
    host: primary.db.example.com
  
  primary_replica:
    &lt;&lt;: *default
    database: myapp_production
    host: replica.db.example.com
    replica: true

# app/models/application_record.rb
class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  # Configure connections
  connects_to database: {
    writing: :primary,
    reading: :primary_replica
  }
end

# Automatic routing:
# - Writes go to primary
# - Reads go to replica

# Example:
User.create!(name: &#39;John&#39;)  # → primary
User.all                     # → replica
User.where(active: true)     # → replica
User.find(1).update!(name: &#39;Jane&#39;)  # → primary

# Manual routing:
ActiveRecord::Base.connected_to(role: :writing) do
  User.all  # Forces read from primary
end

ActiveRecord::Base.connected_to(role: :reading) do
  User.all  # Forces read from replica
end

# ============================================
# SETUP 2: Multiple Databases (Separate Concerns)
# ============================================

# Separate databases for different domains

# config/database.yml
production:
  primary:
    adapter: postgresql
    database: myapp_production
    host: primary.db.example.com
  
  analytics:
    adapter: postgresql
    database: myapp_analytics
    host: analytics.db.example.com
  
  logging:
    adapter: postgresql
    database: myapp_logging
    host: logging.db.example.com

# app/models/application_record.rb
class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  connects_to database: { writing: :primary, reading: :primary }
end

# app/models/analytics_record.rb
class AnalyticsRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  connects_to database: { writing: :analytics, reading: :analytics }
end

# app/models/logging_record.rb
class LoggingRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  connects_to database: { writing: :logging, reading: :logging }
end

# Models using different databases:

# Primary database
class User &lt; ApplicationRecord
  # Uses primary database
end

class Order &lt; ApplicationRecord
  # Uses primary database
end

# Analytics database
class AnalyticsEvent &lt; AnalyticsRecord
  # Uses analytics database
end

class Report &lt; AnalyticsRecord
  # Uses analytics database
end

# Logging database
class AuditLog &lt; LoggingRecord
  # Uses logging database
end

class SystemLog &lt; LoggingRecord
  # Uses logging database
end

# Usage:
User.create!(name: &#39;John&#39;)  # → primary database
AnalyticsEvent.create!(event: &#39;signup&#39;)  # → analytics database
AuditLog.create!(action: &#39;user_created&#39;)  # → logging database

# ============================================
# SETUP 3: Horizontal Sharding
# ============================================

# Split data across multiple databases by shard key

# config/database.yml
production:
  primary:
    adapter: postgresql
    database: myapp_production
    host: primary.db.example.com
  
  shard_one:
    adapter: postgresql
    database: myapp_shard_1
    host: shard1.db.example.com
  
  shard_two:
    adapter: postgresql
    database: myapp_shard_2
    host: shard2.db.example.com
  
  shard_three:
    adapter: postgresql
    database: myapp_shard_3
    host: shard3.db.example.com

# app/models/application_record.rb
class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  connects_to shards: {
    default: { writing: :primary, reading: :primary },
    shard_one: { writing: :shard_one, reading: :shard_one },
    shard_two: { writing: :shard_two, reading: :shard_two },
    shard_three: { writing: :shard_three, reading: :shard_three }
  }
end

# app/models/user.rb
class User &lt; ApplicationRecord
  # Shard by user_id
  def self.shard_for(user_id)
    shard_number = user_id % 3 + 1
    &quot;shard_#{%w[one two three][shard_number - 1]}&quot;.to_sym
  end
end

# Usage - explicit shard selection:
user_id = 12345
shard = User.shard_for(user_id)

ActiveRecord::Base.connected_to(shard: shard) do
  User.where(id: user_id).first
end

# Automatic sharding (custom implementation):
class ShardedUser &lt; ApplicationRecord
  self.table_name = &#39;users&#39;
  
  def self.find_by_id(user_id)
    shard = shard_for(user_id)
    
    ActiveRecord::Base.connected_to(shard: shard) do
      find(user_id)
    end
  end
  
  def self.where_user_id(user_id)
    shard = shard_for(user_id)
    
    ActiveRecord::Base.connected_to(shard: shard) do
      where(id: user_id)
    end
  end
end

# ============================================
# MIGRATIONS WITH MULTIPLE DATABASES
# ============================================

# Run migrations for specific database
rails db:migrate:primary
rails db:migrate:analytics
rails db:migrate:logging

# Or all at once
rails db:migrate

# Generate migration for specific database
rails g migration AddIndexToUsers email:index database:primary
rails g migration CreateAnalyticsEvents database:analytics

# db/migrate/xxx_create_analytics_events.rb
class CreateAnalyticsEvents &lt; ActiveRecord::Migration[7.0]
  def change
    # Specify which database
    create_table :analytics_events, database: :analytics do |t|
      t.string :event_type
      t.jsonb :data
      t.timestamps
    end
  end
end

# Or use separate migration folders
# db/primary_migrate/
# db/analytics_migrate/
# db/logging_migrate/

# config/application.rb
config.paths.add &#39;db/primary_migrate&#39;, with: &#39;db/migrate&#39;
config.paths.add &#39;db/analytics_migrate&#39;, with: &#39;db/analytics_migrate&#39;
config.paths.add &#39;db/logging_migrate&#39;, with: &#39;db/logging_migrate&#39;

# ============================================
# TRANSACTIONS ACROSS DATABASES
# ============================================

# ⚠️ WARNING: Transactions DON&#39;T work across databases!

# ❌ This DOESN&#39;T work:
ApplicationRecord.transaction do
  User.create!(name: &#39;John&#39;)  # primary database
  AnalyticsEvent.create!(event: &#39;signup&#39;)  # analytics database
  # If AnalyticsEvent fails, User creation does NOT rollback!
end

# Each database has separate transaction

# ✓ Correct approach: Separate transactions with error handling
def create_user_with_analytics(user_params)
  user = nil
  
  # Create user (primary database)
  ApplicationRecord.transaction do
    user = User.create!(user_params)
  end
  
  # Create analytics event (analytics database)
  begin
    AnalyticsRecord.transaction do
      AnalyticsEvent.create!(
        event: &#39;user_signup&#39;,
        user_id: user.id
      )
    end
  rescue =&gt; e
    Rails.logger.error(&quot;Analytics event failed: #{e.message}&quot;)
    # User still created, analytics failed
    # Handle accordingly (retry, queue, ignore)
  end
  
  user
end

# Or use background jobs for cross-database operations
class CreateUserService
  def call(user_params)
    user = User.create!(user_params)
    
    # Queue analytics asynchronously
    CreateAnalyticsEventJob.perform_later(user.id, &#39;signup&#39;)
    
    user
  end
end

# ============================================
# SWITCHING DATABASES IN CONTROLLERS
# ============================================

class ReportsController &lt; ApplicationController
  # Run expensive queries on replica
  def index
    ActiveRecord::Base.connected_to(role: :reading) do
      @users = User.all
      @orders = Order.includes(:line_items)
    end
  end
  
  # Force read from primary (after write)
  def show
    @order = Order.find(params[:id])
    
    # Immediately after update, read from primary
    # (replica might be stale)
    ActiveRecord::Base.connected_to(role: :writing) do
      @order.reload
    end
  end
  
  # Query analytics database
  def analytics
    ActiveRecord::Base.connected_to(database: :analytics) do
      @events = AnalyticsEvent.where(&#39;created_at &gt; ?&#39;, 1.week.ago)
    end
  end
end

# ============================================
# AUTOMATIC ROUTING WITH MIDDLEWARE
# ============================================

# app/middleware/database_selector_middleware.rb
class DatabaseSelectorMiddleware
  def initialize(app)
    @app = app
  end
  
  def call(env)
    # Read requests → replica
    # Write requests → primary
    
    if read_request?(env)
      ActiveRecord::Base.connected_to(role: :reading) do
        @app.call(env)
      end
    else
      ActiveRecord::Base.connected_to(role: :writing) do
        @app.call(env)
      end
    end
  end
  
  private
  
  def read_request?(env)
    env[&#39;REQUEST_METHOD&#39;] == &#39;GET&#39;
  end
end

# config/application.rb
config.middleware.use DatabaseSelectorMiddleware

# ============================================
# STICKY WRITES (Read from Primary After Write)
# ============================================

# Problem: Write → Read → Stale data (replica lag)

# Solution: Read from primary for X seconds after write

# app/middleware/sticky_writes_middleware.rb
class StickyWritesMiddleware
  STICKY_DURATION = 5.seconds
  
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request = ActionDispatch::Request.new(env)
    
    # Check if recently wrote
    last_write = request.session[:last_write_at]
    recently_wrote = last_write &amp;&amp; last_write &gt; STICKY_DURATION.ago
    
    if recently_wrote || write_request?(request)
      # Use primary
      ActiveRecord::Base.connected_to(role: :writing) do
        status, headers, body = @app.call(env)
        
        # Mark write time
        if write_request?(request)
          request.session[:last_write_at] = Time.current
        end
        
        [status, headers, body]
      end
    else
      # Use replica
      ActiveRecord::Base.connected_to(role: :reading) do
        @app.call(env)
      end
    end
  end
  
  private
  
  def write_request?(request)
    %w[POST PUT PATCH DELETE].include?(request.method)
  end
end

# ============================================
# MONITORING MULTIPLE DATABASES
# ============================================

# app/controllers/health_controller.rb
class HealthController &lt; ApplicationController
  def check
    status = {
      primary: check_database(:primary),
      replica: check_database(:primary_replica),
      analytics: check_database(:analytics),
      logging: check_database(:logging)
    }
    
    all_healthy = status.values.all? { |s| s[:status] == &#39;ok&#39; }
    
    render json: status, status: all_healthy ? :ok : :service_unavailable
  end
  
  private
  
  def check_database(db_key)
    start = Time.current
    
    ActiveRecord::Base.connected_to(database: db_key) do
      ActiveRecord::Base.connection.execute(&#39;SELECT 1&#39;)
    end
    
    duration = Time.current - start
    
    {
      status: &#39;ok&#39;,
      response_time_ms: (duration * 1000).round(2)
    }
  rescue =&gt; e
    {
      status: &#39;error&#39;,
      error: e.message
    }
  end
end

# ============================================
# CONNECTION POOL PER DATABASE
# ============================================

# config/database.yml
production:
  primary:
    adapter: postgresql
    database: myapp_production
    pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;
  
  primary_replica:
    adapter: postgresql
    database: myapp_production
    pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;
    replica: true
  
  analytics:
    adapter: postgresql
    database: myapp_analytics
    pool: 10  # Larger pool for analytics queries
  
  logging:
    adapter: postgresql
    database: myapp_logging
    pool: 20  # Larger pool for logging (write-heavy)

# Each database has its own connection pool
# Primary: 5 connections
# Replica: 5 connections
# Analytics: 10 connections
# Logging: 20 connections
# Total: 40 connections per worker
</code></pre>
<hr>
<h3>Use Cases</h3>
<pre><code class="language-ruby"># =============================================
# USE CASE 1: Read Replicas (Performance)
# =============================================

# Problem: Heavy read load slowing down writes
# Solution: Route reads to replicas

# Before (single database):
# - All reads and writes on primary
# - Database overloaded
# - Slow queries affect everything

# After (read replicas):
# - Writes: Primary (5% of traffic)
# - Reads: Replicas (95% of traffic)
# - Primary has capacity for writes
# - Replicas handle read load

# =============================================
# USE CASE 2: Separate Concerns (Organization)
# =============================================

# Problem: One database with everything
# Solution: Separate databases by domain

# Before:
# myapp_production:
#   - users
#   - orders
#   - analytics_events (billions of rows!)
#   - audit_logs (billions of rows!)
#   - Slow backups
#   - Slow queries

# After:
# myapp_production:
#   - users
#   - orders
#   
# myapp_analytics:
#   - analytics_events
#   
# myapp_logging:
#   - audit_logs

# Benefits:
# - Fast backups (smaller databases)
# - Independent scaling
# - Optimize each database differently

# =============================================
# USE CASE 3: Horizontal Sharding (Scale)
# =============================================

# Problem: Single database can&#39;t handle load
# Solution: Shard by user_id

# Before:
# - 10M users in one database
# - Slow queries
# - Can&#39;t scale

# After:
# - Shard 1: Users 1-3.3M
# - Shard 2: Users 3.3M-6.6M  
# - Shard 3: Users 6.6M-10M

# Benefits:
# - Distribute load
# - Scale horizontally
# - Each shard manageable size
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Multiple databases</strong>: Rails 6+ supports natively</li>
<li><strong>connects_to</strong>: Declare connections in models</li>
<li><strong>Automatic routing</strong>: Rails routes queries to correct DB</li>
<li><strong>Read replicas</strong>: Most common use case</li>
<li><strong>Separate concerns</strong>: Different DBs for different domains</li>
<li><strong>Sharding</strong>: Distribute data across databases</li>
<li><strong>No cross-DB transactions</strong>: Each DB has separate transaction</li>
<li><strong>Sticky writes</strong>: Read from primary after write</li>
<li><strong>Connection pools</strong>: Each DB has own pool</li>
<li><strong>Monitoring</strong>: Health check all databases</li>
</ol>
<hr>
<h2>Question 335: How does Sharding and Read/Write Splitting work in Rails?</h2>
<h3>Answer</h3>
<p><strong>Sharding</strong> distributes data across multiple databases by a shard key (user_id, tenant_id). <strong>Read/Write splitting</strong> routes writes to primary and reads to replicas. Both improve scalability by distributing load.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Sharding</strong>: Split data across multiple databases</li>
<li><strong>Shard key</strong>: Determine which database (user_id, tenant_id)</li>
<li><strong>Read/Write split</strong>: Writes → primary, Reads → replicas</li>
<li><strong>Rails 6+</strong>: Native support with connects_to</li>
<li><strong>Benefits</strong>: Scale horizontally, distribute load</li>
<li><strong>Challenges</strong>: Cross-shard queries, transactions</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# READ/WRITE SPLITTING (Simpler)
# ============================================

# config/database.yml
production:
  primary:
    adapter: postgresql
    database: myapp_production
    host: primary.db.example.com
    username: &lt;%= ENV[&#39;DB_USERNAME&#39;] %&gt;
    password: &lt;%= ENV[&#39;DB_PASSWORD&#39;] %&gt;
  
  primary_replica:
    adapter: postgresql
    database: myapp_production
    host: replica.db.example.com
    username: &lt;%= ENV[&#39;DB_USERNAME&#39;] %&gt;
    password: &lt;%= ENV[&#39;DB_PASSWORD&#39;] %&gt;
    replica: true

# app/models/application_record.rb
class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  connects_to database: {
    writing: :primary,
    reading: :primary_replica
  }
end

# Automatic routing:
User.create!(name: &#39;John&#39;)      # → PRIMARY (write)
User.all                         # → REPLICA (read)
User.where(active: true)         # → REPLICA (read)
User.find(1).update!(name: &#39;Jane&#39;)  # → PRIMARY (write)

# Multiple replicas (load balancing)
production:
  primary:
    adapter: postgresql
    database: myapp_production
    host: primary.db.example.com
  
  replica_1:
    adapter: postgresql
    database: myapp_production
    host: replica1.db.example.com
    replica: true
  
  replica_2:
    adapter: postgresql
    database: myapp_production
    host: replica2.db.example.com
    replica: true
  
  replica_3:
    adapter: postgresql
    database: myapp_production
    host: replica3.db.example.com
    replica: true

# Rails automatically load balances across replicas
class ApplicationRecord &lt; ActiveRecord::Base
  connects_to database: {
    writing: :primary,
    reading: [:replica_1, :replica_2, :replica_3]
  }
end

# Read queries distributed across 3 replicas

# ============================================
# HORIZONTAL SHARDING (Advanced)
# ============================================

# Shard by user_id
# User 1-1M   → Shard 1
# User 1M-2M  → Shard 2
# User 2M-3M  → Shard 3

# config/database.yml
production:
  primary:
    adapter: postgresql
    database: myapp_primary
    host: primary.db.example.com
  
  shard_1:
    adapter: postgresql
    database: myapp_shard_1
    host: shard1.db.example.com
  
  shard_2:
    adapter: postgresql
    database: myapp_shard_2
    host: shard2.db.example.com
  
  shard_3:
    adapter: postgresql
    database: myapp_shard_3
    host: shard3.db.example.com

# app/models/application_record.rb
class ApplicationRecord &lt; ActiveRecord::Base
  self.abstract_class = true
  
  connects_to shards: {
    default: { writing: :primary },
    shard_1: { writing: :shard_1 },
    shard_2: { writing: :shard_2 },
    shard_3: { writing: :shard_3 }
  }
end

# Shard selection logic
module Sharding
  SHARDS = [:shard_1, :shard_2, :shard_3]
  USERS_PER_SHARD = 1_000_000
  
  def self.shard_for_user(user_id)
    return :default if user_id.nil?
    
    shard_index = (user_id / USERS_PER_SHARD)
    SHARDS[shard_index % SHARDS.size]
  end
  
  def self.all_shards
    SHARDS
  end
end

# app/models/user.rb
class User &lt; ApplicationRecord
  # Shard by user_id (primary key)
  
  def self.find_by_id(id)
    shard = Sharding.shard_for_user(id)
    
    ActiveRecord::Base.connected_to(shard: shard) do
      find(id)
    end
  end
  
  def self.where_user_id(id)
    shard = Sharding.shard_for_user(id)
    
    ActiveRecord::Base.connected_to(shard: shard) do
      where(id: id)
    end
  end
end

# Usage
user = User.find_by_id(1_500_000)
# Automatically queries shard_2

# app/models/post.rb
class Post &lt; ApplicationRecord
  belongs_to :user
  
  # Posts are sharded by user_id (not post_id!)
  
  def self.for_user(user_id)
    shard = Sharding.shard_for_user(user_id)
    
    ActiveRecord::Base.connected_to(shard: shard) do
      where(user_id: user_id)
    end
  end
end

# Usage
posts = Post.for_user(1_500_000)
# Queries shard_2 (same shard as user)

# ============================================
# SHARDING WITH TENANT ISOLATION (Multi-Tenant)
# ============================================

# Each tenant has own shard

# app/models/tenant.rb
class Tenant &lt; ApplicationRecord
  # Stored in primary database
  # Maps tenant_id → shard
  
  enum shard: {
    shard_1: 0,
    shard_2: 1,
    shard_3: 2
  }
end

# app/models/concerns/tenant_scoped.rb
module TenantScoped
  extend ActiveSupport::Concern
  
  included do
    # All queries scoped to current tenant
    default_scope { where(tenant_id: Current.tenant_id) }
    
    # All writes go to tenant&#39;s shard
    before_create :set_tenant
  end
  
  private
  
  def set_tenant
    self.tenant_id = Current.tenant_id
  end
  
  class_methods do
    def shard_for_tenant(tenant_id)
      tenant = Tenant.find(tenant_id)
      tenant.shard.to_sym
    end
    
    # Override query methods to use correct shard
    def all
      shard = shard_for_tenant(Current.tenant_id)
      
      ActiveRecord::Base.connected_to(shard: shard) do
        super
      end
    end
  end
end

# app/models/account.rb
class Account &lt; ApplicationRecord
  include TenantScoped
  
  # Automatically scoped to tenant
  # Automatically uses tenant&#39;s shard
end

# Middleware to set current tenant
class TenantMiddleware
  def initialize(app)
    @app = app
  end
  
  def call(env)
    request = ActionDispatch::Request.new(env)
    
    # Get tenant from subdomain or header
    tenant_id = extract_tenant_id(request)
    
    Current.tenant_id = tenant_id
    
    @app.call(env)
  ensure
    Current.tenant_id = nil
  end
  
  private
  
  def extract_tenant_id(request)
    # From subdomain: acme.myapp.com → &#39;acme&#39;
    subdomain = request.subdomain
    tenant = Tenant.find_by(subdomain: subdomain)
    tenant&amp;.id
  end
end

# ============================================
# CROSS-SHARD QUERIES (Challenge)
# ============================================

# Problem: Query across all shards

# ❌ This doesn&#39;t work:
User.where(email: &#39;john@example.com&#39;)
# Which shard? Must query all!

# ✓ Solution: Query each shard
def find_user_by_email(email)
  Sharding.all_shards.each do |shard|
    user = ActiveRecord::Base.connected_to(shard: shard) do
      User.find_by(email: email)
    end
    
    return user if user
  end
  
  nil
end

# ✓ Solution: Parallel queries
def find_user_by_email_parallel(email)
  results = Parallel.map(Sharding.all_shards) do |shard|
    ActiveRecord::Base.connected_to(shard: shard) do
      User.find_by(email: email)
    end
  end
  
  results.compact.first
end

# ✓ Solution: Lookup table (recommended)
# Keep non-sharded lookup table in primary

class UserLookup &lt; ApplicationRecord
  # In primary database
  # Maps email → shard + user_id
end

def find_user_by_email_with_lookup(email)
  lookup = UserLookup.find_by(email: email)
  return nil unless lookup
  
  ActiveRecord::Base.connected_to(shard: lookup.shard) do
    User.find(lookup.user_id)
  end
end

# Only 2 queries instead of N queries!

# ============================================
# COMBINING SHARDING + READ/WRITE SPLITTING
# ============================================

# Best of both worlds

# config/database.yml
production:
  primary:
    adapter: postgresql
    database: myapp_primary
    host: primary.db.example.com
  
  # Shard 1 with replica
  shard_1_primary:
    adapter: postgresql
    database: myapp_shard_1
    host: shard1-primary.db.example.com
  
  shard_1_replica:
    adapter: postgresql
    database: myapp_shard_1
    host: shard1-replica.db.example.com
    replica: true
  
  # Shard 2 with replica
  shard_2_primary:
    adapter: postgresql
    database: myapp_shard_2
    host: shard2-primary.db.example.com
  
  shard_2_replica:
    adapter: postgresql
    database: myapp_shard_2
    host: shard2-replica.db.example.com
    replica: true

# app/models/application_record.rb
class ApplicationRecord &lt; ActiveRecord::Base
  connects_to shards: {
    default: {
      writing: :primary,
      reading: :primary
    },
    shard_1: {
      writing: :shard_1_primary,
      reading: :shard_1_replica
    },
    shard_2: {
      writing: :shard_2_primary,
      reading: :shard_2_replica
    }
  }
end

# Now queries are:
# 1. Routed to correct shard
# 2. Writes → shard primary
# 3. Reads → shard replica

# Example:
user_id = 1_500_000  # Shard 2
shard = Sharding.shard_for_user(user_id)  # =&gt; :shard_2

# Read (goes to shard_2_replica)
ActiveRecord::Base.connected_to(shard: shard) do
  User.find(user_id)
end

# Write (goes to shard_2_primary)
ActiveRecord::Base.connected_to(shard: shard) do
  User.find(user_id).update!(name: &#39;Jane&#39;)
end

# ============================================
# MIGRATIONS WITH SHARDING
# ============================================

# Run migration on all shards

namespace :db do
  desc &quot;Migrate all shards&quot;
  task migrate_all_shards: :environment do
    # Migrate primary
    puts &quot;Migrating primary...&quot;
    Rake::Task[&#39;db:migrate:primary&#39;].invoke
    
    # Migrate each shard
    Sharding.all_shards.each do |shard|
      puts &quot;Migrating #{shard}...&quot;
      
      ActiveRecord::Base.connected_to(shard: shard) do
        ActiveRecord::Tasks::DatabaseTasks.migrate
      end
    end
  end
end

# Run: rails db:migrate_all_shards

# ============================================
# MONITORING SHARDS
# ============================================

class ShardHealthController &lt; ApplicationController
  def check
    status = {}
    
    # Check each shard
    Sharding.all_shards.each do |shard|
      status[shard] = check_shard(shard)
    end
    
    all_healthy = status.values.all? { |s| s[:status] == &#39;ok&#39; }
    
    render json: status, status: all_healthy ? :ok : :service_unavailable
  end
  
  private
  
  def check_shard(shard)
    start = Time.current
    
    ActiveRecord::Base.connected_to(shard: shard) do
      ActiveRecord::Base.connection.execute(&#39;SELECT 1&#39;)
      
      # Check record count
      user_count = User.count
      
      {
        status: &#39;ok&#39;,
        response_time_ms: ((Time.current - start) * 1000).round(2),
        user_count: user_count
      }
    end
  rescue =&gt; e
    {
      status: &#39;error&#39;,
      error: e.message
    }
  end
end

# GET /shard_health/check
# {
#   &quot;shard_1&quot;: {&quot;status&quot;: &quot;ok&quot;, &quot;response_time_ms&quot;: 5.2, &quot;user_count&quot;: 950000},
#   &quot;shard_2&quot;: {&quot;status&quot;: &quot;ok&quot;, &quot;response_time_ms&quot;: 4.8, &quot;user_count&quot;: 1020000},
#   &quot;shard_3&quot;: {&quot;status&quot;: &quot;ok&quot;, &quot;response_time_ms&quot;: 6.1, &quot;user_count&quot;: 980000}
# }
</code></pre>
<hr>
<h3>Sharding Strategies</h3>
<pre><code class="language-ruby"># ============================================
# STRATEGY 1: Hash-Based Sharding
# ============================================

# Distribute evenly using hash function
def shard_for_user(user_id)
  hash = Digest::MD5.hexdigest(user_id.to_s).to_i(16)
  shard_index = hash % SHARDS.size
  SHARDS[shard_index]
end

# Pros: Even distribution
# Cons: Adding shards requires resharding

# ============================================
# STRATEGY 2: Range-Based Sharding
# ============================================

# Split by ranges
def shard_for_user(user_id)
  case user_id
  when 0..999_999
    :shard_1
  when 1_000_000..1_999_999
    :shard_2
  when 2_000_000..Float::INFINITY
    :shard_3
  end
end

# Pros: Easy to add shards
# Cons: Uneven distribution

# ============================================
# STRATEGY 3: Directory-Based Sharding
# ============================================

# Lookup table maps entity → shard
class ShardDirectory &lt; ApplicationRecord
  # user_id | shard
  # 1       | shard_1
  # 2       | shard_2
end

def shard_for_user(user_id)
  directory = ShardDirectory.find_by(user_id: user_id)
  directory.shard.to_sym
end

# Pros: Flexible, can move users between shards
# Cons: Extra lookup query
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Read/Write split</strong>: Writes → primary, Reads → replicas</li>
<li><strong>Sharding</strong>: Distribute data across databases</li>
<li><strong>Shard key</strong>: Determines which database (user_id, tenant_id)</li>
<li><strong>Rails 6+</strong>: Native support with connects_to</li>
<li><strong>Load balancing</strong>: Multiple replicas for reads</li>
<li><strong>Cross-shard queries</strong>: Query each shard (slow)</li>
<li><strong>Lookup tables</strong>: Map email → shard + ID</li>
<li><strong>Combining</strong>: Sharding + Read/Write split together</li>
<li><strong>Migrations</strong>: Run on all shards</li>
<li><strong>Monitoring</strong>: Health check each shard</li>
</ol>
<h1>Advanced Topics: Code Quality, Reusability &amp; Performance (336-342)</h1>
<h2>Code Quality and Reusability</h2>
<h2>Question 336: What is reusability in Rails?</h2>
<h3>Answer</h3>
<p><strong>Reusability</strong> in Rails means writing code once and using it in multiple places through <strong>concerns</strong>, <strong>services</strong>, <strong>helpers</strong>, <strong>partials</strong>, <strong>gems</strong>, and <strong>engines</strong> to reduce duplication, improve maintainability, and follow DRY principles.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Concerns</strong>: Shared model/controller behavior</li>
<li><strong>Services</strong>: Reusable business logic</li>
<li><strong>Helpers</strong>: View logic used across views</li>
<li><strong>Partials</strong>: Reusable view components</li>
<li><strong>Gems</strong>: Reusable across applications</li>
<li><strong>Engines</strong>: Mountable mini-applications</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<pre><code class="language-ruby"># ============================================
# REUSABILITY PATTERN 1: Concerns (Models)
# ============================================

# Problem: Same logic repeated in multiple models
class Post &lt; ApplicationRecord
  validates :slug, presence: true, uniqueness: true
  
  before_validation :generate_slug
  
  def to_param
    slug
  end
  
  private
  
  def generate_slug
    self.slug = title.parameterize if title.present?
  end
end

class Article &lt; ApplicationRecord
  validates :slug, presence: true, uniqueness: true
  
  before_validation :generate_slug
  
  def to_param
    slug
  end
  
  private
  
  def generate_slug
    self.slug = title.parameterize if title.present?
  end
end

# ✅ Solution: Extract to concern (reusable)
# app/models/concerns/sluggable.rb
module Sluggable
  extend ActiveSupport::Concern
  
  included do
    validates :slug, presence: true, uniqueness: true
    before_validation :generate_slug
  end
  
  def to_param
    slug
  end
  
  private
  
  def generate_slug
    self.slug ||= title.parameterize if title.present?
  end
end

# Use in multiple models
class Post &lt; ApplicationRecord
  include Sluggable
end

class Article &lt; ApplicationRecord
  include Sluggable
end

class Product &lt; ApplicationRecord
  include Sluggable
end

# One implementation, used everywhere ✓

# ============================================
# REUSABILITY PATTERN 2: Service Objects
# ============================================

# Problem: Same business logic in multiple controllers

# ❌ Repeated in multiple controllers
class UsersController &lt; ApplicationController
  def create
    user = User.new(user_params)
    if user.save
      UserMailer.welcome(user).deliver_later
      Analytics.track(&#39;user_signup&#39;, user_id: user.id)
      redirect_to user
    else
      render :new
    end
  end
end

class Api::UsersController &lt; ApplicationController
  def create
    user = User.new(user_params)
    if user.save
      UserMailer.welcome(user).deliver_later
      Analytics.track(&#39;user_signup&#39;, user_id: user.id)
      render json: user, status: :created
    else
      render json: {errors: user.errors}, status: :unprocessable_entity
    end
  end
end

# ✅ Solution: Extract to service (reusable)
# app/services/user_registration_service.rb
class UserRegistrationService
  def initialize(params)
    @params = params
  end
  
  def call
    user = User.new(@params)
    
    if user.save
      send_welcome_email(user)
      track_analytics(user)
      Result.success(user)
    else
      Result.failure(user.errors)
    end
  end
  
  private
  
  def send_welcome_email(user)
    UserMailer.welcome(user).deliver_later
  end
  
  def track_analytics(user)
    Analytics.track(&#39;user_signup&#39;, user_id: user.id)
  end
  
  Result = Struct.new(:success?, :data, :errors) do
    def self.success(data)
      new(true, data, nil)
    end
    
    def self.failure(errors)
      new(false, nil, errors)
    end
  end
end

# Use in multiple controllers
class UsersController &lt; ApplicationController
  def create
    result = UserRegistrationService.new(user_params).call
    
    if result.success?
      redirect_to result.data
    else
      @errors = result.errors
      render :new
    end
  end
end

class Api::UsersController &lt; ApplicationController
  def create
    result = UserRegistrationService.new(user_params).call
    
    if result.success?
      render json: result.data, status: :created
    else
      render json: {errors: result.errors}, status: :unprocessable_entity
    end
  end
end

# One service, multiple uses ✓

# ============================================
# REUSABILITY PATTERN 3: Helpers
# ============================================

# Problem: Same formatting logic in multiple views

# ❌ Repeated in views
# app/views/users/show.html.erb
&lt;p&gt;Joined: &lt;%= @user.created_at.strftime(&#39;%B %d, %Y&#39;) %&gt;&lt;/p&gt;

# app/views/posts/show.html.erb
&lt;p&gt;Published: &lt;%= @post.created_at.strftime(&#39;%B %d, %Y&#39;) %&gt;&lt;/p&gt;

# ✅ Solution: Extract to helper (reusable)
# app/helpers/date_helper.rb
module DateHelper
  def format_date(date)
    return &#39;N/A&#39; if date.nil?
    date.strftime(&#39;%B %d, %Y&#39;)
  end
  
  def time_ago_in_words_custom(time)
    return &#39;never&#39; if time.nil?
    &quot;#{time_ago_in_words(time)} ago&quot;
  end
end

# Use in multiple views
# app/views/users/show.html.erb
&lt;p&gt;Joined: &lt;%= format_date(@user.created_at) %&gt;&lt;/p&gt;

# app/views/posts/show.html.erb
&lt;p&gt;Published: &lt;%= format_date(@post.created_at) %&gt;&lt;/p&gt;

# app/views/comments/index.html.erb
&lt;p&gt;Posted: &lt;%= time_ago_in_words_custom(comment.created_at) %&gt;&lt;/p&gt;

# ============================================
# REUSABILITY PATTERN 4: Partials
# ============================================

# Problem: Same HTML structure repeated

# ❌ Repeated in multiple views
# app/views/posts/show.html.erb
&lt;div class=&quot;card&quot;&gt;
  &lt;h2&gt;&lt;%= @post.title %&gt;&lt;/h2&gt;
  &lt;p&gt;&lt;%= @post.body %&gt;&lt;/p&gt;
  &lt;span class=&quot;author&quot;&gt;&lt;%= @post.user.name %&gt;&lt;/span&gt;
&lt;/div&gt;

# app/views/posts/index.html.erb
&lt;% @posts.each do |post| %&gt;
  &lt;div class=&quot;card&quot;&gt;
    &lt;h2&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
    &lt;p&gt;&lt;%= post.body %&gt;&lt;/p&gt;
    &lt;span class=&quot;author&quot;&gt;&lt;%= post.user.name %&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;% end %&gt;

# ✅ Solution: Extract to partial (reusable)
# app/views/posts/_post_card.html.erb
&lt;div class=&quot;card&quot;&gt;
  &lt;h2&gt;&lt;%= post.title %&gt;&lt;/h2&gt;
  &lt;p&gt;&lt;%= post.body %&gt;&lt;/p&gt;
  &lt;span class=&quot;author&quot;&gt;&lt;%= post.user.name %&gt;&lt;/span&gt;
&lt;/div&gt;

# Use in multiple views
# app/views/posts/show.html.erb
&lt;%= render &#39;post_card&#39;, post: @post %&gt;

# app/views/posts/index.html.erb
&lt;%= render partial: &#39;post_card&#39;, collection: @posts %&gt;

# app/views/dashboard/index.html.erb
&lt;h3&gt;Recent Posts&lt;/h3&gt;
&lt;%= render partial: &#39;posts/post_card&#39;, collection: @recent_posts %&gt;

# ============================================
# REUSABILITY PATTERN 5: View Components
# ============================================

# Modern approach with ViewComponent gem

# Gemfile
gem &#39;view_component&#39;

# app/components/card_component.rb
class CardComponent &lt; ViewComponent::Base
  def initialize(title:, body:, author:)
    @title = title
    @body = body
    @author = author
  end
end

# app/components/card_component.html.erb
&lt;div class=&quot;card&quot;&gt;
  &lt;h2&gt;&lt;%= @title %&gt;&lt;/h2&gt;
  &lt;p&gt;&lt;%= @body %&gt;&lt;/p&gt;
  &lt;span class=&quot;author&quot;&gt;&lt;%= @author %&gt;&lt;/span&gt;
&lt;/div&gt;

# Use anywhere
&lt;%= render CardComponent.new(
  title: @post.title,
  body: @post.body,
  author: @post.user.name
) %&gt;

# Benefits:
# - Encapsulated logic
# - Unit testable
# - Reusable across app

# ============================================
# REUSABILITY PATTERN 6: Gems
# ============================================

# Extract common functionality to gem

# Create gem
# bundle gem my_formatter

# lib/my_formatter.rb
module MyFormatter
  def self.format_currency(amount, currency = &#39;USD&#39;)
    &quot;$#{sprintf(&#39;%.2f&#39;, amount)}&quot;
  end
  
  def self.format_phone(phone)
    phone.gsub(/(\d{3})(\d{3})(\d{4})/, &#39;(\1) \2-\3&#39;)
  end
end

# my_formatter.gemspec
Gem::Specification.new do |spec|
  spec.name          = &quot;my_formatter&quot;
  spec.version       = &quot;1.0.0&quot;
  spec.authors       = [&quot;Your Name&quot;]
  spec.summary       = &quot;Common formatters&quot;
  
  spec.files         = Dir[&#39;lib/**/*&#39;]
  spec.require_paths = [&quot;lib&quot;]
end

# Use in multiple projects
# Gemfile
gem &#39;my_formatter&#39;, git: &#39;https://github.com/yourname/my_formatter&#39;

# Usage
MyFormatter.format_currency(99.99)  # =&gt; &quot;$99.99&quot;
MyFormatter.format_phone(&#39;5551234567&#39;)  # =&gt; &quot;(555) 123-4567&quot;

# ============================================
# REUSABILITY PATTERN 7: Rails Engines
# ============================================

# Create mountable engine
rails plugin new blog_engine --mountable

# Engine structure:
# blog_engine/
#   app/
#     controllers/
#     models/
#     views/
#   lib/
#     blog_engine.rb
#     blog_engine/engine.rb

# lib/blog_engine/engine.rb
module BlogEngine
  class Engine &lt; ::Rails::Engine
    isolate_namespace BlogEngine
  end
end

# Use in main app
# Gemfile
gem &#39;blog_engine&#39;, path: &#39;../blog_engine&#39;

# config/routes.rb
Rails.application.routes.draw do
  mount BlogEngine::Engine =&gt; &quot;/blog&quot;
end

# Now blog functionality available at /blog
# Reusable across multiple applications

# ============================================
# REUSABILITY PATTERN 8: Decorators
# ============================================

# Extract presentation logic

# app/decorators/user_decorator.rb
class UserDecorator &lt; SimpleDelegator
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
  
  def avatar_url(size = :medium)
    if avatar.attached?
      Rails.application.routes.url_helpers.rails_blob_url(
        avatar.variant(resize_to_limit: [size_px(size), size_px(size)])
      )
    else
      &quot;/default-avatar.png&quot;
    end
  end
  
  private
  
  def size_px(size)
    {small: 50, medium: 200, large: 800}[size]
  end
end

# Use in views
&lt;%= image_tag @user.decorate.avatar_url(:medium) %&gt;
&lt;h1&gt;&lt;%= @user.decorate.full_name %&gt;&lt;/h1&gt;

# Reusable presentation logic ✓

# ============================================
# REUSABILITY PATTERN 9: Query Objects
# ============================================

# Extract complex queries

# app/queries/user_search_query.rb
class UserSearchQuery
  def initialize(relation = User.all)
    @relation = relation
  end
  
  def call(params)
    @relation
      .then { |r| by_name(r, params[:name]) }
      .then { |r| by_email(r, params[:email]) }
      .then { |r| by_status(r, params[:status]) }
      .then { |r| by_created_date(r, params[:from], params[:to]) }
  end
  
  private
  
  def by_name(relation, name)
    return relation if name.blank?
    relation.where(&#39;name ILIKE ?&#39;, &quot;%#{name}%&quot;)
  end
  
  def by_email(relation, email)
    return relation if email.blank?
    relation.where(&#39;email ILIKE ?&#39;, &quot;%#{email}%&quot;)
  end
  
  def by_status(relation, status)
    return relation if status.blank?
    relation.where(status: status)
  end
  
  def by_created_date(relation, from, to)
    relation = relation.where(&#39;created_at &gt;= ?&#39;, from) if from.present?
    relation = relation.where(&#39;created_at &lt;= ?&#39;, to) if to.present?
    relation
  end
end

# Use in multiple controllers
class UsersController &lt; ApplicationController
  def index
    @users = UserSearchQuery.new.call(search_params)
  end
end

class Admin::UsersController &lt; ApplicationController
  def index
    @users = UserSearchQuery.new(User.unscoped).call(search_params)
  end
end

# ============================================
# REUSABILITY BENEFITS
# ============================================

# 1. DRY (Don&#39;t Repeat Yourself)
# - Write once, use many times
# - Single source of truth

# 2. Maintainability
# - Fix bug once, fixes everywhere
# - Update logic once, updates everywhere

# 3. Testability
# - Test once, confidence everywhere
# - Easier to test isolated components

# 4. Consistency
# - Same behavior everywhere
# - Reduces bugs from inconsistency

# 5. Productivity
# - Don&#39;t rewrite same code
# - Focus on new features

# Example: Fix once, fixes everywhere
# Bug in Sluggable concern
module Sluggable
  def generate_slug
    # Fixed: handle nil titles
    self.slug ||= (title&amp;.parameterize || &quot;item-#{SecureRandom.hex(4)}&quot;)
  end
end

# Fix applies to:
# - Post
# - Article
# - Product
# All fixed with one change! ✓
</code></pre>
<hr>
<h3>Reusability Best Practices</h3>
<pre><code class="language-ruby"># 1. Identify Duplication
# Look for repeated patterns in code

# 2. Extract to Appropriate Pattern
# - Model logic → Concern
# - Business logic → Service
# - View logic → Helper
# - HTML structure → Partial/Component
# - Cross-app → Gem

# 3. Make it Configurable
module Sluggable
  extend ActiveSupport::Concern
  
  included do |base|
    base.class_eval do
      validates :slug, presence: true, uniqueness: {scope: slug_scope}
    end
  end
  
  class_methods do
    def slug_scope
      []  # Override in model
    end
  end
end

class Post &lt; ApplicationRecord
  include Sluggable
  
  def self.slug_scope
    :user_id  # Unique per user
  end
end

# 4. Document Usage
# Add examples in comments

# 5. Test Thoroughly
# spec/models/concerns/sluggable_spec.rb
RSpec.describe Sluggable do
  let(:model_class) do
    Class.new(ApplicationRecord) do
      self.table_name = &#39;posts&#39;
      include Sluggable
    end
  end
  
  it &quot;generates slug from title&quot; do
    post = model_class.new(title: &quot;Hello World&quot;)
    post.valid?
    expect(post.slug).to eq(&quot;hello-world&quot;)
  end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Reusability</strong>: Write once, use many times</li>
<li><strong>Concerns</strong>: Shared model/controller behavior</li>
<li><strong>Services</strong>: Reusable business logic</li>
<li><strong>Helpers</strong>: View logic used across views</li>
<li><strong>Partials</strong>: Reusable HTML components</li>
<li><strong>ViewComponent</strong>: Modern component approach</li>
<li><strong>Gems</strong>: Reusable across applications</li>
<li><strong>Engines</strong>: Mountable mini-applications</li>
<li><strong>Benefits</strong>: DRY, maintainable, testable, consistent</li>
<li><strong>Identify duplication</strong>: Extract to appropriate pattern</li>
</ol>
<hr>
<h2>Question 337: What is DRY (Don&#39;t Repeat Yourself)?</h2>
<h3>Answer</h3>
<p><strong>DRY (Don&#39;t Repeat Yourself)</strong> is a software principle stating that every piece of knowledge should have a single, unambiguous representation. Avoid duplicating code by extracting common logic to reusable components.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Principle</strong>: Don&#39;t duplicate code or logic</li>
<li><strong>Single source of truth</strong>: One place for each concept</li>
<li><strong>Extract duplication</strong>: Use concerns, services, helpers</li>
<li><strong>Benefits</strong>: Easier maintenance, fewer bugs, consistency</li>
<li><strong>Rails support</strong>: Concerns, partials, helpers, inheritance</li>
<li><strong>Opposite</strong>: WET (Write Everything Twice)</li>
</ul>
<hr>
<h3>Detailed Explanation</h3>
<pre><code class="language-ruby"># ============================================
# DRY PRINCIPLE
# ============================================

# ❌ WET (Write Everything Twice) - BAD
class User &lt; ApplicationRecord
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
  
  def initials
    &quot;#{first_name[0]}#{last_name[0]}&quot;
  end
end

class Admin &lt; ApplicationRecord
  def full_name
    &quot;#{first_name} #{last_name}&quot;  # Duplicated!
  end
  
  def initials
    &quot;#{first_name[0]}#{last_name[0]}&quot;  # Duplicated!
  end
end

# Problems:
# - Code duplicated
# - Bug fix needed in 2 places
# - Inconsistency risk

# ✅ DRY - GOOD
module Nameable
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
  
  def initials
    &quot;#{first_name[0]}#{last_name[0]}&quot;
  end
end

class User &lt; ApplicationRecord
  include Nameable
end

class Admin &lt; ApplicationRecord
  include Nameable
end

# Benefits:
# - Code written once
# - Bug fix in one place
# - Guaranteed consistency

# ============================================
# DRY IN MODELS
# ============================================

# ❌ WET: Repeated validations
class Post &lt; ApplicationRecord
  validates :title, presence: true
  validates :title, length: {minimum: 3, maximum: 100}
  validates :slug, presence: true
  validates :slug, uniqueness: true
  
  before_validation :generate_slug
  
  private
  
  def generate_slug
    self.slug = title.parameterize if title
  end
end

class Article &lt; ApplicationRecord
  validates :title, presence: true
  validates :title, length: {minimum: 3, maximum: 100}
  validates :slug, presence: true
  validates :slug, uniqueness: true
  
  before_validation :generate_slug
  
  private
  
  def generate_slug
    self.slug = title.parameterize if title
  end
end

# ✅ DRY: Extract to concern
module Publishable
  extend ActiveSupport::Concern
  
  included do
    validates :title, presence: true, length: {minimum: 3, maximum: 100}
    validates :slug, presence: true, uniqueness: true
    
    before_validation :generate_slug
  end
  
  private
  
  def generate_slug
    self.slug ||= title.parameterize if title.present?
  end
end

class Post &lt; ApplicationRecord
  include Publishable
end

class Article &lt; ApplicationRecord
  include Publishable
end

# ============================================
# DRY IN CONTROLLERS
# ============================================

# ❌ WET: Repeated before_action
class PostsController &lt; ApplicationController
  before_action :authenticate_user!
  before_action :set_post, only: [:show, :edit, :update, :destroy]
  
  def show
  end
  
  def edit
  end
  
  private
  
  def set_post
    @post = Post.find(params[:id])
  end
end

class ArticlesController &lt; ApplicationController
  before_action :authenticate_user!
  before_action :set_article, only: [:show, :edit, :update, :destroy]
  
  def show
  end
  
  def edit
  end
  
  private
  
  def set_article
    @article = Article.find(params[:id])
  end
end

# ✅ DRY: Extract to base controller
class ApplicationController &lt; ActionController::Base
  before_action :authenticate_user!
end

# Generic resource loading
class ResourceController &lt; ApplicationController
  before_action :set_resource, only: [:show, :edit, :update, :destroy]
  
  private
  
  def set_resource
    resource_class = controller_name.classify.constantize
    instance_variable_set(
      &quot;@#{controller_name.singularize}&quot;,
      resource_class.find(params[:id])
    )
  end
end

class PostsController &lt; ResourceController
  def show
    # @post automatically set
  end
end

class ArticlesController &lt; ResourceController
  def show
    # @article automatically set
  end
end

# ============================================
# DRY IN VIEWS
# ============================================

# ❌ WET: Repeated HTML
# app/views/posts/show.html.erb
&lt;div class=&quot;card&quot;&gt;
  &lt;h2&gt;&lt;%= @post.title %&gt;&lt;/h2&gt;
  &lt;p&gt;&lt;%= @post.body %&gt;&lt;/p&gt;
  &lt;div class=&quot;meta&quot;&gt;
    &lt;span class=&quot;author&quot;&gt;&lt;%= @post.user.name %&gt;&lt;/span&gt;
    &lt;span class=&quot;date&quot;&gt;&lt;%= @post.created_at.strftime(&#39;%B %d, %Y&#39;) %&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;

# app/views/articles/show.html.erb
&lt;div class=&quot;card&quot;&gt;
  &lt;h2&gt;&lt;%= @article.title %&gt;&lt;/h2&gt;
  &lt;p&gt;&lt;%= @article.body %&gt;&lt;/p&gt;
  &lt;div class=&quot;meta&quot;&gt;
    &lt;span class=&quot;author&quot;&gt;&lt;%= @article.user.name %&gt;&lt;/span&gt;
    &lt;span class=&quot;date&quot;&gt;&lt;%= @article.created_at.strftime(&#39;%B %d, %Y&#39;) %&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;

# ✅ DRY: Extract to partial
# app/views/shared/_content_card.html.erb
&lt;div class=&quot;card&quot;&gt;
  &lt;h2&gt;&lt;%= content.title %&gt;&lt;/h2&gt;
  &lt;p&gt;&lt;%= content.body %&gt;&lt;/p&gt;
  &lt;div class=&quot;meta&quot;&gt;
    &lt;span class=&quot;author&quot;&gt;&lt;%= content.user.name %&gt;&lt;/span&gt;
    &lt;span class=&quot;date&quot;&gt;&lt;%= content.created_at.strftime(&#39;%B %d, %Y&#39;) %&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;

# app/views/posts/show.html.erb
&lt;%= render &#39;shared/content_card&#39;, content: @post %&gt;

# app/views/articles/show.html.erb
&lt;%= render &#39;shared/content_card&#39;, content: @article %&gt;

# ============================================
# DRY IN TESTS
# ============================================

# ❌ WET: Repeated test setup
RSpec.describe PostsController do
  let(:user) { User.create!(name: &#39;John&#39;, email: &#39;john@example.com&#39;) }
  
  before do
    sign_in user
  end
  
  describe &quot;GET #index&quot; do
    it &quot;returns success&quot; do
      get :index
      expect(response).to be_successful
    end
  end
end

RSpec.describe ArticlesController do
  let(:user) { User.create!(name: &#39;John&#39;, email: &#39;john@example.com&#39;) }
  
  before do
    sign_in user
  end
  
  describe &quot;GET #index&quot; do
    it &quot;returns success&quot; do
      get :index
      expect(response).to be_successful
    end
  end
end

# ✅ DRY: Extract to shared examples
# spec/support/shared_examples/authenticated_controller.rb
RSpec.shared_examples &quot;authenticated controller&quot; do
  let(:user) { create(:user) }
  
  before do
    sign_in user
  end
end

RSpec.shared_examples &quot;index action&quot; do
  describe &quot;GET #index&quot; do
    it &quot;returns success&quot; do
      get :index
      expect(response).to be_successful
    end
  end
end

# Use in specs
RSpec.describe PostsController do
  it_behaves_like &quot;authenticated controller&quot;
  it_behaves_like &quot;index action&quot;
end

RSpec.describe ArticlesController do
  it_behaves_like &quot;authenticated controller&quot;
  it_behaves_like &quot;index action&quot;
end

# ============================================
# DRY IN ROUTES
# ============================================

# ❌ WET: Repeated route patterns
Rails.application.routes.draw do
  namespace :api do
    namespace :v1 do
      resources :posts do
        member do
          post :publish
          post :unpublish
        end
      end
      
      resources :articles do
        member do
          post :publish
          post :unpublish
        end
      end
    end
  end
end

# ✅ DRY: Extract to concern
# config/routes/concerns/publishable_routes.rb
concern :publishable do
  member do
    post :publish
    post :unpublish
  end
end

# config/routes.rb
Rails.application.routes.draw do
  namespace :api do
    namespace :v1 do
      resources :posts, concerns: :publishable
      resources :articles, concerns: :publishable
    end
  end
end

# ============================================
# DRY IN CONFIGURATION
# ============================================

# ❌ WET: Repeated configuration
# config/environments/staging.rb
config.action_mailer.smtp_settings = {
  address: &#39;smtp.gmail.com&#39;,
  port: 587,
  user_name: ENV[&#39;SMTP_USERNAME&#39;],
  password: ENV[&#39;SMTP_PASSWORD&#39;],
  authentication: &#39;plain&#39;,
  enable_starttls_auto: true
}

# config/environments/production.rb
config.action_mailer.smtp_settings = {
  address: &#39;smtp.gmail.com&#39;,
  port: 587,
  user_name: ENV[&#39;SMTP_USERNAME&#39;],
  password: ENV[&#39;SMTP_PASSWORD&#39;],
  authentication: &#39;plain&#39;,
  enable_starttls_auto: true
}

# ✅ DRY: Extract to shared config
# config/smtp.yml
default: &amp;default
  address: &#39;smtp.gmail.com&#39;
  port: 587
  user_name: &lt;%= ENV[&#39;SMTP_USERNAME&#39;] %&gt;
  password: &lt;%= ENV[&#39;SMTP_PASSWORD&#39;] %&gt;
  authentication: &#39;plain&#39;
  enable_starttls_auto: true

staging:
  &lt;&lt;: *default

production:
  &lt;&lt;: *default

# Load in environments
smtp_config = Rails.application.config_for(:smtp)
config.action_mailer.smtp_settings = smtp_config.symbolize_keys

# ============================================
# DRY VS OVER-DRY
# ============================================

# ✅ GOOD DRY: Extract truly duplicated logic
module Timestampable
  def created_at_formatted
    created_at.strftime(&#39;%B %d, %Y&#39;)
  end
end

# ❌ OVER-DRY: Extract too much
module StringHelpers
  def uppercase
    upcase
  end
  
  def lowercase
    downcase
  end
end

# This is abstraction for abstraction&#39;s sake
# Don&#39;t DRY everything!

# Rule: DRY when there&#39;s actual duplication
# Don&#39;t DRY when:
# - It&#39;s coincidental similarity
# - It reduces clarity
# - It creates unnecessary coupling
</code></pre>
<hr>
<h3>When to Apply DRY</h3>
<pre><code class="language-ruby"># ========================================
# APPLY DRY WHEN:
# ========================================

# ✅ Same logic in multiple places
# Extract to shared module/service

# ✅ Same validations
# Extract to concern

# ✅ Same HTML structure
# Extract to partial

# ✅ Same test setup
# Extract to shared examples

# ✅ Same business logic
# Extract to service object

# ========================================
# DON&#39;T APPLY DRY WHEN:
# ========================================

# ❌ Coincidental similarity
# Two things look similar but have different reasons to change

# Example:
class Invoice
  def total
    line_items.sum(&amp;:amount)  # Sum of line items
  end
end

class ShoppingCart
  def total
    items.sum(&amp;:price)  # Sum of prices
  end
end

# Don&#39;t extract to shared method!
# These totals mean different things
# Will change for different reasons

# ❌ Reduces clarity
# Don&#39;t make code generic just to DRY

# Bad example:
def process_thing(thing, type)
  case type
  when :user
    # user logic
  when :post
    # post logic
  when :order
    # order logic
  end
end

# Better: Separate methods
def process_user(user)
  # user logic
end

def process_post(post)
  # post logic
end

# ❌ Creates unnecessary coupling
# Don&#39;t DRY if it couples unrelated code

# Bad:
module UserAndPostStuff
  # Random mix of user and post logic
end

# Good: Separate concerns
module UserHelpers
end

module PostHelpers
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>DRY</strong>: Don&#39;t Repeat Yourself</li>
<li><strong>Single source of truth</strong>: One place for each concept</li>
<li><strong>Extract duplication</strong>: Use concerns, services, helpers</li>
<li><strong>Benefits</strong>: Maintainable, consistent, fewer bugs</li>
<li><strong>Rails patterns</strong>: Concerns, partials, inheritance</li>
<li><strong>Not always</strong>: Don&#39;t over-DRY</li>
<li><strong>Balance</strong>: DRY vs clarity</li>
<li><strong>Rule</strong>: Extract when truly duplicated</li>
<li><strong>Test</strong>: DRY applies to tests too</li>
<li><strong>Configuration</strong>: DRY configuration with YAML anchors</li>
</ol>
<hr>
<h2>Question 338: How do you use Dry.rb gems in Rails?</h2>
<h3>Answer</h3>
<p><strong>Dry.rb</strong> is a collection of gems providing functional programming tools for Ruby. Key gems include <strong>dry-validation</strong> (complex validations), <strong>dry-types</strong> (type system), <strong>dry-struct</strong> (typed structs), and <strong>dry-monads</strong> (result objects, monads).</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>dry-validation</strong>: Advanced validation schemas</li>
<li><strong>dry-types</strong>: Type coercion and constraints</li>
<li><strong>dry-struct</strong>: Typed data structures</li>
<li><strong>dry-monads</strong>: Result/Maybe monads</li>
<li><strong>dry-transaction</strong>: Transaction steps</li>
<li><strong>Benefits</strong>: Type safety, functional patterns, composable</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# DRY-RB GEMS
# ============================================

# Gemfile
gem &#39;dry-validation&#39;
gem &#39;dry-types&#39;
gem &#39;dry-struct&#39;
gem &#39;dry-monads&#39;
gem &#39;dry-transaction&#39;

# ============================================
# DRY-TYPES (Type System)
# ============================================

# Define custom types
module Types
  include Dry.Types()
  
  Email = String.constrained(format: /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i)
  Age = Integer.constrained(gteq: 0, lteq: 150)
  Username = String.constrained(min_size: 3, max_size: 20)
end

# Usage
Types::Email[&quot;john@example.com&quot;]  # ✓ Valid
Types::Email[&quot;invalid&quot;]  # ✗ Raises Dry::Types::ConstraintError

Types::Age[25]  # ✓ Valid
Types::Age[-5]  # ✗ Raises error
Types::Age[200]  # ✗ Raises error

# Type coercion
Types::Coercible::Integer[&quot;42&quot;]  # =&gt; 42
Types::Coercible::Float[&quot;3.14&quot;]  # =&gt; 3.14

# ============================================
# DRY-STRUCT (Typed Structures)
# ============================================

# Define typed data structures
class User &lt; Dry::Struct
  attribute :id, Types::Integer
  attribute :name, Types::String
  attribute :email, Types::Email
  attribute :age, Types::Age.optional
  attribute :active, Types::Bool.default(true)
end

# Usage
user = User.new(
  id: 1,
  name: &#39;John Doe&#39;,
  email: &#39;john@example.com&#39;,
  age: 30
)

user.name  # =&gt; &quot;John Doe&quot;
user.email  # =&gt; &quot;john@example.com&quot;
user.active  # =&gt; true (default)

# Type checking
user = User.new(
  id: &quot;not an integer&quot;,  # ✗ Raises error
  name: &#39;John&#39;,
  email: &#39;john@example.com&#39;
)

# Immutable by default
user.name = &#39;Jane&#39;  # ✗ Raises FrozenError

# ============================================
# DRY-VALIDATION (Advanced Validations)
# ============================================

# Define validation schema
class UserContract &lt; Dry::Validation::Contract
  params do
    required(:email).filled(:string)
    required(:password).filled(:string)
    required(:password_confirmation).filled(:string)
    optional(:age).filled(:integer)
  end
  
  rule(:email) do
    unless /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i.match?(value)
      key.failure(&#39;must be a valid email&#39;)
    end
  end
  
  rule(:password) do
    unless value.length &gt;= 8
      key.failure(&#39;must be at least 8 characters&#39;)
    end
  end
  
  rule(:password, :password_confirmation) do
    if values[:password] != values[:password_confirmation]
      key(:password_confirmation).failure(&#39;must match password&#39;)
    end
  end
  
  rule(:age) do
    if value &amp;&amp; (value &lt; 18 || value &gt; 100)
      key.failure(&#39;must be between 18 and 100&#39;)
    end
  end
end

# Usage
contract = UserContract.new

result = contract.call(
  email: &#39;john@example.com&#39;,
  password: &#39;password123&#39;,
  password_confirmation: &#39;password123&#39;,
  age: 25
)

result.success?  # =&gt; true
result.errors.to_h  # =&gt; {}

result = contract.call(
  email: &#39;invalid&#39;,
  password: &#39;short&#39;,
  password_confirmation: &#39;different&#39;,
  age: 15
)

result.success?  # =&gt; false
result.errors.to_h
# =&gt; {
#   email: [&#39;must be a valid email&#39;],
#   password: [&#39;must be at least 8 characters&#39;],
#   password_confirmation: [&#39;must match password&#39;],
#   age: [&#39;must be between 18 and 100&#39;]
# }

# Use in Rails controller
class UsersController &lt; ApplicationController
  def create
    contract = UserContract.new
    result = contract.call(user_params)
    
    if result.success?
      user = User.create!(result.to_h)
      redirect_to user
    else
      @errors = result.errors
      render :new
    end
  end
end

# ============================================
# DRY-MONADS (Result Objects)
# ============================================

require &#39;dry/monads&#39;

class UserRegistrationService
  include Dry::Monads[:result]
  
  def call(params)
    validate(params)
      .bind { |valid_params| create_user(valid_params) }
      .bind { |user| send_welcome_email(user) }
      .fmap { |user| user }
  end
  
  private
  
  def validate(params)
    contract = UserContract.new
    result = contract.call(params)
    
    if result.success?
      Success(result.to_h)
    else
      Failure(result.errors.to_h)
    end
  end
  
  def create_user(params)
    user = User.new(params)
    
    if user.save
      Success(user)
    else
      Failure(user.errors.full_messages)
    end
  end
  
  def send_welcome_email(user)
    UserMailer.welcome(user).deliver_later
    Success(user)
  rescue =&gt; e
    Failure(&quot;Failed to send email: #{e.message}&quot;)
  end
end

# Usage
service = UserRegistrationService.new
result = service.call(user_params)

case result
when Success
  user = result.value!
  redirect_to user
when Failure
  @errors = result.failure
  render :new
end

# Or with pattern matching
result = service.call(user_params)

result.match do |m|
  m.success do |user|
    redirect_to user
  end
  
  m.failure do |errors|
    @errors = errors
    render :new
  end
end

# ============================================
# DRY-MONADS: Maybe Monad
# ============================================

class UserFinder
  include Dry::Monads[:maybe]
  
  def find_by_email(email)
    user = User.find_by(email: email)
    user ? Some(user) : None()
  end
end

# Usage
finder = UserFinder.new
result = finder.find_by_email(&#39;john@example.com&#39;)

result.fmap { |user| user.name }  # Returns Some(&quot;John&quot;) or None()

# With default
name = result.value_or(&#39;Guest&#39;)  # Returns name or &#39;Guest&#39;

# Chaining
result
  .fmap { |user| user.posts }
  .fmap { |posts| posts.first }
  .fmap { |post| post.title }
  .value_or(&#39;No posts&#39;)

# ============================================
# DRY-TRANSACTION (Multi-Step Operations)
# ============================================

require &#39;dry/transaction&#39;

class CreateOrder
  include Dry::Transaction
  
  step :validate
  step :create_order
  step :reserve_inventory
  step :process_payment
  step :send_confirmation
  
  private
  
  def validate(input)
    contract = OrderContract.new
    result = contract.call(input)
    
    result.success? ? Success(result.to_h) : Failure(result.errors.to_h)
  end
  
  def create_order(input)
    order = Order.new(input)
    order.save ? Success(order) : Failure(order.errors.full_messages)
  end
  
  def reserve_inventory(order)
    inventory = InventoryService.reserve(order.product_id, order.quantity)
    inventory ? Success(order) : Failure(&#39;Insufficient inventory&#39;)
  end
  
  def process_payment(order)
    payment = PaymentService.process(order)
    payment.success? ? Success(order) : Failure(&#39;Payment failed&#39;)
  end
  
  def send_confirmation(order)
    OrderMailer.confirmation(order).deliver_later
    Success(order)
  end
end

# Usage
result = CreateOrder.new.call(order_params)

result.match do |m|
  m.success do |order|
    render json: order, status: :created
  end
  
  m.failure do |error|
    render json: {error: error}, status: :unprocessable_entity
  end
end

# If any step fails, subsequent steps don&#39;t run
# Automatic rollback possible with custom logic

# ============================================
# COMBINING DRY-RB GEMS
# ============================================

# Complete example with multiple gems

# Types
module Types
  include Dry.Types()
  
  Email = String.constrained(format: /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i)
  Password = String.constrained(min_size: 8)
end

# Struct
class UserInput &lt; Dry::Struct
  transform_keys(&amp;:to_sym)
  
  attribute :email, Types::Email
  attribute :password, Types::Password
  attribute :name, Types::String
end

# Validation
class UserContract &lt; Dry::Validation::Contract
  params do
    required(:email).filled(:string)
    required(:password).filled(:string)
    required(:name).filled(:string)
  end
  
  rule(:email) do
    key.failure(&#39;must be unique&#39;) if User.exists?(email: value)
  end
end

# Service with Result monad
class CreateUserService
  include Dry::Monads[:result]
  
  def call(params)
    validate(params)
      .bind { |valid_params| build_user_input(valid_params) }
      .bind { |user_input| create_user(user_input) }
  end
  
  private
  
  def validate(params)
    result = UserContract.new.call(params)
    result.success? ? Success(result.to_h) : Failure(result.errors.to_h)
  end
  
  def build_user_input(params)
    Success(UserInput.new(params))
  rescue Dry::Struct::Error =&gt; e
    Failure(&quot;Invalid input: #{e.message}&quot;)
  end
  
  def create_user(user_input)
    user = User.create(user_input.to_h)
    user.persisted? ? Success(user) : Failure(user.errors.full_messages)
  end
end

# Usage in controller
class UsersController &lt; ApplicationController
  def create
    result = CreateUserService.new.call(user_params)
    
    result.match do |m|
      m.success do |user|
        render json: user, status: :created
      end
      
      m.failure do |errors|
        render json: {errors: errors}, status: :unprocessable_entity
      end
    end
  end
end
</code></pre>
<hr>
<h3>Benefits of Dry-rb</h3>
<pre><code class="language-ruby"># 1. Type Safety
# Catch errors early
user = User.new(age: &quot;not a number&quot;)  # Raises immediately

# 2. Explicit Failures
# No exceptions, return Success/Failure
result = service.call(params)
if result.success?
  # Handle success
else
  # Handle failure
end

# 3. Composability
# Chain operations
result
  .bind { |data| step1(data) }
  .bind { |data| step2(data) }
  .bind { |data| step3(data) }

# 4. Immutability
# Structs are immutable by default
user.name = &#39;New&#39;  # Error

# 5. Clear Contracts
# Validation schemas as documentation
class UserContract &lt; Dry::Validation::Contract
  # Clearly shows what&#39;s expected
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>dry-validation</strong>: Advanced validation schemas</li>
<li><strong>dry-types</strong>: Type system with coercion</li>
<li><strong>dry-struct</strong>: Immutable typed structures</li>
<li><strong>dry-monads</strong>: Result/Maybe/Either monads</li>
<li><strong>dry-transaction</strong>: Multi-step operations</li>
<li><strong>Type safety</strong>: Catch errors early</li>
<li><strong>Functional</strong>: Functional programming patterns</li>
<li><strong>Composable</strong>: Chain operations</li>
<li><strong>Explicit</strong>: No hidden exceptions</li>
<li><strong>Rails integration</strong>: Works well with Rails</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 339: What is Trailblazer, and how do you use it in Rails?</h2>
<h3>Answer</h3>
<p><strong>Trailblazer</strong> is a high-level architecture framework for Rails that provides <strong>operations</strong>, <strong>contracts</strong>, <strong>cells</strong>, <strong>representers</strong> to organize business logic, separate concerns, and enforce clean architecture patterns beyond standard Rails conventions.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Operations</strong>: Encapsulate business logic</li>
<li><strong>Contracts</strong>: Validation with Reform/dry-validation</li>
<li><strong>Cells</strong>: View models (alternative to partials)</li>
<li><strong>Representers</strong>: JSON/XML serialization</li>
<li><strong>Architecture</strong>: Clean separation of concerns</li>
<li><strong>Benefits</strong>: Testable, reusable, organized</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# SETUP
# ============================================

# Gemfile
gem &#39;trailblazer&#39;
gem &#39;trailblazer-rails&#39;
gem &#39;reform&#39;
gem &#39;reform-rails&#39;

bundle install

# ============================================
# TRAILBLAZER OPERATIONS (Core Concept)
# ============================================

# Traditional Rails (Fat Controller/Model):
class UsersController &lt; ApplicationController
  def create
    @user = User.new(user_params)
    
    if @user.save
      UserMailer.welcome(@user).deliver_later
      Analytics.track(&#39;user_signup&#39;, user_id: @user.id)
      redirect_to @user
    else
      render :new
    end
  end
end

# ✅ Trailblazer: Extract to Operation
# app/concepts/user/operation/create.rb
module User::Operation
  class Create &lt; Trailblazer::Operation
    step :model
    step :contract_build
    step :validate
    step :persist
    step :send_welcome_email
    step :track_analytics
    
    def model(ctx, params:, **)
      ctx[:model] = User.new
    end
    
    def contract_build(ctx, model:, **)
      ctx[:contract] = User::Contract::Create.new(model)
    end
    
    def validate(ctx, params:, contract:, **)
      contract.validate(params[:user])
    end
    
    def persist(ctx, model:, contract:, **)
      model.save
    end
    
    def send_welcome_email(ctx, model:, **)
      UserMailer.welcome(model).deliver_later
    end
    
    def track_analytics(ctx, model:, **)
      Analytics.track(&#39;user_signup&#39;, user_id: model.id)
    end
  end
end

# Controller (Thin!)
class UsersController &lt; ApplicationController
  def create
    result = User::Operation::Create.call(params: params)
    
    if result.success?
      redirect_to result[:model]
    else
      @contract = result[&#39;contract&#39;]
      render :new
    end
  end
end

# Benefits:
# - Business logic in Operation
# - Controller just handles HTTP
# - Testable without HTTP
# - Reusable across controllers

# ============================================
# TRAILBLAZER CONTRACTS (Validation)
# ============================================

# app/concepts/user/contract/create.rb
module User::Contract
  class Create &lt; Reform::Form
    property :email
    property :password
    property :password_confirmation
    property :name
    
    validates :email, presence: true, format: {
      with: /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i
    }
    validates :email, uniqueness: true
    validates :password, presence: true, length: {minimum: 8}
    validates :name, presence: true
    
    validate :passwords_match
    
    private
    
    def passwords_match
      if password != password_confirmation
        errors.add(:password_confirmation, &quot;doesn&#39;t match password&quot;)
      end
    end
  end
end

# Usage in Operation
class Create &lt; Trailblazer::Operation
  step :model
  step :contract_build
  step :validate
  step :persist
  
  def contract_build(ctx, model:, **)
    ctx[:contract] = User::Contract::Create.new(model)
  end
  
  def validate(ctx, params:, contract:, **)
    contract.validate(params[:user])
  end
end

# Access errors in controller
result = User::Operation::Create.call(params: params)

unless result.success?
  @contract = result[&#39;contract&#39;]
  @contract.errors.full_messages
end

# ============================================
# TRAILBLAZER CELLS (View Models)
# ============================================

# Gemfile
gem &#39;cells&#39;
gem &#39;cells-rails&#39;

# app/concepts/user/cell/show.rb
module User::Cell
  class Show &lt; Trailblazer::Cell
    property :name
    property :email
    property :created_at
    
    def formatted_date
      created_at.strftime(&#39;%B %d, %Y&#39;)
    end
    
    def avatar_url
      if model.avatar.attached?
        Rails.application.routes.url_helpers.url_for(model.avatar)
      else
        &#39;/default-avatar.png&#39;
      end
    end
  end
end

# app/concepts/user/view/show.erb
&lt;div class=&quot;user-card&quot;&gt;
  &lt;img src=&quot;&lt;%= avatar_url %&gt;&quot; alt=&quot;&lt;%= name %&gt;&quot;&gt;
  &lt;h2&gt;&lt;%= name %&gt;&lt;/h2&gt;
  &lt;p&gt;&lt;%= email %&gt;&lt;/p&gt;
  &lt;span class=&quot;date&quot;&gt;Member since &lt;%= formatted_date %&gt;&lt;/span&gt;
&lt;/div&gt;

# Usage in view
&lt;%= cell(User::Cell::Show, @user) %&gt;

# Or in controller
def show
  @user = User.find(params[:id])
  render html: cell(User::Cell::Show, @user)
end

# Benefits:
# - Encapsulated view logic
# - Testable independently
# - Reusable components

# ============================================
# TRAILBLAZER REPRESENTERS (Serialization)
# ============================================

# Gemfile
gem &#39;roar&#39;
gem &#39;roar-rails&#39;

# app/concepts/user/representer/show.rb
module User::Representer
  class Show &lt; Roar::Decorator
    include Roar::JSON
    
    property :id
    property :email
    property :name
    property :created_at
    
    # Custom properties
    property :full_name, getter: -&gt;(represented:, **) {
      &quot;#{represented.first_name} #{represented.last_name}&quot;
    }
    
    # Nested associations
    collection :posts, decorator: Post::Representer::Index
  end
end

# Usage
user = User.find(1)
json = User::Representer::Show.new(user).to_json

# {
#   &quot;id&quot;: 1,
#   &quot;email&quot;: &quot;john@example.com&quot;,
#   &quot;name&quot;: &quot;John Doe&quot;,
#   &quot;full_name&quot;: &quot;John Doe&quot;,
#   &quot;created_at&quot;: &quot;2025-01-15T10:00:00Z&quot;,
#   &quot;posts&quot;: [...]
# }

# In controller
def show
  user = User.find(params[:id])
  render json: User::Representer::Show.new(user).to_json
end

# ============================================
# COMPLETE EXAMPLE: Blog Post
# ============================================

# Folder structure:
# app/concepts/
#   post/
#     operation/
#       create.rb
#       update.rb
#       delete.rb
#     contract/
#       create.rb
#       update.rb
#     cell/
#       index.rb
#       show.rb
#     representer/
#       show.rb
#     view/
#       index.erb
#       show.erb

# Operation
# app/concepts/post/operation/create.rb
module Post::Operation
  class Create &lt; Trailblazer::Operation
    step :model
    step :contract_build
    step :validate
    step :persist
    step :notify_subscribers
    
    def model(ctx, params:, current_user:, **)
      ctx[:model] = Post.new(user: current_user)
    end
    
    def contract_build(ctx, model:, **)
      ctx[:contract] = Post::Contract::Create.new(model)
    end
    
    def validate(ctx, params:, contract:, **)
      contract.validate(params[:post])
    end
    
    def persist(ctx, model:, contract:, **)
      contract.sync
      model.save
    end
    
    def notify_subscribers(ctx, model:, **)
      NotifySubscribersJob.perform_later(model.id)
      true
    end
  end
end

# Contract
# app/concepts/post/contract/create.rb
module Post::Contract
  class Create &lt; Reform::Form
    property :title
    property :body
    property :published
    
    validates :title, presence: true, length: {minimum: 3}
    validates :body, presence: true
    
    validate :unique_title_for_user
    
    private
    
    def unique_title_for_user
      if Post.exists?(user_id: model.user_id, title: title)
        errors.add(:title, &#39;already used&#39;)
      end
    end
  end
end

# Controller
class PostsController &lt; ApplicationController
  def create
    result = Post::Operation::Create.call(
      params: params,
      current_user: current_user
    )
    
    if result.success?
      flash[:notice] = &#39;Post created&#39;
      redirect_to result[:model]
    else
      @contract = result[&#39;contract&#39;]
      render :new
    end
  end
  
  def show
    @post = Post.find(params[:id])
    render html: cell(Post::Cell::Show, @post)
  end
end

# Cell
# app/concepts/post/cell/show.rb
module Post::Cell
  class Show &lt; Trailblazer::Cell
    property :title
    property :body
    property :user
    property :created_at
    
    def author_name
      user.name
    end
    
    def formatted_date
      created_at.strftime(&#39;%B %d, %Y&#39;)
    end
  end
end

# app/concepts/post/view/show.erb
&lt;article class=&quot;post&quot;&gt;
  &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;
  &lt;div class=&quot;meta&quot;&gt;
    &lt;span class=&quot;author&quot;&gt;By &lt;%= author_name %&gt;&lt;/span&gt;
    &lt;span class=&quot;date&quot;&gt;&lt;%= formatted_date %&gt;&lt;/span&gt;
  &lt;/div&gt;
  &lt;div class=&quot;body&quot;&gt;
    &lt;%= body %&gt;
  &lt;/div&gt;
&lt;/article&gt;

# ============================================
# TESTING TRAILBLAZER
# ============================================

# Test Operation (no HTTP needed!)
RSpec.describe Post::Operation::Create do
  let(:user) { create(:user) }
  let(:params) do
    {
      post: {
        title: &#39;My Post&#39;,
        body: &#39;Post content&#39;,
        published: true
      }
    }
  end
  
  it &quot;creates post successfully&quot; do
    result = described_class.call(
      params: params,
      current_user: user
    )
    
    expect(result).to be_success
    expect(result[:model]).to be_persisted
    expect(result[:model].title).to eq(&#39;My Post&#39;)
  end
  
  it &quot;fails with invalid params&quot; do
    params[:post][:title] = &#39;&#39;
    
    result = described_class.call(
      params: params,
      current_user: user
    )
    
    expect(result).to be_failure
    expect(result[&#39;contract&#39;].errors[:title]).to be_present
  end
end

# Test Contract
RSpec.describe Post::Contract::Create do
  let(:post) { Post.new }
  let(:contract) { described_class.new(post) }
  
  it &quot;validates successfully&quot; do
    expect(contract.validate(
      title: &#39;My Post&#39;,
      body: &#39;Content&#39;
    )).to be true
  end
  
  it &quot;fails without title&quot; do
    expect(contract.validate(body: &#39;Content&#39;)).to be false
    expect(contract.errors[:title]).to include(&quot;can&#39;t be blank&quot;)
  end
end

# Test Cell
RSpec.describe Post::Cell::Show do
  let(:post) { create(:post, created_at: Time.new(2025, 1, 15)) }
  let(:cell) { described_class.new(post) }
  
  it &quot;formats date correctly&quot; do
    expect(cell.formatted_date).to eq(&#39;January 15, 2025&#39;)
  end
end
</code></pre>
<hr>
<h3>Trailblazer Benefits</h3>
<pre><code class="language-ruby"># 1. Organized Code
# app/concepts/user/     # All user code together
#   operation/
#   contract/
#   cell/
#   representer/

# vs Standard Rails (scattered)
# app/models/user.rb
# app/controllers/users_controller.rb
# app/views/users/
# app/helpers/users_helper.rb

# 2. Testable
# Test operations without HTTP
result = User::Operation::Create.call(params: params)
# No controller, no HTTP, just logic

# 3. Reusable
# Same operation from multiple places
User::Operation::Create.call(...)  # From controller
User::Operation::Create.call(...)  # From API
User::Operation::Create.call(...)  # From background job

# 4. Clean Controllers
class UsersController &lt; ApplicationController
  def create
    result = User::Operation::Create.call(params: params)
    # Just handle HTTP
  end
end

# 5. Explicit Flow
class Create &lt; Trailblazer::Operation
  step :model           # Clear steps
  step :validate
  step :persist
  step :notify
  # Easy to understand flow
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Trailblazer</strong>: Architecture framework for Rails</li>
<li><strong>Operations</strong>: Encapsulate business logic with steps</li>
<li><strong>Contracts</strong>: Validation with Reform</li>
<li><strong>Cells</strong>: View models (alternative to partials)</li>
<li><strong>Representers</strong>: JSON/XML serialization</li>
<li><strong>Concepts</strong>: Organize code by domain</li>
<li><strong>Testable</strong>: Test without HTTP</li>
<li><strong>Reusable</strong>: Use from anywhere</li>
<li><strong>Clean</strong>: Thin controllers</li>
<li><strong>Explicit</strong>: Clear workflow steps</li>
</ol>
<hr>
<h2>Question 340: What are Trailblazer operations?</h2>
<h3>Answer</h3>
<p><strong>Trailblazer Operations</strong> are service objects with a <strong>step-based workflow</strong> that encapsulate business logic. Each operation has sequential <strong>steps</strong> that either succeed or fail, with automatic error handling and a clear, testable flow.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Steps</strong>: Sequential operations (model, validate, persist)</li>
<li><strong>Railway pattern</strong>: Success/failure tracks</li>
<li><strong>Context</strong>: Shared data between steps (ctx)</li>
<li><strong>Explicit flow</strong>: Easy to understand sequence</li>
<li><strong>Testable</strong>: Test without controllers</li>
<li><strong>Reusable</strong>: Call from anywhere</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# BASIC OPERATION
# ============================================

class User::Create &lt; Trailblazer::Operation
  step :model
  step :validate
  step :persist
  
  def model(ctx, params:, **)
    ctx[:model] = User.new
  end
  
  def validate(ctx, params:, model:, **)
    model.attributes = params[:user]
    model.valid?  # Returns true/false
  end
  
  def persist(ctx, model:, **)
    model.save  # Returns true/false
  end
end

# Usage
result = User::Create.call(params: params)

if result.success?
  user = result[:model]
  # Success path
else
  errors = result[:model].errors
  # Failure path
end

# ============================================
# OPERATION FLOW (Railway Pattern)
# ============================================

# Visual representation:
#
# SUCCESS TRACK:
# model ➜ validate ➜ persist ➜ SUCCESS
#   ✓       ✓          ✓
#
# FAILURE TRACK:
# model ➜ validate ✗ FAILURE
#   ✓
#
# If any step returns false, moves to failure track

# ============================================
# CONTEXT (ctx)
# ============================================

# Context is shared state between steps
class User::Create &lt; Trailblazer::Operation
  step :model
  step :validate
  step :persist
  step :notify
  
  def model(ctx, params:, **)
    # Add to context
    ctx[:model] = User.new
    ctx[:timestamp] = Time.current
  end
  
  def validate(ctx, model:, **)
    # Read from context
    model.valid?
  end
  
  def persist(ctx, model:, timestamp:, **)
    # Read multiple values from context
    model.created_at = timestamp
    model.save
  end
  
  def notify(ctx, model:, **)
    # Access anything in context
    ctx[:email_sent] = UserMailer.welcome(model).deliver_later
  end
end

# Access context after operation
result = User::Create.call(params: params)
result[:model]       # User object
result[:timestamp]   # Time
result[:email_sent]  # Mail delivery

# ============================================
# STEP OPTIONS
# ============================================

class User::Create &lt; Trailblazer::Operation
  # Regular step (moves to failure track if returns false)
  step :validate
  
  # Pass step (always succeeds, doesn&#39;t affect track)
  pass :log_attempt
  
  # Fail step (always moves to failure track)
  fail :log_error
  
  # Track if condition
  step :send_admin_notification, if: :admin_user?
  
  # Track unless condition
  step :send_welcome_email, unless: :guest_user?
  
  def validate(ctx, model:, **)
    model.valid?  # If false, moves to failure track
  end
  
  def log_attempt(ctx, **)
    Rails.logger.info(&quot;User creation attempted&quot;)
    # Always continues (pass)
  end
  
  def log_error(ctx, **)
    Rails.logger.error(&quot;User creation failed&quot;)
    # On failure track
  end
  
  def admin_user?(ctx, params:, **)
    params[:role] == &#39;admin&#39;
  end
end

# ============================================
# NESTED STEPS (Substeps)
# ============================================

class Order::Create &lt; Trailblazer::Operation
  step :model
  step :validate
  step Subprocess(Order::CalculateTotal)  # Nested operation
  step :persist
  step Subprocess(Order::NotifyCustomer)
  
  def model(ctx, **)
    ctx[:model] = Order.new
  end
  
  def validate(ctx, model:, **)
    model.valid?
  end
  
  def persist(ctx, model:, **)
    model.save
  end
end

# Subprocess operation
class Order::CalculateTotal &lt; Trailblazer::Operation
  step :calculate_items_total
  step :apply_discount
  step :add_tax
  
  def calculate_items_total(ctx, model:, **)
    ctx[:subtotal] = model.line_items.sum(&amp;:price)
  end
  
  def apply_discount(ctx, subtotal:, model:, **)
    ctx[:discount] = model.discount_amount
    ctx[:after_discount] = subtotal - model.discount_amount
  end
  
  def add_tax(ctx, after_discount:, model:, **)
    ctx[:tax] = after_discount * 0.10
    model.total = after_discount + ctx[:tax]
  end
end

# ============================================
# FAST TRACK (Early Success/Failure)
# ============================================

class User::Create &lt; Trailblazer::Operation
  step :model
  step :check_if_exists, fail_fast: true  # Exit immediately if fails
  step :validate
  step :persist, fast_track: true  # Can exit early on success
  step :notify
  
  def check_if_exists(ctx, params:, **)
    if User.exists?(email: params[:user][:email])
      ctx[:error] = &#39;User already exists&#39;
      return false  # Exits operation immediately (fail_fast)
    end
    true
  end
  
  def persist(ctx, model:, **)
    if model.save
      Railway.pass_fast!  # Skip remaining steps, go to success
    else
      false
    end
  end
end

# ============================================
# CONTRACTS IN OPERATIONS
# ============================================

class User::Create &lt; Trailblazer::Operation
  step :model
  step :contract_build
  step :contract_validate
  step :persist
  
  def model(ctx, **)
    ctx[:model] = User.new
  end
  
  def contract_build(ctx, model:, **)
    ctx[:contract] = User::Contract::Create.new(model)
  end
  
  def contract_validate(ctx, params:, contract:, **)
    contract.validate(params[:user])
  end
  
  def persist(ctx, contract:, **)
    contract.sync  # Sync form to model
    contract.model.save
  end
end

# Access contract errors
result = User::Create.call(params: params)
unless result.success?
  result[:contract].errors.full_messages
end

# ============================================
# POLICIES (Authorization)
# ============================================

class Post::Update &lt; Trailblazer::Operation
  step :model
  step :policy
  step :validate
  step :persist
  
  def model(ctx, params:, **)
    ctx[:model] = Post.find(params[:id])
  end
  
  def policy(ctx, model:, current_user:, **)
    current_user.id == model.user_id  # Only owner can update
  end
  
  def validate(ctx, model:, params:, **)
    model.attributes = params[:post]
    model.valid?
  end
  
  def persist(ctx, model:, **)
    model.save
  end
end

# Usage
result = Post::Update.call(
  params: params,
  current_user: current_user
)

if result.success?
  # Updated
else
  # Failed (validation or authorization)
end

# ============================================
# HOOKS (Before/After)
# ============================================

class User::Create &lt; Trailblazer::Operation
  step :model
  step :validate
  step :persist
  
  # Wrap step with additional logic
  step :notify, before: :log_notification_start, after: :log_notification_end
  
  def model(ctx, **)
    ctx[:model] = User.new
  end
  
  def validate(ctx, model:, params:, **)
    model.attributes = params[:user]
    model.valid?
  end
  
  def persist(ctx, model:, **)
    model.save
  end
  
  def notify(ctx, model:, **)
    UserMailer.welcome(model).deliver_later
  end
  
  def log_notification_start(ctx, **)
    Rails.logger.info(&quot;Starting notification&quot;)
  end
  
  def log_notification_end(ctx, **)
    Rails.logger.info(&quot;Notification completed&quot;)
  end
end

# ============================================
# TESTING OPERATIONS
# ============================================

RSpec.describe User::Create do
  describe &quot;success&quot; do
    let(:params) do
      {
        user: {
          email: &#39;john@example.com&#39;,
          password: &#39;password123&#39;,
          name: &#39;John Doe&#39;
        }
      }
    end
    
    it &quot;creates user&quot; do
      result = described_class.call(params: params)
      
      expect(result).to be_success
      expect(result[:model]).to be_persisted
      expect(result[:model].email).to eq(&#39;john@example.com&#39;)
    end
  end
  
  describe &quot;failure&quot; do
    let(:params) do
      {
        user: {
          email: &#39;&#39;,  # Invalid
          password: &#39;short&#39;,  # Invalid
          name: &#39;John&#39;
        }
      }
    end
    
    it &quot;fails validation&quot; do
      result = described_class.call(params: params)
      
      expect(result).to be_failure
      expect(result[:model]).not_to be_persisted
      expect(result[:model].errors).to be_present
    end
  end
  
  describe &quot;authorization&quot; do
    it &quot;fails if not authorized&quot; do
      result = Post::Update.call(
        params: {id: post.id},
        current_user: other_user
      )
      
      expect(result).to be_failure
    end
  end
end

# Test individual steps
RSpec.describe User::Create do
  let(:operation) { described_class.new }
  let(:ctx) { {} }
  
  describe &quot;#model&quot; do
    it &quot;creates new user&quot; do
      operation.model(ctx, params: {})
      expect(ctx[:model]).to be_a(User)
      expect(ctx[:model]).to be_new_record
    end
  end
  
  describe &quot;#validate&quot; do
    let(:model) { User.new }
    
    before do
      ctx[:model] = model
    end
    
    it &quot;validates with valid params&quot; do
      result = operation.validate(
        ctx,
        model: model,
        params: {user: {email: &#39;john@example.com&#39;, password: &#39;password&#39;}}
      )
      
      expect(result).to be true
    end
  end
end
</code></pre>
<hr>
<h3>Operation Patterns</h3>
<pre><code class="language-ruby"># ============================================
# PATTERN 1: CRUD Operations
# ============================================

# Create
class User::Create &lt; Trailblazer::Operation
  step :model
  step :validate
  step :persist
  step :notify
end

# Update
class User::Update &lt; Trailblazer::Operation
  step :model
  step :policy  # Authorization
  step :validate
  step :persist
  step :notify_changes
end

# Delete
class User::Delete &lt; Trailblazer::Operation
  step :model
  step :policy
  step :destroy
  step :cleanup
end

# ============================================
# PATTERN 2: Multi-Step Business Process
# ============================================

class Order::Checkout &lt; Trailblazer::Operation
  step :validate_cart
  step :calculate_total
  step :validate_payment
  step :create_order
  step :process_payment
  step :reduce_inventory
  step :send_confirmation
end

# ============================================
# PATTERN 3: External API Integration
# ============================================

class User::SyncToMailchimp &lt; Trailblazer::Operation
  step :validate_email
  step :check_mailchimp_status
  step :add_to_list, if: :not_subscribed?
  step :update_tags
  step :record_sync
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Operations</strong>: Service objects with step-based workflow</li>
<li><strong>Steps</strong>: Sequential operations (model, validate, persist)</li>
<li><strong>Railway pattern</strong>: Success/failure tracks</li>
<li><strong>Context (ctx)</strong>: Shared state between steps</li>
<li><strong>Explicit flow</strong>: Clear, readable workflow</li>
<li><strong>Testable</strong>: Test without HTTP/controllers</li>
<li><strong>Reusable</strong>: Call from anywhere</li>
<li><strong>Options</strong>: step, pass, fail, if, unless</li>
<li><strong>Nested</strong>: Subprocess for complex flows</li>
<li><strong>Fast track</strong>: Early exit on success/failure</li>
</ol>
<hr>
<h2>Ruby Performance</h2>
<h2>Question 341: How do you use Delegators in Ruby (SimpleDelegator and Forwardable)?</h2>
<h3>Answer</h3>
<p><strong>Delegators</strong> forward method calls to another object. <strong>SimpleDelegator</strong> wraps an object and delegates all methods, while <strong>Forwardable</strong> selectively delegates specific methods. Used for decorators, proxies, and adapters.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>SimpleDelegator</strong>: Wrap object, delegate all methods</li>
<li><strong>Forwardable</strong>: Delegate specific methods</li>
<li><strong>Use cases</strong>: Decorators, presenters, adapters</li>
<li><strong>Benefits</strong>: Composition over inheritance, flexible</li>
<li><strong>DelegateClass</strong>: Alternative to SimpleDelegator</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# SIMPLEDELEGATOR
# ============================================

# Basic usage
class UserDecorator &lt; SimpleDelegator
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
  
  def formatted_email
    &quot;&lt;#{email}&gt;&quot;
  end
end

# Usage
user = User.new(first_name: &#39;John&#39;, last_name: &#39;Doe&#39;, email: &#39;john@example.com&#39;)
decorated = UserDecorator.new(user)

# Delegated methods (from User)
decorated.first_name  # =&gt; &quot;John&quot; (delegated to user)
decorated.email       # =&gt; &quot;john@example.com&quot; (delegated)

# Decorator methods
decorated.full_name   # =&gt; &quot;John Doe&quot; (decorator)
decorated.formatted_email  # =&gt; &quot;&lt;john@example.com&gt;&quot; (decorator)

# Access wrapped object
decorated.__getobj__  # =&gt; user
decorated.__setobj__(another_user)  # Change wrapped object

# ============================================
# REAL-WORLD EXAMPLE: Presenter
# ============================================

class UserPresenter &lt; SimpleDelegator
  include ActionView::Helpers::DateHelper
  include Rails.application.routes.url_helpers
  
  # All User methods available
  # Plus presentation methods
  
  def display_name
    &quot;#{first_name} #{last_name}&quot;
  end
  
  def avatar_image_tag
    if avatar.attached?
      &quot;&lt;img src=&#39;#{avatar_url}&#39; alt=&#39;#{name}&#39; class=&#39;avatar&#39;&gt;&quot;
    else
      &quot;&lt;img src=&#39;/default-avatar.png&#39; alt=&#39;#{name}&#39; class=&#39;avatar&#39;&gt;&quot;
    end
  end
  
  def member_since
    &quot;Member since #{created_at.strftime(&#39;%B %Y&#39;)}&quot;
  end
  
  def last_seen_text
    if last_seen_at.nil?
      &#39;Never seen&#39;
    elsif last_seen_at &gt; 1.hour.ago
      &#39;Active now&#39;
    else
      &quot;Last seen #{time_ago_in_words(last_seen_at)} ago&quot;
    end
  end
  
  def profile_url
    user_url(self)
  end
end

# Controller
class UsersController &lt; ApplicationController
  def show
    user = User.find(params[:id])
    @user = UserPresenter.new(user)
  end
end

# View
&lt;div class=&quot;user-profile&quot;&gt;
  &lt;%= raw @user.avatar_image_tag %&gt;
  &lt;h1&gt;&lt;%= @user.display_name %&gt;&lt;/h1&gt;
  &lt;p&gt;&lt;%= @user.member_since %&gt;&lt;/p&gt;
  &lt;p&gt;&lt;%= @user.last_seen_text %&gt;&lt;/p&gt;
  &lt;a href=&quot;&lt;%= @user.profile_url %&gt;&quot;&gt;View Profile&lt;/a&gt;
&lt;/div&gt;

# ============================================
# EXAMPLE: Collection Decorator
# ============================================

class UsersCollectionPresenter &lt; SimpleDelegator
  def total_active
    select(&amp;:active?).count
  end
  
  def total_inactive
    reject(&amp;:active?).count
  end
  
  def by_role
    group_by(&amp;:role)
  end
  
  def premium_users
    select(&amp;:premium?)
  end
end

# Usage
users = User.all
decorated_users = UsersCollectionPresenter.new(users)

# Delegated methods (from Array/ActiveRecord::Relation)
decorated_users.count    # Delegated to users
decorated_users.first    # Delegated
decorated_users.map(&amp;:name)  # Delegated

# Custom methods
decorated_users.total_active      # Custom
decorated_users.premium_users     # Custom

# ============================================
# FORWARDABLE
# ============================================

require &#39;forwardable&#39;

class UserProfile
  extend Forwardable
  
  def initialize(user)
    @user = user
  end
  
  # Delegate specific methods to @user
  def_delegators :@user, :name, :email, :created_at
  
  # Delegate with alias
  def_delegator :@user, :admin?, :is_admin?
  
  # Custom methods
  def full_name
    &quot;#{@user.first_name} #{@user.last_name}&quot;
  end
  
  def member_for
    years = (Time.current - @user.created_at) / 1.year
    &quot;#{years.to_i} years&quot;
  end
end

# Usage
user = User.new(
  name: &#39;John Doe&#39;,
  first_name: &#39;John&#39;,
  last_name: &#39;Doe&#39;,
  email: &#39;john@example.com&#39;,
  admin: true,
  created_at: 3.years.ago
)

profile = UserProfile.new(user)

# Delegated methods
profile.name        # =&gt; &quot;John Doe&quot; (delegated)
profile.email       # =&gt; &quot;john@example.com&quot; (delegated)
profile.is_admin?   # =&gt; true (delegated with alias)

# Custom methods
profile.full_name   # =&gt; &quot;John Doe&quot; (custom)
profile.member_for  # =&gt; &quot;3 years&quot; (custom)

# ============================================
# FORWARDABLE: Multiple Delegations
# ============================================

class OrderPresenter
  extend Forwardable
  
  def initialize(order, user)
    @order = order
    @user = user
  end
  
  # Delegate to order
  def_delegators :@order, :id, :total, :status, :created_at
  
  # Delegate to user
  def_delegator :@user, :name, :customer_name
  def_delegator :@user, :email, :customer_email
  
  def summary
    &quot;Order ##{id} for #{customer_name} (#{customer_email})&quot;
  end
  
  def status_label
    case status
    when &#39;pending&#39;
      &#39;Awaiting payment&#39;
    when &#39;paid&#39;
      &#39;Processing&#39;
    when &#39;shipped&#39;
      &#39;On the way&#39;
    else
      status.humanize
    end
  end
end

# Usage
order = Order.find(1)
user = order.user
presenter = OrderPresenter.new(order, user)

presenter.summary  # =&gt; &quot;Order #1 for John Doe (john@example.com)&quot;
presenter.status_label  # =&gt; &quot;Processing&quot;

# ============================================
# DELEGATECLASS (Alternative)
# ============================================

# DelegateClass is like SimpleDelegator but creates a class

class SpecialUser &lt; DelegateClass(User)
  def greeting
    &quot;Hello, #{name}!&quot;
  end
  
  def permission_level
    admin? ? &#39;Administrator&#39; : &#39;Regular User&#39;
  end
end

# Usage
user = User.new(name: &#39;John&#39;, admin: true)
special = SpecialUser.new(user)

special.name  # =&gt; &quot;John&quot; (delegated)
special.greeting  # =&gt; &quot;Hello, John!&quot; (custom)
special.permission_level  # =&gt; &quot;Administrator&quot; (custom)

# ============================================
# COMPARISON: SimpleDelegator vs Forwardable
# ============================================

# SimpleDelegator:
# + Delegates ALL methods automatically
# + Less code for many delegations
# - Harder to see which methods are delegated
# - Performance overhead (method_missing)

class UserDecorator &lt; SimpleDelegator
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
  # All User methods automatically available
end

# Forwardable:
# + Explicit about which methods are delegated
# + Better performance (no method_missing)
# + Can delegate to multiple objects
# - More verbose
# - Must list each method

class UserProfile
  extend Forwardable
  def_delegators :@user, :name, :email, :admin?
  # Must explicitly list methods
end

# ============================================
# USE CASES
# ============================================

# 1. Decorators (SimpleDelegator)
class ProductDecorator &lt; SimpleDelegator
  def display_price
    &quot;$#{sprintf(&#39;%.2f&#39;, price)}&quot;
  end
  
  def availability_status
    in_stock? ? &#39;In Stock&#39; : &#39;Out of Stock&#39;
  end
end

# 2. Adapters (Forwardable)
class LegacyApiAdapter
  extend Forwardable
  
  def initialize(new_api)
    @new_api = new_api
  end
  
  def_delegator :@new_api, :fetch_data, :get_data
  def_delegator :@new_api, :update_record, :save_data
end

# 3. Presenters (SimpleDelegator)
class PostPresenter &lt; SimpleDelegator
  include ActionView::Helpers
  
  def formatted_body
    simple_format(body)
  end
  
  def reading_time
    &quot;#{(body.split.size / 200.0).ceil} min read&quot;
  end
end

# 4. Proxies (SimpleDelegator)
class LoggingProxy &lt; SimpleDelegator
  def method_missing(method, *args, &amp;block)
    Rails.logger.info(&quot;Called: #{method} with #{args}&quot;)
    super
  end
end

# 5. Lazy Loading (SimpleDelegator)
class LazyUser &lt; SimpleDelegator
  def initialize(user_id)
    @user_id = user_id
  end
  
  def __getobj__
    @user ||= User.find(@user_id)
  end
end

lazy_user = LazyUser.new(1)
# User not loaded yet
lazy_user.name  # Loads user on first access

# ============================================
# TESTING DECORATORS
# ============================================

RSpec.describe UserPresenter do
  let(:user) do
    User.new(
      first_name: &#39;John&#39;,
      last_name: &#39;Doe&#39;,
      email: &#39;john@example.com&#39;,
      created_at: 2.years.ago
    )
  end
  
  let(:presenter) { described_class.new(user) }
  
  describe &quot;#display_name&quot; do
    it &quot;returns full name&quot; do
      expect(presenter.display_name).to eq(&#39;John Doe&#39;)
    end
  end
  
  describe &quot;#member_since&quot; do
    it &quot;formats created_at&quot; do
      expect(presenter.member_since).to match(/Member since \w+ \d{4}/)
    end
  end
  
  describe &quot;delegation&quot; do
    it &quot;delegates to user&quot; do
      expect(presenter.email).to eq(&#39;john@example.com&#39;)
    end
  end
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<pre><code class="language-ruby"># 1. Keep decorators focused
# ✓ GOOD: Single responsibility
class UserPresenter &lt; SimpleDelegator
  def full_name
    &quot;#{first_name} #{last_name}&quot;
  end
end

# ✗ BAD: Too many responsibilities
class UserPresenter &lt; SimpleDelegator
  def full_name; end
  def process_payment; end  # Business logic doesn&#39;t belong here
  def send_email; end       # Side effects don&#39;t belong here
end

# 2. Use Forwardable for explicit contracts
class ApiClient
  extend Forwardable
  
  # Clear which methods are available
  def_delegators :@connection, :get, :post, :put, :delete
end

# 3. Don&#39;t overuse
# Only use when composition makes sense
# Don&#39;t wrap everything in delegators

# 4. Document delegated methods
class UserDecorator &lt; SimpleDelegator
  # Delegates: name, email, created_at (from User)
  # Custom: full_name, display_email
  
  def full_name; end
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>SimpleDelegator</strong>: Wraps object, delegates all methods</li>
<li><strong>Forwardable</strong>: Delegates specific methods</li>
<li><strong><strong>getobj</strong></strong>: Access wrapped object</li>
<li><strong>DelegateClass</strong>: Alternative to SimpleDelegator</li>
<li><strong>Use cases</strong>: Decorators, presenters, adapters, proxies</li>
<li><strong>SimpleDelegator</strong>: Good for decorators (many methods)</li>
<li><strong>Forwardable</strong>: Good for adapters (few methods)</li>
<li><strong>Performance</strong>: Forwardable faster (no method_missing)</li>
<li><strong>Explicit</strong>: Forwardable more explicit</li>
<li><strong>Composition</strong>: Alternative to inheritance</li>
</ol>
<hr>
<h2>Question 342: What are class-level instance variables in Rails?</h2>
<h3>Answer</h3>
<p><strong>Class-level instance variables</strong> (@variable at class level) are variables that belong to the <strong>class object itself</strong>, not shared by subclasses. Different from <strong>class variables</strong> (@@variable) which are shared across class hierarchy.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Class instance variables</strong>: @variable at class level</li>
<li><strong>Belong to</strong>: The class object itself</li>
<li><strong>Not shared</strong>: Each class has its own copy</li>
<li><strong>Class variables</strong>: @@variable (shared with subclasses)</li>
<li><strong>Use case</strong>: Configuration, caching per class</li>
<li><strong>Thread-safe</strong>: More predictable than class variables</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# CLASS INSTANCE VARIABLES vs CLASS VARIABLES
# ============================================

# Class Instance Variable (@)
class User
  @count = 0  # Class instance variable
  
  def self.increment
    @count += 1
  end
  
  def self.count
    @count
  end
end

class Admin &lt; User
end

User.increment
User.count  # =&gt; 1

Admin.increment
Admin.count  # =&gt; 1

User.count  # =&gt; 1 (NOT 2!)
# Each class has its own @count

# Class Variable (@@)
class Product
  @@count = 0  # Class variable
  
  def self.increment
    @@count += 1
  end
  
  def self.count
    @@count
  end
end

class Book &lt; Product
end

Product.increment
Product.count  # =&gt; 1

Book.increment
Book.count  # =&gt; 2  # Shared!

Product.count  # =&gt; 2  # Shared across hierarchy!

# ============================================
# DETAILED EXPLANATION
# ============================================

class Counter
  @count = 0  # Class instance variable
  
  class &lt;&lt; self
    attr_accessor :count  # Accessor for class instance variable
  end
  
  def self.increment
    @count += 1
  end
end

# Access
Counter.count  # =&gt; 0
Counter.increment
Counter.count  # =&gt; 1

# Each subclass gets its own
class SpecialCounter &lt; Counter
end

SpecialCounter.count  # =&gt; nil (not inherited)
SpecialCounter.count = 0
SpecialCounter.increment
SpecialCounter.count  # =&gt; 1

Counter.count  # =&gt; 1 (unchanged)

# ============================================
# REAL-WORLD USE CASE: Configuration
# ============================================

class ApplicationMailer &lt; ActionMailer::Base
  @default_from = &#39;noreply@example.com&#39;
  
  class &lt;&lt; self
    attr_accessor :default_from
  end
  
  def self.inherited(subclass)
    # Each subclass gets its own default
    subclass.instance_variable_set(:@default_from, @default_from)
  end
end

class UserMailer &lt; ApplicationMailer
  @default_from = &#39;users@example.com&#39;
end

class OrderMailer &lt; ApplicationMailer
  @default_from = &#39;orders@example.com&#39;
end

ApplicationMailer.default_from  # =&gt; &#39;noreply@example.com&#39;
UserMailer.default_from         # =&gt; &#39;users@example.com&#39;
OrderMailer.default_from        # =&gt; &#39;orders@example.com&#39;

# ============================================
# USE CASE: Caching Per Class
# ============================================

class BaseModel
  @cache = {}
  
  class &lt;&lt; self
    def cache
      @cache ||= {}
    end
    
    def find_cached(id)
      cache[id] ||= find(id)
    end
    
    def clear_cache
      @cache = {}
    end
  end
end

class User &lt; BaseModel
end

class Post &lt; BaseModel
end

# Each class has its own cache
User.find_cached(1)  # Caches in User&#39;s @cache
Post.find_cached(1)  # Caches in Post&#39;s @cache

User.cache.keys  # =&gt; [1]
Post.cache.keys  # =&gt; [1]

# Clearing one doesn&#39;t affect the other
User.clear_cache
User.cache.keys  # =&gt; []
Post.cache.keys  # =&gt; [1]

# ============================================
# USE CASE: Registry Pattern
# ============================================

class Plugin
  @plugins = []
  
  class &lt;&lt; self
    def register(name)
      @plugins ||= []
      @plugins &lt;&lt; name
    end
    
    def plugins
      @plugins || []
    end
  end
end

class AuthPlugin &lt; Plugin
  register :authentication
  register :authorization
end

class CachePlugin &lt; Plugin
  register :redis
  register :memcached
end

AuthPlugin.plugins   # =&gt; [:authentication, :authorization]
CachePlugin.plugins  # =&gt; [:redis, :memcached]
Plugin.plugins       # =&gt; []

# ============================================
# USE CASE: Thread-Safe Counters
# ============================================

class Request
  @count = 0
  @mutex = Mutex.new
  
  class &lt;&lt; self
    def increment
      @mutex.synchronize do
        @count += 1
      end
    end
    
    def count
      @count
    end
  end
end

# Thread-safe incrementing
threads = 100.times.map do
  Thread.new do
    1000.times { Request.increment }
  end
end

threads.each(&amp;:join)
Request.count  # =&gt; 100000 (correct, thread-safe)

# ============================================
# GOTCHA: Inheritance
# ============================================

class Parent
  @setting = &#39;parent&#39;
  
  class &lt;&lt; self
    attr_accessor :setting
  end
end

class Child &lt; Parent
end

# Child doesn&#39;t inherit @setting automatically
Parent.setting  # =&gt; &#39;parent&#39;
Child.setting   # =&gt; nil (not inherited!)

# To inherit, need explicit code
class Parent
  def self.inherited(subclass)
    subclass.instance_variable_set(:@setting, @setting)
  end
end

class Child &lt; Parent
end

Child.setting  # =&gt; &#39;parent&#39; (inherited)
Child.setting = &#39;child&#39;
Child.setting  # =&gt; &#39;child&#39;
Parent.setting # =&gt; &#39;parent&#39; (unchanged)

# ============================================
# RAILS EXAMPLE: Class Attributes
# ============================================

# Rails provides class_attribute helper
class ApplicationController &lt; ActionController::Base
  class_attribute :layout_name, default: &#39;application&#39;
end

class UsersController &lt; ApplicationController
  self.layout_name = &#39;users&#39;
end

ApplicationController.layout_name  # =&gt; &#39;application&#39;
UsersController.layout_name        # =&gt; &#39;users&#39;

# Implemented using class instance variables under the hood

# ============================================
# COMPARISON TABLE
# ============================================

# Feature                | @class_var | @@class_var | CONSTANT
# -----------------------|------------|-------------|----------
# Scope                  | Per class  | Shared      | Shared
# Inherited              | No*        | Yes         | Yes
# Can change             | Yes        | Yes         | No (warning)
# Thread-safe            | With mutex | With mutex  | Yes
# Visibility             | Private    | Private     | Public
# Rails convention       | Preferred  | Avoid       | Use for constants

# * Unless explicitly copied in inherited hook

# ============================================
# BEST PRACTICES
# ============================================

# ✓ GOOD: Use class instance variables for per-class configuration
class Mailer
  @from_address = &#39;default@example.com&#39;
  
  class &lt;&lt; self
    attr_accessor :from_address
  end
end

# ✓ GOOD: Copy to subclasses when needed
class Parent
  @config = {}
  
  def self.inherited(subclass)
    subclass.instance_variable_set(:@config, @config.dup)
  end
end

# ✗ BAD: Don&#39;t use class variables for configuration
class Bad
  @@config = {}  # Shared across all subclasses!
end

# ✓ GOOD: Use Rails class_attribute
class ApplicationController
  class_attribute :page_title, default: &#39;My App&#39;
end

# ✗ BAD: Don&#39;t mix class instance variables and class variables
class Confusing
  @count = 0
  @@total = 0  # Confusing!
end
</code></pre>
<hr>
<h3>Common Pitfalls</h3>
<pre><code class="language-ruby"># PITFALL 1: Forgetting each class has its own copy
class Counter
  @count = 0
end

class SpecialCounter &lt; Counter
end

Counter.instance_variable_get(:@count)  # =&gt; 0
SpecialCounter.instance_variable_get(:@count)  # =&gt; nil (not 0!)

# PITFALL 2: Not thread-safe by default
class Tracker
  @visits = 0
  
  def self.track
    @visits += 1  # Not thread-safe!
  end
end

# Fix: Use Mutex
class Tracker
  @visits = 0
  @mutex = Mutex.new
  
  def self.track
    @mutex.synchronize { @visits += 1 }
  end
end

# PITFALL 3: Using @@ when you mean @
class Base
  @@config = {}  # Shared! Probably not what you want
end

# Fix: Use @
class Base
  @config = {}  # Per-class
end
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Class instance variables</strong>: @variable at class level</li>
<li><strong>Per-class</strong>: Each class has its own copy</li>
<li><strong>Not inherited</strong>: Subclasses don&#39;t automatically get copy</li>
<li><strong>Class variables</strong>: @@variable (shared across hierarchy)</li>
<li><strong>Prefer @</strong>: Over @@ in most cases</li>
<li><strong>Thread safety</strong>: Require explicit synchronization</li>
<li><strong>Rails</strong>: class_attribute uses class instance variables</li>
<li><strong>Configuration</strong>: Good for per-class settings</li>
<li><strong>Caching</strong>: Good for per-class caches</li>
<li><strong>Registry</strong>: Good for plugin systems</li>
</ol>
<h1>Advanced Database &amp; Security (343-351)</h1>
<h2>Advanced Database</h2>
<h2>Question 343: What are ActiveRecord Store and ActiveRecord Attributes?</h2>
<h3>Answer</h3>
<p><strong>ActiveRecord Store</strong> serializes hashes/JSON in a single column for flexible key-value storage. <strong>ActiveRecord Attributes</strong> provides a type system for model attributes with coercion, defaults, and custom types.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Store</strong>: Serialize hashes in single column</li>
<li><strong>Attributes API</strong>: Type system for model attributes</li>
<li><strong>Store</strong>: <code>store :settings, accessors: [:theme, :lang]</code></li>
<li><strong>Attributes</strong>: <code>attribute :price, :decimal, default: 0</code></li>
<li><strong>Use cases</strong>: Flexible data, preferences, metadata</li>
<li><strong>Storage</strong>: JSON, YAML, or serialized Ruby objects</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# ACTIVERECORD STORE
# ============================================

# Migration
class AddSettingsToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :settings, :jsonb, default: {}
    # Or :text for serialized format
  end
end

# Model
class User &lt; ApplicationRecord
  # Basic store
  store :settings
  
  # With accessors (creates getter/setter methods)
  store :settings, accessors: [:theme, :language, :notifications_enabled]
  
  # With coder (JSON, YAML, or custom)
  store :settings, coder: JSON  # Default for jsonb columns
end

# Usage
user = User.new

# Direct hash access
user.settings = {theme: &#39;dark&#39;, language: &#39;en&#39;}
user.settings[:theme]  # =&gt; &#39;dark&#39;
user.settings[:language]  # =&gt; &#39;en&#39;

# Accessor methods (if defined)
user.theme = &#39;light&#39;
user.language = &#39;es&#39;
user.notifications_enabled = true

user.save

# Querying JSON columns
User.where(&quot;settings-&gt;&gt;&#39;theme&#39; = ?&quot;, &#39;dark&#39;)
User.where(&quot;settings @&gt; ?&quot;, {theme: &#39;dark&#39;}.to_json)

# ============================================
# REAL-WORLD EXAMPLE: User Preferences
# ============================================

class User &lt; ApplicationRecord
  store :preferences, accessors: [
    :theme,           # &#39;light&#39; or &#39;dark&#39;
    :language,        # &#39;en&#39;, &#39;es&#39;, &#39;fr&#39;
    :timezone,        # &#39;UTC&#39;, &#39;America/New_York&#39;
    :email_frequency, # &#39;daily&#39;, &#39;weekly&#39;, &#39;never&#39;
    :notifications_enabled,
    :beta_features_enabled
  ]
  
  # Default values
  after_initialize :set_default_preferences, if: :new_record?
  
  private
  
  def set_default_preferences
    self.preferences ||= {}
    self.theme ||= &#39;light&#39;
    self.language ||= &#39;en&#39;
    self.timezone ||= &#39;UTC&#39;
    self.email_frequency ||= &#39;weekly&#39;
    self.notifications_enabled = true if notifications_enabled.nil?
  end
end

# Usage
user = User.create!(email: &#39;john@example.com&#39;)
user.theme  # =&gt; &#39;light&#39;
user.theme = &#39;dark&#39;
user.save

# In views
&lt;body class=&quot;&lt;%= current_user.theme %&gt;-theme&quot;&gt;

# In controllers
Time.zone = current_user.timezone

# ============================================
# EXAMPLE: Product Metadata
# ============================================

class Product &lt; ApplicationRecord
  store :metadata, accessors: [
    :weight,
    :dimensions,
    :color,
    :material,
    :manufacturer
  ]
  
  # Type coercion helper
  def weight
    metadata[:weight]&amp;.to_f
  end
  
  def dimensions
    metadata[:dimensions] || {}
  end
end

# Usage
product = Product.new(name: &#39;Laptop&#39;)
product.weight = &#39;2.5&#39;  # Stored as string
product.weight  # =&gt; 2.5 (coerced to float)
product.dimensions = {length: 14, width: 10, height: 1}
product.color = &#39;Silver&#39;
product.save

# Query by metadata
Product.where(&quot;metadata-&gt;&gt;&#39;color&#39; = ?&quot;, &#39;Silver&#39;)
Product.where(&quot;(metadata-&gt;&gt;&#39;weight&#39;)::float &gt; ?&quot;, 2.0)

# ============================================
# ACTIVERECORD ATTRIBUTES API
# ============================================

# Define custom attributes with types

class Product &lt; ApplicationRecord
  # Attribute with type
  attribute :price, :decimal, default: 0.0
  attribute :available, :boolean, default: true
  attribute :published_at, :datetime
  
  # Virtual attributes (not in database)
  attribute :discount_percentage, :integer, default: 0
  
  # Calculated attribute
  def discounted_price
    price * (1 - discount_percentage / 100.0)
  end
end

# Usage
product = Product.new
product.price  # =&gt; 0.0 (default)
product.available  # =&gt; true (default)

product.price = &quot;99.99&quot;  # String
product.price  # =&gt; 99.99 (coerced to decimal)

product.discount_percentage = 20
product.discounted_price  # =&gt; 79.992

# ============================================
# CUSTOM ATTRIBUTE TYPES
# ============================================

# Define custom type
class MoneyType &lt; ActiveRecord::Type::Value
  def cast(value)
    if value.is_a?(String)
      value.gsub(/[$,]/, &#39;&#39;).to_d
    else
      super
    end
  end
  
  def serialize(value)
    value.to_d if value
  end
end

# Register type
ActiveRecord::Type.register(:money, MoneyType)

# Use in model
class Order &lt; ApplicationRecord
  attribute :total, :money
end

# Usage
order = Order.new
order.total = &quot;$1,234.56&quot;
order.total  # =&gt; 1234.56 (Decimal)

# ============================================
# ARRAY TYPE (PostgreSQL)
# ============================================

# Migration
class AddTagsToPost &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :posts, :tags, :string, array: true, default: []
  end
end

# Model
class Post &lt; ApplicationRecord
  attribute :tags, :string, array: true, default: []
end

# Usage
post = Post.new(title: &#39;My Post&#39;)
post.tags = [&#39;ruby&#39;, &#39;rails&#39;, &#39;programming&#39;]
post.save

# Query
Post.where(&quot;&#39;ruby&#39; = ANY(tags)&quot;)
Post.where(&quot;tags @&gt; ARRAY[?]::varchar[]&quot;, &#39;ruby&#39;)

# ============================================
# HSTORE TYPE (PostgreSQL)
# ============================================

# Enable hstore extension
class EnableHstore &lt; ActiveRecord::Migration[7.0]
  def change
    enable_extension &#39;hstore&#39;
  end
end

# Migration
class AddPropertiesToProducts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :products, :properties, :hstore
  end
end

# Model
class Product &lt; ApplicationRecord
  store_accessor :properties, :color, :size, :weight
end

# Usage
product = Product.new
product.color = &#39;Red&#39;
product.size = &#39;Large&#39;
product.save

# Query
Product.where(&quot;properties -&gt; &#39;color&#39; = ?&quot;, &#39;Red&#39;)

# ============================================
# JSONB COLUMNS (PostgreSQL)
# ============================================

# Migration
class AddDataToEvents &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :events, :data, :jsonb, default: {}
    add_index :events, :data, using: :gin
  end
end

# Model
class Event &lt; ApplicationRecord
  # No special declaration needed
end

# Usage
event = Event.create!(
  name: &#39;user_signup&#39;,
  data: {
    user_id: 123,
    email: &#39;john@example.com&#39;,
    source: &#39;mobile_app&#39;
  }
)

# Query with JSONB operators
Event.where(&quot;data-&gt;&gt;&#39;source&#39; = ?&quot;, &#39;mobile_app&#39;)
Event.where(&quot;data @&gt; ?&quot;, {user_id: 123}.to_json)
Event.where(&quot;data ? &#39;email&#39;&quot;)  # Has key
Event.where(&quot;data-&gt;&gt;&#39;user_id&#39; = &#39;123&#39;&quot;)

# Index for better performance
# add_index :events, &quot;((data-&gt;&gt;&#39;user_id&#39;)::integer)&quot;

# ============================================
# COMBINING STORE AND ATTRIBUTES
# ============================================

class User &lt; ApplicationRecord
  # Store for flexible data
  store :settings, accessors: [:theme, :language]
  
  # Attributes for type safety
  attribute :theme, :string, default: &#39;light&#39;
  attribute :language, :string, default: &#39;en&#39;
  
  # Validation
  validates :theme, inclusion: {in: %w[light dark]}
  validates :language, inclusion: {in: %w[en es fr de]}
end

# ============================================
# PERFORMANCE CONSIDERATIONS
# ============================================

# ❌ BAD: Many small columns
create_table :users do |t|
  t.string :pref_theme
  t.string :pref_language
  t.string :pref_timezone
  t.boolean :pref_notifications
  t.boolean :pref_email_daily
  t.boolean :pref_email_weekly
  # 50+ preference columns...
end

# ✅ GOOD: Single JSONB column
create_table :users do |t|
  t.jsonb :preferences, default: {}
end

add_index :users, :preferences, using: :gin

# Benefits:
# - Flexible schema
# - Easy to add new preferences
# - Better for sparse data
# - Single column to update

# ============================================
# QUERYING STORED ATTRIBUTES
# ============================================

# PostgreSQL JSONB queries
class User &lt; ApplicationRecord
  store :settings, accessors: [:theme, :language]
  
  # Scopes for common queries
  scope :with_theme, -&gt;(theme) {
    where(&quot;settings-&gt;&gt;&#39;theme&#39; = ?&quot;, theme)
  }
  
  scope :with_language, -&gt;(lang) {
    where(&quot;settings-&gt;&gt;&#39;language&#39; = ?&quot;, lang)
  }
  
  scope :notifications_enabled, -&gt; {
    where(&quot;(settings-&gt;&gt;&#39;notifications_enabled&#39;)::boolean = true&quot;)
  }
end

# Usage
User.with_theme(&#39;dark&#39;)
User.with_language(&#39;es&#39;)
User.notifications_enabled

# Complex queries
User.where(&quot;settings @&gt; ?&quot;, {theme: &#39;dark&#39;, language: &#39;en&#39;}.to_json)
User.where(&quot;settings ? &#39;beta_features_enabled&#39;&quot;)  # Has key
</code></pre>
<hr>
<h3>When to Use Each</h3>
<pre><code class="language-ruby"># ========================================
# USE STORE WHEN:
# ========================================

# ✅ Flexible, changing schema
class User &lt; ApplicationRecord
  store :preferences  # Can add any key/value
end

# ✅ User-specific settings
class User &lt; ApplicationRecord
  store :settings, accessors: [:theme, :timezone]
end

# ✅ Metadata that varies by record
class Product &lt; ApplicationRecord
  store :metadata  # Different products, different attributes
end

# ✅ Sparse data (not all records have values)

# ========================================
# USE ATTRIBUTES API WHEN:
# ========================================

# ✅ Type coercion needed
class Product &lt; ApplicationRecord
  attribute :price, :decimal  # Coerce strings to decimal
end

# ✅ Virtual attributes
class Order &lt; ApplicationRecord
  attribute :discount, :integer, default: 0  # Not in DB
end

# ✅ Custom types
class User &lt; ApplicationRecord
  attribute :encrypted_ssn, :encrypted
end

# ========================================
# USE REGULAR COLUMNS WHEN:
# ========================================

# ✅ Frequently queried
# ✅ Need foreign keys
# ✅ Need database constraints
# ✅ Stable schema
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Store</strong>: Serialize hashes in single column</li>
<li><strong>Accessors</strong>: Create getter/setter methods</li>
<li><strong>JSONB</strong>: Best for PostgreSQL (indexable, queryable)</li>
<li><strong>Attributes API</strong>: Type system for model attributes</li>
<li><strong>Custom types</strong>: Extend with custom type classes</li>
<li><strong>Array columns</strong>: PostgreSQL arrays</li>
<li><strong>Hstore</strong>: Key-value in PostgreSQL</li>
<li><strong>Performance</strong>: Index JSONB with GIN</li>
<li><strong>Use cases</strong>: Preferences, metadata, flexible schemas</li>
<li><strong>Query</strong>: Use PostgreSQL JSONB operators</li>
</ol>
<hr>
<h2>Question 344: How do you implement Time-series Data Storage in Rails?</h2>
<h3>Answer</h3>
<p><strong>Time-series data</strong> is data indexed by time (metrics, logs, events). Implement with <strong>partitioning</strong>, <strong>hypertables</strong> (TimescaleDB), <strong>downsampling</strong>, <strong>continuous aggregates</strong>, and appropriate indexes for efficient time-based queries.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Time-series</strong>: Data indexed by timestamp</li>
<li><strong>Partitioning</strong>: Split by time ranges (monthly, daily)</li>
<li><strong>TimescaleDB</strong>: PostgreSQL extension for time-series</li>
<li><strong>Hypertables</strong>: Automatic partitioning</li>
<li><strong>Aggregates</strong>: Pre-compute summaries</li>
<li><strong>Retention</strong>: Auto-delete old data</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# BASIC TIME-SERIES TABLE
# ============================================

# Migration
class CreateMetrics &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :metrics do |t|
      t.string :metric_name, null: false
      t.decimal :value, null: false
      t.jsonb :tags, default: {}
      t.datetime :recorded_at, null: false
      
      t.index [:metric_name, :recorded_at]
      t.index :recorded_at
      t.index :tags, using: :gin
    end
  end
end

# Model
class Metric &lt; ApplicationRecord
  validates :metric_name, :value, :recorded_at, presence: true
  
  # Scopes for time-based queries
  scope :last_hour, -&gt; { where(&#39;recorded_at &gt; ?&#39;, 1.hour.ago) }
  scope :last_day, -&gt; { where(&#39;recorded_at &gt; ?&#39;, 1.day.ago) }
  scope :last_week, -&gt; { where(&#39;recorded_at &gt; ?&#39;, 1.week.ago) }
  
  scope :between, -&gt;(start_time, end_time) {
    where(recorded_at: start_time..end_time)
  }
  
  scope :by_metric, -&gt;(name) { where(metric_name: name) }
end

# Usage
Metric.create!(
  metric_name: &#39;cpu_usage&#39;,
  value: 75.5,
  tags: {host: &#39;web-1&#39;, region: &#39;us-east&#39;},
  recorded_at: Time.current
)

# Query
Metric.by_metric(&#39;cpu_usage&#39;).last_hour
Metric.between(1.day.ago, Time.current)

# ============================================
# TIMESCALEDB (Recommended for Time-Series)
# ============================================

# Gemfile
gem &#39;timescaledb&#39;

# config/database.yml - Add extension
# Enable TimescaleDB extension first in PostgreSQL

# Migration with hypertable
class CreateTemperatureReadings &lt; ActiveRecord::Migration[7.0]
  def up
    # Enable TimescaleDB
    execute &quot;CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE&quot;
    
    # Create table
    create_table :temperature_readings do |t|
      t.string :device_id, null: false
      t.decimal :temperature, precision: 5, scale: 2, null: false
      t.jsonb :metadata, default: {}
      t.datetime :recorded_at, null: false
    end
    
    # Convert to hypertable (automatic partitioning)
    execute &lt;&lt;-SQL
      SELECT create_hypertable(
        &#39;temperature_readings&#39;,
        &#39;recorded_at&#39;,
        chunk_time_interval =&gt; INTERVAL &#39;1 day&#39;
      );
    SQL
    
    # Add indexes
    add_index :temperature_readings, [:device_id, :recorded_at]
    add_index :temperature_readings, :recorded_at, order: {recorded_at: :desc}
  end
  
  def down
    drop_table :temperature_readings
  end
end

# Model
class TemperatureReading &lt; ApplicationRecord
  acts_as_hypertable time_column: &#39;recorded_at&#39;
  
  validates :device_id, :temperature, :recorded_at, presence: true
  
  # Time-series queries
  scope :for_device, -&gt;(device_id) { where(device_id: device_id) }
  scope :recent, -&gt;(duration) { where(&#39;recorded_at &gt; ?&#39;, duration.ago) }
  
  # Aggregations
  def self.average_for_period(device_id, start_time, end_time)
    where(device_id: device_id)
      .where(recorded_at: start_time..end_time)
      .average(:temperature)
  end
  
  def self.max_for_period(device_id, start_time, end_time)
    where(device_id: device_id)
      .where(recorded_at: start_time..end_time)
      .maximum(:temperature)
  end
end

# Usage
# Insert data
TemperatureReading.create!(
  device_id: &#39;sensor-001&#39;,
  temperature: 22.5,
  recorded_at: Time.current
)

# Query
TemperatureReading.for_device(&#39;sensor-001&#39;).recent(1.hour)

# Aggregations
avg_temp = TemperatureReading.average_for_period(
  &#39;sensor-001&#39;,
  1.day.ago,
  Time.current
)

# ============================================
# CONTINUOUS AGGREGATES (TimescaleDB)
# ============================================

# Create continuous aggregate (materialized view)
class CreateHourlyTemperatureAggregates &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE MATERIALIZED VIEW hourly_temperature_stats
      WITH (timescaledb.continuous) AS
      SELECT
        device_id,
        time_bucket(&#39;1 hour&#39;, recorded_at) AS hour,
        AVG(temperature) AS avg_temperature,
        MAX(temperature) AS max_temperature,
        MIN(temperature) AS min_temperature,
        COUNT(*) AS reading_count
      FROM temperature_readings
      GROUP BY device_id, hour
      WITH NO DATA;
    SQL
    
    # Add refresh policy (auto-refresh every hour)
    execute &lt;&lt;-SQL
      SELECT add_continuous_aggregate_policy(&#39;hourly_temperature_stats&#39;,
        start_offset =&gt; INTERVAL &#39;3 hours&#39;,
        end_offset =&gt; INTERVAL &#39;1 hour&#39;,
        schedule_interval =&gt; INTERVAL &#39;1 hour&#39;);
    SQL
  end
  
  def down
    execute &quot;DROP MATERIALIZED VIEW IF EXISTS hourly_temperature_stats&quot;
  end
end

# Model for aggregate
class HourlyTemperatureStat &lt; ApplicationRecord
  self.table_name = &#39;hourly_temperature_stats&#39;
  self.primary_key = [:device_id, :hour]
  
  def readonly?
    true
  end
end

# Query aggregates (much faster)
HourlyTemperatureStat
  .where(device_id: &#39;sensor-001&#39;)
  .where(&#39;hour &gt; ?&#39;, 7.days.ago)
  .order(hour: :desc)

# ============================================
# DATA RETENTION POLICIES
# ============================================

# Automatically delete old data
class AddRetentionPolicy &lt; ActiveRecord::Migration[7.0]
  def up
    # Delete data older than 90 days
    execute &lt;&lt;-SQL
      SELECT add_retention_policy(&#39;temperature_readings&#39;,
        INTERVAL &#39;90 days&#39;);
    SQL
  end
  
  def down
    execute &quot;SELECT remove_retention_policy(&#39;temperature_readings&#39;)&quot;
  end
end

# Manual retention with Rails
class DeleteOldMetricsJob &lt; ApplicationJob
  queue_as :default
  
  def perform
    # Delete metrics older than 90 days
    Metric.where(&#39;recorded_at &lt; ?&#39;, 90.days.ago).delete_all
  end
end

# Schedule daily
# config/schedule.rb (using whenever gem)
every 1.day, at: &#39;2:00 am&#39; do
  runner &quot;DeleteOldMetricsJob.perform_later&quot;
end

# ============================================
# DOWNSAMPLING (Reduce Data Resolution)
# ============================================

# Store high-resolution data short-term
# Store downsampled data long-term

class DownsampleMetricsJob &lt; ApplicationJob
  def perform
    # Downsample data older than 7 days to hourly averages
    start_date = 30.days.ago.beginning_of_day
    end_date = 7.days.ago.end_of_day
    
    (start_date.to_i..end_date.to_i).step(1.hour).each do |timestamp|
      hour_start = Time.at(timestamp)
      hour_end = hour_start + 1.hour
      
      # Get metrics for this hour
      metrics = Metric.where(recorded_at: hour_start..hour_end)
      
      metrics.group(:metric_name).each do |name, records|
        # Create downsampled record
        DownsampledMetric.create!(
          metric_name: name,
          avg_value: records.average(:value),
          min_value: records.minimum(:value),
          max_value: records.maximum(:value),
          count: records.count,
          hour: hour_start
        )
      end
      
      # Delete original high-resolution data
      metrics.delete_all
    end
  end
end

# Downsampled model
class DownsampledMetric &lt; ApplicationRecord
  validates :metric_name, :hour, presence: true
  validates :hour, uniqueness: {scope: :metric_name}
end

# ============================================
# PARTITIONING (PostgreSQL Native)
# ============================================

# Partition by time range
class CreatePartitionedEvents &lt; ActiveRecord::Migration[7.0]
  def up
    # Create partitioned table
    execute &lt;&lt;-SQL
      CREATE TABLE events (
        id BIGSERIAL,
        event_type VARCHAR(255) NOT NULL,
        data JSONB NOT NULL DEFAULT &#39;{}&#39;,
        created_at TIMESTAMP NOT NULL
      ) PARTITION BY RANGE (created_at);
    SQL
    
    # Create partitions for each month
    12.times do |i|
      month = i.months.ago.beginning_of_month
      next_month = month + 1.month
      
      partition_name = &quot;events_#{month.strftime(&#39;%Y_%m&#39;)}&quot;
      
      execute &lt;&lt;-SQL
        CREATE TABLE #{partition_name}
        PARTITION OF events
        FOR VALUES FROM (&#39;#{month}&#39;) TO (&#39;#{next_month}&#39;);
      SQL
      
      execute &quot;CREATE INDEX ON #{partition_name} (created_at);&quot;
    end
  end
  
  def down
    execute &quot;DROP TABLE events CASCADE&quot;
  end
end

# Add new partitions automatically
class CreateNextMonthPartitionJob &lt; ApplicationJob
  def perform
    next_month = 1.month.from_now.beginning_of_month
    month_after = next_month + 1.month
    partition_name = &quot;events_#{next_month.strftime(&#39;%Y_%m&#39;)}&quot;
    
    ActiveRecord::Base.connection.execute &lt;&lt;-SQL
      CREATE TABLE IF NOT EXISTS #{partition_name}
      PARTITION OF events
      FOR VALUES FROM (&#39;#{next_month}&#39;) TO (&#39;#{month_after}&#39;);
    SQL
    
    ActiveRecord::Base.connection.execute &lt;&lt;-SQL
      CREATE INDEX IF NOT EXISTS #{partition_name}_created_at_idx
      ON #{partition_name} (created_at);
    SQL
  end
end

# Schedule monthly
every 1.month, at: &#39;start of month at 1am&#39; do
  runner &quot;CreateNextMonthPartitionJob.perform_later&quot;
end

# ============================================
# BULK INSERT FOR PERFORMANCE
# ============================================

# Insert many records efficiently
class MetricsCollector
  def self.bulk_insert(metrics_data)
    # Using activerecord-import gem
    metrics = metrics_data.map do |data|
      Metric.new(
        metric_name: data[:name],
        value: data[:value],
        recorded_at: data[:timestamp]
      )
    end
    
    Metric.import(metrics, validate: false)
  end
  
  # Or use raw SQL for maximum speed
  def self.bulk_insert_raw(metrics_data)
    values = metrics_data.map do |data|
      &quot;(#{connection.quote(data[:name])}, 
        #{data[:value]}, 
        #{connection.quote(data[:timestamp])})&quot;
    end.join(&#39;,&#39;)
    
    sql = &lt;&lt;-SQL
      INSERT INTO metrics (metric_name, value, recorded_at)
      VALUES #{values}
    SQL
    
    ActiveRecord::Base.connection.execute(sql)
  end
end

# Usage
metrics_data = [
  {name: &#39;cpu_usage&#39;, value: 75, timestamp: Time.current},
  {name: &#39;memory_usage&#39;, value: 60, timestamp: Time.current},
  # ... thousands more
]

MetricsCollector.bulk_insert(metrics_data)

# ============================================
# QUERYING TIME-SERIES DATA
# ============================================

class MetricsQuery
  def initialize(metric_name)
    @metric_name = metric_name
  end
  
  # Get data points for chart
  def data_points(start_time, end_time, interval: &#39;5m&#39;)
    Metric
      .where(metric_name: @metric_name)
      .where(recorded_at: start_time..end_time)
      .group(&quot;date_trunc(&#39;#{interval}&#39;, recorded_at)&quot;)
      .average(:value)
  end
  
  # Get aggregated statistics
  def statistics(start_time, end_time)
    metrics = Metric
      .where(metric_name: @metric_name)
      .where(recorded_at: start_time..end_time)
    
    {
      avg: metrics.average(:value),
      min: metrics.minimum(:value),
      max: metrics.maximum(:value),
      count: metrics.count,
      p95: metrics.percentile(95)
    }
  end
  
  # Percentile calculation
  def self.percentile(percentile)
    select(&quot;percentile_cont(#{percentile / 100.0}) 
            WITHIN GROUP (ORDER BY value) as percentile&quot;)
      .first
      .percentile
  end
end

# Usage
query = MetricsQuery.new(&#39;cpu_usage&#39;)
data = query.data_points(1.day.ago, Time.current, interval: &#39;1h&#39;)
stats = query.statistics(1.day.ago, Time.current)

# ============================================
# REAL-WORLD EXAMPLE: Application Monitoring
# ============================================

class ApplicationMetric &lt; ApplicationRecord
  acts_as_hypertable time_column: &#39;recorded_at&#39;
  
  # Metric types
  TYPES = %w[
    request_duration
    database_query_time
    cache_hit_rate
    error_rate
    memory_usage
    cpu_usage
  ].freeze
  
  validates :metric_type, inclusion: {in: TYPES}
  
  # Recording methods
  def self.record(metric_type, value, tags = {})
    create!(
      metric_type: metric_type,
      value: value,
      tags: tags,
      recorded_at: Time.current
    )
  end
  
  # Query methods
  def self.average_response_time(duration = 1.hour)
    where(metric_type: &#39;request_duration&#39;)
      .where(&#39;recorded_at &gt; ?&#39;, duration.ago)
      .average(:value)
  end
  
  def self.error_rate(duration = 1.hour)
    total = where(&#39;recorded_at &gt; ?&#39;, duration.ago).count
    errors = where(metric_type: &#39;error_rate&#39;)
            .where(&#39;recorded_at &gt; ?&#39;, duration.ago)
            .sum(:value)
    
    (errors.to_f / total * 100).round(2)
  end
end

# Record metrics
ApplicationMetric.record(&#39;request_duration&#39;, 150, {
  endpoint: &#39;/api/users&#39;,
  method: &#39;GET&#39;,
  status: 200
})

# Query
ApplicationMetric.average_response_time(1.hour)
ApplicationMetric.error_rate(24.hours)
</code></pre>
<hr>
<h3>Best Practices</h3>
<pre><code class="language-ruby"># 1. Use appropriate indexes
add_index :metrics, [:metric_name, :recorded_at]
add_index :metrics, :recorded_at, order: {recorded_at: :desc}

# 2. Partition large tables
# Split by month/day for better query performance

# 3. Use continuous aggregates
# Pre-compute hourly/daily summaries

# 4. Implement retention policies
# Auto-delete old data

# 5. Batch inserts
# Insert many records at once

# 6. Downsample old data
# Reduce resolution for historical data

# 7. Use TimescaleDB for production
# Better performance than plain PostgreSQL
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Time-series</strong>: Data indexed by timestamp</li>
<li><strong>TimescaleDB</strong>: Best solution for PostgreSQL</li>
<li><strong>Hypertables</strong>: Automatic partitioning</li>
<li><strong>Continuous aggregates</strong>: Pre-computed summaries</li>
<li><strong>Retention policies</strong>: Auto-delete old data</li>
<li><strong>Downsampling</strong>: Reduce resolution over time</li>
<li><strong>Bulk inserts</strong>: Better performance</li>
<li><strong>Indexes</strong>: Crucial for query performance</li>
<li><strong>Partitioning</strong>: Split large tables by time</li>
<li><strong>Use cases</strong>: Metrics, logs, events, monitoring</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 345: How do you create and use database views in Rails?</h2>
<h3>Answer</h3>
<p><strong>Database views</strong> are virtual tables defined by SQL queries. They simplify complex queries, provide abstraction, improve security, and can have indexes for performance. Rails supports views through migrations and models.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Views</strong>: Virtual tables from SELECT queries</li>
<li><strong>Creation</strong>: Using <code>create_view</code> in migrations</li>
<li><strong>Models</strong>: Map ActiveRecord to views (readonly)</li>
<li><strong>Materialized views</strong>: Cached query results</li>
<li><strong>Benefits</strong>: Simplify queries, security, abstraction</li>
<li><strong>Scenic gem</strong>: Better view management</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# BASIC DATABASE VIEW
# ============================================

# Migration - Create view manually
class CreateActiveUsersView &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE VIEW active_users AS
      SELECT 
        id,
        email,
        name,
        created_at,
        last_sign_in_at
      FROM users
      WHERE 
        deleted_at IS NULL
        AND confirmed_at IS NOT NULL
        AND last_sign_in_at &gt; NOW() - INTERVAL &#39;30 days&#39;
      ORDER BY last_sign_in_at DESC
    SQL
  end
  
  def down
    execute &quot;DROP VIEW IF EXISTS active_users&quot;
  end
end

# Model for view
class ActiveUser &lt; ApplicationRecord
  self.table_name = &#39;active_users&#39;
  self.primary_key = &#39;id&#39;
  
  # Views are read-only
  def readonly?
    true
  end
end

# Usage
ActiveUser.all  # Query the view
ActiveUser.where(&quot;name LIKE ?&quot;, &quot;%John%&quot;)
ActiveUser.count

# ============================================
# USING SCENIC GEM (Recommended)
# ============================================

# Gemfile
gem &#39;scenic&#39;

# Install
rails generate scenic:install

# Generate view
rails generate scenic:view active_users

# This creates:
# db/views/active_users_v01.sql
# db/migrate/xxx_create_active_users.rb

# db/views/active_users_v01.sql
SELECT 
  users.id,
  users.email,
  users.name,
  users.created_at,
  users.last_sign_in_at,
  COUNT(posts.id) AS posts_count
FROM users
LEFT JOIN posts ON posts.user_id = users.id
WHERE 
  users.deleted_at IS NULL
  AND users.confirmed_at IS NOT NULL
GROUP BY users.id

# Generated migration
class CreateActiveUsers &lt; ActiveRecord::Migration[7.0]
  def change
    create_view :active_users
  end
end

# Run migration
rails db:migrate

# Model
class ActiveUser &lt; ApplicationRecord
  # Scenic handles readonly automatically
end

# Usage
ActiveUser.all
ActiveUser.first.posts_count  # From view

# ============================================
# UPDATING VIEWS (Scenic)
# ============================================

# Generate update migration
rails generate scenic:view active_users --version 2

# This creates:
# db/views/active_users_v02.sql
# db/migrate/xxx_update_active_users_to_version_2.rb

# Update SQL in active_users_v02.sql
SELECT 
  users.id,
  users.email,
  users.name,
  users.created_at,
  users.last_sign_in_at,
  COUNT(DISTINCT posts.id) AS posts_count,
  COUNT(DISTINCT comments.id) AS comments_count  -- Added
FROM users
LEFT JOIN posts ON posts.user_id = users.id
LEFT JOIN comments ON comments.user_id = users.id  -- Added
WHERE 
  users.deleted_at IS NULL
  AND users.confirmed_at IS NOT NULL
GROUP BY users.id

# Generated migration
class UpdateActiveUsersToVersion2 &lt; ActiveRecord::Migration[7.0]
  def change
    update_view :active_users, version: 2, revert_to_version: 1
  end
end

# Run migration
rails db:migrate

# Rollback will revert to v1
rails db:rollback

# ============================================
# MATERIALIZED VIEWS
# ============================================

# Materialized views store results (cached)
# Much faster for complex queries

# Migration
class CreateUserStatsView &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE MATERIALIZED VIEW user_stats AS
      SELECT 
        users.id,
        users.email,
        users.name,
        COUNT(DISTINCT posts.id) AS posts_count,
        COUNT(DISTINCT comments.id) AS comments_count,
        COUNT(DISTINCT likes.id) AS likes_count,
        MAX(posts.created_at) AS last_post_at
      FROM users
      LEFT JOIN posts ON posts.user_id = users.id
      LEFT JOIN comments ON comments.user_id = users.id
      LEFT JOIN likes ON likes.user_id = users.id
      GROUP BY users.id
    SQL
    
    # Add index for better performance
    add_index :user_stats, :id, unique: true
    add_index :user_stats, :posts_count
  end
  
  def down
    execute &quot;DROP MATERIALIZED VIEW IF EXISTS user_stats&quot;
  end
end

# Model
class UserStat &lt; ApplicationRecord
  self.table_name = &#39;user_stats&#39;
  self.primary_key = &#39;id&#39;
  
  def readonly?
    true
  end
  
  # Refresh materialized view
  def self.refresh
    ActiveRecord::Base.connection.execute(
      &quot;REFRESH MATERIALIZED VIEW user_stats&quot;
    )
  end
  
  # Concurrent refresh (doesn&#39;t lock)
  def self.refresh_concurrently
    ActiveRecord::Base.connection.execute(
      &quot;REFRESH MATERIALIZED VIEW CONCURRENTLY user_stats&quot;
    )
  end
end

# Usage
UserStat.all  # Fast (reads from cached results)

# Refresh when data changes
UserStat.refresh

# Schedule refresh
class RefreshUserStatsJob &lt; ApplicationJob
  def perform
    UserStat.refresh
  end
end

# Run hourly
every 1.hour do
  runner &quot;RefreshUserStatsJob.perform_later&quot;
end

# ============================================
# REAL-WORLD EXAMPLE: Order Dashboard
# ============================================

# View combining multiple tables
# db/views/order_summaries_v01.sql
SELECT 
  orders.id,
  orders.order_number,
  orders.status,
  orders.created_at,
  users.email AS customer_email,
  users.name AS customer_name,
  SUM(line_items.quantity * line_items.price) AS total,
  COUNT(line_items.id) AS items_count,
  STRING_AGG(DISTINCT products.name, &#39;, &#39;) AS product_names
FROM orders
INNER JOIN users ON users.id = orders.user_id
LEFT JOIN line_items ON line_items.order_id = orders.id
LEFT JOIN products ON products.id = line_items.product_id
GROUP BY 
  orders.id,
  orders.order_number,
  orders.status,
  orders.created_at,
  users.email,
  users.name

# Model
class OrderSummary &lt; ApplicationRecord
  # All the complex joins handled by view
  
  scope :recent, -&gt; { where(&#39;created_at &gt; ?&#39;, 30.days.ago) }
  scope :by_status, -&gt;(status) { where(status: status) }
  
  def total_formatted
    &quot;$#{sprintf(&#39;%.2f&#39;, total)}&quot;
  end
end

# Controller
class Admin::OrdersController &lt; ApplicationController
  def index
    @orders = OrderSummary
      .recent
      .order(created_at: :desc)
      .page(params[:page])
  end
  
  def stats
    @stats = {
      total_orders: OrderSummary.count,
      pending: OrderSummary.by_status(&#39;pending&#39;).count,
      completed: OrderSummary.by_status(&#39;completed&#39;).count,
      revenue: OrderSummary.sum(:total)
    }
  end
end

# View
&lt;% @orders.each do |order| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= order.order_number %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= order.customer_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= order.product_names %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= order.items_count %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= order.total_formatted %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= order.status %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;

# ============================================
# EXAMPLE: Analytics Dashboard
# ============================================

# Materialized view for analytics
class CreateDailySalesView &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE MATERIALIZED VIEW daily_sales AS
      SELECT 
        DATE(orders.created_at) AS sale_date,
        COUNT(DISTINCT orders.id) AS orders_count,
        SUM(orders.total) AS revenue,
        AVG(orders.total) AS average_order_value,
        COUNT(DISTINCT orders.user_id) AS unique_customers
      FROM orders
      WHERE orders.status = &#39;completed&#39;
      GROUP BY DATE(orders.created_at)
      ORDER BY sale_date DESC
    SQL
    
    add_index :daily_sales, :sale_date, unique: true
  end
  
  def down
    execute &quot;DROP MATERIALIZED VIEW IF EXISTS daily_sales&quot;
  end
end

# Model
class DailySale &lt; ApplicationRecord
  self.table_name = &#39;daily_sales&#39;
  self.primary_key = &#39;sale_date&#39;
  
  def readonly?
    true
  end
  
  def self.refresh
    connection.execute(&quot;REFRESH MATERIALIZED VIEW CONCURRENTLY daily_sales&quot;)
  end
  
  # Aggregations
  def self.total_revenue(start_date, end_date)
    where(sale_date: start_date..end_date).sum(:revenue)
  end
  
  def self.growth_rate(days = 30)
    current = where(&#39;sale_date &gt; ?&#39;, days.days.ago).sum(:revenue)
    previous = where(&#39;sale_date BETWEEN ? AND ?&#39;, 
      (days * 2).days.ago, days.days.ago).sum(:revenue)
    
    return 0 if previous.zero?
    ((current - previous) / previous * 100).round(2)
  end
end

# Usage
DailySale.where(&#39;sale_date &gt; ?&#39;, 30.days.ago).order(:sale_date)
DailySale.total_revenue(30.days.ago, Time.current)
DailySale.growth_rate(30)

# Refresh after order completion
class Order &lt; ApplicationRecord
  after_commit :refresh_sales_view, on: :update, if: :saved_change_to_status?
  
  def refresh_sales_view
    if status == &#39;completed&#39;
      RefreshDailySalesJob.perform_later
    end
  end
end

# ============================================
# SECURITY WITH VIEWS
# ============================================

# Hide sensitive columns with view
class CreatePublicUsersView &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE VIEW public_users AS
      SELECT 
        id,
        name,
        avatar_url,
        bio,
        created_at
      FROM users
      -- Excludes: email, encrypted_password, etc.
    SQL
  end
  
  def down
    execute &quot;DROP VIEW IF EXISTS public_users&quot;
  end
end

# Use for API
class Api::UsersController &lt; ApplicationController
  def index
    @users = PublicUser.all
    render json: @users
  end
end

# Only exposes safe columns via view

# ============================================
# JOINING WITH VIEWS
# ============================================

# Can join views with tables
class Post &lt; ApplicationRecord
  # Join with view
  def self.with_active_user_info
    joins(&lt;&lt;-SQL)
      INNER JOIN active_users ON active_users.id = posts.user_id
    SQL
  end
end

# Usage
Post.with_active_user_info
  .select(&#39;posts.*, active_users.name, active_users.posts_count&#39;)

# ============================================
# TESTING VIEWS
# ============================================

RSpec.describe UserStat, type: :model do
  describe &quot;view data&quot; do
    let!(:user) { create(:user) }
    let!(:posts) { create_list(:post, 3, user: user) }
    let!(:comments) { create_list(:comment, 5, user: user) }
    
    before do
      UserStat.refresh
    end
    
    it &quot;calculates correct counts&quot; do
      stat = UserStat.find(user.id)
      
      expect(stat.posts_count).to eq(3)
      expect(stat.comments_count).to eq(5)
    end
  end
end
</code></pre>
<hr>
<h3>View Types Comparison</h3>
<pre><code class="language-ruby"># ========================================
# REGULAR VIEW
# ========================================
# - Virtual table (no data stored)
# - Always up-to-date
# - Query executed every time
# - Fast to create/update
# - Use for: Simple queries, always current data

CREATE VIEW active_users AS SELECT ...

# ========================================
# MATERIALIZED VIEW
# ========================================
# - Physical table (data stored)
# - Snapshot in time
# - Must refresh to update
# - Can have indexes
# - Use for: Complex/expensive queries, analytics

CREATE MATERIALIZED VIEW user_stats AS SELECT ...
REFRESH MATERIALIZED VIEW user_stats

# ========================================
# UPDATABLE VIEW
# ========================================
# - Can INSERT/UPDATE/DELETE through view
# - Simple views only (single table, no aggregates)
# - Use carefully (can be confusing)

CREATE VIEW simple_users AS
SELECT id, name, email FROM users
WHERE active = true

# Can update through view
SimpleUser.find(1).update(name: &#39;New Name&#39;)  # Updates users table
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Views</strong>: Virtual tables from SELECT queries</li>
<li><strong>Scenic gem</strong>: Best for managing views</li>
<li><strong>Readonly</strong>: Views are typically readonly</li>
<li><strong>Materialized</strong>: Store results for performance</li>
<li><strong>Refresh</strong>: Materialized views need refresh</li>
<li><strong>Indexes</strong>: Can index materialized views</li>
<li><strong>Security</strong>: Hide sensitive columns</li>
<li><strong>Simplify</strong>: Complex joins → simple queries</li>
<li><strong>Analytics</strong>: Great for dashboards</li>
<li><strong>Version control</strong>: Scenic tracks view versions</li>
</ol>
<hr>
<h2>Question 346: How do you implement window functions in Rails using ActiveRecord?</h2>
<h3>Answer</h3>
<p><strong>Window functions</strong> perform calculations across rows related to current row without grouping. Use <code>OVER()</code> clause for rankings, running totals, moving averages, and row numbers in PostgreSQL queries.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Window functions</strong>: Calculations across row sets</li>
<li><strong>OVER clause</strong>: Defines window (partition and order)</li>
<li><strong>Common</strong>: ROW_NUMBER, RANK, LAG, LEAD, SUM OVER</li>
<li><strong>ActiveRecord</strong>: Use <code>select()</code> with SQL fragments</li>
<li><strong>Use cases</strong>: Rankings, running totals, percentiles</li>
<li><strong>Performance</strong>: More efficient than subqueries</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# BASIC WINDOW FUNCTIONS
# ============================================

# ROW_NUMBER: Assign unique number to each row
User.select(
  &quot;*&quot;,
  &quot;ROW_NUMBER() OVER (ORDER BY created_at) as row_number&quot;
).to_a

# Each user gets sequential number

# ============================================
# RANKING FUNCTIONS
# ============================================

# RANK: Rank with gaps for ties
Product.select(
  &quot;*&quot;,
  &quot;RANK() OVER (ORDER BY price DESC) as price_rank&quot;
)

# DENSE_RANK: Rank without gaps
Product.select(
  &quot;*&quot;,
  &quot;DENSE_RANK() OVER (ORDER BY price DESC) as dense_rank&quot;
)

# Example results:
# Product | Price | RANK | DENSE_RANK
# A       | 100   | 1    | 1
# B       | 100   | 1    | 1
# C       | 90    | 3    | 2  (note difference)
# D       | 80    | 4    | 3

# ============================================
# PARTITION BY (Group Within Window)
# ============================================

# Rank products within each category
Product.select(
  &quot;*&quot;,
  &quot;RANK() OVER (
    PARTITION BY category_id 
    ORDER BY sales_count DESC
  ) as rank_in_category&quot;
)

# Results: Ranking resets for each category
# Category | Product | Sales | Rank
# Books    | A       | 1000  | 1
# Books    | B       | 800   | 2
# Electronics | C    | 2000  | 1
# Electronics | D    | 1500  | 2

# ============================================
# RUNNING TOTALS
# ============================================

# Running sum of sales
Order.select(
  &quot;*&quot;,
  &quot;SUM(total) OVER (
    ORDER BY created_at 
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) as running_total&quot;
).order(:created_at)

# Simpler syntax (same result)
Order.select(
  &quot;*&quot;,
  &quot;SUM(total) OVER (ORDER BY created_at) as running_total&quot;
).order(:created_at)

# ============================================
# MOVING AVERAGES
# ============================================

# 7-day moving average
Metric.select(
  &quot;*&quot;,
  &quot;AVG(value) OVER (
    ORDER BY recorded_at
    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
  ) as moving_avg_7d&quot;
).where(metric_name: &#39;cpu_usage&#39;)

# 30-day moving average
Metric.select(
  &quot;*&quot;,
  &quot;AVG(value) OVER (
    ORDER BY recorded_at
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) as moving_avg_30d&quot;
)

# ============================================
# LAG and LEAD (Previous/Next Values)
# ============================================

# Compare with previous value
Order.select(
  &quot;*&quot;,
  &quot;LAG(total) OVER (ORDER BY created_at) as prev_total&quot;,
  &quot;total - LAG(total) OVER (ORDER BY created_at) as diff_from_prev&quot;
).order(:created_at)

# Compare with next value
Order.select(
  &quot;*&quot;,
  &quot;LEAD(total) OVER (ORDER BY created_at) as next_total&quot;
)

# ============================================
# REAL-WORLD EXAMPLE: Sales Leaderboard
# ============================================

class User &lt; ApplicationRecord
  def self.sales_leaderboard
    select(
      &quot;users.*&quot;,
      &quot;COUNT(orders.id) as orders_count&quot;,
      &quot;SUM(orders.total) as total_sales&quot;,
      &quot;RANK() OVER (ORDER BY SUM(orders.total) DESC) as rank&quot;
    )
    .joins(:orders)
    .where(orders: {status: &#39;completed&#39;})
    .group(&#39;users.id&#39;)
    .order(&#39;rank ASC&#39;)
  end
  
  def self.regional_leaderboard
    select(
      &quot;users.*&quot;,
      &quot;SUM(orders.total) as total_sales&quot;,
      &quot;RANK() OVER (
        PARTITION BY users.region 
        ORDER BY SUM(orders.total) DESC
      ) as regional_rank&quot;
    )
    .joins(:orders)
    .where(orders: {status: &#39;completed&#39;})
    .group(&#39;users.id&#39;, &#39;users.region&#39;)
    .order(&#39;users.region, regional_rank&#39;)
  end
end

# Usage
leaderboard = User.sales_leaderboard.limit(10)

leaderboard.each do |user|
  puts &quot;#{user.rank}. #{user.name}: $#{user.total_sales}&quot;
end

# Regional
User.regional_leaderboard.each do |user|
  puts &quot;#{user.region} - Rank #{user.regional_rank}: #{user.name}&quot;
end

# ============================================
# EXAMPLE: Product Performance Analysis
# ============================================

class Product &lt; ApplicationRecord
  def self.performance_analysis
    select(
      &quot;products.*&quot;,
      &quot;COUNT(DISTINCT orders.id) as order_count&quot;,
      &quot;SUM(line_items.quantity) as units_sold&quot;,
      &quot;SUM(line_items.quantity * line_items.price) as revenue&quot;,
      
      # Ranking
      &quot;RANK() OVER (ORDER BY SUM(line_items.quantity) DESC) as sales_rank&quot;,
      
      # Running total
      &quot;SUM(SUM(line_items.quantity * line_items.price)) OVER (
        ORDER BY SUM(line_items.quantity) DESC
        ROWS UNBOUNDED PRECEDING
      ) as cumulative_revenue&quot;,
      
      # Percentage of total
      &quot;ROUND(
        100.0 * SUM(line_items.quantity * line_items.price) / 
        SUM(SUM(line_items.quantity * line_items.price)) OVER (),
        2
      ) as revenue_percentage&quot;
    )
    .joins(line_items: :order)
    .where(orders: {status: &#39;completed&#39;})
    .group(&#39;products.id&#39;)
    .order(&#39;sales_rank ASC&#39;)
  end
end

# Usage
analysis = Product.performance_analysis

analysis.each do |product|
  puts &quot;#{product.sales_rank}. #{product.name}&quot;
  puts &quot;  Revenue: $#{product.revenue}&quot;
  puts &quot;  % of Total: #{product.revenue_percentage}%&quot;
  puts &quot;  Cumulative: $#{product.cumulative_revenue}&quot;
end

# ============================================
# EXAMPLE: Time-based Analysis
# ============================================

class Order &lt; ApplicationRecord
  def self.daily_analysis(start_date, end_date)
    select(
      &quot;DATE(created_at) as order_date&quot;,
      &quot;COUNT(*) as orders_count&quot;,
      &quot;SUM(total) as daily_revenue&quot;,
      
      # Previous day comparison
      &quot;LAG(SUM(total)) OVER (ORDER BY DATE(created_at)) as prev_day_revenue&quot;,
      &quot;SUM(total) - LAG(SUM(total)) OVER (ORDER BY DATE(created_at)) as day_over_day_change&quot;,
      
      # 7-day moving average
      &quot;AVG(SUM(total)) OVER (
        ORDER BY DATE(created_at)
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
      ) as moving_avg_7d&quot;,
      
      # Running total for month
      &quot;SUM(SUM(total)) OVER (
        PARTITION BY DATE_TRUNC(&#39;month&#39;, created_at)
        ORDER BY DATE(created_at)
      ) as month_to_date_total&quot;
    )
    .where(created_at: start_date..end_date)
    .where(status: &#39;completed&#39;)
    .group(&quot;DATE(created_at)&quot;)
    .order(&quot;order_date ASC&quot;)
  end
end

# Usage
analysis = Order.daily_analysis(30.days.ago, Time.current)

analysis.each do |day|
  puts &quot;Date: #{day.order_date}&quot;
  puts &quot;  Daily Revenue: $#{day.daily_revenue}&quot;
  puts &quot;  vs Yesterday: $#{day.day_over_day_change}&quot;
  puts &quot;  7-day Avg: $#{day.moving_avg_7d}&quot;
  puts &quot;  Month-to-Date: $#{day.month_to_date_total}&quot;
end

# ============================================
# PERCENTILES
# ============================================

# Calculate percentile rank
User.select(
  &quot;*&quot;,
  &quot;PERCENT_RANK() OVER (
    ORDER BY total_spent
  ) as percentile&quot;
)

# Divide into quantiles
User.select(
  &quot;*&quot;,
  &quot;NTILE(4) OVER (ORDER BY total_spent) as quartile&quot;
)
# Divides users into 4 equal groups

# Get 95th percentile
percentile_95 = User
  .select(&quot;PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY total_spent) as p95&quot;)
  .first
  .p95

# ============================================
# GAPS AND ISLANDS (Consecutive Sequences)
# ============================================

# Find consecutive active days
class UserActivity &lt; ApplicationRecord
  def self.consecutive_streaks(user_id)
    select(
      &quot;*&quot;,
      &quot;DATE(created_at) as activity_date&quot;,
      &quot;DATE(created_at) - 
       (ROW_NUMBER() OVER (ORDER BY DATE(created_at)))::integer 
       as streak_group&quot;
    )
    .where(user_id: user_id)
    .group(&quot;DATE(created_at)&quot;)
  end
  
  def self.longest_streak(user_id)
    streaks = consecutive_streaks(user_id)
    
    from(streaks, :streaks)
      .select(
        &quot;streak_group&quot;,
        &quot;MIN(activity_date) as streak_start&quot;,
        &quot;MAX(activity_date) as streak_end&quot;,
        &quot;COUNT(*) as streak_length&quot;
      )
      .group(&quot;streak_group&quot;)
      .order(&quot;streak_length DESC&quot;)
      .first
  end
end

# ============================================
# HELPERS FOR CLEANER CODE
# ============================================

module WindowFunctions
  extend ActiveSupport::Concern
  
  class_methods do
    def with_rank(order_column, partition_by: nil)
      partition = partition_by ? &quot;PARTITION BY #{partition_by}&quot; : &quot;&quot;
      
      select(
        &quot;*&quot;,
        &quot;RANK() OVER (
          #{partition}
          ORDER BY #{order_column} DESC
        ) as rank&quot;
      )
    end
    
    def with_running_total(sum_column, order_column)
      select(
        &quot;*&quot;,
        &quot;SUM(#{sum_column}) OVER (
          ORDER BY #{order_column}
        ) as running_total&quot;
      )
    end
    
    def with_moving_average(avg_column, window_size, order_column)
      select(
        &quot;*&quot;,
        &quot;AVG(#{avg_column}) OVER (
          ORDER BY #{order_column}
          ROWS BETWEEN #{window_size - 1} PRECEDING AND CURRENT ROW
        ) as moving_avg&quot;
      )
    end
  end
end

class Order &lt; ApplicationRecord
  include WindowFunctions
end

# Usage
Order.with_rank(&#39;total&#39;, partition_by: &#39;user_id&#39;)
Order.with_running_total(&#39;total&#39;, &#39;created_at&#39;)
Order.with_moving_average(&#39;total&#39;, 7, &#39;created_at&#39;)
</code></pre>
<hr>
<h3>Window Function Types</h3>
<pre><code class="language-ruby"># ========================================
# AGGREGATE FUNCTIONS WITH OVER
# ========================================
# SUM, AVG, COUNT, MAX, MIN
# Operate on window instead of groups

&quot;SUM(amount) OVER (ORDER BY date)&quot;
&quot;AVG(value) OVER (PARTITION BY category ORDER BY date)&quot;
&quot;COUNT(*) OVER (PARTITION BY user_id)&quot;

# ========================================
# RANKING FUNCTIONS
# ========================================
# ROW_NUMBER: Unique sequential number
# RANK: Ranking with gaps for ties
# DENSE_RANK: Ranking without gaps
# PERCENT_RANK: Relative rank (0 to 1)

&quot;ROW_NUMBER() OVER (ORDER BY score DESC)&quot;
&quot;RANK() OVER (ORDER BY score DESC)&quot;
&quot;DENSE_RANK() OVER (ORDER BY score DESC)&quot;

# ========================================
# VALUE FUNCTIONS
# ========================================
# LAG: Previous row value
# LEAD: Next row value
# FIRST_VALUE: First value in window
# LAST_VALUE: Last value in window

&quot;LAG(price) OVER (ORDER BY date)&quot;
&quot;LEAD(price) OVER (ORDER BY date)&quot;
&quot;FIRST_VALUE(price) OVER (PARTITION BY product_id ORDER BY date)&quot;

# ========================================
# DISTRIBUTION FUNCTIONS
# ========================================
# NTILE: Divide into N equal groups
# PERCENTILE_CONT: Continuous percentile
# PERCENTILE_DISC: Discrete percentile

&quot;NTILE(10) OVER (ORDER BY revenue)&quot;  # Deciles
&quot;PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY response_time)&quot;
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Window functions</strong>: Calculations across row sets</li>
<li><strong>OVER clause</strong>: Defines window (partition, order, frame)</li>
<li><strong>PARTITION BY</strong>: Group within window</li>
<li><strong>ORDER BY</strong>: Order within window/partition</li>
<li><strong>ROWS/RANGE</strong>: Define frame boundaries</li>
<li><strong>Rankings</strong>: ROW_NUMBER, RANK, DENSE_RANK</li>
<li><strong>Aggregates</strong>: SUM, AVG with OVER</li>
<li><strong>Value functions</strong>: LAG, LEAD for comparisons</li>
<li><strong>Running totals</strong>: Cumulative calculations</li>
<li><strong>Performance</strong>: More efficient than subqueries</li>
</ol>
<hr>
<h2>Question 347: How do you execute raw SQL queries and map to ActiveRecord models?</h2>
<h3>Answer</h3>
<p><strong>Raw SQL queries</strong> execute custom SQL while mapping results to ActiveRecord models using <code>find_by_sql</code>, <code>select_all</code>, <code>connection.execute</code>, or <code>pluck</code>. Useful for complex queries, database-specific features, and performance optimization.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>find_by_sql</strong>: Returns model instances</li>
<li><strong>connection.execute</strong>: Returns raw results</li>
<li><strong>select_all</strong>: Returns hash results</li>
<li><strong>pluck</strong>: Returns array of values</li>
<li><strong>from()</strong>: Use subquery as table</li>
<li><strong>Use cases</strong>: Complex queries, performance, DB features</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# METHOD 1: find_by_sql (Returns Models)
# ============================================

# Returns array of User instances
users = User.find_by_sql(&lt;&lt;-SQL)
  SELECT *
  FROM users
  WHERE created_at &gt; &#39;2024-01-01&#39;
  ORDER BY name
SQL

users.first.class  # =&gt; User
users.first.name   # =&gt; &quot;John&quot; (model attribute)

# With parameters (prevents SQL injection)
users = User.find_by_sql([&lt;&lt;-SQL, Date.current - 30])
  SELECT *
  FROM users
  WHERE created_at &gt; ?
  ORDER BY name
SQL

# Complex query with joins
orders = Order.find_by_sql(&lt;&lt;-SQL)
  SELECT 
    orders.*,
    users.name as user_name,
    COUNT(line_items.id) as items_count
  FROM orders
  INNER JOIN users ON users.id = orders.user_id
  LEFT JOIN line_items ON line_items.order_id = orders.id
  GROUP BY orders.id, users.name
  HAVING COUNT(line_items.id) &gt; 5
SQL

orders.first.user_name    # Accessible as attribute
orders.first.items_count  # Accessible as attribute

# ============================================
# METHOD 2: connection.execute (Raw Results)
# ============================================

# Returns PG::Result (PostgreSQL)
result = ActiveRecord::Base.connection.execute(&lt;&lt;-SQL)
  SELECT name, email FROM users WHERE active = true
SQL

# Access results
result.each do |row|
  puts &quot;#{row[&#39;name&#39;]}: #{row[&#39;email&#39;]}&quot;
end

# Get all rows as array of hashes
rows = result.to_a
rows.first[&#39;name&#39;]  # =&gt; &quot;John&quot;

# ============================================
# METHOD 3: select_all (Hash Results)
# ============================================

# Returns array of hashes
result = ActiveRecord::Base.connection.select_all(&lt;&lt;-SQL)
  SELECT 
    DATE(created_at) as date,
    COUNT(*) as count,
    SUM(total) as revenue
  FROM orders
  WHERE status = &#39;completed&#39;
  GROUP BY DATE(created_at)
SQL

result.to_a  # Array of hashes
result.columns  # =&gt; [&#39;date&#39;, &#39;count&#39;, &#39;revenue&#39;]
result.rows     # =&gt; [[&#39;2025-01-01&#39;, 10, 1000], ...]

# With parameters
result = ActiveRecord::Base.connection.select_all(
  ActiveRecord::Base.sanitize_sql_array([&lt;&lt;-SQL, &#39;completed&#39;])
    SELECT * FROM orders WHERE status = ?
  SQL
])

# ============================================
# METHOD 4: select_one / select_value
# ============================================

# select_one: Returns single hash
user = ActiveRecord::Base.connection.select_one(&lt;&lt;-SQL)
  SELECT * FROM users WHERE email = &#39;john@example.com&#39;
SQL

user[&#39;name&#39;]  # =&gt; &quot;John&quot;

# select_value: Returns single value
count = ActiveRecord::Base.connection.select_value(&lt;&lt;-SQL)
  SELECT COUNT(*) FROM users WHERE active = true
SQL

count  # =&gt; 42 (integer)

# ============================================
# METHOD 5: pluck (Array of Values)
# ============================================

# Get array of values
emails = User.where(active: true).pluck(:email)
# =&gt; [&quot;john@example.com&quot;, &quot;jane@example.com&quot;, ...]

# Multiple columns (array of arrays)
data = User.pluck(:name, :email)
# =&gt; [[&quot;John&quot;, &quot;john@example.com&quot;], [&quot;Jane&quot;, &quot;jane@example.com&quot;]]

# With raw SQL using select
User.select(&#39;DISTINCT region&#39;).pluck(:region)

# ============================================
# METHOD 6: from() with Subquery
# ============================================

# Use subquery as table
subquery = &lt;&lt;-SQL
  SELECT 
    user_id,
    COUNT(*) as order_count,
    SUM(total) as total_spent
  FROM orders
  WHERE status = &#39;completed&#39;
  GROUP BY user_id
SQL

users = User
  .from(&quot;(#{subquery}) as user_stats&quot;)
  .select(&#39;users.*, user_stats.order_count, user_stats.total_spent&#39;)
  .joins(&#39;INNER JOIN users ON users.id = user_stats.user_id&#39;)

users.first.order_count  # Accessible as attribute
users.first.total_spent  # Accessible as attribute

# ============================================
# REAL-WORLD EXAMPLE: Complex Report
# ============================================

class SalesReport
  def self.generate(start_date, end_date)
    Order.find_by_sql([&lt;&lt;-SQL, start_date, end_date])
      WITH daily_sales AS (
        SELECT 
          DATE(orders.created_at) as sale_date,
          users.region,
          COUNT(DISTINCT orders.id) as orders_count,
          SUM(orders.total) as revenue,
          AVG(orders.total) as avg_order_value
        FROM orders
        INNER JOIN users ON users.id = orders.user_id
        WHERE 
          orders.created_at BETWEEN ? AND ?
          AND orders.status = &#39;completed&#39;
        GROUP BY DATE(orders.created_at), users.region
      ),
      regional_totals AS (
        SELECT 
          region,
          SUM(revenue) as total_revenue,
          RANK() OVER (ORDER BY SUM(revenue) DESC) as revenue_rank
        FROM daily_sales
        GROUP BY region
      )
      SELECT 
        daily_sales.*,
        regional_totals.total_revenue as regional_total,
        regional_totals.revenue_rank,
        ROUND(
          100.0 * daily_sales.revenue / regional_totals.total_revenue,
          2
        ) as percent_of_regional_total
      FROM daily_sales
      INNER JOIN regional_totals ON regional_totals.region = daily_sales.region
      ORDER BY daily_sales.sale_date, regional_totals.revenue_rank
    SQL
  end
end

# Usage
report = SalesReport.generate(30.days.ago, Time.current)

report.each do |row|
  puts &quot;#{row.sale_date} - #{row.region}&quot;
  puts &quot;  Revenue: $#{row.revenue}&quot;
  puts &quot;  % of Regional: #{row.percent_of_regional_total}%&quot;
end

# ============================================
# EXAMPLE: Recursive CTE (Organization Tree)
# ============================================

class Employee &lt; ApplicationRecord
  def self.with_subordinates(manager_id)
    find_by_sql([&lt;&lt;-SQL, manager_id])
      WITH RECURSIVE subordinates AS (
        -- Base case: direct reports
        SELECT 
          id,
          name,
          manager_id,
          1 as level
        FROM employees
        WHERE manager_id = ?
        
        UNION ALL
        
        -- Recursive case: reports of reports
        SELECT 
          e.id,
          e.name,
          e.manager_id,
          s.level + 1 as level
        FROM employees e
        INNER JOIN subordinates s ON s.id = e.manager_id
      )
      SELECT * FROM subordinates
      ORDER BY level, name
    SQL
  end
  
  def self.full_org_chart
    find_by_sql(&lt;&lt;-SQL)
      WITH RECURSIVE org_tree AS (
        -- Root level (CEOs with no manager)
        SELECT 
          id,
          name,
          manager_id,
          CAST(name AS TEXT) as path,
          0 as level
        FROM employees
        WHERE manager_id IS NULL
        
        UNION ALL
        
        -- All descendants
        SELECT 
          e.id,
          e.name,
          e.manager_id,
          ot.path || &#39; &gt; &#39; || e.name as path,
          ot.level + 1 as level
        FROM employees e
        INNER JOIN org_tree ot ON ot.id = e.manager_id
      )
      SELECT * FROM org_tree
      ORDER BY path
    SQL
  end
end

# Usage
subordinates = Employee.with_subordinates(ceo_id)

subordinates.each do |emp|
  indent = &quot;  &quot; * emp.level
  puts &quot;#{indent}#{emp.name} (Level #{emp.level})&quot;
end

# ============================================
# EXAMPLE: JSON Aggregation (PostgreSQL)
# ============================================

class Order &lt; ApplicationRecord
  def self.with_items_json
    find_by_sql(&lt;&lt;-SQL)
      SELECT 
        orders.*,
        json_agg(
          json_build_object(
            &#39;id&#39;, line_items.id,
            &#39;product_name&#39;, products.name,
            &#39;quantity&#39;, line_items.quantity,
            &#39;price&#39;, line_items.price
          )
        ) as items
      FROM orders
      LEFT JOIN line_items ON line_items.order_id = orders.id
      LEFT JOIN products ON products.id = line_items.product_id
      GROUP BY orders.id
    SQL
  end
end

# Usage
orders = Order.with_items_json

orders.first.items
# =&gt; [
#   {&quot;id&quot;=&gt;1, &quot;product_name&quot;=&gt;&quot;Widget&quot;, &quot;quantity&quot;=&gt;2, &quot;price&quot;=&gt;10.0},
#   {&quot;id&quot;=&gt;2, &quot;product_name&quot;=&gt;&quot;Gadget&quot;, &quot;quantity&quot;=&gt;1, &quot;price&quot;=&gt;20.0}
# ]

# ============================================
# PARAMETERIZED QUERIES (Security)
# ============================================

# ❌ DANGEROUS: SQL Injection risk
email = params[:email]
User.find_by_sql(&quot;SELECT * FROM users WHERE email = &#39;#{email}&#39;&quot;)
# Vulnerable to: &#39; OR &#39;1&#39;=&#39;1

# ✅ SAFE: Parameterized query
User.find_by_sql([
  &quot;SELECT * FROM users WHERE email = ?&quot;,
  email
])

# ✅ SAFE: Named parameters
User.find_by_sql([
  &quot;SELECT * FROM users WHERE email = :email AND active = :active&quot;,
  {email: email, active: true}
])

# ✅ SAFE: sanitize_sql_array
sql = ActiveRecord::Base.sanitize_sql_array([
  &quot;SELECT * FROM users WHERE email = ? AND created_at &gt; ?&quot;,
  email,
  30.days.ago
])
User.find_by_sql(sql)

# ============================================
# CREATING CUSTOM MODEL FROM SQL
# ============================================

# Create model for query result
class DailySale &lt; ApplicationRecord
  self.table_name = &#39;daily_sales&#39;
  
  # Define as readonly
  def readonly?
    true
  end
  
  # Custom finder
  def self.for_period(start_date, end_date)
    find_by_sql([&lt;&lt;-SQL, start_date, end_date])
      SELECT 
        DATE(created_at) as date,
        COUNT(*) as orders_count,
        SUM(total) as revenue
      FROM orders
      WHERE 
        created_at BETWEEN ? AND ?
        AND status = &#39;completed&#39;
      GROUP BY DATE(created_at)
      ORDER BY date
    SQL
  end
end

# Usage
sales = DailySale.for_period(7.days.ago, Time.current)

sales.each do |day|
  puts &quot;#{day.date}: #{day.orders_count} orders, $#{day.revenue}&quot;
end

# ============================================
# PERFORMANCE: EXPLAIN QUERY
# ============================================

# Get query plan
sql = &lt;&lt;-SQL
  SELECT users.*, COUNT(orders.id) as orders_count
  FROM users
  LEFT JOIN orders ON orders.user_id = users.id
  GROUP BY users.id
  HAVING COUNT(orders.id) &gt; 10
SQL

plan = ActiveRecord::Base.connection.execute(&quot;EXPLAIN ANALYZE #{sql}&quot;)

puts plan.to_a

# Output shows:
# - Execution time
# - Index usage
# - Join methods
# - Row estimates vs actuals

# ============================================
# MAPPING RESULTS TO STRUCTS
# ============================================

# Create struct for results
UserStats = Struct.new(:user_id, :name, :orders_count, :total_spent, keyword_init: true)

def fetch_user_stats
  result = ActiveRecord::Base.connection.select_all(&lt;&lt;-SQL)
    SELECT 
      users.id as user_id,
      users.name,
      COUNT(orders.id) as orders_count,
      SUM(orders.total) as total_spent
    FROM users
    LEFT JOIN orders ON orders.user_id = users.id
    GROUP BY users.id, users.name
  SQL
  
  result.map do |row|
    UserStats.new(
      user_id: row[&#39;user_id&#39;],
      name: row[&#39;name&#39;],
      orders_count: row[&#39;orders_count&#39;],
      total_spent: row[&#39;total_spent&#39;]
    )
  end
end

# Usage
stats = fetch_user_stats

stats.first.name          # =&gt; &quot;John&quot;
stats.first.orders_count  # =&gt; 15

# ============================================
# TRANSACTION WITH RAW SQL
# ============================================

ActiveRecord::Base.transaction do
  # Execute multiple raw SQL statements
  ActiveRecord::Base.connection.execute(&lt;&lt;-SQL)
    UPDATE accounts SET balance = balance - 100 WHERE id = 1
  SQL
  
  ActiveRecord::Base.connection.execute(&lt;&lt;-SQL)
    UPDATE accounts SET balance = balance + 100 WHERE id = 2
  SQL
  
  # Will rollback if any error
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<pre><code class="language-ruby"># 1. Always use parameterized queries
# ✅ GOOD
User.find_by_sql([&quot;SELECT * FROM users WHERE email = ?&quot;, email])

# ❌ BAD (SQL injection)
User.find_by_sql(&quot;SELECT * FROM users WHERE email = &#39;#{email}&#39;&quot;)

# 2. Use appropriate method for result type
# find_by_sql → Need full model instances
# select_all → Need hashes
# pluck → Need simple values
# select_value → Need single value

# 3. Add indexes for raw queries
add_index :users, [:region, :created_at]

# 4. Test query performance
ActiveRecord::Base.connection.execute(&quot;EXPLAIN ANALYZE #{sql}&quot;)

# 5. Consider creating views
# Instead of complex SQL everywhere
CREATE VIEW user_stats AS
  SELECT users.id, COUNT(orders.id) as orders_count
  FROM users LEFT JOIN orders ON orders.user_id = users.id
  GROUP BY users.id
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>find_by_sql</strong>: Returns model instances</li>
<li><strong>connection.execute</strong>: Raw database results</li>
<li><strong>select_all</strong>: Returns array of hashes</li>
<li><strong>pluck</strong>: Simple array of values</li>
<li><strong>Parameterized</strong>: Always use ? or named params</li>
<li><strong>from()</strong>: Use subqueries as tables</li>
<li><strong>CTEs</strong>: WITH RECURSIVE for complex queries</li>
<li><strong>Performance</strong>: Use EXPLAIN ANALYZE</li>
<li><strong>Security</strong>: Never interpolate user input</li>
<li><strong>Use cases</strong>: Complex queries, DB-specific features</li>
</ol>
<hr>
<h2>Security</h2>
<h2>Question 348: What is brute force attack protection?</h2>
<h3>Answer</h3>
<p><strong>Brute force attack protection</strong> prevents attackers from guessing passwords through repeated login attempts. Implement with <strong>rate limiting</strong>, <strong>CAPTCHA</strong>, <strong>account lockouts</strong>, <strong>exponential backoff</strong>, and <strong>IP blocking</strong> to secure authentication endpoints.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Rate limiting</strong>: Limit login attempts per IP/user</li>
<li><strong>Account lockout</strong>: Temporarily lock after failures</li>
<li><strong>CAPTCHA</strong>: Verify human users</li>
<li><strong>Exponential backoff</strong>: Increase delay between attempts</li>
<li><strong>IP blocking</strong>: Block suspicious IPs</li>
<li><strong>2FA</strong>: Add second factor</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# METHOD 1: Rack::Attack (Rate Limiting)
# ============================================

# Gemfile
gem &#39;rack-attack&#39;

# config/initializers/rack_attack.rb
class Rack::Attack
  # Throttle login attempts
  throttle(&#39;limit login attempts per email&#39;, limit: 5, period: 60) do |req|
    if req.path == &#39;/users/sign_in&#39; &amp;&amp; req.post?
      # Normalize email
      req.params[&#39;user&#39;][&#39;email&#39;].to_s.downcase.presence
    end
  end
  
  # Throttle login attempts per IP
  throttle(&#39;limit login attempts per IP&#39;, limit: 10, period: 60) do |req|
    if req.path == &#39;/users/sign_in&#39; &amp;&amp; req.post?
      req.ip
    end
  end
  
  # Block suspicious IPs
  blocklist(&#39;block bad IPs&#39;) do |req|
    # Read from database or Redis
    BlockedIp.exists?(ip: req.ip)
  end
  
  # Allow admin IPs to bypass
  safelist(&#39;allow admin IPs&#39;) do |req|
    [&#39;127.0.0.1&#39;, &#39;::1&#39;].include?(req.ip)
  end
end

# config/application.rb
config.middleware.use Rack::Attack

# ============================================
# METHOD 2: Devise Lockable
# ============================================

# Gemfile
gem &#39;devise&#39;

# Generate Devise lockable migration
rails g migration AddLockableToUsers locked_at:datetime \
  failed_attempts:integer unlock_token:string

# Migration
class AddLockableToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :failed_attempts, :integer, default: 0, null: false
    add_column :users, :unlock_token, :string
    add_column :users, :locked_at, :datetime
    
    add_index :users, :unlock_token, unique: true
  end
end

# Model
class User &lt; ApplicationRecord
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable,
         :lockable  # Add lockable
  
  # Lock strategy: :failed_attempts (default) or :none
  # :failed_attempts - lock after X failed attempts
  # :none - only lock by admin
end

# config/initializers/devise.rb
Devise.setup do |config|
  # Number of attempts before locking
  config.maximum_attempts = 5
  
  # Time period to unlock (20.minutes, 1.hour, etc.)
  config.unlock_strategy = :time
  config.unlock_in = 1.hour
  
  # Or unlock via email
  # config.unlock_strategy = :email
  
  # Or both
  # config.unlock_strategy = :both
end

# Manually lock/unlock
user = User.find(1)
user.lock_access!  # Lock account
user.unlock_access!  # Unlock account

# Check if locked
user.access_locked?  # =&gt; true/false

# ============================================
# METHOD 3: Custom Login Throttling
# ============================================

# Model
class User &lt; ApplicationRecord
  def increment_failed_attempts
    self.failed_attempts ||= 0
    self.failed_attempts += 1
    
    if failed_attempts &gt;= 5
      self.locked_at = Time.current
      self.locked_until = 1.hour.from_now
    end
    
    save
  end
  
  def reset_failed_attempts
    update(
      failed_attempts: 0,
      locked_at: nil,
      locked_until: nil
    )
  end
  
  def locked?
    locked_at.present? &amp;&amp; locked_until.present? &amp;&amp; locked_until &gt; Time.current
  end
  
  def unlock!
    update(
      failed_attempts: 0,
      locked_at: nil,
      locked_until: nil
    )
  end
end

# Controller
class SessionsController &lt; ApplicationController
  def create
    user = User.find_by(email: params[:email])
    
    if user&amp;.locked?
      render json: {
        error: &quot;Account locked. Try again in #{time_until_unlock(user)}&quot;
      }, status: :locked
      return
    end
    
    if user&amp;.authenticate(params[:password])
      user.reset_failed_attempts
      # Login success
      session[:user_id] = user.id
      render json: {success: true}
    else
      user&amp;.increment_failed_attempts
      render json: {
        error: &quot;Invalid credentials. #{5 - (user&amp;.failed_attempts || 0)} attempts remaining&quot;
      }, status: :unauthorized
    end
  end
  
  private
  
  def time_until_unlock(user)
    seconds = (user.locked_until - Time.current).to_i
    &quot;#{seconds / 60} minutes&quot;
  end
end

# ============================================
# METHOD 4: Redis-based Rate Limiting
# ============================================

class LoginRateLimiter
  def initialize(redis = Redis.current)
    @redis = redis
  end
  
  def check(identifier)
    key = &quot;login_attempts:#{identifier}&quot;
    attempts = @redis.get(key).to_i
    
    if attempts &gt;= 5
      ttl = @redis.ttl(key)
      return {
        allowed: false,
        message: &quot;Too many attempts. Try again in #{ttl} seconds&quot;,
        retry_after: ttl
      }
    end
    
    {allowed: true, attempts_remaining: 5 - attempts}
  end
  
  def record_attempt(identifier)
    key = &quot;login_attempts:#{identifier}&quot;
    @redis.multi do
      @redis.incr(key)
      @redis.expire(key, 300) # 5 minutes
    end
  end
  
  def reset(identifier)
    key = &quot;login_attempts:#{identifier}&quot;
    @redis.del(key)
  end
end

# Controller
class SessionsController &lt; ApplicationController
  def create
    limiter = LoginRateLimiter.new
    
    # Check by email
    email_check = limiter.check(params[:email])
    unless email_check[:allowed]
      render json: {error: email_check[:message]}, 
        status: :too_many_requests
      return
    end
    
    # Check by IP
    ip_check = limiter.check(request.ip)
    unless ip_check[:allowed]
      render json: {error: ip_check[:message]}, 
        status: :too_many_requests
      return
    end
    
    user = User.find_by(email: params[:email])
    
    if user&amp;.authenticate(params[:password])
      limiter.reset(params[:email])
      limiter.reset(request.ip)
      # Success
    else
      limiter.record_attempt(params[:email])
      limiter.record_attempt(request.ip)
      render json: {
        error: &quot;Invalid credentials&quot;,
        attempts_remaining: email_check[:attempts_remaining] - 1
      }, status: :unauthorized
    end
  end
end

# ============================================
# METHOD 5: CAPTCHA (reCAPTCHA)
# ============================================

# Gemfile
gem &#39;recaptcha&#39;

# config/initializers/recaptcha.rb
Recaptcha.configure do |config|
  config.site_key = ENV[&#39;RECAPTCHA_SITE_KEY&#39;]
  config.secret_key = ENV[&#39;RECAPTCHA_SECRET_KEY&#39;]
end

# View
&lt;%= form_with url: session_path do |f| %&gt;
  &lt;%= f.text_field :email %&gt;
  &lt;%= f.password_field :password %&gt;
  
  &lt;% if @show_captcha %&gt;
    &lt;%= recaptcha_tags %&gt;
  &lt;% end %&gt;
  
  &lt;%= f.submit &quot;Login&quot; %&gt;
&lt;% end %&gt;

# Controller
class SessionsController &lt; ApplicationController
  def create
    @show_captcha = failed_attempts_count(params[:email]) &gt;= 3
    
    if @show_captcha
      unless verify_recaptcha
        flash[:error] = &quot;Please complete the CAPTCHA&quot;
        render :new
        return
      end
    end
    
    # Normal login logic
  end
  
  private
  
  def failed_attempts_count(email)
    Rails.cache.read(&quot;failed_attempts:#{email}&quot;) || 0
  end
end

# ============================================
# METHOD 6: Exponential Backoff
# ============================================

class ExponentialBackoffLimiter
  def initialize(redis = Redis.current)
    @redis = redis
  end
  
  def check(identifier)
    attempts = get_attempts(identifier)
    
    if attempts &gt; 0
      wait_time = calculate_wait_time(attempts)
      last_attempt = get_last_attempt_time(identifier)
      elapsed = Time.current - last_attempt
      
      if elapsed &lt; wait_time
        remaining = (wait_time - elapsed).to_i
        return {
          allowed: false,
          message: &quot;Please wait #{remaining} seconds before trying again&quot;,
          wait_time: remaining
        }
      end
    end
    
    {allowed: true}
  end
  
  def record_attempt(identifier)
    key = &quot;backoff_attempts:#{identifier}&quot;
    time_key = &quot;backoff_time:#{identifier}&quot;
    
    @redis.multi do
      @redis.incr(key)
      @redis.set(time_key, Time.current.to_i)
      @redis.expire(key, 1.hour)
      @redis.expire(time_key, 1.hour)
    end
  end
  
  def reset(identifier)
    @redis.del(&quot;backoff_attempts:#{identifier}&quot;)
    @redis.del(&quot;backoff_time:#{identifier}&quot;)
  end
  
  private
  
  def get_attempts(identifier)
    @redis.get(&quot;backoff_attempts:#{identifier}&quot;).to_i
  end
  
  def get_last_attempt_time(identifier)
    timestamp = @redis.get(&quot;backoff_time:#{identifier}&quot;).to_i
    Time.at(timestamp)
  end
  
  def calculate_wait_time(attempts)
    # Exponential: 1s, 2s, 4s, 8s, 16s, ...
    [2 ** (attempts - 1), 300].min  # Cap at 5 minutes
  end
end

# Usage
limiter = ExponentialBackoffLimiter.new
check = limiter.check(params[:email])

unless check[:allowed]
  render json: {error: check[:message]}, 
    status: :too_many_requests
  return
end

# ============================================
# METHOD 7: IP Reputation &amp; Blocking
# ============================================

class IpReputationChecker
  SUSPICIOUS_IPS_KEY = &#39;suspicious_ips&#39;
  BLOCKED_IPS_KEY = &#39;blocked_ips&#39;
  
  def initialize(redis = Redis.current)
    @redis = redis
  end
  
  def check(ip)
    if blocked?(ip)
      return {
        allowed: false,
        reason: &#39;IP blocked due to suspicious activity&#39;
      }
    end
    
    if suspicious?(ip)
      return {
        allowed: true,
        require_captcha: true,
        reason: &#39;Suspicious IP - CAPTCHA required&#39;
      }
    end
    
    {allowed: true}
  end
  
  def mark_suspicious(ip, reason)
    @redis.sadd(SUSPICIOUS_IPS_KEY, ip)
    @redis.hset(&quot;suspicious_ip_reasons&quot;, ip, reason)
    @redis.expire(SUSPICIOUS_IPS_KEY, 24.hours)
  end
  
  def block_ip(ip, reason, duration = 24.hours)
    @redis.sadd(BLOCKED_IPS_KEY, ip)
    @redis.hset(&quot;blocked_ip_reasons&quot;, ip, reason)
    @redis.expire(BLOCKED_IPS_KEY, duration)
  end
  
  def unblock_ip(ip)
    @redis.srem(BLOCKED_IPS_KEY, ip)
    @redis.hdel(&quot;blocked_ip_reasons&quot;, ip)
  end
  
  private
  
  def blocked?(ip)
    @redis.sismember(BLOCKED_IPS_KEY, ip)
  end
  
  def suspicious?(ip)
    @redis.sismember(SUSPICIOUS_IPS_KEY, ip)
  end
end

# Middleware
class IpReputationMiddleware
  def initialize(app)
    @app = app
    @checker = IpReputationChecker.new
  end
  
  def call(env)
    request = Rack::Request.new(env)
    ip = request.ip
    
    check = @checker.check(ip)
    
    unless check[:allowed]
      return [403, {&#39;Content-Type&#39; =&gt; &#39;application/json&#39;}, 
        [{error: check[:reason]}.to_json]]
    end
    
    if check[:require_captcha]
      env[&#39;REQUIRE_CAPTCHA&#39;] = true
    end
    
    @app.call(env)
  end
end

# config/application.rb
config.middleware.use IpReputationMiddleware

# ============================================
# MONITORING &amp; ALERTS
# ============================================

class LoginMonitor
  def self.track_failed_attempt(email, ip, user_agent)
    Rails.logger.warn(
      &quot;Failed login attempt: #{email} from #{ip} (#{user_agent})&quot;
    )
    
    # Send alert if too many failures
    failed_count = Rails.cache.read(&quot;global_failed:#{ip}&quot;) || 0
    Rails.cache.write(&quot;global_failed:#{ip}&quot;, failed_count + 1, expires_in: 1.hour)
    
    if failed_count &gt; 20
      SecurityMailer.brute_force_detected(ip).deliver_later
    end
  end
end
</code></pre>
<hr>
<h3>Best Practices</h3>
<pre><code class="language-ruby"># 1. Multiple layers of protection
# - Rate limit by IP
# - Rate limit by email
# - Account lockout
# - CAPTCHA after failures
# - 2FA for sensitive accounts

# 2. Don&#39;t leak information
# ❌ BAD
&quot;User not found&quot;
&quot;Wrong password&quot;

# ✅ GOOD
&quot;Invalid email or password&quot;

# 3. Log suspicious activity
Rails.logger.warn(&quot;Failed login: #{email} from #{ip}&quot;)

# 4. Implement exponential backoff
# 1st attempt: immediate
# 2nd: wait 1s
# 3rd: wait 2s
# 4th: wait 4s
# etc.

# 5. Consider 2FA/MFA
# Always for admin accounts
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Rate limiting</strong>: Essential first defense</li>
<li><strong>Account lockout</strong>: Temporary after failures</li>
<li><strong>CAPTCHA</strong>: Verify human users</li>
<li><strong>Exponential backoff</strong>: Increase delays</li>
<li><strong>IP blocking</strong>: Block suspicious IPs</li>
<li><strong>Redis</strong>: Fast rate limit storage</li>
<li><strong>Monitoring</strong>: Log and alert on attacks</li>
<li><strong>2FA</strong>: Additional security layer</li>
<li><strong>Don&#39;t leak</strong>: Same error for all failures</li>
<li><strong>Multiple layers</strong>: Defense in depth</li>
</ol>
<hr>
<h2>Question 349: How do you harden a Rails application against DDoS attacks?</h2>
<h3>Answer</h3>
<p><strong>DDoS (Distributed Denial of Service) protection</strong> prevents overwhelming the application with requests. Implement with <strong>CDN/WAF</strong> (Cloudflare), <strong>rate limiting</strong>, <strong>load balancing</strong>, <strong>caching</strong>, <strong>auto-scaling</strong>, and <strong>traffic analysis</strong> to maintain availability.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>CDN/WAF</strong>: Cloudflare, AWS Shield</li>
<li><strong>Rate limiting</strong>: Rack::Attack, Nginx limits</li>
<li><strong>Load balancing</strong>: Distribute traffic</li>
<li><strong>Caching</strong>: Reduce backend load</li>
<li><strong>Auto-scaling</strong>: Handle traffic spikes</li>
<li><strong>Monitoring</strong>: Detect attacks early</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# LAYER 1: CDN &amp; WAF (First Defense)
# ============================================

# Use Cloudflare, AWS CloudFront + WAF, or Fastly
# Benefits:
# - Absorb attack traffic at edge
# - Challenge suspicious requests
# - Rate limit at CDN level
# - Cache static assets
# - DDoS protection included

# Cloudflare configuration (via dashboard):
# - Enable &quot;I&#39;m Under Attack Mode&quot; during attack
# - Set security level to &quot;High&quot;
# - Configure rate limiting rules
# - Enable bot fight mode
# - Set firewall rules

# ============================================
# LAYER 2: Application Rate Limiting
# ============================================

# Gemfile
gem &#39;rack-attack&#39;
gem &#39;redis&#39;

# config/initializers/rack_attack.rb
class Rack::Attack
  # Use Redis for distributed rate limiting
  Rack::Attack.cache.store = ActiveSupport::Cache::RedisCacheStore.new(
    url: ENV[&#39;REDIS_URL&#39;]
  )
  
  # =====================================
  # THROTTLES (Rate Limiting)
  # =====================================
  
  # Limit requests per IP
  throttle(&#39;req/ip&#39;, limit: 300, period: 5.minutes) do |req|
    req.ip unless req.path.start_with?(&#39;/assets&#39;)
  end
  
  # Stricter limit for API endpoints
  throttle(&#39;api/ip&#39;, limit: 100, period: 1.minute) do |req|
    if req.path.start_with?(&#39;/api&#39;)
      req.ip
    end
  end
  
  # Limit login attempts
  throttle(&#39;login/ip&#39;, limit: 5, period: 20.seconds) do |req|
    if req.path == &#39;/login&#39; &amp;&amp; req.post?
      req.ip
    end
  end
  
  # Limit expensive operations
  throttle(&#39;search/ip&#39;, limit: 10, period: 1.minute) do |req|
    if req.path == &#39;/search&#39; &amp;&amp; req.get?
      req.ip
    end
  end
  
  # =====================================
  # BLOCKLISTS
  # =====================================
  
  # Block known bad IPs
  blocklist(&#39;block bad IPs&#39;) do |req|
    # Load from database
    BlockedIp.exists?(ip: req.ip)
  end
  
  # Block based on request characteristics
  blocklist(&#39;block suspicious requests&#39;) do |req|
    # Block if no user agent
    req.user_agent.blank? ||
    # Block common attack tools
    req.user_agent =~ /curl|wget|python-requests|scrapy/i ||
    # Block if suspicious referrer
    (req.referrer.present? &amp;&amp; req.referrer =~ /viagra|casino|porn/i)
  end
  
  # =====================================
  # SAFELISTS (Whitelist)
  # =====================================
  
  # Allow localhost
  safelist(&#39;allow localhost&#39;) do |req|
    &#39;127.0.0.1&#39; == req.ip || &#39;::1&#39; == req.ip
  end
  
  # Allow monitoring services
  safelist(&#39;allow monitors&#39;) do |req|
    [&#39;monitor1.example.com&#39;, &#39;monitor2.example.com&#39;].include?(req.ip)
  end
  
  # =====================================
  # TRACKING
  # =====================================
  
  # Track requests for analysis
  track(&#39;requests by ip&#39;, limit: 1000, period: 1.hour) do |req|
    req.ip
  end
  
  # =====================================
  # RESPONSES
  # =====================================
  
  # Custom response for throttled requests
  self.throttled_responder = lambda do |env|
    match_data = env[&#39;rack.attack.match_data&#39;]
    now = match_data[:epoch_time]
    
    headers = {
      &#39;Content-Type&#39; =&gt; &#39;application/json&#39;,
      &#39;X-RateLimit-Limit&#39; =&gt; match_data[:limit].to_s,
      &#39;X-RateLimit-Remaining&#39; =&gt; &#39;0&#39;,
      &#39;X-RateLimit-Reset&#39; =&gt; (now + (match_data[:period] - now % match_data[:period])).to_s
    }
    
    [429, headers, [{error: &#39;Rate limit exceeded. Please try again later.&#39;}.to_json]]
  end
  
  # Custom response for blocked requests
  self.blocklisted_responder = lambda do |env|
    [403, {&#39;Content-Type&#39; =&gt; &#39;application/json&#39;}, 
     [{error: &#39;Forbidden&#39;}.to_json]]
  end
end

# Enable in application
# config/application.rb
config.middleware.use Rack::Attack

# ============================================
# LAYER 3: Nginx Rate Limiting
# ============================================

# nginx.conf
http {
  # Define rate limit zones
  limit_req_zone $binary_remote_addr zone=general:10m rate=10r/s;
  limit_req_zone $binary_remote_addr zone=api:10m rate=5r/s;
  limit_req_zone $binary_remote_addr zone=login:10m rate=1r/s;
  
  # Connection limits
  limit_conn_zone $binary_remote_addr zone=addr:10m;
  
  server {
    listen 80;
    server_name example.com;
    
    # Apply general limit
    limit_req zone=general burst=20 nodelay;
    limit_conn addr 10;
    
    # Stricter limit for API
    location /api {
      limit_req zone=api burst=5 nodelay;
    }
    
    # Strictest for login
    location /login {
      limit_req zone=login burst=3 nodelay;
    }
    
    # Block by user agent
    if ($http_user_agent ~* (curl|wget|scrapy)) {
      return 403;
    }
  }
}

# ============================================
# LAYER 4: Load Balancing &amp; Auto-Scaling
# ============================================

# AWS Elastic Load Balancer + Auto Scaling
# Distributes traffic across multiple servers

# terraform/main.tf
resource &quot;aws_lb&quot; &quot;main&quot; {
  name               = &quot;app-lb&quot;
  internal           = false
  load_balancer_type = &quot;application&quot;
  security_groups    = [aws_security_group.lb.id]
  subnets            = aws_subnet.public.*.id
  
  enable_deletion_protection = true
  enable_http2               = true
}

resource &quot;aws_autoscaling_group&quot; &quot;app&quot; {
  name                 = &quot;app-asg&quot;
  vpc_zone_identifier  = aws_subnet.private.*.id
  target_group_arns    = [aws_lb_target_group.app.arn]
  health_check_type    = &quot;ELB&quot;
  health_check_grace_period = 300
  
  min_size         = 2
  max_size         = 10
  desired_capacity = 2
  
  # Scale based on CPU
  metric {
    name = &quot;CPUUtilization&quot;
    target_value = 70.0
  }
  
  # Scale based on request count
  metric {
    name = &quot;RequestCountPerTarget&quot;
    target_value = 1000.0
  }
}

# ============================================
# LAYER 5: Aggressive Caching
# ============================================

# Cache everything possible to reduce backend load

# Controller-level caching
class PostsController &lt; ApplicationController
  # Cache entire action
  caches_action :index, expires_in: 5.minutes
  caches_action :show, expires_in: 15.minutes
  
  def index
    @posts = Post.published.limit(20)
  end
  
  def show
    @post = Post.find(params[:id])
  end
end

# Fragment caching in views
&lt;% cache [&#39;posts&#39;, Post.maximum(:updated_at)] do %&gt;
  &lt;% @posts.each do |post| %&gt;
    &lt;% cache post do %&gt;
      &lt;%= render post %&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;

# HTTP caching headers
class ApplicationController &lt; ActionController::Base
  def set_cache_headers(duration = 5.minutes)
    expires_in duration, public: true
    fresh_when(etag: @resource, last_modified: @resource.updated_at)
  end
end

class PostsController &lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    set_cache_headers(15.minutes)
  end
end

# CDN configuration
# config/environments/production.rb
config.action_controller.asset_host = &#39;https://cdn.example.com&#39;
config.public_file_server.headers = {
  &#39;Cache-Control&#39; =&gt; &#39;public, max-age=31536000&#39;
}

# ============================================
# LAYER 6: Connection Pooling &amp; Queuing
# ============================================

# Limit concurrent connections to database

# config/database.yml
production:
  adapter: postgresql
  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 } %&gt;
  timeout: 5000
  
# Puma configuration
# config/puma.rb
workers ENV.fetch(&quot;WEB_CONCURRENCY&quot;) { 4 }
threads_count = ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 5 }
threads threads_count, threads_count

preload_app!

# Queue long-running tasks
class ExpensiveOperation
  def perform
    # Instead of processing synchronously
    ExpensiveJob.perform_later(params)
    
    render json: {status: &#39;queued&#39;}
  end
end

# ============================================
# LAYER 7: Monitoring &amp; Detection
# ============================================

# Detect attacks early and respond

class DdosDetector
  THRESHOLD = 1000  # requests per minute
  
  def self.check
    current_rate = request_rate_per_minute
    
    if current_rate &gt; THRESHOLD
      alert_team
      enable_defense_mode
    end
  end
  
  private
  
  def self.request_rate_per_minute
    # Get from Redis/metrics
    Redis.current.get(&#39;requests_last_minute&#39;).to_i
  end
  
  def self.alert_team
    SlackNotifier.notify(
      &quot;🚨 Possible DDoS attack detected! #{request_rate_per_minute} req/min&quot;
    )
  end
  
  def self.enable_defense_mode
    # Tighten rate limits
    Redis.current.set(&#39;defense_mode&#39;, &#39;enabled&#39;, ex: 1.hour)
    
    # Require CAPTCHA for all requests
    Redis.current.set(&#39;require_captcha&#39;, &#39;true&#39;, ex: 1.hour)
  end
end

# Schedule check every minute
class DdosCheckJob &lt; ApplicationJob
  def perform
    DdosDetector.check
  end
end

# ============================================
# LAYER 8: Database Protection
# ============================================

# Protect database from overload

# Read replicas for read-heavy operations
class ApplicationRecord &lt; ActiveRecord::Base
  connects_to database: {
    writing: :primary,
    reading: :replica
  }
end

# Use database connection pools wisely
class SlowQuery &lt; ApplicationRecord
  # Timeout long queries
  def self.search_with_timeout(query)
    ActiveRecord::Base.connection.execute(
      &quot;SET statement_timeout = &#39;5s&#39;&quot;
    )
    
    where(&quot;title ILIKE ?&quot;, &quot;%#{query}%&quot;)
  ensure
    ActiveRecord::Base.connection.execute(
      &quot;RESET statement_timeout&quot;
    )
  end
end

# Query result limits
class PostsController &lt; ApplicationController
  def index
    @posts = Post.limit(100)  # Never return unlimited results
  end
end

# ============================================
# LAYER 9: Circuit Breaker Pattern
# ============================================

# Protect external services

class ExternalApiCircuitBreaker
  FAILURE_THRESHOLD = 5
  TIMEOUT_DURATION = 60  # seconds
  
  def initialize
    @failures = 0
    @last_failure_time = nil
    @state = :closed  # :closed, :open, :half_open
  end
  
  def call(&amp;block)
    case @state
    when :open
      if Time.current - @last_failure_time &gt; TIMEOUT_DURATION
        @state = :half_open
        try_request(&amp;block)
      else
        raise CircuitOpenError, &quot;Circuit breaker is open&quot;
      end
    when :half_open
      try_request(&amp;block)
    else  # :closed
      try_request(&amp;block)
    end
  end
  
  private
  
  def try_request(&amp;block)
    result = block.call
    on_success
    result
  rescue =&gt; e
    on_failure
    raise e
  end
  
  def on_success
    @failures = 0
    @state = :closed
  end
  
  def on_failure
    @failures += 1
    @last_failure_time = Time.current
    
    if @failures &gt;= FAILURE_THRESHOLD
      @state = :open
    end
  end
end

# Usage
breaker = ExternalApiCircuitBreaker.new

begin
  breaker.call do
    ExternalApi.fetch_data
  end
rescue CircuitOpenError
  # Return cached data or error
  Rails.cache.fetch(&#39;external_api_data&#39;)
end

# ============================================
# EMERGENCY RESPONSE PLAN
# ============================================

# Document and automate response

class EmergencyResponse
  def self.under_attack!
    Rails.logger.error(&quot;EMERGENCY: Under DDoS attack!&quot;)
    
    # 1. Enable Cloudflare &quot;Under Attack Mode&quot;
    CloudflareApi.enable_under_attack_mode
    
    # 2. Tighten rate limits
    Redis.current.set(&#39;rate_limit_multiplier&#39;, 0.1, ex: 1.hour)
    
    # 3. Enable aggressive caching
    Redis.current.set(&#39;aggressive_cache&#39;, &#39;true&#39;, ex: 1.hour)
    
    # 4. Disable expensive features
    Redis.current.set(&#39;disable_search&#39;, &#39;true&#39;, ex: 1.hour)
    Redis.current.set(&#39;disable_api&#39;, &#39;true&#39;, ex: 1.hour)
    
    # 5. Scale up infrastructure
    AwsApi.scale_to_max
    
    # 6. Alert team
    PagerDuty.trigger_incident(
      title: &quot;DDoS Attack Detected&quot;,
      severity: &quot;critical&quot;
    )
    
    # 7. Log for analysis
    SecurityLog.create!(
      event: &#39;ddos_response_activated&#39;,
      timestamp: Time.current
    )
  end
  
  def self.all_clear!
    # Restore normal operations
    CloudflareApi.disable_under_attack_mode
    Redis.current.del(&#39;rate_limit_multiplier&#39;)
    Redis.current.del(&#39;aggressive_cache&#39;)
    Redis.current.del(&#39;disable_search&#39;)
    Redis.current.del(&#39;disable_api&#39;)
  end
end
</code></pre>
<hr>
<h3>DDoS Defense Layers</h3>
<pre><code class="language-ruby"># Layer 1: CDN/WAF (Cloudflare, AWS Shield)
# - Absorb attack at edge
# - Challenge suspicious traffic
# - Cache static content

# Layer 2: Rate Limiting (Rack::Attack)
# - Limit requests per IP
# - Limit expensive operations
# - Block suspicious patterns

# Layer 3: Load Balancing
# - Distribute traffic
# - Auto-scale servers
# - Health checks

# Layer 4: Caching
# - Cache everything possible
# - Reduce backend load
# - HTTP caching headers

# Layer 5: Database Protection
# - Connection pooling
# - Read replicas
# - Query timeouts

# Layer 6: Monitoring
# - Detect attacks early
# - Auto-response
# - Alert team

# Layer 7: Circuit Breakers
# - Protect external services
# - Fail gracefully
# - Return cached data
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>CDN/WAF</strong>: First line of defense (Cloudflare)</li>
<li><strong>Rate limiting</strong>: Multiple layers (CDN, app, Nginx)</li>
<li><strong>Load balancing</strong>: Distribute traffic, auto-scale</li>
<li><strong>Caching</strong>: Reduce backend load aggressively</li>
<li><strong>Monitoring</strong>: Detect attacks early</li>
<li><strong>Circuit breakers</strong>: Protect external services</li>
<li><strong>Emergency plan</strong>: Documented response procedures</li>
<li><strong>Multiple layers</strong>: Defense in depth</li>
<li><strong>Auto-scaling</strong>: Handle legitimate traffic spikes</li>
<li><strong>Database protection</strong>: Connection limits, timeouts</li>
</ol>
<hr>
<h2>Question 350: How do you implement multi-factor authentication (MFA) in Rails?</h2>
<h3>Answer</h3>
<p><strong>Multi-factor authentication (MFA)</strong> requires users to provide two or more verification factors. Implement with <strong>TOTP</strong> (Time-based One-Time Password), <strong>SMS codes</strong>, <strong>backup codes</strong>, or <strong>WebAuthn</strong> for additional security beyond passwords.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>TOTP</strong>: Google Authenticator, Authy apps</li>
<li><strong>SMS</strong>: Send codes via Twilio</li>
<li><strong>Backup codes</strong>: One-time use codes</li>
<li><strong>WebAuthn</strong>: Hardware keys (YubiKey)</li>
<li><strong>Devise</strong>: Use devise-two-factor gem</li>
<li><strong>Recovery</strong>: Backup codes for access</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# METHOD 1: TOTP with Devise (Most Common)
# ============================================

# Gemfile
gem &#39;devise&#39;
gem &#39;devise-two-factor&#39;
gem &#39;rqrcode&#39;  # For QR codes

# Install
rails generate devise:install
rails generate devise User
rails generate devise_two_factor User ENCRYPTION_KEY

# Migration
class AddTwoFactorToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :encrypted_otp_secret, :string
    add_column :users, :encrypted_otp_secret_iv, :string
    add_column :users, :encrypted_otp_secret_salt, :string
    add_column :users, :consumed_timestep, :integer
    add_column :users, :otp_required_for_login, :boolean
    add_column :users, :otp_backup_codes, :text, array: true
  end
end

# Model
class User &lt; ApplicationRecord
  devise :two_factor_authenticatable,
         :database_authenticatable, :registerable,
         :recoverable, :rememberable, :validatable
  
  # Encrypt OTP secret
  devise :two_factor_backupable, otp_backup_codes_count: 10
  
  # Generate OTP secret
  def enable_two_factor!
    self.otp_required_for_login = true
    self.otp_secret = User.generate_otp_secret
    generate_otp_backup_codes!
    save!
  end
  
  def disable_two_factor!
    self.otp_required_for_login = false
    self.otp_secret = nil
    self.otp_backup_codes = nil
    save!
  end
  
  # Generate QR code for authenticator app
  def provisioning_uri
    otp_uri = &quot;otpauth://totp/#{CGI.escape(&quot;MyApp:#{email}&quot;)}?secret=#{otp_secret}&amp;issuer=MyApp&quot;
  end
  
  def qr_code
    require &#39;rqrcode&#39;
    qrcode = RQRCode::QRCode.new(provisioning_uri)
    qrcode.as_svg(
      offset: 0,
      color: &#39;000&#39;,
      module_size: 4,
      shape_rendering: &#39;crispEdges&#39;
    )
  end
end

# Routes
Rails.application.routes.draw do
  devise_for :users
  
  namespace :two_factor do
    get &#39;/setup&#39;, to: &#39;setup#new&#39;
    post &#39;/setup&#39;, to: &#39;setup#create&#39;
    delete &#39;/disable&#39;, to: &#39;setup#destroy&#39;
    post &#39;/verify&#39;, to: &#39;verification#create&#39;
  end
end

# Setup Controller
class TwoFactor::SetupController &lt; ApplicationController
  before_action :authenticate_user!
  
  def new
    # Show QR code and secret
    @qr_code = current_user.qr_code
    @secret = current_user.otp_secret
  end
  
  def create
    if current_user.validate_and_consume_otp!(params[:otp_code])
      current_user.enable_two_factor!
      flash[:notice] = &quot;Two-factor authentication enabled&quot;
      redirect_to root_path
    else
      flash[:error] = &quot;Invalid code&quot;
      render :new
    end
  end
  
  def destroy
    current_user.disable_two_factor!
    flash[:notice] = &quot;Two-factor authentication disabled&quot;
    redirect_to root_path
  end
end

# Verification Controller
class TwoFactor::VerificationController &lt; ApplicationController
  def create
    user = find_user
    
    if user.validate_and_consume_otp!(params[:otp_code])
      sign_in(user)
      redirect_to root_path
    elsif user.invalidate_otp_backup_code!(params[:otp_code])
      sign_in(user)
      flash[:warning] = &quot;Logged in with backup code. #{user.otp_backup_codes.count} remaining&quot;
      redirect_to root_path
    else
      flash[:error] = &quot;Invalid code&quot;
      render :new
    end
  end
  
  private
  
  def find_user
    # Get user from session after password verification
    User.find(session[:otp_user_id])
  end
end

# View for QR code
# app/views/two_factor/setup/new.html.erb
&lt;h2&gt;Enable Two-Factor Authentication&lt;/h2&gt;

&lt;div&gt;
  &lt;h3&gt;Step 1: Scan QR Code&lt;/h3&gt;
  &lt;p&gt;Use Google Authenticator or Authy to scan:&lt;/p&gt;
  &lt;%= @qr_code.html_safe %&gt;
  
  &lt;h3&gt;Step 2: Enter Secret Manually (Alternative)&lt;/h3&gt;
  &lt;code&gt;&lt;%= @secret %&gt;&lt;/code&gt;
  
  &lt;h3&gt;Step 3: Verify Code&lt;/h3&gt;
  &lt;%= form_with url: two_factor_setup_path do |f| %&gt;
    &lt;%= f.text_field :otp_code, placeholder: &#39;6-digit code&#39; %&gt;
    &lt;%= f.submit &#39;Enable 2FA&#39; %&gt;
  &lt;% end %&gt;
&lt;/div&gt;

# ============================================
# METHOD 2: SMS-based MFA (Twilio)
# ============================================

# Gemfile
gem &#39;twilio-ruby&#39;

# config/initializers/twilio.rb
Twilio.configure do |config|
  config.account_sid = ENV[&#39;TWILIO_ACCOUNT_SID&#39;]
  config.auth_token = ENV[&#39;TWILIO_AUTH_TOKEN&#39;]
end

# Migration
class AddSmsToUsers &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :phone_number, :string
    add_column :users, :phone_verified, :boolean, default: false
    add_column :users, :sms_mfa_enabled, :boolean, default: false
  end
end

# Model
class User &lt; ApplicationRecord
  def send_sms_code
    code = generate_sms_code
    store_sms_code(code)
    
    client = Twilio::REST::Client.new
    client.messages.create(
      from: ENV[&#39;TWILIO_PHONE_NUMBER&#39;],
      to: phone_number,
      body: &quot;Your verification code is: #{code}&quot;
    )
  end
  
  def verify_sms_code(code)
    stored_code = Rails.cache.read(&quot;sms_code:#{id}&quot;)
    return false unless stored_code
    
    if stored_code == code
      Rails.cache.delete(&quot;sms_code:#{id}&quot;)
      true
    else
      false
    end
  end
  
  private
  
  def generate_sms_code
    SecureRandom.random_number(999999).to_s.rjust(6, &#39;0&#39;)
  end
  
  def store_sms_code(code)
    Rails.cache.write(&quot;sms_code:#{id}&quot;, code, expires_in: 5.minutes)
  end
end

# Controller
class SmsVerificationController &lt; ApplicationController
  def create
    current_user.send_sms_code
    render json: {message: &#39;Code sent&#39;}
  end
  
  def verify
    if current_user.verify_sms_code(params[:code])
      session[:sms_verified] = true
      render json: {success: true}
    else
      render json: {error: &#39;Invalid code&#39;}, status: :unprocessable_entity
    end
  end
end

# ============================================
# METHOD 3: WebAuthn (Hardware Keys)
# ============================================

# Gemfile
gem &#39;webauthn&#39;

# config/initializers/webauthn.rb
WebAuthn.configure do |config|
  config.origin = ENV[&#39;WEBAUTHN_ORIGIN&#39;] || &#39;http://localhost:3000&#39;
  config.rp_name = &quot;MyApp&quot;
end

# Migration
class CreateWebauthnCredentials &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :webauthn_credentials do |t|
      t.references :user, null: false, foreign_key: true
      t.string :external_id, null: false
      t.string :public_key, null: false
      t.string :nickname
      t.bigint :sign_count, default: 0
      t.timestamps
      
      t.index :external_id, unique: true
    end
  end
end

# Model
class WebauthnCredential &lt; ApplicationRecord
  belongs_to :user
end

class User &lt; ApplicationRecord
  has_many :webauthn_credentials
end

# Controller
class WebauthnController &lt; ApplicationController
  def register_challenge
    options = WebAuthn::Credential.options_for_create(
      user: {
        id: WebAuthn.generate_user_id,
        name: current_user.email
      },
      exclude: current_user.webauthn_credentials.pluck(:external_id)
    )
    
    session[:creation_challenge] = options.challenge
    
    render json: options
  end
  
  def register_credential
    webauthn_credential = WebAuthn::Credential.from_create(params)
    
    begin
      webauthn_credential.verify(session[:creation_challenge])
      
      current_user.webauthn_credentials.create!(
        external_id: webauthn_credential.id,
        public_key: webauthn_credential.public_key,
        sign_count: webauthn_credential.sign_count,
        nickname: params[:nickname]
      )
      
      render json: {success: true}
    rescue WebAuthn::Error =&gt; e
      render json: {error: e.message}, status: :unprocessable_entity
    end
  end
  
  def authentication_challenge
    options = WebAuthn::Credential.options_for_get(
      allow: current_user.webauthn_credentials.pluck(:external_id)
    )
    
    session[:authentication_challenge] = options.challenge
    
    render json: options
  end
  
  def authenticate
    webauthn_credential = WebAuthn::Credential.from_get(params)
    
    stored_credential = current_user.webauthn_credentials
      .find_by(external_id: webauthn_credential.id)
    
    begin
      webauthn_credential.verify(
        session[:authentication_challenge],
        public_key: stored_credential.public_key,
        sign_count: stored_credential.sign_count
      )
      
      stored_credential.update!(sign_count: webauthn_credential.sign_count)
      session[:webauthn_verified] = true
      
      render json: {success: true}
    rescue WebAuthn::Error =&gt; e
      render json: {error: e.message}, status: :unprocessable_entity
    end
  end
end

# ============================================
# BACKUP CODES
# ============================================

class User &lt; ApplicationRecord
  def generate_backup_codes(count = 10)
    self.backup_codes = Array.new(count) do
      SecureRandom.hex(4).upcase  # 8 character codes
    end
    save!
  end
  
  def use_backup_code(code)
    return false unless backup_codes.include?(code.upcase)
    
    self.backup_codes.delete(code.upcase)
    save!
  end
  
  def backup_codes_remaining
    backup_codes&amp;.count || 0
  end
end

# View
&lt;h3&gt;Backup Codes&lt;/h3&gt;
&lt;p&gt;Save these codes in a safe place. Each can only be used once.&lt;/p&gt;
&lt;ul&gt;
  &lt;% current_user.backup_codes.each do |code| %&gt;
    &lt;li&gt;&lt;code&gt;&lt;%= code %&gt;&lt;/code&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;

# ============================================
# COMPLETE LOGIN FLOW WITH MFA
# ============================================

class SessionsController &lt; ApplicationController
  def create
    user = User.find_by(email: params[:email])
    
    if user&amp;.authenticate(params[:password])
      if user.otp_required_for_login?
        # Require 2FA
        session[:pending_user_id] = user.id
        redirect_to two_factor_verification_path
      else
        # Login without 2FA
        sign_in(user)
        redirect_to root_path
      end
    else
      flash[:error] = &quot;Invalid credentials&quot;
      render :new
    end
  end
end

class TwoFactorVerificationsController &lt; ApplicationController
  def new
    @user = User.find(session[:pending_user_id])
  end
  
  def create
    user = User.find(session[:pending_user_id])
    
    if user.validate_and_consume_otp!(params[:otp_code])
      session.delete(:pending_user_id)
      sign_in(user)
      redirect_to root_path
    elsif params[:backup_code] &amp;&amp; user.use_backup_code(params[:backup_code])
      session.delete(:pending_user_id)
      sign_in(user)
      flash[:warning] = &quot;#{user.backup_codes_remaining} backup codes remaining&quot;
      redirect_to root_path
    else
      flash[:error] = &quot;Invalid code&quot;
      render :new
    end
  end
end
</code></pre>
<hr>
<h3>MFA Methods Comparison</h3>
<pre><code class="language-ruby"># ============================================
# TOTP (Time-based One-Time Password)
# ============================================
# Pros:
# - No SMS costs
# - Works offline
# - Industry standard
# - Google Authenticator, Authy support

# Cons:
# - Requires smartphone
# - Setup can be confusing for users
# - Lost device = account recovery needed

# ============================================
# SMS Codes
# ============================================
# Pros:
# - Easy for users
# - No app required
# - Familiar

# Cons:
# - SMS costs
# - SIM swapping attacks
# - Delivery delays
# - Less secure than TOTP

# ============================================
# WebAuthn (Hardware Keys)
# ============================================
# Pros:
# - Most secure
# - Phishing resistant
# - No SMS/app needed

# Cons:
# - Requires hardware key purchase
# - Browser support varies
# - Lost key = account recovery needed

# ============================================
# Backup Codes
# ============================================
# Essential for all methods
# - Account recovery
# - Lost device access
# - One-time use
# - Store securely
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>TOTP</strong>: Most common (Google Authenticator)</li>
<li><strong>Devise-two-factor</strong>: Easy Rails integration</li>
<li><strong>QR codes</strong>: For easy setup</li>
<li><strong>Backup codes</strong>: Always provide recovery</li>
<li><strong>SMS</strong>: Alternative but less secure</li>
<li><strong>WebAuthn</strong>: Most secure (hardware keys)</li>
<li><strong>Enforce for admins</strong>: Require MFA for privileged accounts</li>
<li><strong>User experience</strong>: Make setup easy</li>
<li><strong>Recovery</strong>: Multiple backup methods</li>
<li><strong>Education</strong>: Teach users why MFA matters</li>
</ol>
<hr>
<h2>Question 351: What is HSTS (HTTP Strict Transport Security)?</h2>
<h3>Answer</h3>
<p><strong>HSTS</strong> forces browsers to use HTTPS connections only, preventing protocol downgrade attacks and cookie hijacking. Implemented via <code>Strict-Transport-Security</code> header, it ensures all communication happens over encrypted connections.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>HSTS</strong>: Force HTTPS only connections</li>
<li><strong>Header</strong>: <code>Strict-Transport-Security: max-age=31536000</code></li>
<li><strong>Prevents</strong>: Protocol downgrade, MITM attacks</li>
<li><strong>Preload</strong>: Submit to browser preload lists</li>
<li><strong>Rails</strong>: Configure in production.rb</li>
<li><strong>Security</strong>: Essential for production apps</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# BASIC HSTS CONFIGURATION
# ============================================

# config/environments/production.rb
Rails.application.configure do
  # Force all access to the app over SSL
  config.force_ssl = true
  
  # HSTS settings
  config.ssl_options = {
    hsts: {
      expires: 31536000,  # 1 year in seconds
      subdomains: true,
      preload: true
    }
  }
end

# This sets the header:
# Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

# ============================================
# WHAT HSTS DOES
# ============================================

# WITHOUT HSTS:
# 1. User types &quot;example.com&quot; (no https://)
# 2. Browser makes HTTP request
# 3. Server redirects to HTTPS
# 4. MITM attacker can intercept HTTP request!

# WITH HSTS:
# 1. User types &quot;example.com&quot;
# 2. Browser remembers HSTS policy
# 3. Browser automatically uses HTTPS
# 4. No HTTP request made = No MITM opportunity

# ============================================
# HSTS HEADER BREAKDOWN
# ============================================

# Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

# max-age=31536000
# - Browser remembers for 1 year (31536000 seconds)
# - After visiting once, browser will use HTTPS for 1 year
# - Common values: 31536000 (1 year), 63072000 (2 years)

# includeSubDomains
# - Apply HSTS to all subdomains
# - example.com, api.example.com, www.example.com all use HTTPS
# - Be careful: All subdomains must support HTTPS

# preload
# - Indicates you want to be included in browser preload list
# - Browsers ship with list of HSTS sites
# - HTTPS enforced even on first visit
# - Must submit to hstspreload.org

# ============================================
# CUSTOM MIDDLEWARE (Advanced Control)
# ============================================

class HstsMiddleware
  def initialize(app, options = {})
    @app = app
    @max_age = options[:max_age] || 31536000
    @include_subdomains = options[:include_subdomains] != false
    @preload = options[:preload] == true
    @exclude_paths = options[:exclude_paths] || []
  end
  
  def call(env)
    request = Rack::Request.new(env)
    status, headers, body = @app.call(env)
    
    # Only add HSTS to HTTPS requests
    if request.ssl? &amp;&amp; !excluded_path?(request.path)
      headers[&#39;Strict-Transport-Security&#39;] = hsts_header
    end
    
    [status, headers, body]
  end
  
  private
  
  def hsts_header
    parts = [&quot;max-age=#{@max_age}&quot;]
    parts &lt;&lt; &#39;includeSubDomains&#39; if @include_subdomains
    parts &lt;&lt; &#39;preload&#39; if @preload
    parts.join(&#39;; &#39;)
  end
  
  def excluded_path?(path)
    @exclude_paths.any? { |pattern| path.match?(pattern) }
  end
end

# config/application.rb
config.middleware.use HstsMiddleware,
  max_age: 63072000,  # 2 years
  include_subdomains: true,
  preload: true,
  exclude_paths: [/^\/health/, /^\/status/]

# ============================================
# NGINX CONFIGURATION
# ============================================

# /etc/nginx/sites-available/myapp
server {
  listen 443 ssl http2;
  server_name example.com www.example.com;
  
  # SSL certificates
  ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;
  
  # HSTS header
  add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains; preload&quot; always;
  
  # Other security headers
  add_header X-Frame-Options &quot;SAMEORIGIN&quot; always;
  add_header X-Content-Type-Options &quot;nosniff&quot; always;
  add_header X-XSS-Protection &quot;1; mode=block&quot; always;
  
  location / {
    proxy_pass http://localhost:3000;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}

# Redirect HTTP to HTTPS
server {
  listen 80;
  server_name example.com www.example.com;
  
  # 301 permanent redirect to HTTPS
  return 301 https://$host$request_uri;
}

# ============================================
# HSTS PRELOAD SUBMISSION
# ============================================

# Requirements for preload list:
# 1. Valid SSL certificate
# 2. Redirect all HTTP to HTTPS (same host)
# 3. Serve HSTS header on all subdomains
# 4. HSTS header must have:
#    - max-age &gt;= 31536000 (1 year)
#    - includeSubDomains directive
#    - preload directive

# Check readiness
def check_hsts_preload_ready
  response = HTTParty.get(&#39;https://example.com&#39;)
  hsts = response.headers[&#39;strict-transport-security&#39;]
  
  checks = {
    has_hsts: hsts.present?,
    max_age_ok: hsts&amp;.match(/max-age=(\d+)/)&amp;.[](1).to_i &gt;= 31536000,
    has_subdomains: hsts&amp;.include?(&#39;includeSubDomains&#39;),
    has_preload: hsts&amp;.include?(&#39;preload&#39;)
  }
  
  checks.all? { |_, v| v }
end

# Submit to preload list
# Visit: https://hstspreload.org
# Enter domain and submit

# WARNING: Difficult to remove from preload list
# - Takes months
# - Affects all subdomains forever
# - Only submit when absolutely ready

# ============================================
# TESTING HSTS
# ============================================

# Test HSTS header
def test_hsts_header
  uri = URI(&#39;https://example.com&#39;)
  response = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|
    http.get(&#39;/&#39;)
  end
  
  hsts = response[&#39;strict-transport-security&#39;]
  
  puts &quot;HSTS Header: #{hsts}&quot;
  puts &quot;✓ max-age present&quot; if hsts&amp;.match?(/max-age=\d+/)
  puts &quot;✓ includeSubDomains&quot; if hsts&amp;.include?(&#39;includeSubDomains&#39;)
  puts &quot;✓ preload&quot; if hsts&amp;.include?(&#39;preload&#39;)
end

# Test with curl
# curl -I https://example.com
# Look for: Strict-Transport-Security header

# Test redirect
# curl -I http://example.com
# Should see: 301 redirect to https://

# ============================================
# MONITORING &amp; COMPLIANCE
# ============================================

class HstsMonitor
  def self.check
    response = HTTParty.get(Rails.application.config.host)
    hsts = response.headers[&#39;strict-transport-security&#39;]
    
    if hsts.blank?
      alert(&#39;HSTS header missing!&#39;)
      return false
    end
    
    max_age = hsts.match(/max-age=(\d+)/)&amp;.[](1).to_i
    
    if max_age &lt; 31536000
      alert(&quot;HSTS max-age too low: #{max_age}&quot;)
      return false
    end
    
    unless hsts.include?(&#39;includeSubDomains&#39;)
      alert(&#39;HSTS missing includeSubDomains&#39;)
      return false
    end
    
    true
  end
  
  def self.alert(message)
    Rails.logger.error(&quot;HSTS Check Failed: #{message}&quot;)
    # Send to monitoring service
  end
end

# Schedule daily check
class HstsCheckJob &lt; ApplicationJob
  def perform
    HstsMonitor.check
  end
end

# ============================================
# CLEARING HSTS (Development)
# ============================================

# If you need to clear HSTS for localhost (development):

# Chrome:
# 1. Visit chrome://net-internals/#hsts
# 2. Enter domain in &quot;Delete domain security policies&quot;
# 3. Click &quot;Delete&quot;

# Firefox:
# 1. Visit about:preferences#privacy
# 2. Click &quot;Clear Data&quot; under Cookies and Site Data
# 3. Check &quot;Cached Web Content&quot;
# 4. Click &quot;Clear&quot;

# Safari:
# 1. Develop → Empty Caches
# 2. Safari → Clear History

# ============================================
# GRADUAL HSTS ROLLOUT
# ============================================

# Start with short max-age, gradually increase

class GradualHstsRollout
  STAGES = [
    {max_age: 300, duration: 1.week},      # 5 minutes
    {max_age: 3600, duration: 1.week},     # 1 hour
    {max_age: 86400, duration: 1.week},    # 1 day
    {max_age: 604800, duration: 2.weeks},  # 1 week
    {max_age: 2592000, duration: 1.month}, # 30 days
    {max_age: 31536000, duration: nil}     # 1 year (final)
  ]
  
  def self.current_stage
    deployment_date = Date.parse(ENV[&#39;HSTS_DEPLOYMENT_DATE&#39;])
    days_since = (Date.current - deployment_date).to_i
    
    elapsed = 0
    STAGES.each do |stage|
      return stage if stage[:duration].nil?
      elapsed += stage[:duration].in_days
      return stage if days_since &lt; elapsed
    end
    
    STAGES.last
  end
  
  def self.current_max_age
    current_stage[:max_age]
  end
end

# Use in config
config.ssl_options = {
  hsts: {
    expires: GradualHstsRollout.current_max_age,
    subdomains: true,
    preload: false  # Don&#39;t enable until final stage
  }
}

# ============================================
# HSTS WITH SUBDOMAINS
# ============================================

# Ensure ALL subdomains support HTTPS
# api.example.com
# www.example.com
# blog.example.com
# admin.example.com

# Check all subdomains
class SubdomainSslChecker
  SUBDOMAINS = %w[www api blog admin]
  
  def self.check_all
    results = {}
    
    SUBDOMAINS.each do |subdomain|
      url = &quot;https://#{subdomain}.example.com&quot;
      results[subdomain] = check_ssl(url)
    end
    
    results
  end
  
  def self.check_ssl(url)
    uri = URI(url)
    Net::HTTP.start(uri.host, uri.port, use_ssl: true, verify_mode: OpenSSL::SSL::VERIFY_PEER) do |http|
      response = http.get(&#39;/&#39;)
      {
        ssl_valid: true,
        status: response.code,
        hsts: response[&#39;strict-transport-security&#39;]
      }
    end
  rescue OpenSSL::SSL::SSLError =&gt; e
    {ssl_valid: false, error: e.message}
  end
end

# ============================================
# SECURITY HEADERS HELPER
# ============================================

# Add to ApplicationController
class ApplicationController &lt; ActionController::Base
  before_action :set_security_headers
  
  private
  
  def set_security_headers
    # HSTS (handled by Rails config.force_ssl)
    # response.headers[&#39;Strict-Transport-Security&#39;] = &#39;max-age=31536000; includeSubDomains; preload&#39;
    
    # Prevent clickjacking
    response.headers[&#39;X-Frame-Options&#39;] = &#39;SAMEORIGIN&#39;
    
    # Prevent MIME sniffing
    response.headers[&#39;X-Content-Type-Options&#39;] = &#39;nosniff&#39;
    
    # XSS Protection
    response.headers[&#39;X-XSS-Protection&#39;] = &#39;1; mode=block&#39;
    
    # Referrer Policy
    response.headers[&#39;Referrer-Policy&#39;] = &#39;strict-origin-when-cross-origin&#39;
    
    # Permissions Policy
    response.headers[&#39;Permissions-Policy&#39;] = &#39;geolocation=(), microphone=(), camera=()&#39;
    
    # Content Security Policy
    response.headers[&#39;Content-Security-Policy&#39;] = &quot;default-src &#39;self&#39;; script-src &#39;self&#39; &#39;unsafe-inline&#39;&quot;
  end
end

# Or use secure_headers gem
# Gemfile
gem &#39;secure_headers&#39;

# config/initializers/secure_headers.rb
SecureHeaders::Configuration.default do |config|
  config.hsts = &quot;max-age=#{1.year.to_i}; includeSubDomains; preload&quot;
  config.x_frame_options = &quot;SAMEORIGIN&quot;
  config.x_content_type_options = &quot;nosniff&quot;
  config.x_xss_protection = &quot;1; mode=block&quot;
  config.referrer_policy = &quot;strict-origin-when-cross-origin&quot;
end
</code></pre>
<hr>
<h3>HSTS Best Practices</h3>
<pre><code class="language-ruby"># 1. Start with short max-age
# Test with 5 minutes, then increase
config.ssl_options = {hsts: {expires: 300}}  # 5 minutes

# 2. Enable includeSubDomains carefully
# Ensure ALL subdomains have valid SSL
config.ssl_options = {hsts: {subdomains: true}}

# 3. Wait before preload
# Only enable after months of successful HSTS
config.ssl_options = {hsts: {preload: true}}

# 4. Monitor SSL expiration
# Expired SSL + HSTS = total site outage

# 5. Test thoroughly
# - Check all subdomains
# - Test redirects
# - Verify headers

# 6. Document rollback procedure
# HSTS can&#39;t be easily disabled once set
</code></pre>
<hr>
<h3>Common Issues</h3>
<pre><code class="language-ruby"># ============================================
# ISSUE 1: Expired SSL Certificate
# ============================================

# Problem: SSL expires + HSTS = site inaccessible
# Solution: Monitor SSL expiration

class SslExpirationChecker
  def self.check
    uri = URI(&#39;https://example.com&#39;)
    cert = get_certificate(uri)
    
    days_until_expiry = (cert.not_after - Time.now) / 1.day
    
    if days_until_expiry &lt; 30
      alert(&quot;SSL expires in #{days_until_expiry} days!&quot;)
    end
  end
  
  def self.get_certificate(uri)
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    http.start
    http.peer_cert
  ensure
    http.finish if http.started?
  end
end

# ============================================
# ISSUE 2: Mixed Content
# ============================================

# Problem: HTTPS page loads HTTP resources = blocked
# Solution: Use protocol-relative or HTTPS URLs

# ❌ BAD
&lt;img src=&quot;http://example.com/image.jpg&quot;&gt;

# ✅ GOOD
&lt;img src=&quot;https://example.com/image.jpg&quot;&gt;
&lt;img src=&quot;//example.com/image.jpg&quot;&gt;

# Check for mixed content
def check_mixed_content
  response = HTTParty.get(&#39;https://example.com&#39;)
  body = response.body
  
  if body.match?(/src=[&quot;&#39;]http:\/\//)
    puts &quot;⚠️  Found HTTP resources in HTTPS page!&quot;
  end
end

# ============================================
# ISSUE 3: Subdomain Without SSL
# ============================================

# Problem: HSTS with includeSubDomains but subdomain has no SSL
# Solution: Get SSL for all subdomains or don&#39;t use includeSubDomains

# Use wildcard certificate
# *.example.com covers all subdomains
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>HSTS</strong>: Force HTTPS only, prevent downgrade</li>
<li><strong>Header</strong>: <code>Strict-Transport-Security: max-age=31536000</code></li>
<li><strong>max-age</strong>: How long browser remembers (1 year recommended)</li>
<li><strong>includeSubDomains</strong>: Apply to all subdomains (careful!)</li>
<li><strong>preload</strong>: Submit to browser preload list (permanent!)</li>
<li><strong>Rails</strong>: Use <code>config.force_ssl = true</code></li>
<li><strong>Gradual rollout</strong>: Start with short max-age</li>
<li><strong>Monitor</strong>: SSL expiration, header presence</li>
<li><strong>Mixed content</strong>: Ensure all resources use HTTPS</li>
<li><strong>Essential</strong>: Critical security for production apps</li>
</ol>
<h1>Final Topics: Integrations, Versions, Git &amp; More (352-362)</h1>
<h2>Integrations</h2>
<h2>Question 352: What is Apache Kafka, and how can it be integrated with Rails?</h2>
<h3>Answer</h3>
<p><strong>Apache Kafka</strong> is a distributed event streaming platform for high-throughput, fault-tolerant message processing. Integrate with Rails using <strong>ruby-kafka</strong> gem or <strong>Karafka</strong> framework for building event-driven applications with publish-subscribe patterns.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Kafka</strong>: Distributed event streaming platform</li>
<li><strong>Topics</strong>: Categories for messages</li>
<li><strong>Producers</strong>: Send messages to topics</li>
<li><strong>Consumers</strong>: Read messages from topics</li>
<li><strong>ruby-kafka</strong>: Low-level Kafka client</li>
<li><strong>Karafka</strong>: Rails-friendly framework</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# WHAT IS KAFKA?
# ============================================

# Kafka = Distributed messaging system
# - High throughput (millions of messages/sec)
# - Fault tolerant (replication)
# - Persistent (messages stored on disk)
# - Scalable (add more brokers)

# Key Concepts:
# - Topic: Category/feed of messages
# - Producer: Publishes messages to topics
# - Consumer: Subscribes to topics, processes messages
# - Broker: Kafka server
# - Partition: Topic split for parallelism

# ============================================
# METHOD 1: ruby-kafka Gem (Low-level)
# ============================================

# Gemfile
gem &#39;ruby-kafka&#39;

# config/initializers/kafka.rb
KAFKA = Kafka.new(
  seed_brokers: ENV.fetch(&#39;KAFKA_BROKERS&#39;, &#39;localhost:9092&#39;).split(&#39;,&#39;),
  client_id: &#39;rails-app&#39;,
  logger: Rails.logger
)

# Producer - Send messages
class KafkaProducer
  def self.publish(topic, message, key: nil)
    producer = KAFKA.producer
    
    producer.produce(
      message.to_json,
      topic: topic,
      key: key,
      partition_key: key
    )
    
    producer.deliver_messages
  ensure
    producer.shutdown
  end
  
  def self.publish_async(topic, message, key: nil)
    producer = KAFKA.async_producer(
      delivery_interval: 10,
      delivery_threshold: 100,
      max_buffer_size: 1000
    )
    
    producer.produce(
      message.to_json,
      topic: topic,
      key: key
    )
  end
end

# Usage - Publish events
class Order &lt; ApplicationRecord
  after_create :publish_created_event
  after_update :publish_updated_event
  
  private
  
  def publish_created_event
    KafkaProducer.publish(&#39;orders&#39;, {
      event: &#39;order.created&#39;,
      order_id: id,
      user_id: user_id,
      total: total,
      timestamp: Time.current.iso8601
    }, key: id.to_s)
  end
  
  def publish_updated_event
    KafkaProducer.publish(&#39;orders&#39;, {
      event: &#39;order.updated&#39;,
      order_id: id,
      status: status,
      timestamp: Time.current.iso8601
    }, key: id.to_s)
  end
end

# Consumer - Read messages
class KafkaConsumer
  def self.consume(topic, group_id)
    consumer = KAFKA.consumer(group_id: group_id)
    consumer.subscribe(topic)
    
    # Trap interrupt signal
    trap(&#39;TERM&#39;) { consumer.stop }
    trap(&#39;INT&#39;) { consumer.stop }
    
    consumer.each_message do |message|
      process_message(message)
    end
  ensure
    consumer.stop
  end
  
  def self.process_message(message)
    data = JSON.parse(message.value)
    
    case data[&#39;event&#39;]
    when &#39;order.created&#39;
      handle_order_created(data)
    when &#39;order.updated&#39;
      handle_order_updated(data)
    else
      Rails.logger.warn(&quot;Unknown event: #{data[&#39;event&#39;]}&quot;)
    end
  rescue =&gt; e
    Rails.logger.error(&quot;Error processing message: #{e.message}&quot;)
    # Store in dead letter queue
    DeadLetterQueue.create!(
      topic: message.topic,
      partition: message.partition,
      offset: message.offset,
      value: message.value,
      error: e.message
    )
  end
  
  def self.handle_order_created(data)
    # Send confirmation email
    OrderMailer.confirmation(data[&#39;order_id&#39;]).deliver_later
    
    # Update inventory
    InventoryService.reserve(data[&#39;order_id&#39;])
    
    # Track analytics
    Analytics.track(&#39;order_created&#39;, data)
  end
  
  def self.handle_order_updated(data)
    # Handle status changes
    if data[&#39;status&#39;] == &#39;shipped&#39;
      ShippingNotificationService.notify(data[&#39;order_id&#39;])
    end
  end
end

# Run consumer (in separate process)
# rails runner &quot;KafkaConsumer.consume(&#39;orders&#39;, &#39;rails-consumer-group&#39;)&quot;

# Or with Rake task
# lib/tasks/kafka.rake
namespace :kafka do
  desc &quot;Start Kafka consumer&quot;
  task consume: :environment do
    KafkaConsumer.consume(&#39;orders&#39;, &#39;rails-consumer-group&#39;)
  end
end

# Run: rake kafka:consume

# ============================================
# METHOD 2: Karafka Framework (Recommended)
# ============================================

# Gemfile
gem &#39;karafka&#39;
gem &#39;waterdrop&#39;  # For producing

# Install
bundle exec karafka install

# config/karafka.rb
class KarafkaApp &lt; Karafka::App
  setup do |config|
    config.kafka = {
      &#39;bootstrap.servers&#39;: ENV.fetch(&#39;KAFKA_BROKERS&#39;, &#39;localhost:9092&#39;),
      &#39;client.id&#39;: &#39;rails-app&#39;
    }
    config.client_id = &#39;rails-app&#39;
    config.consumer_persistence = true
  end
  
  routes.draw do
    topic :orders do
      consumer OrdersConsumer
    end
    
    topic :users do
      consumer UsersConsumer
    end
    
    topic :notifications do
      consumer NotificationsConsumer
    end
  end
end

# Producer with WaterDrop
# config/initializers/waterdrop.rb
WaterDrop.setup do |config|
  config.deliver = true
  config.kafka = {
    &#39;bootstrap.servers&#39;: ENV.fetch(&#39;KAFKA_BROKERS&#39;, &#39;localhost:9092&#39;),
    &#39;client.id&#39;: &#39;rails-app-producer&#39;
  }
end

# Publish events
class EventPublisher
  def self.publish(topic, event_type, data)
    WaterDrop::Producer.call(
      {
        event_type: event_type,
        data: data,
        timestamp: Time.current.iso8601
      }.to_json,
      topic: topic
    )
  end
end

# Usage in models
class Order &lt; ApplicationRecord
  after_create_commit :publish_created
  after_update_commit :publish_updated
  
  private
  
  def publish_created
    EventPublisher.publish(&#39;orders&#39;, &#39;order.created&#39;, {
      order_id: id,
      user_id: user_id,
      total: total
    })
  end
  
  def publish_updated
    EventPublisher.publish(&#39;orders&#39;, &#39;order.updated&#39;, {
      order_id: id,
      status: status
    })
  end
end

# Consumer
# app/consumers/orders_consumer.rb
class OrdersConsumer &lt; ApplicationConsumer
  def consume
    messages.each do |message|
      data = JSON.parse(message.payload)
      
      case data[&#39;event_type&#39;]
      when &#39;order.created&#39;
        handle_order_created(data[&#39;data&#39;])
      when &#39;order.updated&#39;
        handle_order_updated(data[&#39;data&#39;])
      end
    end
  end
  
  private
  
  def handle_order_created(data)
    OrderMailer.confirmation(data[&#39;order_id&#39;]).deliver_later
    InventoryService.reserve(data[&#39;order_id&#39;])
  end
  
  def handle_order_updated(data)
    if data[&#39;status&#39;] == &#39;shipped&#39;
      ShippingNotificationJob.perform_later(data[&#39;order_id&#39;])
    end
  end
end

# Start Karafka server
# bundle exec karafka server

# ============================================
# REAL-WORLD USE CASE: Event-Driven Microservices
# ============================================

# Service 1: Orders Service (Rails)
class OrdersService
  def create_order(params)
    order = Order.create!(params)
    
    # Publish event
    EventPublisher.publish(&#39;orders&#39;, &#39;order.created&#39;, {
      order_id: order.id,
      user_id: order.user_id,
      items: order.line_items.map { |item|
        {product_id: item.product_id, quantity: item.quantity}
      },
      total: order.total
    })
    
    order
  end
end

# Service 2: Inventory Service (listens to Kafka)
class InventoryConsumer &lt; ApplicationConsumer
  def consume
    messages.each do |message|
      data = JSON.parse(message.payload)
      
      case data[&#39;event_type&#39;]
      when &#39;order.created&#39;
        reserve_inventory(data[&#39;data&#39;])
      when &#39;order.cancelled&#39;
        release_inventory(data[&#39;data&#39;])
      end
    end
  end
  
  private
  
  def reserve_inventory(data)
    data[&#39;items&#39;].each do |item|
      InventoryItem.find_by(product_id: item[&#39;product_id&#39;])
        .decrement!(:quantity, item[&#39;quantity&#39;])
    end
    
    # Publish confirmation
    EventPublisher.publish(&#39;inventory&#39;, &#39;inventory.reserved&#39;, {
      order_id: data[&#39;order_id&#39;]
    })
  end
end

# Service 3: Notification Service
class NotificationConsumer &lt; ApplicationConsumer
  def consume
    messages.each do |message|
      data = JSON.parse(message.payload)
      
      case data[&#39;event_type&#39;]
      when &#39;order.created&#39;
        send_order_confirmation(data[&#39;data&#39;])
      when &#39;order.shipped&#39;
        send_shipping_notification(data[&#39;data&#39;])
      end
    end
  end
end

# ============================================
# PATTERNS: Event Sourcing with Kafka
# ============================================

# Store all events in Kafka
class EventStore
  def self.append(aggregate_type, aggregate_id, event_type, data)
    event = {
      event_id: SecureRandom.uuid,
      aggregate_type: aggregate_type,
      aggregate_id: aggregate_id,
      event_type: event_type,
      data: data,
      timestamp: Time.current.iso8601
    }
    
    WaterDrop::Producer.call(
      event.to_json,
      topic: &quot;events.#{aggregate_type.downcase}&quot;,
      key: aggregate_id.to_s
    )
  end
end

# Rebuild state from events
class OrderAggregate
  attr_reader :id, :status, :items, :total
  
  def initialize(order_id)
    @id = order_id
    @status = nil
    @items = []
    @total = 0
    
    load_from_events
  end
  
  private
  
  def load_from_events
    # Read all events for this order from Kafka
    consumer = KAFKA.consumer(group_id: &quot;order-#{@id}-reader&quot;)
    consumer.subscribe(&quot;events.order&quot;)
    
    consumer.each_message do |message|
      event = JSON.parse(message.value)
      next unless event[&#39;aggregate_id&#39;] == @id
      
      apply_event(event)
    end
  end
  
  def apply_event(event)
    case event[&#39;event_type&#39;]
    when &#39;OrderCreated&#39;
      @status = &#39;pending&#39;
      @items = event[&#39;data&#39;][&#39;items&#39;]
      @total = event[&#39;data&#39;][&#39;total&#39;]
    when &#39;OrderPaid&#39;
      @status = &#39;paid&#39;
    when &#39;OrderShipped&#39;
      @status = &#39;shipped&#39;
    end
  end
end

# ============================================
# MONITORING &amp; ERROR HANDLING
# ============================================

# Monitor consumer lag
class KafkaMonitor
  def self.check_lag(group_id)
    admin = Kafka::Admin.new(
      seed_brokers: ENV[&#39;KAFKA_BROKERS&#39;].split(&#39;,&#39;)
    )
    
    consumer_groups = admin.describe_consumer_group(group_id)
    
    consumer_groups.each do |group|
      group.members.each do |member|
        member.assignments.each do |assignment|
          lag = assignment.lag
          
          if lag &gt; 10000
            alert(&quot;High lag on #{assignment.topic}: #{lag}&quot;)
          end
        end
      end
    end
  end
  
  def self.alert(message)
    Rails.logger.error(&quot;Kafka Monitor: #{message}&quot;)
    SlackNotifier.notify(message)
  end
end

# Dead letter queue for failed messages
class DeadLetterQueueConsumer &lt; ApplicationConsumer
  def consume
    messages.each do |message|
      # Process failed message
      retry_message(message)
    end
  end
  
  private
  
  def retry_message(message)
    # Attempt to reprocess
    original_data = JSON.parse(message.payload)
    
    case original_data[&#39;original_topic&#39;]
    when &#39;orders&#39;
      OrdersConsumer.new.process_message(original_data[&#39;original_message&#39;])
    end
  rescue =&gt; e
    # Still failing, log permanently
    Rails.logger.error(&quot;Permanent failure: #{e.message}&quot;)
  end
end

# ============================================
# TESTING KAFKA INTEGRATION
# ============================================

RSpec.describe &#39;Kafka Integration&#39; do
  describe &#39;Publishing events&#39; do
    it &#39;publishes order created event&#39; do
      expect(WaterDrop::Producer).to receive(:call).with(
        hash_including(event_type: &#39;order.created&#39;),
        topic: &#39;orders&#39;
      )
      
      Order.create!(user_id: 1, total: 100)
    end
  end
  
  describe &#39;Consuming events&#39; do
    it &#39;processes order created event&#39; do
      message = double(
        payload: {
          event_type: &#39;order.created&#39;,
          data: {order_id: 1, user_id: 1}
        }.to_json
      )
      
      expect(OrderMailer).to receive(:confirmation)
        .with(1)
        .and_return(double(deliver_later: true))
      
      consumer = OrdersConsumer.new
      consumer.consume([message])
    end
  end
end
</code></pre>
<hr>
<h3>When to Use Kafka</h3>
<pre><code class="language-ruby"># ✅ Use Kafka when:
# - High throughput needed (millions of events)
# - Event-driven microservices
# - Event sourcing architecture
# - Real-time data processing
# - Log aggregation
# - Stream processing

# ❌ Don&#39;t use Kafka when:
# - Simple background jobs (use Sidekiq)
# - Request-response pattern (use HTTP)
# - Small scale (&lt;1000 events/day)
# - Team unfamiliar with Kafka
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>Kafka</strong>: Distributed event streaming platform</li>
<li><strong>Topics</strong>: Categories for messages</li>
<li><strong>Producers</strong>: Publish messages to topics</li>
<li><strong>Consumers</strong>: Subscribe and process messages</li>
<li><strong>ruby-kafka</strong>: Low-level client library</li>
<li><strong>Karafka</strong>: Rails-friendly framework</li>
<li><strong>Event-driven</strong>: Decouple microservices</li>
<li><strong>Scalability</strong>: Handle millions of messages</li>
<li><strong>Persistence</strong>: Messages stored on disk</li>
<li><strong>Use cases</strong>: Microservices, event sourcing, logs</li>
</ol>
<hr>
<h2>Question 353: How do you use CDNs in a Rails application?</h2>
<h3>Answer</h3>
<p><strong>CDN (Content Delivery Network)</strong> serves static assets from edge locations worldwide, reducing latency and server load. Configure Rails to use CDN via <code>asset_host</code>, upload assets to S3/CloudFront, and leverage caching for images, CSS, and JavaScript.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>CDN</strong>: Distribute assets globally</li>
<li><strong>asset_host</strong>: Configure CDN URL</li>
<li><strong>CloudFront</strong>: AWS CDN service</li>
<li><strong>Cloudflare</strong>: Popular CDN with DDoS protection</li>
<li><strong>Asset pipeline</strong>: Automatic fingerprinting</li>
<li><strong>Benefits</strong>: Faster load times, reduced bandwidth</li>
</ul>
<hr>
<h3>Complete Implementation</h3>
<pre><code class="language-ruby"># ============================================
# CDN BASICS
# ============================================

# Without CDN:
# User in Australia → Requests asset → US Server → Long latency

# With CDN:
# User in Australia → Requests asset → Sydney edge location → Fast!

# CDN benefits:
# - Faster asset delivery (edge locations worldwide)
# - Reduced bandwidth costs (CDN caches assets)
# - DDoS protection (CDN absorbs attacks)
# - SSL/TLS termination (CDN handles HTTPS)

# ============================================
# METHOD 1: CloudFront (AWS)
# ============================================

# Step 1: Upload assets to S3
# Gemfile
gem &#39;aws-sdk-s3&#39;

# config/storage.yml
amazon:
  service: S3
  access_key_id: &lt;%= ENV[&#39;AWS_ACCESS_KEY_ID&#39;] %&gt;
  secret_access_key: &lt;%= ENV[&#39;AWS_SECRET_ACCESS_KEY&#39;] %&gt;
  region: us-east-1
  bucket: my-app-assets

# config/environments/production.rb
Rails.application.configure do
  # Use S3 for Active Storage
  config.active_storage.service = :amazon
  
  # Configure asset host for CDN
  config.action_controller.asset_host = ENV[&#39;CDN_HOST&#39;]
  # e.g., &#39;https://d111111abcdef8.cloudfront.net&#39;
  
  # Enable asset fingerprinting
  config.assets.digest = true
  
  # Compile assets
  config.assets.compile = false
  
  # Asset compression
  config.assets.compress = true
  config.assets.js_compressor = :uglifier
  config.assets.css_compressor = :sass
end

# Step 2: Create CloudFront distribution
# (via AWS Console or Terraform)

# terraform/cloudfront.tf
resource &quot;aws_cloudfront_distribution&quot; &quot;assets&quot; {
  origin {
    domain_name = aws_s3_bucket.assets.bucket_regional_domain_name
    origin_id   = &quot;S3-${aws_s3_bucket.assets.id}&quot;
    
    s3_origin_config {
      origin_access_identity = aws_cloudfront_origin_access_identity.assets.cloudfront_access_identity_path
    }
  }
  
  enabled             = true
  is_ipv6_enabled     = true
  comment             = &quot;Assets CDN&quot;
  default_root_object = &quot;index.html&quot;
  
  default_cache_behavior {
    allowed_methods  = [&quot;GET&quot;, &quot;HEAD&quot;]
    cached_methods   = [&quot;GET&quot;, &quot;HEAD&quot;]
    target_origin_id = &quot;S3-${aws_s3_bucket.assets.id}&quot;
    
    forwarded_values {
      query_string = false
      cookies {
        forward = &quot;none&quot;
      }
    }
    
    viewer_protocol_policy = &quot;redirect-to-https&quot;
    min_ttl                = 0
    default_ttl            = 86400    # 1 day
    max_ttl                = 31536000 # 1 year
    compress               = true
  }
  
  restrictions {
    geo_restriction {
      restriction_type = &quot;none&quot;
    }
  }
  
  viewer_certificate {
    cloudfront_default_certificate = true
  }
}

# Step 3: Deploy assets
# lib/tasks/assets.rake
namespace :assets do
  desc &quot;Deploy assets to S3 and invalidate CloudFront&quot;
  task deploy: :environment do
    # Precompile assets
    Rake::Task[&#39;assets:precompile&#39;].invoke
    
    # Upload to S3
    s3 = Aws::S3::Client.new
    bucket = ENV[&#39;S3_BUCKET&#39;]
    
    Dir.glob(&#39;public/assets/**/*&#39;).each do |file|
      next if File.directory?(file)
      
      key = file.sub(&#39;public/&#39;, &#39;&#39;)
      
      s3.put_object(
        bucket: bucket,
        key: key,
        body: File.read(file),
        acl: &#39;public-read&#39;,
        cache_control: &#39;public, max-age=31536000&#39;,
        content_type: MIME::Types.type_for(file).first.to_s
      )
      
      puts &quot;Uploaded: #{key}&quot;
    end
    
    # Invalidate CloudFront cache
    cloudfront = Aws::CloudFront::Client.new
    cloudfront.create_invalidation(
      distribution_id: ENV[&#39;CLOUDFRONT_DISTRIBUTION_ID&#39;],
      invalidation_batch: {
        paths: {
          quantity: 1,
          items: [&#39;/assets/*&#39;]
        },
        caller_reference: Time.now.to_i.to_s
      }
    )
    
    puts &quot;CloudFront cache invalidated&quot;
  end
end

# Run: rake assets:deploy

# ============================================
# METHOD 2: Cloudflare
# ============================================

# Step 1: Add domain to Cloudflare
# Step 2: Update DNS to Cloudflare nameservers
# Step 3: Enable CDN in Cloudflare dashboard

# config/environments/production.rb
Rails.application.configure do
  # Assets served through Cloudflare automatically
  config.action_controller.asset_host = &#39;https://assets.example.com&#39;
  
  # Or use CDN subdomain
  # config.action_controller.asset_host = &#39;https://cdn.example.com&#39;
end

# Cloudflare caching rules (via dashboard):
# - Cache Level: Standard
# - Browser Cache TTL: 1 year
# - Edge Cache TTL: 1 month

# Page Rules:
# assets.example.com/*
# - Cache Level: Cache Everything
# - Edge Cache TTL: 1 month
# - Browser Cache TTL: 1 year

# ============================================
# METHOD 3: Asset Sync (Automatic S3 Upload)
# ============================================

# Gemfile
gem &#39;asset_sync&#39;

# config/initializers/asset_sync.rb
if defined?(AssetSync)
  AssetSync.configure do |config|
    config.fog_provider = &#39;AWS&#39;
    config.aws_access_key_id = ENV[&#39;AWS_ACCESS_KEY_ID&#39;]
    config.aws_secret_access_key = ENV[&#39;AWS_SECRET_ACCESS_KEY&#39;]
    config.fog_directory = ENV[&#39;S3_BUCKET&#39;]
    config.fog_region = &#39;us-east-1&#39;
    
    # Automatically upload after precompile
    config.existing_remote_files = &#39;keep&#39;
    
    # Asset host
    config.asset_host = ENV[&#39;CDN_HOST&#39;]
    
    # Gzip compression
    config.gzip_compression = true
  end
end

# Now assets automatically upload on deploy
# rake assets:precompile

# ============================================
# ADVANCED: Multiple CDN Hosts (Sharding)
# ============================================

# Distribute assets across multiple subdomains
# Increases parallel downloads (browser limit per domain)

# config/environments/production.rb
Rails.application.configure do
  config.action_controller.asset_host = Proc.new do |source|
    # Hash source to consistently use same host
    &quot;https://assets#{Digest::MD5.hexdigest(source).to_i(16) % 4}.example.com&quot;
  end
end

# Results in:
# - assets0.example.com
# - assets1.example.com
# - assets2.example.com
# - assets3.example.com

# ============================================
# ACTIVE STORAGE WITH CDN
# ============================================

# Serve user uploads through CDN

# config/storage.yml
amazon:
  service: S3
  access_key_id: &lt;%= ENV[&#39;AWS_ACCESS_KEY_ID&#39;] %&gt;
  secret_access_key: &lt;%= ENV[&#39;AWS_SECRET_ACCESS_KEY&#39;] %&gt;
  region: us-east-1
  bucket: my-app-uploads

# Model
class User &lt; ApplicationRecord
  has_one_attached :avatar
end

# Generate CloudFront URL for uploads
class User &lt; ApplicationRecord
  has_one_attached :avatar
  
  def avatar_cdn_url
    return nil unless avatar.attached?
    
    # Use CloudFront URL instead of S3
    cdn_host = ENV[&#39;CDN_HOST&#39;]
    key = avatar.key
    
    &quot;#{cdn_host}/#{key}&quot;
  end
end

# Usage in views
&lt;%= image_tag current_user.avatar_cdn_url %&gt;

# ============================================
# CACHE HEADERS FOR CDN
# ============================================

# Set proper cache headers for assets

# config/environments/production.rb
Rails.application.configure do
  # Public file server (for assets not in asset pipeline)
  config.public_file_server.enabled = true
  config.public_file_server.headers = {
    &#39;Cache-Control&#39; =&gt; &#39;public, max-age=31536000&#39;,
    &#39;Expires&#39; =&gt; 1.year.from_now.httpdate
  }
end

# Custom cache headers in controller
class AssetsController &lt; ApplicationController
  def show
    @asset = Asset.find(params[:id])
    
    expires_in 1.year, public: true
    fresh_when(etag: @asset, last_modified: @asset.updated_at, public: true)
  end
end

# ============================================
# PURGING CDN CACHE
# ============================================

# Cloudflare purge
class CloudflareCachePurge
  def self.purge_all
    require &#39;net/http&#39;
    
    uri = URI(&quot;https://api.cloudflare.com/client/v4/zones/#{ENV[&#39;CLOUDFLARE_ZONE_ID&#39;]}/purge_cache&quot;)
    
    request = Net::HTTP::Post.new(uri)
    request[&#39;X-Auth-Email&#39;] = ENV[&#39;CLOUDFLARE_EMAIL&#39;]
    request[&#39;X-Auth-Key&#39;] = ENV[&#39;CLOUDFLARE_API_KEY&#39;]
    request[&#39;Content-Type&#39;] = &#39;application/json&#39;
    request.body = {purge_everything: true}.to_json
    
    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
      http.request(request)
    end
    
    JSON.parse(response.body)
  end
  
  def self.purge_files(urls)
    uri = URI(&quot;https://api.cloudflare.com/client/v4/zones/#{ENV[&#39;CLOUDFLARE_ZONE_ID&#39;]}/purge_cache&quot;)
    
    request = Net::HTTP::Post.new(uri)
    request[&#39;X-Auth-Email&#39;] = ENV[&#39;CLOUDFLARE_EMAIL&#39;]
    request[&#39;X-Auth-Key&#39;] = ENV[&#39;CLOUDFLARE_API_KEY&#39;]
    request[&#39;Content-Type&#39;] = &#39;application/json&#39;
    request.body = {files: urls}.to_json
    
    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
      http.request(request)
    end
    
    JSON.parse(response.body)
  end
end

# Usage
CloudflareCachePurge.purge_all
CloudflareCachePurge.purge_files([
  &#39;https://example.com/assets/application.css&#39;,
  &#39;https://example.com/assets/application.js&#39;
])

# CloudFront invalidation
class CloudFrontInvalidation
  def self.invalidate(paths)
    cloudfront = Aws::CloudFront::Client.new
    
    cloudfront.create_invalidation(
      distribution_id: ENV[&#39;CLOUDFRONT_DISTRIBUTION_ID&#39;],
      invalidation_batch: {
        paths: {
          quantity: paths.size,
          items: paths
        },
        caller_reference: Time.now.to_i.to_s
      }
    )
  end
end

# Usage
CloudFrontInvalidation.invalidate([&#39;/assets/*&#39;, &#39;/uploads/*&#39;])

# ============================================
# MONITORING CDN PERFORMANCE
# ============================================

# Check CDN cache hit rate
class CdnMonitor
  def self.check_hit_rate
    # Cloudflare Analytics API
    uri = URI(&quot;https://api.cloudflare.com/client/v4/zones/#{ENV[&#39;CLOUDFLARE_ZONE_ID&#39;]}/analytics/dashboard&quot;)
    
    request = Net::HTTP::Get.new(uri)
    request[&#39;X-Auth-Email&#39;] = ENV[&#39;CLOUDFLARE_EMAIL&#39;]
    request[&#39;X-Auth-Key&#39;] = ENV[&#39;CLOUDFLARE_API_KEY&#39;]
    
    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
      http.request(request)
    end
    
    data = JSON.parse(response.body)
    
    {
      requests: data[&#39;result&#39;][&#39;totals&#39;][&#39;requests&#39;][&#39;all&#39;],
      cached: data[&#39;result&#39;][&#39;totals&#39;][&#39;requests&#39;][&#39;cached&#39;],
      hit_rate: (data[&#39;result&#39;][&#39;totals&#39;][&#39;requests&#39;][&#39;cached&#39;].to_f / 
                 data[&#39;result&#39;][&#39;totals&#39;][&#39;requests&#39;][&#39;all&#39;] * 100).round(2)
    }
  end
end

# Alert if hit rate too low
hit_rate = CdnMonitor.check_hit_rate[:hit_rate]
if hit_rate &lt; 80
  SlackNotifier.notify(&quot;CDN hit rate low: #{hit_rate}%&quot;)
end
</code></pre>
<hr>
<h3>CDN Best Practices</h3>
<pre><code class="language-ruby"># 1. Use asset fingerprinting
config.assets.digest = true  # application-abc123.css

# 2. Set long cache times
config.public_file_server.headers = {
  &#39;Cache-Control&#39; =&gt; &#39;public, max-age=31536000&#39;
}

# 3. Enable compression
config.assets.compress = true
config.assets.js_compressor = :uglifier

# 4. Use CDN for user uploads
# Store in S3, serve through CloudFront

# 5. Invalidate cache on deploy
# Cloudflare or CloudFront invalidation

# 6. Monitor cache hit rate
# Should be &gt;80% for assets

# 7. Use multiple CDN hosts (asset sharding)
# Bypass browser per-domain connection limits
</code></pre>
<hr>
<h3>Key Takeaways</h3>
<ol>
<li><strong>CDN</strong>: Global edge locations for fast delivery</li>
<li><strong>asset_host</strong>: Configure CDN URL in Rails</li>
<li><strong>CloudFront</strong>: AWS CDN with S3 integration</li>
<li><strong>Cloudflare</strong>: Easy CDN with DDoS protection</li>
<li><strong>Asset pipeline</strong>: Automatic fingerprinting</li>
<li><strong>Cache headers</strong>: Long TTL for static assets</li>
<li><strong>Invalidation</strong>: Purge cache on updates</li>
<li><strong>Monitoring</strong>: Track cache hit rates</li>
<li><strong>Compression</strong>: Gzip/Brotli for smaller files</li>
<li><strong>Benefits</strong>: Faster loads, reduced costs</li>
</ol>
<p>ENDOFFILE</p>
<hr>
<h2>Question 354: What is TensorFlow.js, and how can it be used in a Rails + JavaScript app?</h2>
<h3>Answer</h3>
<p><strong>TensorFlow.js</strong> is a JavaScript machine learning library for running ML models in browsers and Node.js. Integrate with Rails by serving models, using Stimulus/React for UI, and leveraging pre-trained models for image recognition, text classification, or predictions.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>TensorFlow.js</strong>: ML library for JavaScript</li>
<li><strong>Use cases</strong>: Image recognition, predictions, NLP</li>
<li><strong>Integration</strong>: Serve models from Rails, run in browser</li>
<li><strong>Pre-trained models</strong>: Use existing models (MobileNet, BERT)</li>
<li><strong>Custom models</strong>: Train in Python, convert to TF.js</li>
<li><strong>Real-time</strong>: Client-side predictions (no server needed)</li>
</ul>
<hr>
<h3>Implementation Summary</h3>
<pre><code class="language-ruby"># Rails backend serves the model
class ModelsController &lt; ApplicationController
  def show
    # Serve TensorFlow.js model files
    send_file Rails.root.join(&#39;public&#39;, &#39;models&#39;, &#39;model.json&#39;),
      type: &#39;application/json&#39;,
      disposition: &#39;inline&#39;
  end
end

# Frontend with Stimulus
# app/javascript/controllers/ml_controller.js
import { Controller } from &quot;@hotwired/stimulus&quot;
import * as tf from &#39;@tensorflow/tfjs&#39;

export default class extends Controller {
  async connect() {
    // Load pre-trained model
    this.model = await tf.loadLayersModel(&#39;/models/model.json&#39;)
  }
  
  async predict(imageData) {
    const tensor = tf.browser.fromPixels(imageData)
    const prediction = this.model.predict(tensor)
    return prediction.dataSync()
  }
}
</code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Image classification (e.g., product categorization)</li>
<li>Text sentiment analysis</li>
<li>Real-time predictions without server calls</li>
<li>Recommendation systems</li>
<li>Pose detection, object detection</li>
</ul>
<hr>
<h2>Version Management</h2>
<h2>Question 355: What is a Gemset?</h2>
<h3>Answer</h3>
<p>A <strong>Gemset</strong> is an isolated collection of gems for a specific Ruby version, managed by <strong>RVM</strong> (Ruby Version Manager). Each gemset contains its own set of gems, preventing conflicts between projects with different dependency versions.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Gemset</strong>: Isolated gem collection per project</li>
<li><strong>RVM</strong>: Tool that manages gemsets</li>
<li><strong>Per-project</strong>: Different gems for each project</li>
<li><strong>Prevents conflicts</strong>: Project A uses Rails 6, Project B uses Rails 7</li>
<li><strong>Commands</strong>: <code>rvm gemset create</code>, <code>rvm gemset use</code></li>
<li><strong>Alternative</strong>: Bundler handles this now (gemsets less common)</li>
</ul>
<hr>
<h3>Quick Reference</h3>
<pre><code class="language-bash"># Create gemset
rvm gemset create myproject

# Use gemset
rvm use 3.2.0@myproject

# List gemsets
rvm gemset list

# Delete gemset
rvm gemset delete myproject

# Modern approach: Use Bundler
# Bundler installs gems per-project automatically
bundle install --path vendor/bundle
</code></pre>
<p><strong>Note</strong>: With modern Bundler, gemsets are less necessary. Bundler manages dependencies per-project via <code>Gemfile</code> and <code>Gemfile.lock</code>.</p>
<hr>
<h2>Question 356: What is a Gem?</h2>
<h3>Answer</h3>
<p>A <strong>Gem</strong> is a packaged Ruby library/application containing reusable code, distributed via RubyGems.org. Gems provide functionality like web frameworks (Rails), testing (RSpec), authentication (Devise), and can be installed with <code>gem install</code> or managed via Bundler.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Gem</strong>: Packaged Ruby library</li>
<li><strong>RubyGems</strong>: Package manager for Ruby</li>
<li><strong>Distribution</strong>: Published to rubygems.org</li>
<li><strong>Installation</strong>: <code>gem install name</code> or via Bundler</li>
<li><strong>Structure</strong>: Code + gemspec file</li>
<li><strong>Examples</strong>: Rails, Devise, Sidekiq, RSpec</li>
</ul>
<hr>
<h3>Gem Structure</h3>
<pre><code class="language-ruby"># my_gem.gemspec
Gem::Specification.new do |spec|
  spec.name          = &quot;my_gem&quot;
  spec.version       = &quot;1.0.0&quot;
  spec.authors       = [&quot;Your Name&quot;]
  spec.email         = [&quot;you@example.com&quot;]
  spec.summary       = &quot;Brief description&quot;
  spec.description   = &quot;Longer description&quot;
  spec.homepage      = &quot;https://github.com/you/my_gem&quot;
  spec.license       = &quot;MIT&quot;
  
  spec.files         = Dir[&#39;lib/**/*&#39;, &#39;README.md&#39;]
  spec.require_paths = [&quot;lib&quot;]
  
  spec.add_dependency &quot;activesupport&quot;, &quot;&gt;= 6.0&quot;
  spec.add_development_dependency &quot;rspec&quot;, &quot;~&gt; 3.0&quot;
end

# lib/my_gem.rb
module MyGem
  def self.hello
    &quot;Hello from MyGem!&quot;
  end
end

# Usage in Gemfile
gem &#39;my_gem&#39;

# Usage in code
require &#39;my_gem&#39;
MyGem.hello  # =&gt; &quot;Hello from MyGem!&quot;
</code></pre>
<hr>
<h2>Question 357: Difference between Ruby versions and features introduced/removed</h2>
<h3>Answer</h3>
<p>Ruby versions introduce new features, performance improvements, and deprecations. Major versions (3.x) bring significant changes, while minor versions (3.2, 3.3) add features. Key milestones: Ruby 2.0 (keyword arguments), 2.3 (safe navigation), 3.0 (YJIT, types), 3.2 (WASM support).</p>
<hr>
<h3>Ruby Version Highlights</h3>
<pre><code class="language-ruby"># ============================================
# RUBY 2.0 (2013)
# ============================================
# - Keyword arguments
def greet(name:, age:)
  &quot;Hello #{name}, age #{age}&quot;
end

# - %i (array of symbols)
symbols = %i[foo bar baz]  # [:foo, :bar, :baz]

# ============================================
# RUBY 2.1 (2013)
# ============================================
# - Required keyword arguments
def user(name:, email:)  # Both required
end

# - Rational/Complex number literals
r = 1/3r  # Rational
c = 2+3i  # Complex

# ============================================
# RUBY 2.3 (2015)
# ============================================
# - Safe navigation operator
user&amp;.name  # nil if user is nil

# - Frozen string literals
# frozen_string_literal: true

# - Hash#dig
hash = {a: {b: {c: 1}}}
hash.dig(:a, :b, :c)  # =&gt; 1

# ============================================
# RUBY 2.4 (2016)
# ============================================
# - Hash#transform_values
{a: 1, b: 2}.transform_values { |v| v * 2 }  # {a: 2, b: 4}

# - Comparable#clamp
5.clamp(1, 3)  # =&gt; 3

# ============================================
# RUBY 2.5 (2017)
# ============================================
# - yield_self (later renamed to then)
5.then { |x| x * 2 }.then { |x| x + 3 }  # =&gt; 13

# - rescue in blocks
result = begin
  dangerous_operation
rescue =&gt; e
  &quot;Error: #{e.message}&quot;
end

# ============================================
# RUBY 2.7 (2019)
# ============================================
# - Pattern matching (experimental)
case [1, 2, 3]
in [a, b, c]
  puts &quot;#{a}, #{b}, #{c}&quot;
end

# - Numbered parameters
[1, 2, 3].map { _1 * 2 }  # =&gt; [2, 4, 6]

# - Warning for keyword argument changes

# ============================================
# RUBY 3.0 (2020)
# ============================================
# - 3x faster than Ruby 2.0
# - YJIT (Just-In-Time compiler)
# - RBS (type signatures)
# - Rightward assignment
value = 42
value =&gt; x
x  # =&gt; 42

# - Endless method definition
def square(x) = x * x

# - Find pattern in pattern matching
case [1, 2, 3, 4, 5]
in [*, 3, *]
  puts &quot;Contains 3&quot;
end

# ============================================
# RUBY 3.1 (2021)
# ============================================
# - Shorthand hash syntax
{name: name, age: age}  # Old
{name:, age:}           # New (Ruby 3.1+)

# - Pin operator in pattern matching
value = 42
case [1, 42, 3]
in [*, ^value, *]
  puts &quot;Contains #{value}&quot;
end

# ============================================
# RUBY 3.2 (2022)
# ============================================
# - WASM support
# - Set is now a built-in class
require &#39;set&#39;  # No longer needed
Set.new([1, 2, 3])

# - Improved error messages

# ============================================
# RUBY 3.3 (2023)
# ============================================
# - YJIT improvements
# - Parser improvements
# - Performance optimizations

# ============================================
# DEPRECATED/REMOVED
# ============================================
# Ruby 2.7: Keyword argument changes
# Ruby 3.0: Removed flip-flop operator
# Ruby 3.0: Removed positional arguments with keywords
</code></pre>
<hr>
<h2>Question 358: Difference between Rails versions and features introduced/removed</h2>
<h3>Answer</h3>
<p>Rails versions evolve with new features, security updates, and deprecations. Major versions (6.x, 7.x, 8.x) introduce significant changes. Key features: Rails 5 (ActionCable), 6 (multi-DB, parallel tests), 7 (Hotwire, import maps), 8 (Kamal deployment, Solid Cache).</p>
<hr>
<h3>Rails Version Highlights</h3>
<pre><code class="language-ruby"># ============================================
# RAILS 4.0 (2013)
# ============================================
# - Strong Parameters (mass assignment protection)
params.require(:user).permit(:name, :email)

# - Turbolinks
# - Russian Doll Caching
# - ActiveRecord::Relation#none

# ============================================
# RAILS 4.1 (2014)
# ============================================
# - Spring (application preloader)
# - Variants (mobile/desktop views)
# - enum support
class User &lt; ApplicationRecord
  enum role: [:user, :admin, :moderator]
end

# ============================================
# RAILS 4.2 (2014)
# ============================================
# - ActiveJob (background jobs abstraction)
# - Adequate Record (performance improvements)
# - Foreign key support in migrations
# - Web Console

# ============================================
# RAILS 5.0 (2016)
# ============================================
# - ActionCable (WebSockets)
# - API mode
rails new myapp --api

# - Rails command instead of rake
rails db:migrate  # instead of rake db:migrate

# - Required belongs_to by default

# ============================================
# RAILS 5.1 (2017)
# ============================================
# - Webpack support via Webpacker
# - Encrypted secrets
rails secrets:setup

# - System tests
# - Form with model improvements

# ============================================
# RAILS 5.2 (2018)
# ============================================
# - ActiveStorage (file uploads)
# - Redis cache store
# - Credentials (encrypted)
rails credentials:edit

# - Content Security Policy
# - Direct uploads to cloud storage

# ============================================
# RAILS 6.0 (2019)
# ============================================
# - Multiple databases
class ApplicationRecord &lt; ActiveRecord::Base
  connects_to database: { writing: :primary, reading: :replica }
end

# - Parallel testing
# - Action Mailbox (incoming emails)
# - Action Text (rich text)
# - Webpacker by default

# ============================================
# RAILS 6.1 (2020)
# ============================================
# - Horizontal sharding
# - Delegated types
# - Destroy associations async
# - Query method #sole and #find_sole_by
# - ActiveRecord::Base.strict_loading_by_default

# ============================================
# RAILS 7.0 (2021)
# ============================================
# - Hotwire (Turbo + Stimulus) by default
# - Import maps (no Node.js/Webpack required)
# - Encrypted attributes
class User &lt; ApplicationRecord
  encrypts :email
end

# - async query loading
# - Dockerfile generated by default

# ============================================
# RAILS 7.1 (2023)
# ============================================
# - Dockerfile improvements
# - generate_token for ActiveRecord
# - Composite primary keys
# - Trilogy MySQL adapter
# - Bun and esbuild support

# ============================================
# RAILS 8.0 (2024)
# ============================================
# - Kamal deployment (built-in)
# - Solid Cache (database-backed cache)
# - Solid Queue (database-backed jobs)
# - Solid Cable (database-backed ActionCable)
# - Authentication generator
rails generate authentication

# - PWA support
# - Thruster (HTTP/2 proxy)

# ============================================
# DEPRECATED/REMOVED
# ============================================
# Rails 6.0: Removed support for Ruby &lt; 2.5
# Rails 7.0: Webpacker removed (use import maps)
# Rails 7.0: Sprockets no longer default
# Rails 8.0: Removed support for Ruby &lt; 3.1
</code></pre>
<hr>
<h2>Git</h2>
<h2>Question 359: What is the difference between rebase and merge?</h2>
<h3>Answer</h3>
<p><strong>Merge</strong> creates a merge commit combining two branches, preserving history. <strong>Rebase</strong> rewrites history by applying commits on top of another branch, creating a linear history. Merge is safer for public branches; rebase is cleaner for feature branches.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Merge</strong>: Creates merge commit, preserves history</li>
<li><strong>Rebase</strong>: Rewrites history, linear timeline</li>
<li><strong>Merge</strong>: Safe for public/shared branches</li>
<li><strong>Rebase</strong>: Clean history, better for feature branches</li>
<li><strong>Conflicts</strong>: Both can have conflicts</li>
<li><strong>Golden rule</strong>: Never rebase public/shared branches</li>
</ul>
<hr>
<h3>Detailed Comparison</h3>
<pre><code class="language-bash"># ============================================
# MERGE
# ============================================

# Scenario: Feature branch diverged from main
#     A---B---C feature
#    /
# D---E---F---G main

git checkout main
git merge feature

# Result: Creates merge commit
#     A---B---C
#    /         \
# D---E---F---G---H main
#             (merge commit)

# Preserves complete history
# - All commits stay in order
# - Shows when feature was merged
# - Non-destructive

# Commands:
git checkout main
git merge feature              # Creates merge commit
git merge --no-ff feature      # Always create merge commit
git merge --squash feature     # Squash all commits into one

# ============================================
# REBASE
# ============================================

# Same scenario
#     A---B---C feature
#    /
# D---E---F---G main

git checkout feature
git rebase main

# Result: Commits moved to tip of main
# D---E---F---G---A&#39;---B&#39;---C&#39; feature
#                 main

# Linear history
# - Feature commits appear after main
# - Clean, straight line
# - Rewrites commit hashes (A→A&#39;, B→B&#39;, C→C&#39;)

# Commands:
git checkout feature
git rebase main                # Move commits to tip
git rebase -i main             # Interactive rebase
git rebase --onto new old      # Rebase onto different branch

# ============================================
# WHEN TO USE EACH
# ============================================

# USE MERGE when:
# ✅ Working on public/shared branches
# ✅ Want to preserve complete history
# ✅ Multiple people working on branch
# ✅ Want to see when features were integrated
# ✅ Collaborating with team

# USE REBASE when:
# ✅ Working on private feature branch
# ✅ Want clean, linear history
# ✅ Before creating pull request
# ✅ Cleaning up local commits
# ✅ Nobody else using your branch

# ============================================
# INTERACTIVE REBASE
# ============================================

git rebase -i HEAD~3  # Rebase last 3 commits

# Opens editor:
# pick abc123 Add feature A
# pick def456 Fix typo
# pick ghi789 Add feature B

# Can change to:
# pick abc123 Add feature A
# squash def456 Fix typo        # Combine with previous
# reword ghi789 Add feature B   # Change commit message
# drop jkl012 Debug code        # Remove commit

# ============================================
# HANDLING CONFLICTS
# ============================================

# Merge conflicts
git merge feature
# CONFLICT in file.rb
# Fix conflicts
git add file.rb
git commit  # Complete merge

# Rebase conflicts
git rebase main
# CONFLICT in file.rb
# Fix conflicts
git add file.rb
git rebase --continue  # Continue rebase
# Or
git rebase --abort     # Cancel rebase

# ============================================
# GOLDEN RULES
# ============================================

# ❌ NEVER rebase public branches
git checkout main
git rebase feature  # BAD! Others have main

# ✅ Only rebase private branches
git checkout feature
git rebase main  # GOOD! Only you have feature

# ❌ Don&#39;t rebase after pushing
git push origin feature
git rebase main  # BAD! Others pulled feature
git push --force  # Very bad!

# ✅ Rebase before pushing
git rebase main
git push origin feature  # GOOD! Clean history

# ============================================
# REAL-WORLD WORKFLOW
# ============================================

# Feature development workflow:

# 1. Create feature branch
git checkout -b feature/new-feature

# 2. Make commits
git commit -m &quot;Add feature part 1&quot;
git commit -m &quot;Add feature part 2&quot;
git commit -m &quot;Fix bug&quot;

# 3. Before PR: Rebase on main and clean up
git fetch origin
git rebase -i origin/main

# Squash/reorder commits in editor

# 4. Push to remote
git push origin feature/new-feature

# 5. Create Pull Request

# 6. Merge PR (on GitHub/GitLab)
# - Use &quot;Squash and merge&quot; for clean history
# - Or &quot;Merge commit&quot; to preserve history

# ============================================
# COMPARISON TABLE
# ============================================

# Aspect          | Merge                   | Rebase
# ----------------|-------------------------|------------------
# History         | Preserves all commits   | Rewrites history
# Timeline        | Non-linear (branches)   | Linear
# Commit hashes   | Unchanged               | New hashes
# Safety          | Safe for shared branches| Dangerous if shared
# Readability     | Shows merge points      | Clean, straight
# Conflicts       | Once                    | Per commit
# Use case        | Public branches         | Feature branches
</code></pre>
<hr>
<h2>Data Structures</h2>
<h2>Question 360: What is the difference between single linked list and double linked list?</h2>
<h3>Answer</h3>
<p><strong>Single linked list</strong> nodes have one pointer (next), traversing forward only. <strong>Double linked list</strong> nodes have two pointers (next, previous), allowing bidirectional traversal. Double requires more memory but enables O(1) deletion and reverse iteration.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Single</strong>: One pointer per node (next)</li>
<li><strong>Double</strong>: Two pointers per node (next, previous)</li>
<li><strong>Traversal</strong>: Single=forward only, Double=both directions</li>
<li><strong>Memory</strong>: Single uses less, Double uses more</li>
<li><strong>Operations</strong>: Double enables O(1) deletion with node reference</li>
<li><strong>Use cases</strong>: Single for simple lists, Double for LRU cache</li>
</ul>
<hr>
<h3>Implementation</h3>
<pre><code class="language-ruby"># ============================================
# SINGLE LINKED LIST
# ============================================

class Node
  attr_accessor :value, :next
  
  def initialize(value)
    @value = value
    @next = nil
  end
end

class SingleLinkedList
  attr_reader :head
  
  def initialize
    @head = nil
  end
  
  # Add to beginning: O(1)
  def prepend(value)
    new_node = Node.new(value)
    new_node.next = @head
    @head = new_node
  end
  
  # Add to end: O(n)
  def append(value)
    new_node = Node.new(value)
    
    if @head.nil?
      @head = new_node
      return
    end
    
    current = @head
    current = current.next while current.next
    current.next = new_node
  end
  
  # Delete node: O(n)
  def delete(value)
    return if @head.nil?
    
    if @head.value == value
      @head = @head.next
      return
    end
    
    current = @head
    while current.next
      if current.next.value == value
        current.next = current.next.next
        return
      end
      current = current.next
    end
  end
  
  # Find: O(n)
  def find(value)
    current = @head
    while current
      return current if current.value == value
      current = current.next
    end
    nil
  end
  
  # Print: O(n)
  def print
    values = []
    current = @head
    while current
      values &lt;&lt; current.value
      current = current.next
    end
    values.join(&#39; -&gt; &#39;)
  end
end

# Usage
list = SingleLinkedList.new
list.prepend(1)
list.append(2)
list.append(3)
list.print  # =&gt; &quot;1 -&gt; 2 -&gt; 3&quot;

# ============================================
# DOUBLE LINKED LIST
# ============================================

class DNode
  attr_accessor :value, :next, :prev
  
  def initialize(value)
    @value = value
    @next = nil
    @prev = nil
  end
end

class DoubleLinkedList
  attr_reader :head, :tail
  
  def initialize
    @head = nil
    @tail = nil
  end
  
  # Add to beginning: O(1)
  def prepend(value)
    new_node = DNode.new(value)
    
    if @head.nil?
      @head = @tail = new_node
      return
    end
    
    new_node.next = @head
    @head.prev = new_node
    @head = new_node
  end
  
  # Add to end: O(1) - Better than single!
  def append(value)
    new_node = DNode.new(value)
    
    if @tail.nil?
      @head = @tail = new_node
      return
    end
    
    new_node.prev = @tail
    @tail.next = new_node
    @tail = new_node
  end
  
  # Delete node: O(1) if you have node reference!
  def delete_node(node)
    if node.prev
      node.prev.next = node.next
    else
      @head = node.next
    end
    
    if node.next
      node.next.prev = node.prev
    else
      @tail = node.prev
    end
  end
  
  # Delete by value: O(n)
  def delete(value)
    current = @head
    while current
      if current.value == value
        delete_node(current)
        return
      end
      current = current.next
    end
  end
  
  # Print forward: O(n)
  def print_forward
    values = []
    current = @head
    while current
      values &lt;&lt; current.value
      current = current.next
    end
    values.join(&#39; &lt;-&gt; &#39;)
  end
  
  # Print backward: O(n) - Only possible with double!
  def print_backward
    values = []
    current = @tail
    while current
      values &lt;&lt; current.value
      current = current.prev
    end
    values.join(&#39; &lt;-&gt; &#39;)
  end
end

# Usage
list = DoubleLinkedList.new
list.append(1)
list.append(2)
list.append(3)
list.print_forward   # =&gt; &quot;1 &lt;-&gt; 2 &lt;-&gt; 3&quot;
list.print_backward  # =&gt; &quot;3 &lt;-&gt; 2 &lt;-&gt; 1&quot;

# ============================================
# COMPARISON
# ============================================

# Operation         | Single  | Double
# ------------------|---------|--------
# Prepend           | O(1)    | O(1)
# Append            | O(n)    | O(1) ← Better!
# Delete (value)    | O(n)    | O(n)
# Delete (node ref) | O(n)    | O(1) ← Much better!
# Find              | O(n)    | O(n)
# Reverse traverse  | No      | Yes ← Only double!
# Memory per node   | 1 ptr   | 2 ptrs ← More memory

# ============================================
# REAL-WORLD USE: LRU Cache
# ============================================

# LRU Cache uses double linked list
class LRUCache
  def initialize(capacity)
    @capacity = capacity
    @cache = {}
    @list = DoubleLinkedList.new
  end
  
  def get(key)
    return nil unless @cache.key?(key)
    
    node = @cache[key]
    # Move to front (most recently used)
    @list.delete_node(node)
    @list.prepend(node.value)
    
    node.value[:value]
  end
  
  def put(key, value)
    if @cache.key?(key)
      node = @cache[key]
      @list.delete_node(node)
    elsif @cache.size &gt;= @capacity
      # Evict least recently used (tail)
      @cache.delete(@list.tail.value[:key])
      @list.delete_node(@list.tail)
    end
    
    @list.prepend({key: key, value: value})
    @cache[key] = @list.head
  end
end

# Why double linked list?
# - Need O(1) deletion (delete node)
# - Need O(1) append to front
# - Need O(1) remove from tail
# Single linked list can&#39;t do this efficiently!
</code></pre>
<hr>
<h2>Miscellaneous</h2>
<h2>Question 361: What is Sweeper in Rails?</h2>
<h3>Answer</h3>
<p><strong>Sweepers</strong> were Rails 2/3 feature for automatic cache expiration when models changed, acting as observers that clear caches on create/update/destroy. <strong>Removed in Rails 4</strong> - now use callbacks, concerns, or ActiveJob for cache management.</p>
<p><strong>Short Answer:</strong></p>
<ul>
<li><strong>Sweepers</strong>: Automatic cache expiration (Rails 2-3)</li>
<li><strong>Removed</strong>: Deprecated in Rails 4</li>
<li><strong>Purpose</strong>: Clear caches when models change</li>
<li><strong>Modern alternative</strong>: Use callbacks or concerns</li>
<li><strong>Example</strong>: Clear product cache when product updates</li>
</ul>
<hr>
<h3>Legacy and Modern Approaches</h3>
<pre><code class="language-ruby"># ============================================
# LEGACY: Sweepers (Rails 2-3) - DON&#39;T USE
# ============================================

# Old Rails 2/3 syntax (doesn&#39;t work in modern Rails)
class ProductSweeper &lt; ActionController::Caching::Sweeper
  observe Product
  
  def after_save(product)
    expire_cache(product)
  end
  
  def after_destroy(product)
    expire_cache(product)
  end
  
  private
  
  def expire_cache(product)
    expire_action(controller: &#39;products&#39;, action: &#39;show&#39;, id: product.id)
    expire_fragment(&quot;product_#{product.id}&quot;)
  end
end

# ============================================
# MODERN: Model Callbacks
# ============================================

class Product &lt; ApplicationRecord
  after_save :clear_cache
  after_destroy :clear_cache
  
  private
  
  def clear_cache
    Rails.cache.delete(&quot;product/#{id}&quot;)
    Rails.cache.delete(&quot;products/all&quot;)
  end
end

# ============================================
# MODERN: Concern for Reusability
# ============================================

module Cacheable
  extend ActiveSupport::Concern
  
  included do
    after_save :clear_cache
    after_destroy :clear_cache
  end
  
  def cache_key
    &quot;#{self.class.name.downcase}/#{id}&quot;
  end
  
  private
  
  def clear_cache
    Rails.cache.delete(cache_key)
  end
end

class Product &lt; ApplicationRecord
  include Cacheable
end

# ============================================
# MODERN: Cache Versioning (Best)
# ============================================

class Product &lt; ApplicationRecord
  # Rails automatically uses cache_key_with_version
  # Cache automatically invalidates when updated_at changes
end

# View
&lt;% cache product do %&gt;
  &lt;%= product.name %&gt;
  &lt;%= product.price %&gt;
&lt;% end %&gt;

# Cache key: products/1-20250101120000000000
# When product updates, updated_at changes
# New cache key: products/1-20250101130000000000
# Old cache automatically expires
</code></pre>
<hr>
<h2>Question 362: What is the difference between MongoDB and PostgreSQL JSON support?</h2>
<h3>Answer</h3>
<p><strong>MongoDB</strong> is document database with native JSON (BSON) storage, schema-less, and optimized for JSON operations. <strong>PostgreSQL JSON/JSONB</strong> adds JSON columns to relational tables, providing SQL queries with JSON operators, type safety, and ACID transactions while keeping relational benefits.</p>
<hr>
<h3>Detailed Comparison</h3>
<pre><code class="language-ruby"># ============================================
# MONGODB (Document Database)
# ============================================

# Native JSON storage (BSON format)
# Schema-less, flexible structure

# Document example
{
  _id: ObjectId(&quot;507f1f77bcf86cd799439011&quot;),
  name: &quot;John Doe&quot;,
  email: &quot;john@example.com&quot;,
  address: {
    street: &quot;123 Main St&quot;,
    city: &quot;New York&quot;,
    zip: &quot;10001&quot;
  },
  orders: [
    {id: 1, total: 99.99, date: ISODate(&quot;2025-01-01&quot;)},
    {id: 2, total: 149.99, date: ISODate(&quot;2025-01-15&quot;)}
  ]
}

# Mongoid (MongoDB + Rails)
class User
  include Mongoid::Document
  
  field :name, type: String
  field :email, type: String
  field :address, type: Hash
  field :orders, type: Array
end

# Query
User.where(&quot;address.city&quot; =&gt; &quot;New York&quot;)
User.where(&quot;orders.total&quot; =&gt; {&quot;$gt&quot; =&gt; 100})

# ============================================
# POSTGRESQL JSONB (Relational + JSON)
# ============================================

# Relational table with JSONB column

# Migration
create_table :users do |t|
  t.string :name
  t.string :email
  t.jsonb :address, default: {}
  t.jsonb :metadata, default: {}
  
  t.index :address, using: :gin
end

# Model
class User &lt; ApplicationRecord
  # JSONB stored in column
end

# Store JSON
user = User.create!(
  name: &quot;John Doe&quot;,
  email: &quot;john@example.com&quot;,
  address: {
    street: &quot;123 Main St&quot;,
    city: &quot;New York&quot;,
    zip: &quot;10001&quot;
  }
)

# Query with JSONB operators
User.where(&quot;address-&gt;&gt;&#39;city&#39; = ?&quot;, &quot;New York&quot;)
User.where(&quot;address @&gt; ?&quot;, {city: &quot;New York&quot;}.to_json)
User.where(&quot;address ? &#39;zip&#39;&quot;)  # Has key

# ============================================
# KEY DIFFERENCES
# ============================================

# Aspect          | MongoDB                    | PostgreSQL JSONB
# ----------------|----------------------------|------------------
# Storage         | Native JSON (BSON)         | Binary JSON in column
# Schema          | Schema-less                | Table schema + JSON column
# Queries         | MongoDB query language     | SQL with JSON operators
# Indexes         | Automatic on all fields    | Must create GIN index
# Transactions    | Limited (multi-document)   | Full ACID transactions
# Joins           | No joins (embed/reference) | Full SQL joins
# Type safety     | Dynamic types              | Column types + JSON
# Scaling         | Horizontal (sharding)      | Vertical (replication)
# Consistency     | Eventual consistency       | Strong consistency
# Use case        | Document-centric apps      | Relational + flexible data

# ============================================
# WHEN TO USE EACH
# ============================================

# Use MongoDB when:
# ✅ Document-oriented data model
# ✅ Flexible, evolving schema
# ✅ Horizontal scaling needed
# ✅ No complex joins required
# ✅ High write throughput

# Use PostgreSQL JSONB when:
# ✅ Primarily relational data
# ✅ Need ACID transactions
# ✅ Complex joins required
# ✅ Some flexible metadata
# ✅ Type safety important
</code></pre>
<h1>Behavioral and Scenario-Based Questions (363-376)</h1>
<h2>Experience Questions</h2>
<h2>Question 363: Can you describe a challenging project you worked on?</h2>
<h3>Answer Framework</h3>
<p><strong>Use STAR Method:</strong></p>
<ul>
<li><strong>S</strong>ituation: Context and background</li>
<li><strong>T</strong>ask: Your responsibility</li>
<li><strong>A</strong>ction: What you did</li>
<li><strong>R</strong>esult: Outcome and learnings</li>
</ul>
<hr>
<h3>Sample Answer Template</h3>
<pre><code>SITUATION:
&quot;At [Company], we had a monolithic Rails application serving 100,000+ 
daily active users. As the user base grew, we experienced severe 
performance degradation - page load times increased from 200ms to 5+ 
seconds, and our database was hitting 95% CPU usage regularly.&quot;

TASK:
&quot;I was tasked as the technical lead to improve application performance 
and scalability while maintaining zero downtime for users.&quot;

ACTION:
&quot;I took a multi-pronged approach:

1. Performance Analysis:
   - Used New Relic and Scout APM to identify bottlenecks
   - Found N+1 queries causing 80% of slow pages
   - Discovered missing database indexes on frequently queried columns

2. Database Optimization:
   - Implemented eager loading with includes() to eliminate N+1 queries
   - Added composite indexes on user_id + created_at columns
   - Set up read replicas to distribute read traffic
   - Implemented query result caching for expensive aggregations

3. Application Architecture:
   - Extracted background processing to Sidekiq (was running inline)
   - Implemented fragment caching for homepage and dashboards
   - Added Redis for session storage (was using database)
   - Introduced rate limiting with Rack::Attack

4. Infrastructure:
   - Scaled from 2 to 6 web servers with load balancing
   - Implemented CDN (CloudFront) for static assets
   - Set up auto-scaling based on CPU and request count

5. Monitoring:
   - Created custom Datadog dashboards for key metrics
   - Set up alerts for response time &gt; 1s, error rate &gt; 1%
   - Implemented detailed logging with Papertrail&quot;

RESULT:
&quot;Results after 3 months:
- Page load times: 5s → 300ms (94% improvement)
- Database CPU: 95% → 40%
- Successfully handled 3x traffic during product launch
- Zero downtime during entire migration
- Team learned modern Rails performance patterns

Key Learnings:
- Importance of monitoring BEFORE problems occur
- Database optimization yields highest ROI
- Incremental changes are safer than big bang rewrites
- Documentation is crucial for team knowledge transfer&quot;
</code></pre>
<hr>
<h3>Key Points to Emphasize</h3>
<p><strong>Technical Skills:</strong></p>
<ul>
<li>Specific technologies used (Rails, Redis, Sidekiq)</li>
<li>Metrics and quantifiable improvements</li>
<li>Problem-solving methodology</li>
<li>Tools for debugging and monitoring</li>
</ul>
<p><strong>Soft Skills:</strong></p>
<ul>
<li>Team collaboration and communication</li>
<li>Leadership and decision-making</li>
<li>Handling pressure and deadlines</li>
<li>Learning from challenges</li>
</ul>
<p><strong>Business Impact:</strong></p>
<ul>
<li>User experience improvements</li>
<li>Cost savings or revenue impact</li>
<li>Scalability for future growth</li>
</ul>
<hr>
<h2>Question 364: Have you faced performance issues in Rails applications? How did you resolve them?</h2>
<h3>Answer</h3>
<p><strong>Common Performance Issues and Solutions:</strong></p>
<hr>
<h3>Detailed Response Template</h3>
<pre><code>&quot;Yes, I&#39;ve encountered several performance challenges in Rails applications. 
Here are specific examples with solutions:

ISSUE 1: N+1 QUERY PROBLEM

Problem:
- Dashboard loading in 8+ seconds
- Database showing 1000+ queries per page load
- User complaints about slow admin interface

Investigation:
- Enabled Bullet gem to detect N+1 queries
- Found: Loading 100 users, then querying posts for each user individually
- Original code:
  @users = User.limit(100)
  # In view: @users.each { |user| user.posts.count }
  # Generated: 1 query for users + 100 queries for posts = 101 queries

Solution:
- Implemented eager loading:
  @users = User.includes(:posts).limit(100)
- Added counter cache:
  class User &lt; ApplicationRecord
    has_many :posts
  end
  
  class Post &lt; ApplicationRecord
    belongs_to :user, counter_cache: true
  end
- Result: 101 queries → 2 queries, 8s → 400ms

ISSUE 2: MISSING DATABASE INDEXES

Problem:
- Search feature timing out (30+ seconds)
- Database showing full table scans
- Query: User.where(email: &#39;test@example.com&#39;, status: &#39;active&#39;)

Investigation:
- Used EXPLAIN ANALYZE on slow queries
- Found sequential scans on 5 million row table
- No indexes on email or status columns

Solution:
- Added composite index:
  add_index :users, [:email, :status]
- Result: 30s → 50ms (99.8% improvement)

ISSUE 3: INEFFICIENT RENDERING

Problem:
- Product catalog page rendering slowly (3-5 seconds)
- View rendering time was 80% of total request time
- Rendering 1000 products with partials

Investigation:
- Rails log showed: Rendering collection partial (1000 iterations)
- Each partial rendered price, image, description

Solution:
- Implemented fragment caching:
  &lt;% cache product do %&gt;
    &lt;%= render product %&gt;
  &lt;% end %&gt;
  
- Added low-level caching for expensive calculations:
  def discounted_price
    Rails.cache.fetch(&quot;product/#{id}/discount&quot;, expires_in: 1.hour) do
      calculate_complex_discount
    end
  end
  
- Result: 3-5s → 200ms on cache hit

ISSUE 4: MEMORY BLOAT

Problem:
- Application servers running out of memory
- Frequent restarts required
- Memory usage growing from 500MB to 2GB over hours

Investigation:
- Used memory_profiler gem
- Found batch job loading entire dataset into memory:
  Product.all.each { |p| process(p) }  # Loads all products!

Solution:
- Implemented batch processing:
  Product.find_each(batch_size: 1000) do |product|
    process(product)
  end
  
- Used select() to load only needed columns:
  Product.select(:id, :name, :price).find_each
  
- Result: Memory stable at 500MB

ISSUE 5: SLOW BACKGROUND JOBS

Problem:
- Email sending jobs taking 10+ minutes
- Queue backing up to thousands of jobs
- SendGrid API being rate limited

Investigation:
- Jobs sending emails one at a time synchronously
- No connection pooling
- Each job making new API connection

Solution:
- Implemented bulk sending:
  class BulkEmailJob &lt; ApplicationJob
    def perform(user_ids)
      users = User.where(id: user_ids).pluck(:email)
      SendGrid.send_bulk(users, template)  # Batch API call
    end
  end
  
- Added Sidekiq rate limiting:
  class EmailJob &lt; ApplicationJob
    sidekiq_options queue: :emails, retry: 3
    sidekiq_throttle threshold: { limit: 100, period: 1.minute }
  end
  
- Result: 10 minutes → 30 seconds, no rate limiting

KEY TOOLS I USE:

1. Detection:
   - Bullet (N+1 queries)
   - rack-mini-profiler (request profiling)
   - Scout APM / New Relic (production monitoring)
   - Skylight (query analysis)

2. Analysis:
   - EXPLAIN ANALYZE (query plans)
   - Rails.logger (request logs)
   - memory_profiler (memory leaks)
   - derailed_benchmarks (performance testing)

3. Prevention:
   - Code reviews focusing on performance
   - Performance budgets (page load &lt; 1s)
   - Automated alerts for slow endpoints
   - Regular performance testing in staging

LESSONS LEARNED:

1. Monitor first, optimize second
2. Database optimization yields highest ROI
3. Caching is powerful but needs invalidation strategy
4. N+1 queries are the #1 Rails performance issue
5. Always test performance fixes with production-like data&quot;
</code></pre>
<hr>
<h2>Question 365: Have you worked in Agile/Scrum? What was your role?</h2>
<h3>Answer Template</h3>
<pre><code>&quot;Yes, I&#39;ve worked in Agile/Scrum environments for [X] years across 
multiple teams and projects.

MY ROLES:

As Developer:
- Participated in daily standups (15 minutes)
- Contributed to sprint planning and estimation
- Delivered features within 2-week sprints
- Participated in retrospectives and demos
- Pair programmed on complex features
- Reviewed team members&#39; pull requests

As Technical Lead (Last 2 years):
- Led sprint planning sessions
- Broke down epics into user stories
- Estimated story points with team (planning poker)
- Identified technical risks and dependencies
- Mentored junior developers
- Made architectural decisions
- Facilitated technical discussions in retrospectives

SPECIFIC PRACTICES:

Sprint Planning:
- 2-week sprints
- Story point estimation (Fibonacci: 1, 2, 3, 5, 8, 13)
- Velocity tracking (average 40 points per sprint)
- Definition of Done checklist:
  * Code complete
  * Tests passing (&gt;90% coverage)
  * Code reviewed and approved
  * Deployed to staging
  * QA verified
  * Documentation updated

Daily Standups:
- What I did yesterday
- What I&#39;ll do today
- Any blockers
- Keep it to 15 minutes
- Detailed discussions taken offline

Code Reviews:
- All code requires 2 approvals before merge
- Review within 4 hours
- Check: functionality, tests, performance, security
- Leave constructive feedback
- Use GitHub PR templates

Sprint Retrospectives:
- What went well
- What didn&#39;t go well
- Action items for next sprint
- Examples from my retros:
  * Added linting rules after code style discussions
  * Implemented pairing on complex features
  * Created technical debt backlog

Tools Used:
- Jira for sprint board and backlog
- GitHub for code reviews and CI/CD
- Slack for team communication
- Confluence for documentation
- Zoom for remote ceremonies

CHALLENGES AND HOW I ADDRESSED THEM:

Challenge 1: Scope Creep
- Sprint goals kept expanding mid-sprint
- Solution: Implemented strict definition of sprint commitment
- New requests go to backlog for next sprint
- Only critical bugs interrupt sprint

Challenge 2: Unbalanced Workload
- Some developers overloaded, others underutilized
- Solution: Improved story point estimation
- Encouraged pair programming on complex tasks
- Better breakdown of large stories

Challenge 3: Technical Debt
- Always deprioritized for features
- Solution: Allocated 20% of sprint capacity to tech debt
- Tracked technical debt in backlog
- Demonstrated ROI of debt reduction

RESULTS:

Team Metrics:
- Consistent velocity (35-45 points/sprint)
- 95% sprint commitment achieved
- Reduced bug count by 40%
- Improved deployment frequency (2x/week → daily)

Personal Growth:
- Learned to balance speed with quality
- Improved estimation accuracy
- Better stakeholder communication
- Enhanced collaboration skills

KEY LEARNINGS:

1. Agile is about people, not process
2. Regular retrospectives drive continuous improvement
3. Short feedback loops catch issues early
4. Team autonomy leads to better outcomes
5. Documentation is crucial for distributed teams&quot;
</code></pre>
<hr>
<h2>Question 366: How do you handle code reviews and pull requests in a team?</h2>
<h3>Answer</h3>
<pre><code>MY CODE REVIEW PHILOSOPHY:

&quot;Code reviews are about learning, sharing knowledge, and maintaining 
quality - not finding faults.&quot;

AS A REVIEWER:

1. REVIEW PROMPTLY
   - Respond within 4 hours during work hours
   - Longer reviews scheduled as pair review sessions
   - Set GitHub notifications for my team&#39;s PRs

2. FOCUS AREAS (In Order of Priority)
   
   a) Functionality &amp; Logic:
      - Does it solve the problem correctly?
      - Are edge cases handled?
      - Is error handling appropriate?
   
   b) Security:
      - SQL injection vulnerabilities
      - XSS vulnerabilities
      - Authentication/authorization checks
      - Sensitive data exposure
   
   c) Performance:
      - N+1 queries
      - Missing indexes
      - Inefficient algorithms
      - Memory usage
   
   d) Tests:
      - Adequate test coverage (&gt;90%)
      - Tests are meaningful (not just passing)
      - Edge cases covered
      - Integration tests for critical paths
   
   e) Code Quality:
      - DRY principle followed
      - SOLID principles
      - Clear naming
      - Appropriate abstraction level
   
   f) Style &amp; Conventions:
      - Follows team style guide
      - RuboCop passing
      - Consistent with codebase patterns

3. PROVIDING FEEDBACK

   Structure:
   - Start positive: &quot;Nice approach to handling X&quot;
   - Be specific: Not &quot;This is wrong&quot;, but &quot;This could cause N+1 queries&quot;
   - Suggest solutions: Include code examples
   - Distinguish must-fix vs. nice-to-have
   - Ask questions: &quot;Have you considered...?&quot;

   Example Comments:
   
   ✅ GOOD:
   &quot;This query will cause an N+1 issue when loading posts. Consider:
   
   @users = User.includes(:posts).where(active: true)
   
   This reduces queries from N+1 to 2. What do you think?&quot;
   
   ❌ BAD:
   &quot;N+1 query here. Fix it.&quot;

   Comment Categories:
   - 🔴 BLOCKER: Must fix before merge (security, major bugs)
   - 🟡 IMPORTANT: Should fix (performance, maintainability)
   - 🟢 NITPICK: Nice to have (style, small improvements)
   - 💭 QUESTION: Seeking clarification

4. APPROVAL CRITERIA

   Approve when:
   - All blockers resolved
   - Tests passing
   - No security concerns
   - Performance acceptable
   - Code is maintainable
   
   Request changes when:
   - Critical bugs present
   - Security vulnerabilities
   - Major performance issues
   - Missing critical tests

AS AN AUTHOR:

1. BEFORE CREATING PR

   Self-review checklist:
   - [ ] All tests passing locally
   - [ ] RuboCop violations fixed
   - [ ] No commented-out code
   - [ ] No debug statements (binding.pry, console.log)
   - [ ] Added/updated tests
   - [ ] Updated documentation
   - [ ] Checked for N+1 queries (Bullet gem)
   - [ ] Verified database migrations (rollback test)

2. PR DESCRIPTION

   Template I use:
   ```markdown
   ## What
   Brief description of changes
   
   ## Why
   Link to Jira ticket / Issue #123
   Problem being solved
   
   ## How
   Technical approach
   Key decisions made
   
   ## Testing
   - [ ] Unit tests added
   - [ ] Integration tests added
   - [ ] Manual testing done
   
   ## Screenshots (if UI changes)
   Before / After images
   
   ## Deployment Notes
   - Requires migration: Yes/No
   - Environment variables: None
   - Feature flag: off by default
</code></pre>
<ol start="3">
<li><p>RESPONDING TO FEEDBACK</p>
<ul>
<li>Respond to all comments (even nitpicks)</li>
<li>If disagreeing, explain reasoning constructively</li>
<li>If agreeing, fix and reply &quot;Fixed in abc123&quot;</li>
<li>Ask for clarification if unclear</li>
<li>Thank reviewers for catching issues</li>
</ul>
<p>Example responses:
&quot;Great catch! Fixed in commit abc123&quot;
&quot;I considered that approach, but went with X because...&quot;
&quot;Can you clarify what you mean by...?&quot;</p>
</li>
<li><p>KEEPING PRs SMALL</p>
<p>Guidelines:</p>
<ul>
<li>&lt; 400 lines of code changes</li>
<li>Single responsibility (one feature/fix)</li>
<li>If larger, break into multiple PRs</li>
<li>Use feature flags for partial features</li>
</ul>
</li>
</ol>
<p>TEAM PRACTICES:</p>
<ol>
<li><p>PR Requirements:</p>
<ul>
<li>Minimum 2 approvals</li>
<li>All CI checks passing</li>
<li>No unresolved conversations</li>
<li>Up to date with main branch</li>
</ul>
</li>
<li><p>Review Rotation:</p>
<ul>
<li>Assign 2 reviewers automatically</li>
<li>Junior + Senior pairing</li>
<li>Domain expert for complex features</li>
</ul>
</li>
<li><p>Pair Reviews:</p>
<ul>
<li>For complex PRs (&gt;500 lines)</li>
<li>Screen sharing session</li>
<li>30-60 minute dedicated time</li>
</ul>
</li>
<li><p>Code Review Metrics We Track:</p>
<ul>
<li>Time to first review</li>
<li>Time to merge</li>
<li>Number of review cycles</li>
<li>Bug escape rate</li>
</ul>
</li>
</ol>
<p>EXAMPLES FROM MY EXPERIENCE:</p>
<p>Example 1: Security Issue Caught
Issue: PR was storing passwords in plain text
Comment: &quot;🔴 BLOCKER: Passwords should never be stored in plain text. 
Use has_secure_password with bcrypt. Example:</p>
<p>class User &lt; ApplicationRecord
  has_secure_password
end</p>
<p>This automatically handles encryption.&quot;</p>
<p>Result: Developer learned about secure password storage</p>
<p>Example 2: Performance Optimization
Issue: Loading all records in controller
Comment: &quot;🟡 This loads all 100k records into memory. Consider pagination:</p>
<p>@users = User.page(params[:page]).per(25)</p>
<p>or if you need all records, use find_each:</p>
<p>User.find_each(batch_size: 1000) do |user|
  process(user)
end&quot;</p>
<p>Result: Implemented pagination, avoided OOM issues</p>
<p>Example 3: Test Coverage
Issue: Missing edge case tests
Comment: &quot;💭 What happens if the user is nil? Could you add a test for:</p>
<p>it &#39;handles nil user gracefully&#39; do
  result = described_class.call(user: nil)
  expect(result).to be_failure
end&quot;</p>
<p>Result: Edge case bug found and fixed</p>
<p>DIFFICULT SITUATIONS:</p>
<p>Situation 1: Author Defensive</p>
<ul>
<li>Stay professional and focus on code, not person</li>
<li>Use &quot;we&quot; language: &quot;Should we consider...&quot;</li>
<li>Offer to pair program if repeated friction</li>
</ul>
<p>Situation 2: Disagreement on Approach</p>
<ul>
<li>Have synchronous discussion (call/meeting)</li>
<li>Document decision in PR for future reference</li>
<li>Defer to team lead if no consensus</li>
<li>Remember: &quot;Better is the enemy of good enough&quot;</li>
</ul>
<p>Situation 3: Emergency Hotfix</p>
<ul>
<li>Reduced review process (1 approval)</li>
<li>Focus only on security and critical bugs</li>
<li>Follow up with detailed review post-merge</li>
<li>Document in PR: &quot;HOTFIX - detailed review to follow&quot;</li>
</ul>
<p>KEY PRINCIPLES:</p>
<ol>
<li>Be kind and constructive</li>
<li>Assume positive intent</li>
<li>Teach, don&#39;t just critique</li>
<li>Recognize good work</li>
<li>Review code, not people</li>
<li>Pick your battles (not every nitpick matters)</li>
<li>Fast reviews keep momentum</li>
<li>Everyone&#39;s code can improve (including mine)</li>
</ol>
<p>IMPACT:</p>
<ul>
<li>Reduced production bugs by 60%</li>
<li>Improved code quality scores (CodeClimate: B → A)</li>
<li>Team velocity increased (less rework)</li>
<li>Junior developers ramped up faster</li>
<li>Shared knowledge across team</li>
<li>Better architectural consistency&quot;</li>
</ul>
<pre><code>
---

## Question 367: What is the biggest mistake you made in a project, and how did you resolve it?

### Answer Template
</code></pre>
<p>&quot;One of my biggest mistakes happened early in my career, and it taught 
me valuable lessons about testing and database operations.</p>
<p>THE MISTAKE:</p>
<p>Project: E-commerce platform with 500k users
Task: Implement soft delete for user accounts (to comply with GDPR)
My Approach: Added deleted_at column and updated User model</p>
<p>What I Did Wrong:</p>
<ol>
<li><p>Wrote migration to add deleted_at column</p>
</li>
<li><p>Updated User model with default_scope to filter deleted users:</p>
<p>class User &lt; ApplicationRecord
  default_scope { where(deleted_at: nil) }
end</p>
</li>
<li><p>Tested manually with a few test accounts</p>
</li>
<li><p>Got code review approval (they didn&#39;t catch it either)</p>
</li>
<li><p>Deployed to production on Friday afternoon (first red flag!)</p>
</li>
</ol>
<p>THE DISASTER:</p>
<p>Within 30 minutes of deployment:</p>
<ul>
<li>Customer support flooded with complaints</li>
<li>Users couldn&#39;t log in</li>
<li>Admin dashboard showing 0 users</li>
<li>Orders failing to process</li>
<li>Email jobs failing</li>
</ul>
<p>Root Cause Analysis:
The default_scope affected ALL User queries including:</p>
<ul>
<li>Authentication: User.find_by(email: email) returned nil for all users!</li>
<li>The migration added deleted_at column</li>
<li>PostgreSQL default for new columns is NULL</li>
<li>But my code treated NULL as &quot;deleted&quot; </li>
<li>ALL users appeared deleted!</li>
</ul>
<p>THE FIX (Under Pressure):</p>
<p>Immediate Actions (15 minutes):</p>
<ol>
<li><p>Rolled back deployment
git revert HEAD
git push origin main
Deploy to production</p>
</li>
<li><p>Database remained in broken state (deleted_at = NULL)</p>
</li>
<li><p>Created emergency hotfix:</p>
<h1>Update all users to explicitly not deleted</h1>
<p>User.unscoped.update_all(deleted_at: nil)</p>
<h1>This didn&#39;t work because of default_scope!</h1>
<h1>Had to use:</h1>
<p>ActiveRecord::Base.connection.execute(
  &quot;UPDATE users SET deleted_at = NULL&quot;
)</p>
</li>
<li><p>Deployed hotfix (30 minutes from incident)</p>
</li>
<li><p>Verified services restored:</p>
<ul>
<li>Users could log in ✓</li>
<li>Orders processing ✓</li>
<li>Admin dashboard working ✓</li>
</ul>
</li>
</ol>
<p>Post-Incident (Next Day):</p>
<ol>
<li><p>Proper Fix:</p>
<h1>Removed default_scope</h1>
<p>class User &lt; ApplicationRecord</p>
<h1>default_scope { where(deleted_at: nil) }  # REMOVED</h1>
<p>  scope :active, -&gt; { where(deleted_at: nil) }
  scope :deleted, -&gt; { where.not(deleted_at: nil) }
end</p>
<h1>Updated all queries to use explicit scope</h1>
<p>User.active.find_by(email: email)</p>
<h1>Added explicit validation</h1>
<p>validates :deleted_at, absence: true, on: :create</p>
</li>
<li><p>Better Migration:
class AddDeletedAtToUsers &lt; ActiveRecord::Migration[6.0]
  def change
add_column :users, :deleted_at, :datetime

# Explicitly set existing records to not deleted
reversible do |dir|
  dir.up do
    # In up migration, no need to update (NULL is fine temporarily)
  end
end
  end
end</p>
</li>
</ol>
<p>WHAT I LEARNED:</p>
<p>Technical Lessons:</p>
<ol>
<li><p>Default Scopes Are Dangerous</p>
<ul>
<li>They affect ALL queries (including internal Rails operations)</li>
<li>Hard to debug when they cause issues</li>
<li>Better to use explicit scopes</li>
<li>Only use for truly global conditions</li>
</ul>
</li>
<li><p>NULL Handling</p>
<ul>
<li>Be explicit about NULL vs. specific values</li>
<li>Document what NULL means</li>
<li>Use database constraints when possible:
add_column :users, :deleted_at, :datetime, default: -&gt; { &#39;NULL&#39; }</li>
</ul>
</li>
<li><p>Testing Production Scenarios</p>
<ul>
<li>Manual testing isn&#39;t enough</li>
<li>Need automated integration tests</li>
<li>Should have tested:<ul>
<li>User authentication with new column</li>
<li>Existing user queries</li>
<li>Admin functionality</li>
</ul>
</li>
</ul>
<p>Integration test I wrote afterward:</p>
<p>describe &#39;User soft delete&#39; do
  let(:user) { create(:user) }</p>
<p>  context &#39;active user&#39; do
    it &#39;can authenticate&#39; do
      expect(User.find_by(email: user.email)).to eq(user)
    end</p>
<pre><code>it &#39;appears in active scope&#39; do
  expect(User.active).to include(user)
end
</code></pre>
<p>  end</p>
<p>  context &#39;deleted user&#39; do
    before { user.update(deleted_at: Time.current) }</p>
<pre><code>it &#39;cannot authenticate&#39; do
  expect(User.active.find_by(email: user.email)).to be_nil
end

it &#39;still exists in database&#39; do
  expect(User.unscoped.find(user.id)).to eq(user)
end
</code></pre>
<p>  end
end</p>
</li>
<li><p>Deployment Timing</p>
<ul>
<li>Never deploy major changes on Friday</li>
<li>Never deploy without full team available</li>
<li>Always have rollback plan</li>
</ul>
</li>
</ol>
<p>Process Lessons:</p>
<ol>
<li><p>Code Review Improvements</p>
<ul>
<li>Reviewers now specifically check for default_scope</li>
<li>Checklist item: &quot;Database columns nullable?&quot;</li>
<li>Required to show migration + rollback tested</li>
</ul>
</li>
<li><p>Staging Environment</p>
<ul>
<li>Deployed to staging with production-like data</li>
<li>Ran full test suite against staging</li>
<li>Had QA verify critical paths</li>
</ul>
</li>
<li><p>Feature Flags</p>
<ul>
<li><p>Implemented feature flag for soft delete:</p>
<p>def deleted?
  return false unless FeatureFlag.enabled?(:soft_delete)
  deleted_at.present?
end</p>
</li>
<li><p>Gradual rollout: 1% → 10% → 50% → 100%</p>
</li>
</ul>
</li>
<li><p>Monitoring &amp; Alerts</p>
<ul>
<li>Added alerts for login failure rate</li>
<li>Dashboard for key metrics</li>
<li>Would have caught issue in 1 minute instead of 15</li>
</ul>
</li>
<li><p>Communication</p>
<ul>
<li>Notified team immediately when I realized issue</li>
<li>Sent post-mortem to entire engineering team</li>
<li>Shared learnings in company-wide meeting</li>
</ul>
</li>
<li><p>Documentation</p>
<ul>
<li>Wrote detailed post-mortem document</li>
<li>Updated deployment runbook</li>
<li>Created &quot;Common Rails Pitfalls&quot; guide</li>
</ul>
</li>
</ol>
<p>POSITIVE OUTCOMES:</p>
<ol>
<li>Learned More From This Mistake Than From 10 Successes</li>
<li>Team Implemented Better Processes (helped everyone)</li>
<li>Gained Trust By Owning Mistake Completely</li>
<li>Became Go-To Person For Database Migrations</li>
<li>Wrote Blog Post That Helped Other Developers</li>
</ol>
<p>POST-MORTEM TEMPLATE WE CREATED:</p>
<pre><code class="language-markdown">## Incident Post-Mortem

### What Happened
- Timeline of events
- User impact
- System impact

### Root Cause
- Technical root cause
- Process root cause

### Resolution
- Immediate fix
- Permanent fix
- Verification

### Lessons Learned
- What went wrong
- What went right
- What we&#39;ll do differently

### Action Items
- [ ] Item 1 (Owner: Name, Due: Date)
- [ ] Item 2 (Owner: Name, Due: Date)
</code></pre>
<p>THE REAL LESSON:</p>
<p>Mistakes are inevitable. What matters is:</p>
<ol>
<li>Own them immediately</li>
<li>Fix them quickly</li>
<li>Learn from them deeply</li>
<li>Share learnings openly</li>
<li>Improve processes</li>
<li>Move forward</li>
</ol>
<p>This mistake made me a significantly better engineer. I&#39;m now extremely 
careful with:</p>
<ul>
<li>Default scopes (almost never use them)</li>
<li>NULL handling in migrations</li>
<li>Testing with production-like scenarios</li>
<li>Deployment timing and rollback plans</li>
<li>Communication during incidents</li>
</ul>
<p>When junior developers make mistakes now, I share this story to show 
that everyone makes mistakes, and the important thing is learning 
from them.&quot;</p>
<pre><code>
---

## Question 368: How do you mentor junior developers in your team?

### Answer
</code></pre>
<p>MY MENTORING PHILOSOPHY:</p>
<p>&quot;Great mentoring is about empowering developers to solve problems 
independently, not just giving them answers.&quot;</p>
<p>FORMAL MENTORING STRUCTURE:</p>
<ol>
<li><p>Initial Setup (Week 1)</p>
<p>One-on-one meeting to discuss:</p>
<ul>
<li>Career goals and interests</li>
<li>Current skill level</li>
<li>Learning style (hands-on, reading, pair programming)</li>
<li>Areas they want to improve</li>
</ul>
<p>Create 90-day development plan:</p>
<ul>
<li>Short-term goals (30 days)</li>
<li>Medium-term goals (60 days)</li>
<li>Long-term goals (90 days)</li>
</ul>
<p>Example 90-Day Plan:</p>
<pre><code>30 Days:
- Complete onboarding tasks
- Merge first PR independently
- Understand codebase architecture
- Learn team workflows

60 Days:
- Handle medium-complexity features
- Conduct first code review
- Debug production issue independently
- Present in team meeting

90 Days:
- Lead small feature from design to deploy
- Mentor new team member
- Contribute to architectural decisions
- Improve existing system (refactoring project)
</code></pre>
</li>
<li><p>Regular Check-ins</p>
<p>Weekly 1-on-1 (30 minutes):</p>
<ul>
<li>Review progress on current tasks</li>
<li>Discuss blockers</li>
<li>Answer technical questions</li>
<li>Provide feedback on recent work</li>
</ul>
<p>Monthly Review (60 minutes):</p>
<ul>
<li>Progress toward 90-day goals</li>
<li>Adjust goals if needed</li>
<li>Discuss career growth</li>
<li>Technical deep dive on interesting topic</li>
</ul>
</li>
</ol>
<p>DAILY MENTORING APPROACHES:</p>
<ol>
<li><p>PAIR PROGRAMMING</p>
<p>When to use:</p>
<ul>
<li>New feature they haven&#39;t seen before</li>
<li>Complex debugging session</li>
<li>Introducing new pattern or tool</li>
<li>Their first time doing something (first PR, first deployment)</li>
</ul>
<p>My approach:</p>
<ul>
<li>Start with them driving, I navigate</li>
<li>Ask questions instead of giving answers:
&quot;What do you think is causing this?&quot;
&quot;How would you approach solving this?&quot;</li>
<li>Gradually let them take more control</li>
<li>Explain my thinking process out loud</li>
</ul>
<p>Example Session:</p>
<pre><code>Task: Implement search with Elasticsearch

Hour 1: I drive, explain concepts
- Show Elasticsearch basics
- Explain indexing strategy
- Demonstrate query DSL

Hour 2: They drive, I guide
- They write the code
- I ask: &quot;What happens if search returns no results?&quot;
- I point out potential issues
- They fix problems

Hour 3: They drive solo
- I only speak when they ask
- They implement tests
- They handle edge cases
- I review final code
</code></pre>
</li>
<li><p>CODE REVIEW AS TEACHING</p>
<p>Instead of just approving/rejecting, I use reviews to teach:</p>
<p>Example 1: Teaching Design Patterns</p>
<pre><code>Their code:
if user.admin?
  # 50 lines of admin logic
elsif user.moderator?
  # 40 lines of moderator logic
elsif user.regular?
  # 30 lines of regular logic
end

My comment:
&quot;This is a good start! As the number of roles grows, this will 
become hard to maintain. Have you considered the Strategy pattern?

class AdminPermissionStrategy
  def can_edit?(resource)
    true  # Admins can edit anything
  end
end

class ModeratorPermissionStrategy
  def can_edit?(resource)
    resource.created_at &gt; 7.days.ago
  end
end

user.permission_strategy.can_edit?(post)

This makes it easier to add new roles and test each in isolation.
Want to pair on refactoring this?&quot;
</code></pre>
<p>Example 2: Teaching Performance</p>
<pre><code>Their code:
@posts = Post.all
@posts.each do |post|
  post.comments.count  # N+1 query!
end

My comment:
&quot;This will cause performance issues with many posts. Let&#39;s use 
Bullet gem to detect N+1 queries:

# In development.rb
config.after_initialize do
  Bullet.enable = true
  Bullet.alert = true
end

Then fix with:
@posts = Post.includes(:comments).all

Can you test this and confirm queries reduced? Use the Rails log.&quot;
</code></pre>
</li>
<li><p>ASYNC LEARNING</p>
<p>Resources I create/share:</p>
<p>a) Internal Wiki Pages:</p>
<ul>
<li>&quot;Our Rails Architecture Patterns&quot;</li>
<li>&quot;How to Debug Production Issues&quot;</li>
<li>&quot;Database Query Optimization Guide&quot;</li>
<li>&quot;Testing Best Practices&quot;</li>
</ul>
<p>b) Code Examples Library:</p>
<ul>
<li>Service objects template</li>
<li>Background job template</li>
<li>API controller template</li>
<li>RSpec test template</li>
</ul>
<p>c) Video Recordings:</p>
<ul>
<li>Screen recordings of me solving problems</li>
<li>Architecture decision walkthroughs</li>
<li>Debugging sessions</li>
</ul>
<p>d) Reading Recommendations:</p>
<ul>
<li>&quot;99 Bottles of OOP&quot; for refactoring</li>
<li>&quot;Practical Object-Oriented Design in Ruby&quot; (POODR)</li>
<li>&quot;Rails AntiPatterns&quot;</li>
<li>Specific blog posts for current challenges</li>
</ul>
</li>
<li><p>GRADUATED RESPONSIBILITY</p>
<p>Start small, increase complexity:</p>
<p>Week 1-2: Bug Fixes</p>
<ul>
<li>Assign clear, small bugs</li>
<li>Provide detailed context</li>
<li>Review thoroughly with explanations</li>
</ul>
<p>Week 3-4: Small Features</p>
<ul>
<li>Well-defined requirements</li>
<li>Existing patterns to follow</li>
<li>Available for questions</li>
</ul>
<p>Week 5-8: Medium Features</p>
<ul>
<li>Some ambiguity in requirements</li>
<li>Need to make some decisions</li>
<li>Less hand-holding</li>
</ul>
<p>Week 9+: Complex Features</p>
<ul>
<li>Design decisions required</li>
<li>Multiple approaches possible</li>
<li>They lead implementation</li>
</ul>
<p>Example progression for one mentee:</p>
<pre><code>Week 1: Fix validation error message
Week 2: Add new field to form
Week 3: Implement email notifications
Week 5: Build CSV export feature
Week 7: Design and implement search
Week 10: Lead refactoring of payment system
</code></pre>
</li>
</ol>
<p>SPECIFIC TEACHING TECHNIQUES:</p>
<ol>
<li><p>SOCRATIC METHOD</p>
<p>Instead of:
&quot;The problem is you&#39;re missing an index. Add one.&quot;</p>
<p>I ask:
&quot;What do you notice about the query performance?&quot;
→ &quot;It&#39;s slow&quot;</p>
<p>&quot;What does the EXPLAIN output show?&quot;
→ &quot;Sequential scan&quot;</p>
<p>&quot;What could make this faster?&quot;
→ &quot;An index?&quot;</p>
<p>&quot;Great! What columns should we index?&quot;
→ They figure it out themselves</p>
</li>
<li><p>RUBBER DUCK DEBUGGING</p>
<p>When they&#39;re stuck:
&quot;Explain the problem to me line by line&quot;</p>
<p>Often they solve it while explaining!
This teaches them to debug independently.</p>
</li>
<li><p>SHOW YOUR WORK</p>
<p>When I solve a problem:
&quot;Let me share my screen and talk through my thinking...&quot;</p>
<p>I narrate my debugging process:</p>
<ul>
<li>&quot;First, I check the logs for errors...&quot;</li>
<li>&quot;Now I&#39;m adding puts statements to see variable values...&quot;</li>
<li>&quot;This tells me the issue is in the database query...&quot;</li>
<li>&quot;Let me try EXPLAIN to see the query plan...&quot;</li>
</ul>
</li>
<li><p>CELEBRATE WINS</p>
<p>Public recognition:</p>
<ul>
<li>&quot;Great PR by @junior_dev - clean code and thorough tests!&quot;</li>
<li>Share their solution in team meeting</li>
<li>Nominate for company recognition</li>
</ul>
<p>Private encouragement:</p>
<ul>
<li>&quot;Your code quality has improved significantly&quot;</li>
<li>&quot;I noticed you caught that edge case - good thinking!&quot;</li>
<li>&quot;You&#39;re ready for more complex features&quot;</li>
</ul>
</li>
</ol>
<p>HANDLING COMMON SITUATIONS:</p>
<ol>
<li><p>They&#39;re Stuck (30+ minutes)</p>
<p>Don&#39;t immediately solve it:</p>
<p>First: &quot;What have you tried so far?&quot;
Then: &quot;What do the error messages say?&quot;
Then: &quot;Let&#39;s debug this together&quot;
Finally: &quot;Here&#39;s one approach that might work...&quot;</p>
</li>
<li><p>They Made a Mistake</p>
<p>Focus on learning, not blame:</p>
<p>&quot;I see the issue. Let&#39;s talk through what happened and how 
to prevent it next time.&quot;</p>
<p>&quot;What tests could we write to catch this earlier?&quot;</p>
<p>Share my own similar mistakes: &quot;I did the same thing once...&quot;</p>
</li>
<li><p>They&#39;re Struggling with Concept</p>
<p>Multiple approaches:</p>
<ul>
<li>Draw diagrams</li>
<li>Use analogies: &quot;Think of it like...&quot;</li>
<li>Pair program to show in practice</li>
<li>Share article/video explaining it</li>
<li>Create simple example project</li>
</ul>
</li>
<li><p>They&#39;re Moving Too Fast</p>
<p>&quot;Your code works, but let&#39;s discuss maintainability...&quot;</p>
<p>Guide toward:</p>
<ul>
<li>Better naming</li>
<li>Simpler solutions</li>
<li>More tests</li>
<li>Documentation</li>
</ul>
</li>
<li><p>They&#39;re Too Slow/Perfectionist</p>
<p>&quot;This is good enough for now. Perfect is the enemy of done.&quot;</p>
<p>&quot;We can refactor later if needed. Let&#39;s ship this.&quot;</p>
</li>
</ol>
<p>MEASURING SUCCESS:</p>
<p>Quantitative:</p>
<ul>
<li>PRs merged per week</li>
<li>Code review comments decreasing</li>
<li>Time to complete tasks</li>
<li>Test coverage of their code</li>
<li>Bug rate in their code</li>
</ul>
<p>Qualitative:</p>
<ul>
<li>Confidence in asking questions</li>
<li>Willingness to take on challenges</li>
<li>Helping other team members</li>
<li>Contributing ideas in meetings</li>
<li>Problem-solving independently</li>
</ul>
<p>RESOURCES I&#39;VE CREATED:</p>
<ol>
<li><p>&quot;Junior Dev Checklist&quot;</p>
<ul>
<li><input disabled="" type="checkbox"> Understand the problem before coding</li>
<li><input disabled="" type="checkbox"> Write tests first (TDD)</li>
<li><input disabled="" type="checkbox"> Keep PRs small (&lt;400 lines)</li>
<li><input disabled="" type="checkbox"> Check for N+1 queries (Bullet)</li>
<li><input disabled="" type="checkbox"> Add error handling</li>
<li><input disabled="" type="checkbox"> Update documentation</li>
<li><input disabled="" type="checkbox"> Self-review before submitting</li>
<li><input disabled="" type="checkbox"> Respond to review feedback promptly</li>
</ul>
</li>
<li><p>&quot;Debugging Flowchart&quot;</p>
<ul>
<li>Read error message carefully</li>
<li>Check recent changes (git diff)</li>
<li>Add logging/debugging</li>
<li>Reproduce in console/debugger</li>
<li>Google error if unfamiliar</li>
<li>Check Stack Overflow</li>
<li>Ask team in Slack</li>
<li>Schedule 1-on-1 if still stuck</li>
</ul>
</li>
<li><p>&quot;Rails Best Practices&quot; Doc</p>
<ul>
<li>Database: indexes, N+1, batch processing</li>
<li>Security: strong params, SQL injection, XSS</li>
<li>Performance: caching, background jobs</li>
<li>Testing: unit, integration, coverage</li>
<li>Code quality: naming, DRY, SOLID</li>
</ul>
</li>
</ol>
<p>THINGS I&#39;VE LEARNED AS A MENTOR:</p>
<ol>
<li><p>Everyone learns differently</p>
<ul>
<li>Some need step-by-step instructions</li>
<li>Some learn best by doing</li>
<li>Some need to understand theory first</li>
</ul>
</li>
<li><p>Patience is crucial</p>
<ul>
<li>What&#39;s obvious to me isn&#39;t to them</li>
<li>Let them struggle (within reason)</li>
<li>Mistakes are learning opportunities</li>
</ul>
</li>
<li><p>Psychological safety matters</p>
<ul>
<li>&quot;There are no stupid questions&quot;</li>
<li>Admit when I don&#39;t know something</li>
<li>Share my own mistakes</li>
</ul>
</li>
<li><p>Balance is key</p>
<ul>
<li>Too much help = dependency</li>
<li>Too little help = frustration</li>
<li>Find the right level for each person</li>
</ul>
</li>
<li><p>Celebrate progress</p>
<ul>
<li>Notice improvements</li>
<li>Acknowledge effort</li>
<li>Build confidence</li>
</ul>
</li>
</ol>
<p>SUCCESS STORIES:</p>
<p>Mentee 1:</p>
<ul>
<li>Started: Struggled with basic Rails concepts</li>
<li>After 6 months: Independently built payment integration</li>
<li>After 1 year: Mentoring other juniors</li>
<li>Now: Senior developer at company</li>
</ul>
<p>Mentee 2:</p>
<ul>
<li>Started: CS degree but no production experience</li>
<li>After 3 months: Comfortable with full feature development</li>
<li>After 6 months: Led database migration with millions of records</li>
<li>Now: Technical lead on critical project</li>
</ul>
<p>THE MOST REWARDING PART:</p>
<p>Watching them grow from asking &quot;How do I do this?&quot; to showing 
me new techniques they learned. The best moment is when they 
start mentoring others - that&#39;s when you know they&#39;ve truly 
grown as developers.&quot;</p>
<pre><code>
This comprehensive answer demonstrates real mentoring experience, specific techniques, measurable outcomes, and genuine care for developing others - key qualities companies look for in senior developers and tech leads.

---

## Scenario-Based Questions

These questions test your ability to handle real-world challenges and demonstrate problem-solving methodology, technical depth, and communication skills.

[Due to length, the remaining scenario-based questions Q369-376 will be completed in the next response with equal depth and practical examples]

Would you like me to continue with the remaining scenario-based questions (Q369-376)?

ENDOFFILE

## Scenario-Based Questions (Continued)

## Question 369: Your Rails application has a slow query causing performance issues. How do you debug and optimize it?

### Answer

**Systematic Approach to Query Optimization:**
</code></pre>
<p>SCENARIO: Dashboard loading slowly (8+ seconds), database CPU at 90%</p>
<p>STEP 1: IDENTIFY THE SLOW QUERY (10 minutes)</p>
<p>Tools &amp; Methods:</p>
<ol>
<li><p>Check Rails logs:
tail -f log/production.log | grep &quot;Completed in&quot;</p>
<h1>Look for requests taking &gt;1000ms</h1>
</li>
<li><p>Use APM tools:</p>
<ul>
<li>New Relic &quot;Slow SQL Queries&quot;</li>
<li>Scout APM &quot;Database Time&quot;</li>
<li>Skylight &quot;Most Time-Consuming Queries&quot;</li>
</ul>
</li>
<li><p>Check database slow query log:</p>
<h1>PostgreSQL</h1>
<p>ALTER DATABASE mydb SET log_min_duration_statement = 1000;</p>
<h1>Queries &gt;1s logged to /var/log/postgresql/</h1>
</li>
<li><p>Capture query in production:</p>
<h1>Add to controller temporarily</h1>
<p>ActiveSupport::Notifications.subscribe &quot;sql.active_record&quot; do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  if event.duration &gt; 1000
Rails.logger.error(&quot;SLOW QUERY: #{event.duration}ms: #{event.payload[:sql]}&quot;)
  end
end</p>
</li>
</ol>
<p>Found Query:
SELECT users.<em>, 
       (SELECT COUNT(</em>) FROM posts WHERE posts.user_id = users.id) as posts_count,
       (SELECT COUNT(*) FROM comments WHERE comments.user_id = users.id) as comments_count
FROM users
WHERE users.created_at &gt; &#39;2024-01-01&#39;
ORDER BY users.created_at DESC</p>
<p>Time: 8,247ms
Rows: 5,000</p>
<p>STEP 2: ANALYZE QUERY PLAN (5 minutes)</p>
<p>Run EXPLAIN ANALYZE:</p>
<p>EXPLAIN ANALYZE
SELECT users.<em>, 
       (SELECT COUNT(</em>) FROM posts WHERE posts.user_id = users.id),
       (SELECT COUNT(*) FROM comments WHERE comments.user_id = users.id)
FROM users
WHERE users.created_at &gt; &#39;2024-01-01&#39;
ORDER BY users.created_at DESC;</p>
<p>Output Analysis:
┌─────────────────────────────────────────────────────────────┐
│ Sort (cost=15234.21..15284.21 rows=5000 width=256)         │
│   Sort Key: created_at DESC                                  │
│   -&gt;  Seq Scan on users (cost=0.00..14234.21 rows=5000)    │ ← RED FLAG!
│         Filter: (created_at &gt; &#39;2024-01-01&#39;)                 │
│         SubPlan 1                                            │
│           -&gt;  Aggregate (cost=100.00..100.01 rows=1)        │ ← RED FLAG!
│                 -&gt;  Seq Scan on posts (cost=0.00..99.99)    │
│                       Filter: (user_id = users.id)          │
│         SubPlan 2                                            │
│           -&gt;  Aggregate (cost=80.00..80.01 rows=1)          │ ← RED FLAG!
│                 -&gt;  Seq Scan on comments (cost=0.00..79.99) │
│                       Filter: (user_id = users.id)          │
└─────────────────────────────────────────────────────────────┘
Planning time: 2.1ms
Execution time: 8247.3ms</p>
<p>Problems Identified:</p>
<ol>
<li>Sequential scan on users (no index on created_at)</li>
<li>Two subqueries executed for EACH user (N+1 at database level)</li>
<li>Each subquery does sequential scan (no indexes on foreign keys)</li>
</ol>
<p>STEP 3: FIX #1 - ADD MISSING INDEXES (15 minutes)</p>
<p>Generate migration:
rails g migration AddPerformanceIndexes</p>
<p>class AddPerformanceIndexes &lt; ActiveRecord::Migration[7.0]
  def change
    # Index on users.created_at for WHERE clause
    add_index :users, :created_at</p>
<pre><code># Indexes on foreign keys for subqueries
add_index :posts, :user_id
add_index :comments, :user_id
</code></pre>
<p>  end
end</p>
<p>rails db:migrate</p>
<p>Test query again:
Time: 8,247ms → 2,143ms (74% improvement)</p>
<p>Still slow! Need more optimization.</p>
<p>STEP 4: FIX #2 - ELIMINATE SUBQUERIES (20 minutes)</p>
<p>Problem: Correlated subqueries execute once per row
Better: Use JOINs with GROUP BY</p>
<p>Optimized Query:
SELECT 
  users.*,
  COUNT(DISTINCT posts.id) as posts_count,
  COUNT(DISTINCT comments.id) as comments_count
FROM users
LEFT JOIN posts ON posts.user_id = users.id
LEFT JOIN comments ON comments.user_id = users.id
WHERE users.created_at &gt; &#39;2024-01-01&#39;
GROUP BY users.id
ORDER BY users.created_at DESC;</p>
<p>Time: 2,143ms → 287ms (87% improvement from optimized query)</p>
<p>STEP 5: IMPLEMENT IN RAILS (10 minutes)</p>
<p>Original Rails code (SLOW):
class UsersController &lt; ApplicationController
  def index
    @users = User.where(&#39;created_at &gt; ?&#39;, Date.new(2024, 1, 1))
                 .order(created_at: :desc)
  end
end</p>
<h1>In view</h1>
<p>&lt;% @users.each do |user| %&gt;
  &lt;%= user.posts.count %&gt; posts
  &lt;%= user.comments.count %&gt; comments
&lt;% end %&gt;</p>
<p>Optimized Rails code (FAST):
class UsersController &lt; ApplicationController
  def index
    @users = User.select(
               &#39;users.*&#39;,
               &#39;COUNT(DISTINCT posts.id) as posts_count&#39;,
               &#39;COUNT(DISTINCT comments.id) as comments_count&#39;
             )
             .left_joins(:posts, :comments)
             .where(&#39;users.created_at &gt; ?&#39;, Date.new(2024, 1, 1))
             .group(&#39;users.id&#39;)
             .order(created_at: :desc)
  end
end</p>
<h1>In view</h1>
<p>&lt;% @users.each do |user| %&gt;
  &lt;%= user.posts_count %&gt; posts
  &lt;%= user.comments_count %&gt; comments
&lt;% end %&gt;</p>
<p>STEP 6: ALTERNATIVE - COUNTER CACHES (30 minutes)</p>
<p>Even better for frequently accessed counts:</p>
<p>Migration:
class AddCounterCaches &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :posts_count, :integer, default: 0
    add_column :users, :comments_count, :integer, default: 0</p>
<pre><code># Backfill existing counts
reversible do |dir|
  dir.up do
    User.find_each do |user|
      User.reset_counters(user.id, :posts, :comments)
    end
  end
end
</code></pre>
<p>  end
end</p>
<p>Models:
class Post &lt; ApplicationRecord
  belongs_to :user, counter_cache: true
end</p>
<p>class Comment &lt; ApplicationRecord
  belongs_to :user, counter_cache: true
end</p>
<p>Controller (SIMPLEST &amp; FASTEST):
class UsersController &lt; ApplicationController
  def index
    @users = User.where(&#39;created_at &gt; ?&#39;, Date.new(2024, 1, 1))
                 .order(created_at: :desc)
  end
end</p>
<h1>In view - NO queries needed!</h1>
<p>&lt;% @users.each do |user| %&gt;
  &lt;%= user.posts_count %&gt; posts      # Instant (from column)
  &lt;%= user.comments_count %&gt; comments # Instant (from column)
&lt;% end %&gt;</p>
<p>Time: 287ms → 43ms (90% improvement)
Database queries: Complex JOIN → Simple SELECT</p>
<p>STEP 7: ADD PAGINATION (5 minutes)</p>
<p>Don&#39;t load all 5,000 users:</p>
<p>Gemfile:
gem &#39;kaminari&#39;</p>
<p>Controller:
class UsersController &lt; ApplicationController
  def index
    @users = User.where(&#39;created_at &gt; ?&#39;, Date.new(2024, 1, 1))
                 .order(created_at: :desc)
                 .page(params[:page])
                 .per(25)  # 25 users per page
  end
end</p>
<p>View:
&lt;%= paginate @users %&gt;</p>
<p>Time: 43ms → 12ms (loading 25 instead of 5,000)</p>
<p>STEP 8: ADD CACHING (10 minutes)</p>
<p>For frequently accessed page:</p>
<p>Controller:
class UsersController &lt; ApplicationController
  def index
    cache_key = &quot;users_index/#{params[:page]}/#{User.maximum(:updated_at)}&quot;</p>
<pre><code>@users = Rails.cache.fetch(cache_key, expires_in: 5.minutes) do
  User.where(&#39;created_at &gt; ?&#39;, Date.new(2024, 1, 1))
      .order(created_at: :desc)
      .page(params[:page])
      .per(25)
      .to_a
end
</code></pre>
<p>  end
end</p>
<p>First request: 12ms (database)
Subsequent requests: 2ms (cache hit)</p>
<p>FINAL RESULTS:</p>
<p>Original:</p>
<ul>
<li>Time: 8,247ms</li>
<li>Queries: 1 + (N × 2) = 10,001 queries for 5,000 users</li>
<li>Database CPU: 90%</li>
</ul>
<p>Optimized:</p>
<ul>
<li>Time: 2ms (99.97% faster)</li>
<li>Queries: 1 query for 25 users</li>
<li>Database CPU: 15%</li>
<li>User experience: Instant page load</li>
</ul>
<p>STEP 9: PREVENT REGRESSION (15 minutes)</p>
<ol>
<li>Add performance test:</li>
</ol>
<h1>test/performance/users_controller_test.rb</h1>
<p>require &#39;test_helper&#39;</p>
<p>class UsersControllerPerformanceTest &lt; ActionDispatch::IntegrationTest
  test &quot;index page loads in under 100ms&quot; do
    # Create test data
    100.times do |i|
      user = User.create!(name: &quot;User #{i}&quot;)
      5.times { user.posts.create!(title: &quot;Post&quot;) }
      3.times { user.comments.create!(body: &quot;Comment&quot;) }
    end</p>
<pre><code># Measure performance
start = Time.now
get users_path
duration = (Time.now - start) * 1000

assert_response :success
assert duration &lt; 100, &quot;Page took #{duration}ms (should be &lt;100ms)&quot;
</code></pre>
<p>  end
end</p>
<ol start="2">
<li>Add query count check:</li>
</ol>
<p>test &quot;index doesn&#39;t cause N+1 queries&quot; do
  users = create_list(:user, 10, :with_posts, :with_comments)</p>
<h1>Should be exactly 1 query</h1>
<p>  assert_queries(1) do
    get users_path
  end
end</p>
<ol start="3">
<li>Monitor in production:</li>
</ol>
<h1>config/initializers/query_monitor.rb</h1>
<p>ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)</p>
<p>  if event.duration &gt; 1000
    SlackNotifier.notify(
      &quot;Slow query detected: #{event.duration}ms&quot;,
      event.payload[:sql]
    )
  end
end</p>
<ol start="4">
<li>Set up alerts:</li>
</ol>
<h1>New Relic alert policy</h1>
<h1>Alert when: Database query time &gt; 1s</h1>
<h1>For: 5 minutes</h1>
<h1>Notify: #engineering-alerts Slack channel</h1>
<p>LESSONS LEARNED:</p>
<ol>
<li>Always use EXPLAIN ANALYZE first</li>
<li>Look for sequential scans (add indexes)</li>
<li>Avoid N+1 queries (use includes/joins)</li>
<li>Counter caches for frequently accessed counts</li>
<li>Paginate large result sets</li>
<li>Cache when appropriate</li>
<li>Test performance, don&#39;t assume</li>
<li>Monitor production queries</li>
<li>Document optimization for team</li>
</ol>
<p>TOOLS SUMMARY:</p>
<p>Detection:</p>
<ul>
<li>Rails logs</li>
<li>APM (New Relic, Scout, Skylight)</li>
<li>Database slow query logs</li>
<li>Bullet gem (N+1 detection)</li>
</ul>
<p>Analysis:</p>
<ul>
<li>EXPLAIN ANALYZE</li>
<li>Query plan visualizers</li>
<li>pg_stat_statements (PostgreSQL)</li>
</ul>
<p>Optimization:</p>
<ul>
<li>Indexes (add_index)</li>
<li>Eager loading (includes, joins)</li>
<li>Counter caches</li>
<li>Pagination (kaminari, pagy)</li>
<li>Caching (Rails.cache, fragment caching)</li>
</ul>
<p>Prevention:</p>
<ul>
<li>Performance tests</li>
<li>Query count assertions</li>
<li>Production monitoring</li>
<li>Alerts for slow queries</li>
</ul>
<pre><code>
---

## Question 370: You need to migrate a large database schema with minimal downtime. What is your approach?

### Answer
</code></pre>
<p>SCENARIO: Migrate 50 million user records, add new columns, change data types
Requirement: &lt;5 minutes total downtime
Current downtime for naive migration: 2+ hours</p>
<p>STRATEGY: ZERO-DOWNTIME MIGRATION</p>
<p>PHASE 1: PREPARATION (Day 1)</p>
<ol>
<li><p>Analyze Current State:</p>
<p>SELECT 
  COUNT(*) as total_rows,
  pg_size_pretty(pg_total_relation_size(&#39;users&#39;)) as total_size,
  pg_size_pretty(pg_indexes_size(&#39;users&#39;)) as index_size
FROM users;</p>
<p>Results:</p>
<ul>
<li>total_rows: 50,000,000</li>
<li>total_size: 12 GB</li>
<li>index_size: 8 GB</li>
<li>Estimated migration time: 2-3 hours (unacceptable)</li>
</ul>
</li>
<li><p>Plan Migration Strategy:</p>
<p>Changes needed:
a) Add column: email_verified (boolean)
b) Change column: phone (string → string with validation)
c) Add index: on (email, email_verified)
d) Remove column: legacy_id (no longer used)</p>
</li>
<li><p>Create Deployment Plan:</p>
<p>Multi-phase approach:</p>
<ul>
<li>Phase 1: Add new columns (non-blocking)</li>
<li>Phase 2: Backfill data (background)</li>
<li>Phase 3: Deploy code using new columns</li>
<li>Phase 4: Clean up old columns</li>
</ul>
<p>Total downtime: ~2 minutes (just for code deploy)</p>
</li>
</ol>
<p>PHASE 2: ADD NEW COLUMNS (Day 1, 5 minutes)</p>
<p>Migration 1 - Add columns without constraints:</p>
<p>class AddEmailVerifiedToUsers &lt; ActiveRecord::Migration[7.0]
  disable_ddl_transaction!  # Important for PostgreSQL</p>
<p>  def up
    # Add column without default (fast, no table rewrite)
    add_column :users, :email_verified, :boolean</p>
<pre><code># Add new phone column
add_column :users, :phone_new, :string
</code></pre>
<p>  end</p>
<p>  def down
    remove_column :users, :email_verified
    remove_column :users, :phone_new
  end
end</p>
<p>Deploy: Zero downtime
Time: ~5 seconds (just adds columns, no data changes)</p>
<p>PHASE 3: BACKFILL DATA (Day 1-2, Background)</p>
<p>Create background job to backfill:</p>
<p>class BackfillEmailVerified &lt; ApplicationJob
  queue_as :low_priority</p>
<p>  def perform(start_id, end_id)
    User.where(id: start_id..end_id).find_each(batch_size: 1000) do |user|
      user.update_column(:email_verified, user.email.present?)
    end
  end
end</p>
<h1>Queue jobs for all user ID ranges</h1>
<p>class BackfillEmailVerifiedJob &lt; ApplicationJob
  def perform
    batch_size = 10_000</p>
<pre><code>User.select(:id).find_in_batches(batch_size: batch_size) do |batch|
  start_id = batch.first.id
  end_id = batch.last.id
  
  BackfillEmailVerified.perform_later(start_id, end_id)
end
</code></pre>
<p>  end
end</p>
<h1>Run</h1>
<p>BackfillEmailVerifiedJob.perform_later</p>
<p>Monitor progress:
class BackfillMonitor
  def self.check
    total = User.count
    filled = User.where.not(email_verified: nil).count
    percentage = (filled.to_f / total * 100).round(2)</p>
<pre><code>puts &quot;Backfill progress: #{filled}/#{total} (#{percentage}%)&quot;
</code></pre>
<p>  end
end</p>
<h1>Check every hour</h1>
<h1>BackfillMonitor.check</h1>
<p>Time: 24-48 hours (background, no impact on users)</p>
<p>PHASE 4: ADD INDEXES CONCURRENTLY (Day 2, 30 minutes)</p>
<p>Migration 2 - Add index without locking:</p>
<p>class AddIndexToEmailVerified &lt; ActiveRecord::Migration[7.0]
  disable_ddl_transaction!</p>
<p>  def up
    # CONCURRENT keyword prevents table locking
    add_index :users, [:email, :email_verified], 
      algorithm: :concurrently,
      name: &#39;index_users_on_email_and_verified&#39;
  end</p>
<p>  def down
    remove_index :users, name: &#39;index_users_on_email_and_verified&#39;
  end
end</p>
<p>Deploy: Zero downtime
Time: ~30 minutes (creates index in background)</p>
<p>PHASE 5: MAKE COLUMN NOT NULL (Day 3, 5 minutes)</p>
<p>After backfill complete (100% filled):</p>
<p>Migration 3 - Add constraints:</p>
<p>class AddConstraintsToEmailVerified &lt; ActiveRecord::Migration[7.0]
  def up
    # Validate constraint first (doesn&#39;t lock)
    add_check_constraint :users, 
      &#39;email_verified IS NOT NULL&#39;,
      name: &#39;users_email_verified_not_null&#39;,
      validate: false</p>
<pre><code># Then validate (scans table but doesn&#39;t lock writes)
validate_check_constraint :users, name: &#39;users_email_verified_not_null&#39;

# Finally change column (instant, just changes metadata)
change_column_null :users, :email_verified, false

# Remove check constraint (no longer needed)
remove_check_constraint :users, name: &#39;users_email_verified_not_null&#39;
</code></pre>
<p>  end
end</p>
<p>Deploy: Zero downtime
Time: ~5 minutes</p>
<p>PHASE 6: DEPLOY CODE CHANGES (Day 3, 2 minutes downtime)</p>
<p>Update application code:</p>
<h1>Old code (before migration)</h1>
<p>class User &lt; ApplicationRecord
  def verified?
    # Old logic
    email.present?
  end
end</p>
<h1>New code (after migration)</h1>
<p>class User &lt; ApplicationRecord
  def verified?
    email_verified
  end
end</p>
<p>Deploy with brief maintenance window:</p>
<ol>
<li>Put app in maintenance mode (2 minutes)</li>
<li>Deploy new code</li>
<li>Restart app servers</li>
<li>Remove maintenance mode</li>
</ol>
<p>Downtime: ~2 minutes</p>
<p>PHASE 7: CLEANUP OLD COLUMNS (Day 7, 5 minutes)</p>
<p>After confirming everything works (1 week buffer):</p>
<p>Migration 4 - Remove old column:</p>
<p>class RemoveLegacyIdFromUsers &lt; ActiveRecord::Migration[7.0]
  def up
    # Drop column (instant in PostgreSQL 11+)
    remove_column :users, :legacy_id
  end</p>
<p>  def down
    add_column :users, :legacy_id, :integer
  end
end</p>
<p>Deploy: Zero downtime
Time: ~1 second</p>
<p>ALTERNATIVE APPROACH: GHOST/pt-online-schema-change</p>
<p>For very large tables (100M+ rows):</p>
<p>Using gh-ost (GitHub&#39;s tool):</p>
<p>gh-ost <br>  --user=&quot;root&quot; <br>  --password=&quot;password&quot; <br>  --host=&quot;localhost&quot; <br>  --database=&quot;production&quot; <br>  --table=&quot;users&quot; <br>  --alter=&quot;ADD COLUMN email_verified BOOLEAN&quot; <br>  --execute <br>  --allow-on-master <br>  --concurrent-rowcount</p>
<p>How it works:</p>
<ol>
<li>Creates ghost table with new schema</li>
<li>Copies data in chunks</li>
<li>Applies ongoing changes via binary log</li>
<li>Atomic table swap at the end</li>
</ol>
<p>Advantages:</p>
<ul>
<li>Zero blocking</li>
<li>Can pause/resume</li>
<li>Can abort without damage</li>
<li>Throttling to limit impact</li>
</ul>
<p>DATA MIGRATION EXAMPLE: COMPLEX CHANGE</p>
<p>Change phone format from &quot;5551234567&quot; to &quot;+1-555-123-4567&quot;:</p>
<p>Phase 1: Add new column
add_column :users, :phone_formatted, :string</p>
<p>Phase 2: Dual-write in application
class User &lt; ApplicationRecord
  before_save :sync_phone_formats</p>
<p>  def sync_phone_formats
    if phone_changed?
      self.phone_formatted = format_phone(phone)
    end
  end</p>
<p>  private</p>
<p>  def format_phone(number)
    # Convert 5551234567 to +1-555-123-4567
    return nil if number.blank?
    &quot;+1-#{number[0..2]}-#{number[3..5]}-#{number[6..9]}&quot;
  end
end</p>
<p>Phase 3: Backfill existing data
User.find_each(batch_size: 1000) do |user|
  next if user.phone.blank?
  user.update_column(:phone_formatted, user.format_phone(user.phone))
end</p>
<p>Phase 4: Switch reads to new column
class User &lt; ApplicationRecord
  def phone
    phone_formatted || read_attribute(:phone)
  end
end</p>
<p>Phase 5: Remove old column (after verification period)
remove_column :users, :phone
rename_column :users, :phone_formatted, :phone</p>
<p>MONITORING DURING MIGRATION:</p>
<ol>
<li><p>Database Performance:</p>
<p>-- Check for blocking queries
SELECT pid, query, wait_event, state
FROM pg_stat_activity
WHERE state != &#39;idle&#39; AND query NOT LIKE &#39;%pg_stat_activity%&#39;;</p>
<p>-- Check table bloat
SELECT schemaname, tablename, 
   pg_size_pretty(pg_total_relation_size(schemaname||&#39;.&#39;||tablename))
FROM pg_tables
WHERE tablename = &#39;users&#39;;</p>
</li>
<li><p>Application Performance:</p>
<h1>Monitor response times</h1>
<p>class MigrationMonitor
  def self.check
avg_response_time = RequestLog.where(
  &#39;created_at &gt; ?&#39;, 10.minutes.ago
).average(:duration)

if avg_response_time &gt; 1000
  alert(&quot;Response time degraded: #{avg_response_time}ms&quot;)
end
  end
end</p>
</li>
<li><p>Backfill Progress:</p>
<p>class BackfillProgress
  def self.report
total = User.count
completed = User.where.not(email_verified: nil).count
remaining = total - completed

rate_per_hour = completed / hours_running
hours_remaining = remaining / rate_per_hour

{
  total: total,
  completed: completed,
  percentage: (completed.to_f / total * 100).round(2),
  estimated_completion: hours_remaining.round(1)
}
  end
end</p>
</li>
</ol>
<p>ROLLBACK PLAN:</p>
<p>If issues arise:</p>
<p>Phase 1-3 (Adding columns): Safe to rollback</p>
<ul>
<li>Columns are optional</li>
<li>No data loss</li>
<li>Just remove columns</li>
</ul>
<p>Phase 4+ (Using new columns): Need careful rollback</p>
<ol>
<li>Deploy old code first</li>
<li>Then remove new columns</li>
<li>Keep old columns until fully validated</li>
</ol>
<p>Emergency Rollback Script:</p>
<h1>rollback.sh</h1>
<p>#!/bin/bash
echo &quot;Rolling back migration...&quot;</p>
<h1>Deploy previous version</h1>
<p>cap production deploy:rollback</p>
<h1>Run rollback migration</h1>
<p>bundle exec rails db:rollback STEP=1</p>
<p>echo &quot;Rollback complete&quot;</p>
<p>LESSONS LEARNED:</p>
<ol>
<li>Never do large migrations in one step</li>
<li>Always backfill in background</li>
<li>Use algorithm: :concurrently for indexes</li>
<li>Keep old and new columns during transition</li>
<li>Monitor database and app performance</li>
<li>Have rollback plan ready</li>
<li>Test on staging with production-size data</li>
<li>Schedule during low-traffic hours</li>
<li>Communicate with team and stakeholders</li>
<li>Keep changes reversible</li>
</ol>
<p>TIMELINE SUMMARY:</p>
<p>Traditional approach (with downtime):</p>
<ul>
<li>Day 1: 2-3 hour downtime for migration</li>
<li>High risk, stressed team, angry users</li>
</ul>
<p>Zero-downtime approach:</p>
<ul>
<li>Day 1: Add columns (5 seconds)</li>
<li>Day 1-2: Backfill data (background, 24-48 hours)</li>
<li>Day 2: Add indexes (30 minutes, no blocking)</li>
<li>Day 3: Add constraints (5 minutes)</li>
<li>Day 3: Deploy code (2 minutes downtime)</li>
<li>Day 7: Cleanup (5 minutes)</li>
</ul>
<p>Total user impact: 2 minutes
Total calendar time: 1 week
Risk: Low (each step is reversible)</p>
<p>This is the approach I&#39;ve successfully used for migrations on 
tables with 50M-100M+ rows in production.&quot;</p>
<pre><code>
---

[Continuing with Q371-376 in next part due to comprehensive detail]

Would you like me to complete the remaining scenario questions (Q371-376) with the same depth?


## Question 371: Your database has an increasing number of deadlocks. How do you investigate and resolve them?

### Answer
</code></pre>
<p>SCENARIO: Production database experiencing 50+ deadlocks per day
Impact: Failed transactions, user errors, data inconsistency</p>
<p>STEP 1: UNDERSTAND WHAT DEADLOCKS ARE (Concept Review)</p>
<p>Deadlock: Two transactions wait for each other to release locks</p>
<p>Example:
Transaction A: Locks User #1, wants to lock Order #100
Transaction B: Locks Order #100, wants to lock User #1
→ Circular wait = Deadlock!</p>
<p>Database kills one transaction to break the deadlock (typically the newer one)</p>
<p>STEP 2: DETECT AND MONITOR DEADLOCKS (Day 1, 1 hour)</p>
<p>A. Enable PostgreSQL Deadlock Logging:</p>
<p>-- In postgresql.conf
log_lock_waits = on
deadlock_timeout = 1s
log_line_prefix = &#39;%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h &#39;</p>
<p>-- Or via SQL
ALTER SYSTEM SET log_lock_waits = on;
SELECT pg_reload_conf();</p>
<p>B. Check PostgreSQL Logs:</p>
<p>grep &quot;deadlock detected&quot; /var/log/postgresql/postgresql-*.log</p>
<p>Example log entry:
2025-01-15 14:23:45 UTC [12345]: ERROR: deadlock detected
DETAIL: Process 12345 waits for ShareLock on transaction 67890; 
        blocked by process 12346.
        Process 12346 waits for ShareLock on transaction 67891; 
        blocked by process 12345.
HINT: See server log for query details.
CONTEXT: while updating tuple (0,1) in relation &quot;orders&quot;</p>
<p>C. Set up Monitoring:</p>
<h1>config/initializers/deadlock_monitor.rb</h1>
<p>ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)</p>
<p>  if event.payload[:exception]&amp;.first == &#39;PG::DeadlockDetected&#39;
    DeadlockLogger.log(
      query: event.payload[:sql],
      params: event.payload[:binds],
      backtrace: caller
    )</p>
<pre><code># Alert team
SlackNotifier.notify(&quot;Deadlock detected: #{event.payload[:sql]}&quot;)
</code></pre>
<p>  end
end</p>
<p>D. Create Deadlock Tracking Table:</p>
<p>class CreateDeadlockLogs &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :deadlock_logs do |t|
      t.text :query
      t.text :backtrace
      t.jsonb :metadata
      t.timestamps
    end</p>
<pre><code>add_index :deadlock_logs, :created_at
</code></pre>
<p>  end
end</p>
<p>class DeadlockLogger
  def self.log(query:, params:, backtrace:)
    DeadlockLog.create!(
      query: query,
      backtrace: backtrace.first(10).join(&quot;\n&quot;),
      metadata: {
        params: params,
        thread: Thread.current.object_id,
        timestamp: Time.current
      }
    )
  end
end</p>
<p>STEP 3: ANALYZE DEADLOCK PATTERNS (Day 1, 2 hours)</p>
<p>A. Query Database for Lock Information:</p>
<p>-- Active locks
SELECT 
  l.pid,
  l.mode,
  l.granted,
  a.query,
  a.state,
  a.wait_event
FROM pg_locks l
JOIN pg_stat_activity a ON a.pid = l.pid
WHERE NOT l.granted
ORDER BY a.query_start;</p>
<p>-- Blocking queries
SELECT 
  blocked_locks.pid AS blocked_pid,
  blocked_activity.usename AS blocked_user,
  blocking_locks.pid AS blocking_pid,
  blocking_activity.usename AS blocking_user,
  blocked_activity.query AS blocked_query,
  blocking_activity.query AS blocking_query
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity 
  ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
  ON blocking_locks.locktype = blocked_locks.locktype
  AND blocking_locks.relation = blocked_locks.relation
  AND blocking_locks.page = blocked_locks.page
  AND blocking_locks.tuple = blocked_locks.tuple
  AND blocking_locks.virtualxid = blocked_locks.virtualxid
  AND blocking_locks.transactionid = blocked_locks.transactionid
  AND blocking_locks.classid = blocked_locks.classid
  AND blocking_locks.objid = blocked_locks.objid
  AND blocking_locks.objsubid = blocked_locks.objsubid
  AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity 
  ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;</p>
<p>B. Analyze Deadlock Logs:</p>
<p>class DeadlockAnalyzer
  def self.analyze(start_date: 7.days.ago)
    logs = DeadlockLog.where(&#39;created_at &gt; ?&#39;, start_date)</p>
<pre><code># Find most common queries
query_counts = logs.group(:query).count.sort_by { |k, v| -v }

# Find common patterns
patterns = logs.group_by do |log|
  extract_tables_from_query(log.query)
end

report = {
  total_deadlocks: logs.count,
  most_common_queries: query_counts.first(10),
  table_patterns: patterns.transform_values(&amp;:count),
  hourly_distribution: logs.group_by_hour(:created_at).count
}

report
</code></pre>
<p>  end</p>
<p>  def self.extract_tables_from_query(query)
    # Simple regex to extract table names
    query.scan(/FROM\s+(\w+)|UPDATE\s+(\w+)|INTO\s+(\w+)/i)
         .flatten
         .compact
         .uniq
         .sort
  end
end</p>
<h1>Run analysis</h1>
<p>report = DeadlockAnalyzer.analyze
puts report.inspect</p>
<p>Output reveals pattern:</p>
<ul>
<li>80% of deadlocks involve orders and order_items tables</li>
<li>Most occur during checkout process</li>
<li>Peak times: 12pm-2pm, 6pm-8pm (high traffic)</li>
</ul>
<p>STEP 4: IDENTIFY ROOT CAUSE (Day 1-2, 4 hours)</p>
<p>Found problematic code pattern:</p>
<h1>Bad Code (Causes Deadlocks)</h1>
<p>class OrderService
  def process_order(order_id, items)
    Order.transaction do
      order = Order.lock.find(order_id)  # Lock order first</p>
<pre><code>  items.each do |item|
    # Lock each item in random order!
    order_item = OrderItem.lock.find(item[:id])
    order_item.update!(quantity: item[:quantity])
  end
  
  order.update!(total: calculate_total(items))
end
</code></pre>
<p>  end
end</p>
<h1>Another transaction doing opposite:</h1>
<p>class InventoryService
  def update_inventory(item_ids)
    OrderItem.transaction do
      item_ids.each do |item_id|
        item = OrderItem.lock.find(item_id)  # Lock items first
        item.update!(stock: item.stock - 1)</p>
<pre><code>    # Then lock order
    order = Order.lock.find(item.order_id)  # Lock order second
    order.update!(updated_at: Time.current)
  end
end
</code></pre>
<p>  end
end</p>
<p>Deadlock Scenario:</p>
<ul>
<li>Transaction A: Locks Order #1, then tries to lock OrderItem #100</li>
<li>Transaction B: Locks OrderItem #100, then tries to lock Order #1
→ DEADLOCK!</li>
</ul>
<p>Root Causes Identified:</p>
<ol>
<li>Inconsistent lock ordering</li>
<li>Locking records in loops (random order)</li>
<li>Long-running transactions</li>
<li>High concurrency on same records</li>
</ol>
<p>STEP 5: IMPLEMENT SOLUTIONS (Day 2-3)</p>
<p>SOLUTION 1: Consistent Lock Ordering</p>
<p>Rule: Always lock in the same order across entire application</p>
<h1>Good Code - Lock in consistent order</h1>
<p>class OrderService
  def process_order(order_id, items)
    # Define lock order: Always lock order first, then items
    Order.transaction do
      order = Order.lock.find(order_id)</p>
<pre><code>  # Lock items in deterministic order (by ID)
  item_ids = items.map { |i| i[:id] }.sort
  order_items = OrderItem.where(id: item_ids).order(:id).lock
  
  order_items.each do |item|
    new_quantity = items.find { |i| i[:id] == item.id }[:quantity]
    item.update!(quantity: new_quantity)
  end
  
  order.update!(total: calculate_total(items))
end
</code></pre>
<p>  end
end</p>
<p>class InventoryService
  def update_inventory(item_ids)
    OrderItem.transaction do
      # Lock items in sorted order
      items = OrderItem.where(id: item_ids).order(:id).lock</p>
<pre><code>  # Group by order_id to lock orders in sorted order
  orders_to_update = items.group_by(&amp;:order_id).keys.sort
  
  items.each do |item|
    item.update!(stock: item.stock - 1)
  end
  
  # Lock all orders at once, in order
  Order.where(id: orders_to_update).order(:id).lock.each do |order|
    order.touch
  end
end
</code></pre>
<p>  end
end</p>
<p>Result: 80% reduction in deadlocks</p>
<p>SOLUTION 2: Optimistic Locking</p>
<p>Use version column instead of database locks:</p>
<p>class AddVersionToOrders &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :orders, :lock_version, :integer, default: 0, null: false
    add_column :order_items, :lock_version, :integer, default: 0, null: false
  end
end</p>
<p>class Order &lt; ApplicationRecord</p>
<h1>Rails automatically handles optimistic locking with lock_version</h1>
<p>end</p>
<p>class OrderService
  def process_order(order_id, items)
    max_retries = 3
    retries = 0</p>
<pre><code>begin
  Order.transaction do
    order = Order.find(order_id)
    
    items.each do |item_data|
      item = OrderItem.find(item_data[:id])
      item.quantity = item_data[:quantity]
      item.save!  # Will raise StaleObjectError if version changed
    end
    
    order.total = calculate_total(items)
    order.save!  # Will raise StaleObjectError if version changed
  end
rescue ActiveRecord::StaleObjectError =&gt; e
  retries += 1
  if retries &lt; max_retries
    sleep(0.1 * retries)  # Exponential backoff
    retry
  else
    raise
  end
end
</code></pre>
<p>  end
end</p>
<p>Advantages:</p>
<ul>
<li>No database locks = No deadlocks</li>
<li>Better for high-concurrency scenarios</li>
<li>Automatic retry with exponential backoff</li>
</ul>
<p>Result: 95% reduction in deadlocks</p>
<p>SOLUTION 3: Advisory Locks</p>
<p>For application-level locking:</p>
<p>class OrderService
  def process_order(order_id, items)
    # Use advisory lock based on order_id
    lock_id = order_id</p>
<pre><code>ActiveRecord::Base.connection.execute(
  &quot;SELECT pg_advisory_lock(#{lock_id})&quot;
)

begin
  order = Order.find(order_id)
  
  items.each do |item_data|
    item = OrderItem.find(item_data[:id])
    item.update!(quantity: item_data[:quantity])
  end
  
  order.update!(total: calculate_total(items))
ensure
  ActiveRecord::Base.connection.execute(
    &quot;SELECT pg_advisory_unlock(#{lock_id})&quot;
  )
end
</code></pre>
<p>  end
end</p>
<p>Or use advisory_lock gem:</p>
<h1>Gemfile</h1>
<p>gem &#39;with_advisory_lock&#39;</p>
<p>class Order &lt; ApplicationRecord
  def process_with_items(items)
    with_advisory_lock(&quot;order_#{id}&quot;) do
      # No deadlocks possible - only one transaction at a time
      items.each do |item_data|
        item = order_items.find(item_data[:id])
        item.update!(quantity: item_data[:quantity])
      end</p>
<pre><code>  update!(total: calculate_total(items))
end
</code></pre>
<p>  end
end</p>
<p>SOLUTION 4: Reduce Transaction Scope</p>
<p>Break large transactions into smaller ones:</p>
<h1>Bad - Long transaction</h1>
<p>def process_order(order_id, items)
  Order.transaction do
    order = Order.lock.find(order_id)</p>
<pre><code># 100 items = 100 queries in transaction
items.each do |item|
  process_item(item)  # External API call!
end

send_confirmation_email(order)  # Slow!
update_inventory(items)  # Another service!

order.update!(status: &#39;completed&#39;)
</code></pre>
<p>  end
end</p>
<h1>Good - Minimal transaction</h1>
<p>def process_order(order_id, items)</p>
<h1>Pre-process outside transaction</h1>
<p>  processed_items = items.map { |item| preprocess_item(item) }</p>
<h1>Quick transaction - just database updates</h1>
<p>  Order.transaction do
    order = Order.lock.find(order_id)</p>
<pre><code># Bulk update
OrderItem.where(id: processed_items.map(&amp;:id)).update_all(
  processed: true,
  updated_at: Time.current
)

order.update!(
  status: &#39;completed&#39;,
  total: processed_items.sum(&amp;:price)
)
</code></pre>
<p>  end</p>
<h1>Move slow operations outside transaction</h1>
<p>  SendConfirmationEmailJob.perform_later(order_id)
  UpdateInventoryJob.perform_later(processed_items.map(&amp;:id))
end</p>
<p>Result: Transaction time: 5s → 50ms (100x faster)</p>
<p>SOLUTION 5: Queue Serial Processing</p>
<p>For operations that can be serialized:</p>
<h1>Gemfile</h1>
<p>gem &#39;sidekiq&#39;</p>
<p>class ProcessOrderJob &lt; ApplicationJob
  queue_as :critical</p>
<h1>Ensure only one job per order at a time</h1>
<p>  sidekiq_options lock: :until_executed,
                  lock_args_method: :lock_args</p>
<p>  def self.lock_args(args)
    # Lock based on order_id
    [args.first]
  end</p>
<p>  def perform(order_id, items)
    Order.transaction do
      order = Order.find(order_id)</p>
<pre><code>  items.each do |item_data|
    item = OrderItem.find(item_data[:id])
    item.update!(quantity: item_data[:quantity])
  end
  
  order.update!(total: calculate_total(items))
end
</code></pre>
<p>  end
end</p>
<h1>In controller</h1>
<p>def update
  ProcessOrderJob.perform_later(params[:id], params[:items])
  render json: {status: &#39;processing&#39;}
end</p>
<p>STEP 6: IMPLEMENT MONITORING (Day 3)</p>
<p>Create dashboard to track improvements:</p>
<p>class DeadlockMetrics
  def self.daily_report
    today = Date.current</p>
<pre><code>{
  date: today,
  total_deadlocks: DeadlockLog.where(created_at: today.all_day).count,
  by_hour: DeadlockLog
    .where(created_at: today.all_day)
    .group_by_hour(:created_at)
    .count,
  by_query: DeadlockLog
    .where(created_at: today.all_day)
    .group(:query)
    .count
    .sort_by { |k, v| -v }
    .first(10),
  comparison_to_last_week: calculate_weekly_comparison
}
</code></pre>
<p>  end</p>
<p>  def self.calculate_weekly_comparison
    this_week = DeadlockLog.where(created_at: 7.days.ago..Time.current).count
    last_week = DeadlockLog.where(created_at: 14.days.ago..7.days.ago).count</p>
<pre><code>change_percent = ((this_week - last_week).to_f / last_week * 100).round(2)

{
  this_week: this_week,
  last_week: last_week,
  change_percent: change_percent
}
</code></pre>
<p>  end
end</p>
<h1>Schedule daily report</h1>
<p>class DeadlockReportJob &lt; ApplicationJob
  def perform
    report = DeadlockMetrics.daily_report</p>
<pre><code>SlackNotifier.notify(
  &quot;Daily Deadlock Report&quot;,
  report.to_json
)
</code></pre>
<p>  end
end</p>
<p>Set up alerts:</p>
<h1>config/initializers/deadlock_alerts.rb</h1>
<p>ActiveSupport::Notifications.subscribe(&#39;sql.active_record&#39;) do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)</p>
<p>  if event.payload[:exception]&amp;.first == &#39;PG::DeadlockDetected&#39;
    # Increment counter
    Redis.current.incr(&#39;deadlocks:today&#39;)</p>
<pre><code># Alert if threshold exceeded
count = Redis.current.get(&#39;deadlocks:today&#39;).to_i
if count &gt; 10
  PagerDuty.trigger(
    &quot;High deadlock rate: #{count} today&quot;,
    severity: &#39;warning&#39;
  )
end
</code></pre>
<p>  end
end</p>
<p>STEP 7: PREVENT FUTURE DEADLOCKS (Ongoing)</p>
<ol>
<li><p>Code Review Checklist:</p>
<h1>.github/pull_request_template.md</h1>
<h2>Database Locking</h2>
<ul>
<li><input disabled="" type="checkbox"> Locks acquired in consistent order?</li>
<li><input disabled="" type="checkbox"> Transaction scope minimized?</li>
<li><input disabled="" type="checkbox"> Optimistic locking considered?</li>
<li><input disabled="" type="checkbox"> No loops with locks inside?</li>
</ul>
</li>
<li><p>Database Transaction Guidelines:</p>
<h1>docs/database_guidelines.md</h1>
<p><strong>Lock Ordering Rules:</strong></p>
<ol>
<li>Always lock parent before child (Order before OrderItem)</li>
<li>Always lock in ID order when locking multiple records</li>
<li>Use .order(:id).lock for collections</li>
</ol>
<p><strong>Transaction Best Practices:</strong></p>
<ol>
<li>Keep transactions short (&lt;100ms)</li>
<li>No external API calls in transactions</li>
<li>No slow computations in transactions</li>
<li>Use background jobs for slow operations</li>
</ol>
</li>
<li><p>Testing for Deadlocks:</p>
<h1>test/concurrency/deadlock_test.rb</h1>
<p>require &#39;test_helper&#39;</p>
<p>class DeadlockTest &lt; ActiveSupport::TestCase
  test &quot;concurrent order processing doesn&#39;t deadlock&quot; do
order = create(:order)
items = create_list(:order_item, 10, order: order)

threads = 10.times.map do
  Thread.new do
    OrderService.process_order(order.id, items.sample(5))
  end
end

# Should complete without deadlock
assert_nothing_raised do
  threads.each(&amp;:join)
end
  end
end</p>
</li>
</ol>
<p>RESULTS:</p>
<p>Before optimization:</p>
<ul>
<li>Deadlocks per day: 50+</li>
<li>Transaction times: 5-10 seconds</li>
<li>Failed transactions: 2-3% of orders</li>
<li>Customer complaints: Daily</li>
</ul>
<p>After optimization:</p>
<ul>
<li>Deadlocks per day: 2-3 (94% reduction)</li>
<li>Transaction times: 50ms average</li>
<li>Failed transactions: 0.1% of orders</li>
<li>Customer complaints: None</li>
</ul>
<p>Key changes:</p>
<ol>
<li>Consistent lock ordering (50% reduction)</li>
<li>Optimistic locking where possible (30% reduction)</li>
<li>Reduced transaction scope (10% reduction)</li>
<li>Queue-based processing (4% reduction)</li>
</ol>
<p>LESSONS LEARNED:</p>
<ol>
<li>Deadlocks are caused by inconsistent lock ordering</li>
<li>Monitoring is essential to identify patterns</li>
<li>Optimistic locking is often better than pessimistic</li>
<li>Keep transactions as short as possible</li>
<li>Test concurrent scenarios explicitly</li>
<li>Document locking conventions</li>
<li>Review code specifically for locking patterns</li>
<li>Advisory locks for application-level coordination</li>
<li>Queue serialization for truly conflicting operations</li>
<li>Track metrics to measure improvement</li>
</ol>
<p>TOOLS SUMMARY:</p>
<p>Detection:</p>
<ul>
<li>PostgreSQL logs (log_lock_waits)</li>
<li>Application logging</li>
<li>Monitoring dashboards</li>
</ul>
<p>Analysis:</p>
<ul>
<li>pg_locks system view</li>
<li>pg_stat_activity</li>
<li>Custom deadlock analyzer</li>
</ul>
<p>Prevention:</p>
<ul>
<li>Consistent lock ordering</li>
<li>Optimistic locking (lock_version)</li>
<li>Advisory locks (with_advisory_lock gem)</li>
<li>Transaction scope reduction</li>
<li>Queue-based processing (Sidekiq)</li>
</ul>
<p>This systematic approach resolved our deadlock crisis and 
established patterns to prevent future occurrences.&quot;</p>
<pre><code>
---

## Question 372: Your Rails app needs to support searching through millions of records. How do you design the database and optimize queries?
---
### Answer
</code></pre>
<p>SCENARIO: E-commerce platform with 10M products
Requirement: Fast full-text search (&lt;100ms), filters, sorting
Current: PostgreSQL with basic LIKE queries (30+ seconds)</p>
<p>COMPREHENSIVE SEARCH SOLUTION:</p>
<p>PHASE 1: EVALUATE SEARCH APPROACHES (Day 1)</p>
<p>Options Comparison:</p>
<ol>
<li><p>PostgreSQL LIKE (Current)
SELECT * FROM products WHERE name LIKE &#39;%laptop%&#39;</p>
<ul>
<li>Pros: Simple, no additional infrastructure</li>
<li>Cons: Slow (30s), no ranking, no fuzzy matching</li>
<li>Verdict: ❌ Not suitable for millions of records</li>
</ul>
</li>
<li><p>PostgreSQL Full-Text Search
SELECT * FROM products 
WHERE to_tsvector(&#39;english&#39;, name) @@ to_tsquery(&#39;laptop&#39;)</p>
<ul>
<li>Pros: Built-in, good performance, ranking</li>
<li>Cons: Complex syntax, limited features</li>
<li>Verdict: ✅ Good for 1-10M records</li>
</ul>
</li>
<li><p>Elasticsearch</p>
<ul>
<li>Pros: Excellent search, facets, fuzzy matching, scales</li>
<li>Cons: Additional infrastructure, eventual consistency</li>
<li>Verdict: ✅ Best for 10M+ records</li>
</ul>
</li>
<li><p>Algolia / Meilisearch (Managed)</p>
<ul>
<li>Pros: Managed service, great UX, typo tolerance</li>
<li>Cons: Cost, data export to third party</li>
<li>Verdict: ✅ Good for fast implementation</li>
</ul>
</li>
</ol>
<p>Decision: Start with PostgreSQL Full-Text Search, migrate to 
Elasticsearch if we outgrow it</p>
<p>PHASE 2: POSTGRESQL FULL-TEXT SEARCH (Day 1-2)</p>
<p>A. Add Search Column and Index:</p>
<p>class AddSearchToProducts &lt; ActiveRecord::Migration[7.0]
  def up
    # Add tsvector column for search
    add_column :products, :search_vector, :tsvector</p>
<pre><code># Create GIN index (critical for performance!)
execute &lt;&lt;-SQL
  CREATE INDEX index_products_on_search_vector 
  ON products 
  USING GIN(search_vector);
SQL

# Create trigger to auto-update search_vector
execute &lt;&lt;-SQL
  CREATE FUNCTION products_search_trigger() RETURNS trigger AS $$
  BEGIN
    NEW.search_vector :=
      setweight(to_tsvector(&#39;english&#39;, coalesce(NEW.name, &#39;&#39;)), &#39;A&#39;) ||
      setweight(to_tsvector(&#39;english&#39;, coalesce(NEW.description, &#39;&#39;)), &#39;B&#39;) ||
      setweight(to_tsvector(&#39;english&#39;, coalesce(NEW.category, &#39;&#39;)), &#39;C&#39;);
    RETURN NEW;
  END
  $$ LANGUAGE plpgsql;
  
  CREATE TRIGGER products_search_update 
  BEFORE INSERT OR UPDATE ON products
  FOR EACH ROW EXECUTE FUNCTION products_search_trigger();
SQL

# Backfill existing records
Product.find_each(batch_size: 1000) do |product|
  product.update_column(:search_vector, nil)  # Trigger will populate
  product.save!
end
</code></pre>
<p>  end</p>
<p>  def down
    execute &quot;DROP TRIGGER IF EXISTS products_search_update ON products&quot;
    execute &quot;DROP FUNCTION IF EXISTS products_search_trigger()&quot;
    remove_index :products, :search_vector
    remove_column :products, :search_vector
  end
end</p>
<p>Weights explanation:</p>
<ul>
<li>A = Highest (product name)</li>
<li>B = Medium (description)</li>
<li>C = Lower (category)</li>
</ul>
<p>B. Create Search Model/Service:</p>
<p>class ProductSearch
  def initialize(query, options = {})
    @query = query
    @category = options[:category]
    @min_price = options[:min_price]
    @max_price = options[:max_price]
    @sort = options[:sort] || &#39;relevance&#39;
    @page = options[:page] || 1
    @per_page = options[:per_page] || 25
  end</p>
<p>  def results
    scope = Product.all</p>
<pre><code># Full-text search
if @query.present?
  scope = scope.where(
    &quot;search_vector @@ plainto_tsquery(&#39;english&#39;, ?)&quot;,
    @query
  ).select(
    &quot;products.*&quot;,
    &quot;ts_rank(search_vector, plainto_tsquery(&#39;english&#39;, ?)) AS rank&quot;,
    @query
  )
end

# Filters
scope = scope.where(category: @category) if @category.present?
scope = scope.where(&#39;price &gt;= ?&#39;, @min_price) if @min_price.present?
scope = scope.where(&#39;price &lt;= ?&#39;, @max_price) if @max_price.present?

# Sorting
scope = case @sort
        when &#39;relevance&#39;
          scope.order(&#39;rank DESC, products.id DESC&#39;)
        when &#39;price_asc&#39;
          scope.order(&#39;price ASC&#39;)
        when &#39;price_desc&#39;
          scope.order(&#39;price DESC&#39;)
        when &#39;newest&#39;
          scope.order(&#39;created_at DESC&#39;)
        else
          scope.order(&#39;id DESC&#39;)
        end

# Pagination
scope.page(@page).per(@per_page)
</code></pre>
<p>  end</p>
<p>  def facets
    # Count by category
    base_scope = Product.all</p>
<pre><code>if @query.present?
  base_scope = base_scope.where(
    &quot;search_vector @@ plainto_tsquery(&#39;english&#39;, ?)&quot;,
    @query
  )
end

{
  categories: base_scope.group(:category).count,
  price_ranges: {
    &#39;Under $50&#39; =&gt; base_scope.where(&#39;price &lt; 50&#39;).count,
    &#39;$50-$100&#39; =&gt; base_scope.where(price: 50..100).count,
    &#39;$100-$500&#39; =&gt; base_scope.where(price: 100..500).count,
    &#39;Over $500&#39; =&gt; base_scope.where(&#39;price &gt; 500&#39;).count
  }
}
</code></pre>
<p>  end
end</p>
<p>C. Controller:</p>
<p>class SearchController &lt; ApplicationController
  def index
    @search = ProductSearch.new(
      params[:q],
      category: params[:category],
      min_price: params[:min_price],
      max_price: params[:max_price],
      sort: params[:sort],
      page: params[:page]
    )</p>
<pre><code>@results = @search.results
@facets = @search.facets

# Cache search results
cache_key = &quot;search/#{cache_key_params}&quot;
@results = Rails.cache.fetch(cache_key, expires_in: 5.minutes) do
  @results.to_a
end
</code></pre>
<p>  end</p>
<p>  private</p>
<p>  def cache_key_params
    params.slice(:q, :category, :min_price, :max_price, :sort, :page)
          .to_query
  end
end</p>
<p>Results:</p>
<ul>
<li>Query time: 30s → 150ms (99.5% improvement)</li>
<li>Can handle up to 10M products</li>
<li>Ranking by relevance</li>
<li>Faceted search</li>
</ul>
<p>PHASE 3: ELASTICSEARCH INTEGRATION (Day 3-5)</p>
<p>For 10M+ products or advanced features:</p>
<p>A. Setup Elasticsearch:</p>
<h1>Gemfile</h1>
<p>gem &#39;elasticsearch-model&#39;
gem &#39;elasticsearch-rails&#39;</p>
<h1>config/initializers/elasticsearch.rb</h1>
<p>Elasticsearch::Model.client = Elasticsearch::Client.new(
  url: ENV[&#39;ELASTICSEARCH_URL&#39;],
  log: Rails.env.development?
)</p>
<p>B. Add Search to Model:</p>
<p>class Product &lt; ApplicationRecord
  include Elasticsearch::Model
  include Elasticsearch::Model::Callbacks</p>
<h1>Define searchable fields and settings</h1>
<p>  settings index: {
    number_of_shards: 5,
    number_of_replicas: 1,
    analysis: {
      analyzer: {
        product_analyzer: {
          type: &#39;custom&#39;,
          tokenizer: &#39;standard&#39;,
          filter: [&#39;lowercase&#39;, &#39;asciifolding&#39;, &#39;synonym&#39;, &#39;snowball&#39;]
        }
      },
      filter: {
        synonym: {
          type: &#39;synonym&#39;,
          synonyms: [
            &#39;laptop, notebook, computer&#39;,
            &#39;phone, mobile, smartphone&#39;
          ]
        }
      }
    }
  } do
    mappings dynamic: &#39;false&#39; do
      indexes :name, type: &#39;text&#39;, analyzer: &#39;product_analyzer&#39;, boost: 3
      indexes :description, type: &#39;text&#39;, analyzer: &#39;product_analyzer&#39;
      indexes :category, type: &#39;keyword&#39;
      indexes :price, type: &#39;float&#39;
      indexes :created_at, type: &#39;date&#39;
      indexes :in_stock, type: &#39;boolean&#39;
      indexes :rating, type: &#39;float&#39;
      indexes :review_count, type: &#39;integer&#39;
    end
  end</p>
<h1>Define what gets indexed</h1>
<p>  def as_indexed_json(options = {})
    as_json(
      only: [:id, :name, :description, :category, :price, :created_at],
      methods: [:in_stock, :rating, :review_count]
    )
  end
end</p>
<p>C. Create Indexes:</p>
<h1>Rake task</h1>
<p>namespace :elasticsearch do
  task reindex: :environment do
    Product.<strong>elasticsearch</strong>.create_index! force: true
    Product.import force: true, batch_size: 5000</p>
<pre><code>puts &quot;Indexed #{Product.count} products&quot;
</code></pre>
<p>  end
end</p>
<h1>Run</h1>
<p>rake elasticsearch:reindex</p>
<p>D. Advanced Search Service:</p>
<p>class ElasticsearchProductSearch
  def initialize(query, options = {})
    @query = query
    @category = options[:category]
    @min_price = options[:min_price]
    @max_price = options[:max_price]
    @in_stock = options[:in_stock]
    @sort = options[:sort] || &#39;relevance&#39;
    @page = options[:page] || 1
    @per_page = options[:per_page] || 25
  end</p>
<p>  def search
    Product.search(definition)
  end</p>
<p>  def definition
    {
      query: query_clause,
      filter: filter_clause,
      sort: sort_clause,
      aggs: aggregations,
      from: (@page - 1) * @per_page,
      size: @per_page,
      highlight: {
        fields: {
          name: {},
          description: {fragment_size: 150}
        }
      }
    }
  end</p>
<p>  private</p>
<p>  def query_clause
    if @query.present?
      {
        multi_match: {
          query: @query,
          fields: [&#39;name^3&#39;, &#39;description&#39;, &#39;category&#39;],
          type: &#39;best_fields&#39;,
          fuzziness: &#39;AUTO&#39;,
          operator: &#39;and&#39;
        }
      }
    else
      {match_all: {}}
    end
  end</p>
<p>  def filter_clause
    filters = []</p>
<pre><code>filters &lt;&lt; {term: {category: @category}} if @category.present?
filters &lt;&lt; {range: {price: {gte: @min_price}}} if @min_price.present?
filters &lt;&lt; {range: {price: {lte: @max_price}}} if @max_price.present?
filters &lt;&lt; {term: {in_stock: true}} if @in_stock == &#39;true&#39;

filters.any? ? {bool: {must: filters}} : nil
</code></pre>
<p>  end</p>
<p>  def sort_clause
    case @sort
    when &#39;relevance&#39;
      [{_score: {order: &#39;desc&#39;}}]
    when &#39;price_asc&#39;
      [{price: {order: &#39;asc&#39;}}]
    when &#39;price_desc&#39;
      [{price: {order: &#39;desc&#39;}}]
    when &#39;newest&#39;
      [{created_at: {order: &#39;desc&#39;}}]
    when &#39;rating&#39;
      [{rating: {order: &#39;desc&#39;}}, {review_count: {order: &#39;desc&#39;}}]
    else
      [{_score: {order: &#39;desc&#39;}}]
    end
  end</p>
<p>  def aggregations
    {
      categories: {
        terms: {field: &#39;category&#39;, size: 50}
      },
      price_ranges: {
        range: {
          field: &#39;price&#39;,
          ranges: [
            {to: 50, key: &#39;Under $50&#39;},
            {from: 50, to: 100, key: &#39;$50-$100&#39;},
            {from: 100, to: 500, key: &#39;$100-$500&#39;},
            {from: 500, key: &#39;Over $500&#39;}
          ]
        }
      },
      avg_price: {
        avg: {field: &#39;price&#39;}
      },
      in_stock_count: {
        filter: {term: {in_stock: true}}
      }
    }
  end
end</p>
<p>E. Controller with Elasticsearch:</p>
<p>class SearchController &lt; ApplicationController
  def index
    @search_service = ElasticsearchProductSearch.new(
      params[:q],
      category: params[:category],
      min_price: params[:min_price],
      max_price: params[:max_price],
      in_stock: params[:in_stock],
      sort: params[:sort],
      page: params[:page]
    )</p>
<pre><code>@search_results = @search_service.search
@products = @search_results.records
@facets = @search_results.response[&#39;aggregations&#39;]
@total = @search_results.response[&#39;hits&#39;][&#39;total&#39;][&#39;value&#39;]
</code></pre>
<p>  end
end</p>
<p>F. Auto-complete / Suggestions:</p>
<p>class Product &lt; ApplicationRecord</p>
<h1>Add suggest field to mapping</h1>
<p>  settings index: {analysis: {...}} do
    mappings do
      indexes :name, type: &#39;text&#39;, analyzer: &#39;product_analyzer&#39;
      indexes :name_suggest, type: &#39;completion&#39;
    end
  end</p>
<p>  def as_indexed_json(options = {})
    as_json(only: [:id, :name, :price]).merge(
      name_suggest: {
        input: [name, *name.split],
        weight: popularity_score
      }
    )
  end
end</p>
<h1>Suggest endpoint</h1>
<p>class SuggestionsController &lt; ApplicationController
  def index
    results = Product.search(
      suggest: {
        products: {
          prefix: params[:q],
          completion: {
            field: &#39;name_suggest&#39;,
            size: 10,
            fuzzy: {fuzziness: &#39;AUTO&#39;}
          }
        }
      }
    )</p>
<pre><code>suggestions = results.response[&#39;suggest&#39;][&#39;products&#39;][0][&#39;options&#39;]
                     .map { |opt| opt[&#39;_source&#39;] }

render json: suggestions
</code></pre>
<p>  end
end</p>
<p>Results with Elasticsearch:</p>
<ul>
<li>Query time: 150ms → 20ms (87% improvement)</li>
<li>Fuzzy matching (typo tolerance)</li>
<li>Auto-complete: &lt;10ms</li>
<li>Advanced features: facets, suggestions, highlighting</li>
<li>Scalable to 100M+ products</li>
</ul>
<p>PHASE 4: OPTIMIZATION TECHNIQUES</p>
<p>A. Database Indexes for Filters:</p>
<p>-- Composite indexes for common filter combinations
CREATE INDEX idx_products_category_price 
  ON products(category, price);</p>
<p>CREATE INDEX idx_products_in_stock_created 
  ON products(in_stock, created_at DESC) 
  WHERE in_stock = true;</p>
<p>-- Partial index for active products
CREATE INDEX idx_active_products 
  ON products(id) 
  WHERE deleted_at IS NULL AND active = true;</p>
<p>B. Denormalization for Performance:</p>
<p>-- Add computed columns
ALTER TABLE products ADD COLUMN search_popularity INTEGER DEFAULT 0;</p>
<p>-- Update via background job
class UpdateProductPopularity &lt; ApplicationJob
  def perform
    Product.find_each do |product|
      popularity = calculate_popularity(product)
      product.update_column(:search_popularity, popularity)
    end
  end</p>
<p>  def calculate_popularity(product)
    (product.views_count * 1) +
    (product.purchases_count * 10) +
    (product.rating * product.review_count * 5)
  end
end</p>
<p>C. Caching Strategy:</p>
<h1>Cache popular searches</h1>
<p>class CachedSearch
  def self.perform(query, options = {})
    cache_key = &quot;search/#{query}/#{options.to_query}&quot;</p>
<pre><code>Rails.cache.fetch(cache_key, expires_in: 10.minutes) do
  ElasticsearchProductSearch.new(query, options).search.to_a
end
</code></pre>
<p>  end
end</p>
<h1>Pre-warm cache for popular searches</h1>
<p>class WarmSearchCacheJob &lt; ApplicationJob
  POPULAR_SEARCHES = [&#39;laptop&#39;, &#39;phone&#39;, &#39;headphones&#39;, &#39;camera&#39;]</p>
<p>  def perform
    POPULAR_SEARCHES.each do |query|
      CachedSearch.perform(query)
    end
  end
end</p>
<p>D. Read Replicas for Heavy Queries:</p>
<p>class Product &lt; ApplicationRecord</p>
<h1>Use read replica for searches</h1>
<p>  connects_to database: {writing: :primary, reading: :replica}
end</p>
<p>class SearchController &lt; ApplicationController
  def index
    ActiveRecord::Base.connected_to(role: :reading) do
      @products = ProductSearch.new(params[:q]).results
    end
  end
end</p>
<p>E. Async Index Updates:</p>
<h1>Don&#39;t block user requests waiting for Elasticsearch</h1>
<p>class Product &lt; ApplicationRecord
  after_commit :reindex_async, on: [:create, :update]</p>
<p>  def reindex_async
    ReindexProductJob.perform_later(id)
  end
end</p>
<p>class ReindexProductJob &lt; ApplicationJob
  queue_as :low_priority</p>
<p>  def perform(product_id)
    product = Product.find(product_id)
    product.<strong>elasticsearch</strong>.index_document
  end
end</p>
<p>PHASE 5: MONITORING &amp; MAINTENANCE</p>
<p>A. Search Analytics:</p>
<p>class SearchAnalytics &lt; ApplicationRecord</p>
<h1>Track searches</h1>
<p>  def self.log_search(query, results_count, response_time)
    create!(
      query: query,
      results_count: results_count,
      response_time: response_time,
      searched_at: Time.current
    )
  end
end</p>
<h1>In controller</h1>
<p>def index
  start_time = Time.current</p>
<h1>... perform search ...</h1>
<p>  response_time = (Time.current - start_time) * 1000</p>
<p>  SearchAnalytics.log_search(
    params[:q],
    @products.count,
    response_time
  )
end</p>
<p>B. Monitor Search Performance:</p>
<p>class SearchMonitor
  def self.slow_searches(threshold_ms = 1000)
    SearchAnalytics
      .where(&#39;response_time &gt; ?&#39;, threshold_ms)
      .where(&#39;searched_at &gt; ?&#39;, 24.hours.ago)
      .group(:query)
      .having(&#39;COUNT(*) &gt; 5&#39;)
      .count
  end</p>
<p>  def self.zero_result_searches
    SearchAnalytics
      .where(results_count: 0)
      .where(&#39;searched_at &gt; ?&#39;, 24.hours.ago)
      .group(:query)
      .count
      .sort_by { |k, v| -v }
      .first(20)
  end
end</p>
<p>C. Elasticsearch Health:</p>
<p>class ElasticsearchHealth
  def self.check
    client = Elasticsearch::Model.client</p>
<pre><code>{
  cluster_health: client.cluster.health,
  index_stats: client.indices.stats(index: &#39;products&#39;),
  slow_queries: check_slow_queries
}
</code></pre>
<p>  end</p>
<p>  def self.check_slow_queries
    # Query Elasticsearch slow log
    client = Elasticsearch::Model.client
    client.search(
      index: &#39;.monitoring-es-*&#39;,
      body: {
        query: {
          bool: {
            must: [
              {range: {timestamp: {gte: &#39;now-1h&#39;}}},
              {range: {took: {gte: 1000}}}
            ]
          }
        },
        size: 10,
        sort: [{took: {order: &#39;desc&#39;}}]
      }
    )
  end
end</p>
<p>FINAL ARCHITECTURE:</p>
<p>┌─────────────┐
│   User      │
└──────┬──────┘
       │
       ▼
┌─────────────────────┐
│  Load Balancer      │
└──────────┬──────────┘
           │
     ┌─────┴─────┐
     ▼           ▼
┌─────────┐ ┌─────────┐
│ Web     │ │ Web     │
│ Server  │ │ Server  │
└────┬────┘ └────┬────┘
     │           │
     └─────┬─────┘
           │
     ┌─────┴──────┐
     │            │
     ▼            ▼
┌──────────┐ ┌──────────────┐
│PostgreSQL│ │Elasticsearch │
│(filters) │ │(full-text)   │
└──────────┘ └──────────────┘</p>
<p>Query Flow:</p>
<ol>
<li>User searches &quot;laptop under $500&quot;</li>
<li>Elasticsearch: full-text search for &quot;laptop&quot;</li>
<li>PostgreSQL: filter by price &lt; $500</li>
<li>Combine results</li>
<li>Cache for 5 minutes</li>
<li>Return to user in &lt;50ms</li>
</ol>
<p>RESULTS:</p>
<p>Initial State:</p>
<ul>
<li>Technology: PostgreSQL LIKE queries</li>
<li>Performance: 30+ seconds</li>
<li>Features: Basic text match only</li>
<li>Scalability: Maxed out at 1M products</li>
</ul>
<p>Final State:</p>
<ul>
<li>Technology: Elasticsearch + PostgreSQL</li>
<li>Performance: 20ms average</li>
<li>Features: Full-text, fuzzy, suggestions, facets</li>
<li>Scalability: 100M+ products</li>
</ul>
<p>Metrics:</p>
<ul>
<li>Search speed: 1500x faster</li>
<li>User satisfaction: 45% → 92%</li>
<li>Conversion rate: +23%</li>
<li>Bounce rate: -35%</li>
</ul>
<p>This architecture now powers search for 10M products 
with sub-100ms response times and advanced features!&quot;</p>
<pre><code>
---

[Continue with Q373-376 in next response for complete coverage]


## Question 373: You need to implement a multi-tenant database where each tenant has separate data. How do you design the schema?

### Answer
</code></pre>
<p>SCENARIO: SaaS application with 1,000+ companies (tenants)
Requirements: Data isolation, performance, scalability, compliance</p>
<p>MULTI-TENANT STRATEGIES COMPARISON:</p>
<p>STRATEGY 1: SEPARATE DATABASES (Database-per-Tenant)</p>
<p>Architecture:</p>
<ul>
<li>Each tenant gets own PostgreSQL database</li>
<li>tenant_1_production, tenant_2_production, etc.</li>
</ul>
<p>Pros:
✅ Complete data isolation
✅ Easy to backup/restore per tenant
✅ Can customize schema per tenant
✅ Simpler compliance (GDPR, HIPAA)
✅ Easy to scale (different servers per tenant)</p>
<p>Cons:
❌ High operational overhead
❌ Expensive (more databases = more resources)
❌ Schema migrations slow (run on every database)
❌ Hard to query across tenants
❌ Connection pooling challenges</p>
<p>Implementation:</p>
<h1>config/database.yml</h1>
<p>production:
  adapter: postgresql
  encoding: unicode
  pool: 5</p>
<h1>Base configuration</h1>
<p>  host: &lt;%= ENV[&#39;DB_HOST&#39;] %&gt;
  username: &lt;%= ENV[&#39;DB_USER&#39;] %&gt;
  password: &lt;%= ENV[&#39;DB_PASSWORD&#39;] %&gt;</p>
<h1>Middleware to switch database</h1>
<p>class TenantMiddleware
  def initialize(app)
    @app = app
  end</p>
<p>  def call(env)
    request = Rack::Request.new(env)
    tenant = extract_tenant(request)</p>
<pre><code>if tenant
  Apartment::Tenant.switch(tenant.database_name) do
    @app.call(env)
  end
else
  [401, {}, [&#39;Tenant not found&#39;]]
end
</code></pre>
<p>  end</p>
<p>  private</p>
<p>  def extract_tenant(request)
    # From subdomain
    subdomain = request.host.split(&#39;.&#39;).first
    Tenant.find_by(subdomain: subdomain)</p>
<pre><code># Or from header
# tenant_id = request.headers[&#39;X-Tenant-ID&#39;]
# Tenant.find(tenant_id)
</code></pre>
<p>  end
end</p>
<h1>Using Apartment gem</h1>
<h1>Gemfile</h1>
<p>gem &#39;apartment&#39;</p>
<h1>config/initializers/apartment.rb</h1>
<p>Apartment.configure do |config|
  config.excluded_models = [&#39;Tenant&#39;, &#39;User&#39;]
  config.tenant_names = lambda { Tenant.pluck(:database_name) }
end</p>
<h1>Models</h1>
<p>class Tenant &lt; ApplicationRecord</p>
<h1>Stored in public schema</h1>
<p>  self.table_name = &#39;tenants&#39;</p>
<p>  has_many :users</p>
<p>  after_create :create_database</p>
<p>  def create_database
    Apartment::Tenant.create(database_name)
  end
end</p>
<p>class Order &lt; ApplicationRecord</p>
<h1>Stored in tenant-specific database</h1>
<p>end</p>
<h1>Usage</h1>
<p>tenant = Tenant.find_by(subdomain: &#39;acme&#39;)
Apartment::Tenant.switch(tenant.database_name) do
  Order.all  # Queries acme&#39;s database
end</p>
<p>When to use:</p>
<ul>
<li>&lt;100 tenants</li>
<li>High data isolation requirements</li>
<li>Custom schema per tenant needed</li>
<li>Large tenants with dedicated resources</li>
</ul>
<p>STRATEGY 2: SHARED DATABASE, SHARED SCHEMA (Row-level)</p>
<p>Architecture:</p>
<ul>
<li>Single database</li>
<li>tenant_id column on every table</li>
<li>Default scope filters by tenant_id</li>
</ul>
<p>Pros:
✅ Simplest implementation
✅ Easy to manage
✅ Cost-effective
✅ Fast schema migrations
✅ Easy cross-tenant reporting</p>
<p>Cons:
❌ Risk of data leakage
❌ Complex queries (always filter by tenant_id)
❌ Hard to scale individual tenants
❌ Noisy neighbor problem</p>
<p>Implementation:</p>
<h1>Migration</h1>
<p>class AddTenantToAllTables &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :users, :tenant_id, :bigint, null: false
    add_column :orders, :tenant_id, :bigint, null: false
    add_column :products, :tenant_id, :bigint, null: false</p>
<pre><code># Add indexes
add_index :users, [:tenant_id, :id]
add_index :orders, [:tenant_id, :id]
add_index :products, [:tenant_id, :id]

# Add foreign key
add_foreign_key :users, :tenants
</code></pre>
<p>  end
end</p>
<h1>Concern for multi-tenancy</h1>
<p>module MultiTenant
  extend ActiveSupport::Concern</p>
<p>  included do
    belongs_to :tenant</p>
<pre><code>validates :tenant_id, presence: true

default_scope { where(tenant_id: Current.tenant_id) }

before_validation :set_tenant
</code></pre>
<p>  end</p>
<p>  private</p>
<p>  def set_tenant
    self.tenant_id ||= Current.tenant_id
  end
end</p>
<h1>Models</h1>
<p>class Order &lt; ApplicationRecord
  include MultiTenant</p>
<p>  has_many :line_items
end</p>
<p>class LineItem &lt; ApplicationRecord
  include MultiTenant</p>
<p>  belongs_to :order
end</p>
<h1>Current tenant tracking</h1>
<p>class Current &lt; ActiveSupport::CurrentAttributes
  attribute :tenant_id, :user
end</p>
<h1>Controller</h1>
<p>class ApplicationController &lt; ActionController::Base
  before_action :set_current_tenant</p>
<p>  private</p>
<p>  def set_current_tenant
    tenant = find_tenant</p>
<pre><code>if tenant
  Current.tenant_id = tenant.id
else
  render json: {error: &#39;Tenant not found&#39;}, status: 404
end
</code></pre>
<p>  end</p>
<p>  def find_tenant
    # From subdomain
    subdomain = request.subdomain
    Tenant.find_by(subdomain: subdomain)</p>
<pre><code># Or from authenticated user
# current_user&amp;.tenant
</code></pre>
<p>  end
end</p>
<h1>ActsAsTenant gem (recommended)</h1>
<h1>Gemfile</h1>
<p>gem &#39;acts_as_tenant&#39;</p>
<h1>config/initializers/acts_as_tenant.rb</h1>
<p>ActsAsTenant.configure do |config|
  config.require_tenant = true  # Raise error if no tenant set
end</p>
<h1>Models</h1>
<p>class ApplicationRecord &lt; ActiveRecord::Base
  acts_as_tenant(:tenant)
end</p>
<p>class Order &lt; ApplicationRecord</p>
<h1>Automatically scoped to Current.tenant</h1>
<p>end</p>
<h1>Controller</h1>
<p>class ApplicationController &lt; ActionController::Base
  set_current_tenant_through_filter</p>
<p>  before_action :set_tenant</p>
<p>  def set_tenant
    tenant = Tenant.find_by(subdomain: request.subdomain)
    set_current_tenant(tenant)
  end
end</p>
<h1>Usage - automatic scoping</h1>
<p>Order.all  # SELECT * FROM orders WHERE tenant_id = 123</p>
<h1>Skip tenant scoping (admin operations)</h1>
<p>ActsAsTenant.without_tenant do
  Order.all  # All tenants
end</p>
<p>When to use:</p>
<ul>
<li>1,000+ small tenants</li>
<li>Simple schema</li>
<li>Cost-effective hosting</li>
<li>Easy management</li>
</ul>
<p>STRATEGY 3: SHARED DATABASE, SEPARATE SCHEMAS (Schema-per-Tenant)</p>
<p>Architecture:</p>
<ul>
<li>Single PostgreSQL database</li>
<li>Separate schema for each tenant</li>
<li>public schema for shared tables</li>
</ul>
<p>Pros:
✅ Good data isolation
✅ More cost-effective than separate DBs
✅ Can customize per-tenant
✅ Single database to manage</p>
<p>Cons:
❌ PostgreSQL-specific
❌ Connection pooling complex
❌ Slower migrations (one per schema)
❌ Can hit schema limits (thousands)</p>
<p>Implementation:</p>
<h1>Using Apartment gem with schemas</h1>
<h1>config/initializers/apartment.rb</h1>
<p>Apartment.configure do |config|
  config.excluded_models = [&#39;Tenant&#39;]
  config.use_schemas = true  # Use schemas instead of DBs
  config.tenant_names = lambda { Tenant.pluck(:schema_name) }
end</p>
<h1>Models</h1>
<p>class Tenant &lt; ApplicationRecord
  after_create :create_schema</p>
<p>  def create_schema
    Apartment::Tenant.create(schema_name)
  end
end</p>
<h1>Middleware</h1>
<p>class TenantMiddleware
  def call(env)
    tenant = extract_tenant(Rack::Request.new(env))</p>
<pre><code>Apartment::Tenant.switch(tenant.schema_name) do
  @app.call(env)
end
</code></pre>
<p>  end
end</p>
<h1>Database structure</h1>
<p>CREATE SCHEMA tenant_acme;
CREATE SCHEMA tenant_widgets;
CREATE SCHEMA public;  -- For shared tables</p>
<p>-- Each tenant schema has same tables
CREATE TABLE tenant_acme.orders (...);
CREATE TABLE tenant_widgets.orders (...);</p>
<p>-- Public schema has tenant registry
CREATE TABLE public.tenants (...);</p>
<p>When to use:</p>
<ul>
<li>100-1,000 tenants</li>
<li>PostgreSQL required</li>
<li>Need some isolation</li>
<li>Moderate cost constraints</li>
</ul>
<p>HYBRID APPROACH (Recommended for Large Scale)</p>
<p>Combine strategies based on tenant size:</p>
<p>class Tenant &lt; ApplicationRecord
  enum isolation_level: {
    shared: 0,      # Small tenants: shared schema
    schema: 1,      # Medium tenants: separate schema
    database: 2     # Large tenants: separate database
  }</p>
<p>  def switch
    case isolation_level
    when &#39;shared&#39;
      Current.tenant_id = id
      yield
    when &#39;schema&#39;
      Apartment::Tenant.switch(schema_name) { yield }
    when &#39;database&#39;
      ActiveRecord::Base.establish_connection(database_config)
      yield
      ActiveRecord::Base.establish_connection(:production)
    end
  end
end</p>
<h1>Usage</h1>
<p>tenant.switch do
  Order.all  # Routed correctly based on isolation level
end</p>
<p>SECURITY BEST PRACTICES:</p>
<ol>
<li>Row-Level Security (PostgreSQL):</li>
</ol>
<p>-- Enable RLS on all tables
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;</p>
<p>-- Create policy
CREATE POLICY tenant_isolation ON orders
  USING (tenant_id = current_setting(&#39;app.current_tenant_id&#39;)::bigint);</p>
<p>-- Set tenant in session
class ApplicationController &lt; ActionController::Base
  before_action :set_tenant_context</p>
<p>  def set_tenant_context
    tenant_id = find_tenant.id
    ActiveRecord::Base.connection.execute(
      &quot;SET app.current_tenant_id = #{tenant_id}&quot;
    )
  end
end</p>
<ol start="2">
<li>Prevent Cross-Tenant Data Leakage:</li>
</ol>
<h1>Test every query</h1>
<p>RSpec.describe Order, type: :model do
  describe &#39;tenant isolation&#39; do
    let(:tenant1) { create(:tenant) }
    let(:tenant2) { create(:tenant) }</p>
<pre><code>it &#39;only returns current tenant orders&#39; do
  order1 = create(:order, tenant: tenant1)
  order2 = create(:order, tenant: tenant2)
  
  ActsAsTenant.with_tenant(tenant1) do
    expect(Order.all).to include(order1)
    expect(Order.all).not_to include(order2)
  end
end

it &#39;prevents updating other tenant records&#39; do
  order = create(:order, tenant: tenant2)
  
  ActsAsTenant.with_tenant(tenant1) do
    expect {
      order.update!(total: 999)
    }.to raise_error(ActiveRecord::RecordNotFound)
  end
end
</code></pre>
<p>  end
end</p>
<ol start="3">
<li>Audit Logging:</li>
</ol>
<p>class AuditLog &lt; ApplicationRecord
  acts_as_tenant(:tenant)</p>
<p>  belongs_to :user</p>
<p>  def self.log(action, resource, details = {})
    create!(
      action: action,
      resource_type: resource.class.name,
      resource_id: resource.id,
      user: Current.user,
      details: details,
      ip_address: Current.request_ip
    )
  end
end</p>
<h1>In models</h1>
<p>class Order &lt; ApplicationRecord
  after_create { AuditLog.log(&#39;create&#39;, self) }
  after_update { AuditLog.log(&#39;update&#39;, self, changes) }
  after_destroy { AuditLog.log(&#39;destroy&#39;, self) }
end</p>
<p>PERFORMANCE OPTIMIZATION:</p>
<ol>
<li>Tenant-Specific Indexes:</li>
</ol>
<p>-- Composite indexes with tenant_id first
CREATE INDEX idx_orders_tenant_created 
  ON orders(tenant_id, created_at DESC);</p>
<p>CREATE INDEX idx_users_tenant_email 
  ON users(tenant_id, email);</p>
<ol start="2">
<li>Partitioning Large Tables:</li>
</ol>
<p>-- Partition by tenant_id ranges
CREATE TABLE orders (
  id BIGSERIAL,
  tenant_id BIGINT NOT NULL,
  created_at TIMESTAMP NOT NULL,
  ...
) PARTITION BY RANGE (tenant_id);</p>
<p>-- Create partitions
CREATE TABLE orders_1_1000 PARTITION OF orders
  FOR VALUES FROM (1) TO (1000);</p>
<p>CREATE TABLE orders_1001_2000 PARTITION OF orders
  FOR VALUES FROM (1001) TO (2000);</p>
<ol start="3">
<li>Connection Pooling:</li>
</ol>
<h1>config/database.yml</h1>
<p>production:
  adapter: postgresql
  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 25 } %&gt;</p>
<h1>Middleware for connection management</h1>
<p>class TenantConnectionMiddleware
  def call(env)
    tenant = extract_tenant(Rack::Request.new(env))</p>
<pre><code># Use connection pool specific to tenant if large
if tenant.large?
  tenant.with_connection { @app.call(env) }
else
  @app.call(env)
end
</code></pre>
<p>  end
end</p>
<p>DATA ISOLATION TESTING:</p>
<h1>Test suite to ensure isolation</h1>
<p>describe &#39;Multi-tenant isolation&#39; do
  let(:tenant1) { create(:tenant) }
  let(:tenant2) { create(:tenant) }</p>
<p>  it &#39;isolates data between tenants&#39; do
    ActsAsTenant.with_tenant(tenant1) do
      @order1 = create(:order, total: 100)
    end</p>
<pre><code>ActsAsTenant.with_tenant(tenant2) do
  @order2 = create(:order, total: 200)
  
  expect(Order.count).to eq(1)
  expect(Order.first).to eq(@order2)
  expect(Order.sum(:total)).to eq(200)
end
</code></pre>
<p>  end</p>
<p>  it &#39;prevents cross-tenant associations&#39; do
    user1 = nil
    user2 = nil</p>
<pre><code>ActsAsTenant.with_tenant(tenant1) do
  user1 = create(:user)
end

ActsAsTenant.with_tenant(tenant2) do
  user2 = create(:user)
  order = create(:order)
  
  expect {
    order.update!(user_id: user1.id)
  }.to raise_error(ActiveRecord::InvalidForeignKey)
end
</code></pre>
<p>  end
end</p>
<p>MIGRATION STRATEGY:</p>
<h1>Run migration on all tenants</h1>
<p>namespace :tenants do
  task migrate: :environment do
    Tenant.find_each do |tenant|
      puts &quot;Migrating #{tenant.name}...&quot;</p>
<pre><code>  tenant.switch do
    ActiveRecord::Migrator.migrate(&#39;db/migrate/&#39;)
  end
end
</code></pre>
<p>  end
end</p>
<h1>Or with Apartment gem</h1>
<p>rake apartment:migrate</p>
<p>RECOMMENDED ARCHITECTURE:</p>
<p>For SaaS with 1,000+ tenants:</p>
<ol>
<li>Small tenants (&lt;100 users): Shared database + ActsAsTenant</li>
<li>Medium tenants (100-1,000 users): Separate schema</li>
<li>Large tenants (1,000+ users): Separate database</li>
<li>Enterprise tenants: Dedicated server/cluster</li>
</ol>
<p>Implementation:
┌────────────────────────────────────────┐
│           Application Layer             │
│  (Routes to correct isolation strategy) │
└────────────────┬───────────────────────┘
                 │
       ┌─────────┼─────────┐
       │         │         │
       ▼         ▼         ▼
┌─────────┐ ┌─────────┐ ┌──────────┐
│ Shared  │ │ Schema  │ │ Separate │
│ Schema  │ │ per     │ │ Database │
│ (1000   │ │ Tenant  │ │ (10 large│
│ tenants)│ │ (100)   │ │ tenants) │
└─────────┘ └─────────┘ └──────────┘</p>
<p>This gives flexibility, cost-effectiveness, and scalability!&quot;</p>
<pre><code>
---

## Question 374: Describe a performance issue you encountered with an SQL query. How did you optimize it?

### Answer Template
</code></pre>
<p>REAL EXAMPLE: Slow Dashboard Query</p>
<p>SITUATION:
Company dashboard showing 30-second load times
Customer complaints increasing
Database CPU at 85%
Executive team frustrated</p>
<p>THE PROBLEMATIC QUERY:</p>
<h1>Controller</h1>
<p>def dashboard
  @stats = {
    total_revenue: calculate_total_revenue,
    top_customers: find_top_customers,
    monthly_trends: calculate_monthly_trends
  }
end</p>
<h1>The slow query</h1>
<p>def calculate_monthly_trends
  (0..11).map do |i|
    month = i.months.ago.beginning_of_month
    {
      month: month.strftime(&#39;%B %Y&#39;),
      orders: Order.where(
        &#39;created_at &gt;= ? AND created_at &lt; ?&#39;,
        month,
        month.end_of_month
      ).count,
      revenue: Order.where(
        &#39;created_at &gt;= ? AND created_at &lt; ?&#39;,
        month,
        month.end_of_month
      ).sum(:total)
    }
  end
end</p>
<p>Generated SQL (executed 24 times!):
SELECT COUNT(*) FROM orders 
WHERE created_at &gt;= &#39;2024-01-01&#39; AND created_at &lt; &#39;2024-02-01&#39;;</p>
<p>SELECT SUM(total) FROM orders 
WHERE created_at &gt;= &#39;2024-01-01&#39; AND created_at &lt; &#39;2024-02-01&#39;;</p>
<p>SELECT COUNT(*) FROM orders 
WHERE created_at &gt;= &#39;2024-02-01&#39; AND created_at &lt; &#39;2024-03-01&#39;;
...</p>
<p>Time: 30+ seconds</p>
<p>STEP 1: IDENTIFY THE PROBLEM</p>
<p>Used EXPLAIN ANALYZE:</p>
<p>EXPLAIN ANALYZE
SELECT COUNT(*) FROM orders 
WHERE created_at &gt;= &#39;2024-01-01&#39; AND created_at &lt; &#39;2024-02-01&#39;;</p>
<p>Result:
Seq Scan on orders (cost=0.00..45123.45 rows=10234 width=0)
  Filter: (created_at &gt;= &#39;2024-01-01&#39; AND created_at &lt; &#39;2024-02-01&#39;)
  Rows Removed by Filter: 2456789
Planning time: 0.234 ms
Execution time: 2347.123 ms</p>
<p>Problems:</p>
<ol>
<li>Sequential scan (no index)</li>
<li>24 separate queries (N+1 at date level)</li>
<li>Each query scans entire table</li>
</ol>
<p>STEP 2: ADD INDEX</p>
<p>Migration:
class AddIndexToOrdersCreatedAt &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :orders, :created_at
  end
end</p>
<p>Result after index:
Index Scan using index_orders_on_created_at
  (cost=0.43..1234.56 rows=10234 width=0)
Execution time: 234.123 ms</p>
<p>Improvement: 2,347ms → 234ms (90% faster)
But still 24 queries × 234ms = 5.6 seconds</p>
<p>STEP 3: COMBINE QUERIES</p>
<p>Optimized version:
def calculate_monthly_trends
  start_date = 11.months.ago.beginning_of_month
  end_date = Time.current.end_of_month</p>
<h1>Single query with GROUP BY</h1>
<p>  results = Order
    .where(created_at: start_date..end_date)
    .group(&quot;DATE_TRUNC(&#39;month&#39;, created_at)&quot;)
    .select(
      &quot;DATE_TRUNC(&#39;month&#39;, created_at) as month&quot;,
      &quot;COUNT(*) as order_count&quot;,
      &quot;SUM(total) as revenue&quot;
    )</p>
<h1>Convert to hash for easy lookup</h1>
<p>  results_by_month = results.index_by { |r| r.month.to_date }</p>
<h1>Build array with zeros for missing months</h1>
<p>  (0..11).map do |i|
    month = i.months.ago.beginning_of_month.to_date
    result = results_by_month[month]</p>
<pre><code>{
  month: month.strftime(&#39;%B %Y&#39;),
  orders: result&amp;.order_count || 0,
  revenue: result&amp;.revenue || 0
}
</code></pre>
<p>  end
end</p>
<p>Generated SQL (ONE query):
SELECT 
  DATE_TRUNC(&#39;month&#39;, created_at) as month,
  COUNT(*) as order_count,
  SUM(total) as revenue
FROM orders
WHERE created_at BETWEEN &#39;2024-01-01&#39; AND &#39;2024-12-31&#39;
GROUP BY DATE_TRUNC(&#39;month&#39;, created_at);</p>
<p>Result: 5.6 seconds → 234ms (96% faster)</p>
<p>STEP 4: ADD MATERIALIZED VIEW</p>
<p>For frequently accessed dashboard:</p>
<p>class CreateMonthlyStatsView &lt; ActiveRecord::Migration[7.0]
  def up
    execute &lt;&lt;-SQL
      CREATE MATERIALIZED VIEW monthly_stats AS
      SELECT 
        DATE_TRUNC(&#39;month&#39;, created_at) as month,
        COUNT(*) as order_count,
        SUM(total) as revenue,
        AVG(total) as avg_order_value,
        COUNT(DISTINCT user_id) as unique_customers
      FROM orders
      GROUP BY DATE_TRUNC(&#39;month&#39;, created_at)
      ORDER BY month DESC;</p>
<pre><code>  CREATE UNIQUE INDEX idx_monthly_stats_month 
    ON monthly_stats(month);
SQL
</code></pre>
<p>  end</p>
<p>  def down
    execute &quot;DROP MATERIALIZED VIEW IF EXISTS monthly_stats&quot;
  end
end</p>
<p>Model:
class MonthlyStat &lt; ApplicationRecord
  self.table_name = &#39;monthly_stats&#39;</p>
<p>  def readonly?
    true
  end</p>
<p>  def self.refresh
    connection.execute(&#39;REFRESH MATERIALIZED VIEW CONCURRENTLY monthly_stats&#39;)
  end
end</p>
<p>Updated controller:
def calculate_monthly_trends</p>
<h1>Query materialized view (super fast!)</h1>
<p>  MonthlyStat
    .where(&#39;month &gt;= ?&#39;, 11.months.ago.beginning_of_month)
    .order(month: :asc)
    .map do |stat|
      {
        month: stat.month.strftime(&#39;%B %Y&#39;),
        orders: stat.order_count,
        revenue: stat.revenue
      }
    end
end</p>
<h1>Refresh nightly</h1>
<p>class RefreshStatsJob &lt; ApplicationJob
  def perform
    MonthlyStat.refresh
  end
end</p>
<p>Result: 234ms → 12ms (98% faster overall)</p>
<p>STEP 5: ADD CACHING</p>
<p>Final optimization:
def calculate_monthly_trends
  Rails.cache.fetch(&#39;dashboard/monthly_trends&#39;, expires_in: 1.hour) do
    MonthlyStat
      .where(&#39;month &gt;= ?&#39;, 11.months.ago.beginning_of_month)
      .order(month: :asc)
      .to_a
  end
end</p>
<p>Result: 12ms → 2ms on cache hit (99.99% faster overall)</p>
<p>FINAL RESULTS:</p>
<p>Original: 30 seconds
After index: 5.6 seconds
After query consolidation: 234ms
After materialized view: 12ms
After caching: 2ms (cache hit)</p>
<p>Total improvement: 15,000x faster!</p>
<p>LESSONS LEARNED:</p>
<ol>
<li>Always use EXPLAIN ANALYZE</li>
<li>Add indexes on filtered/sorted columns</li>
<li>Minimize number of queries (combine with GROUP BY)</li>
<li>Use materialized views for complex aggregations</li>
<li>Cache expensive calculations</li>
<li>Monitor query performance in production</li>
<li>Test with production-size data</li>
</ol>
<p>This pattern applies to many slow query scenarios:</p>
<ul>
<li>N+1 queries → Use includes/joins</li>
<li>Missing indexes → Add composite indexes</li>
<li>Multiple queries → Combine with GROUP BY</li>
<li>Complex aggregations → Materialized views</li>
<li>Frequent access → Caching</li>
</ul>
<p>The key is systematic optimization: measure, optimize one thing, 
measure again, repeat.&quot;</p>
<pre><code>
---

## Question 375: Have you ever migrated large datasets in production? What approach did you take?

### Answer Template
</code></pre>
<p>REAL EXAMPLE: Migrating 500M Records to New Schema</p>
<p>SCENARIO:</p>
<ul>
<li>Migrate user activity logs (500M records, 2TB data)</li>
<li>Change from JSON column to proper relational schema</li>
<li>Zero downtime requirement</li>
<li>Cannot lose any data</li>
<li>Must continue writing during migration</li>
</ul>
<p>OLD SCHEMA:
┌────────────────┐
│ activity_logs  │
├────────────────┤
│ id             │
│ user_id        │
│ data (JSONB)   │ ← Everything in here
│ created_at     │
└────────────────┘</p>
<p>NEW SCHEMA:
┌─────────────────┐     ┌──────────────┐
│ activities      │     │ activity_    │
├─────────────────┤     │ properties   │
│ id              │─┐   ├──────────────┤
│ user_id         │ │   │ id           │
│ activity_type   │ │   │ activity_id  │
│ occurred_at     │ │   │ key          │
│ ip_address      │ └──&lt;│ value        │
└─────────────────┘     └──────────────┘</p>
<p>PHASE 1: PREPARATION (Week 1)</p>
<ol>
<li>Analyze Current Data:</li>
</ol>
<p>SELECT 
  COUNT(*) as total_records,
  pg_size_pretty(pg_total_relation_size(&#39;activity_logs&#39;)) as size,
  MIN(created_at) as oldest,
  MAX(created_at) as newest,
  COUNT(DISTINCT user_id) as unique_users
FROM activity_logs;</p>
<p>Results:</p>
<ul>
<li>500,000,000 records</li>
<li>2 TB total size</li>
<li>Date range: 2020-01-01 to 2025-01-15</li>
<li>5,000,000 unique users</li>
</ul>
<ol start="2">
<li>Create New Schema:</li>
</ol>
<p>class CreateNewActivitySchema &lt; ActiveRecord::Migration[7.0]
  def change
    create_table :activities do |t|
      t.references :user, null: false, index: true
      t.string :activity_type, null: false
      t.datetime :occurred_at, null: false
      t.inet :ip_address
      t.timestamps</p>
<pre><code>  t.index [:user_id, :occurred_at]
  t.index [:activity_type, :occurred_at]
end

create_table :activity_properties do |t|
  t.references :activity, null: false, foreign_key: true
  t.string :key, null: false
  t.text :value
  
  t.index [:activity_id, :key], unique: true
end
</code></pre>
<p>  end
end</p>
<ol start="3">
<li>Calculate Migration Time:</li>
</ol>
<h1>Test migration on sample</h1>
<p>sample_size = 1_000_000
start_time = Time.now</p>
<p>ActivityLog.limit(sample_size).find_each(batch_size: 1000) do |log|
  migrate_log(log)
end</p>
<p>elapsed = Time.now - start_time
rate = sample_size / elapsed</p>
<p>puts &quot;Migration rate: #{rate.round(0)} records/second&quot;
total_time = 500_000_000 / rate / 3600
puts &quot;Estimated total time: #{total_time.round(1)} hours&quot;</p>
<h1>Output: ~1000 records/sec = ~140 hours = 6 days!</h1>
<p>PHASE 2: DUAL-WRITE IMPLEMENTATION (Week 2)</p>
<p>Write to both old and new schemas:</p>
<p>class ActivityLogger
  def self.log(user_id, type, data)
    # Write to old schema (existing functionality)
    old_log = ActivityLog.create!(
      user_id: user_id,
      data: {
        type: type,
        ip: Current.ip_address,
        **data
      }
    )</p>
<pre><code># ALSO write to new schema (dual write)
new_activity = Activity.create!(
  user_id: user_id,
  activity_type: type,
  occurred_at: Time.current,
  ip_address: Current.ip_address
)

data.each do |key, value|
  ActivityProperty.create!(
    activity: new_activity,
    key: key.to_s,
    value: value.to_s
  )
end
</code></pre>
<p>  rescue =&gt; e
    # Log error but don&#39;t fail (new schema issues shouldn&#39;t break app)
    Rails.logger.error(&quot;Dual write failed: #{e.message}&quot;)
    Sentry.capture_exception(e)
  end
end</p>
<p>Deploy dual-write code
Wait 1 week to ensure stable
All NEW records now in both schemas</p>
<p>PHASE 3: BACKFILL OLD DATA (Week 3-5)</p>
<p>Migrate historical data in batches:</p>
<p>class BackfillActivitiesJob &lt; ApplicationJob
  queue_as :low_priority</p>
<p>  def perform(start_id, end_id)
    ActivityLog
      .where(id: start_id..end_id)
      .where.missing(:migrated_activity)  # Skip if already migrated
      .find_each(batch_size: 1000) do |log|
        migrate_log(log)
      end
  end</p>
<p>  private</p>
<p>  def migrate_log(log)
    data = log.data.symbolize_keys</p>
<pre><code>activity = Activity.create!(
  user_id: log.user_id,
  activity_type: data[:type],
  occurred_at: log.created_at,
  ip_address: data[:ip]
)

data.except(:type, :ip).each do |key, value|
  ActivityProperty.create!(
    activity: activity,
    key: key.to_s,
    value: value.to_s
  )
end

# Mark as migrated
log.update_column(:migrated_activity_id, activity.id)
</code></pre>
<p>  rescue =&gt; e
    Rails.logger.error(&quot;Migration failed for log #{log.id}: #{e.message}&quot;)
    # Continue with next record
  end
end</p>
<h1>Queue migration jobs</h1>
<p>class QueueBackfillJobsJob &lt; ApplicationJob
  def perform
    batch_size = 100_000</p>
<pre><code>ActivityLog.select(:id).find_in_batches(batch_size: batch_size) do |batch|
  start_id = batch.first.id
  end_id = batch.last.id
  
  BackfillActivitiesJob.perform_later(start_id, end_id)
end
</code></pre>
<p>  end
end</p>
<h1>Start migration</h1>
<p>QueueBackfillJobsJob.perform_later</p>
<h1>Monitor progress</h1>
<p>class MigrationProgress
  def self.report
    total = ActivityLog.count
    migrated = ActivityLog.where.not(migrated_activity_id: nil).count
    percentage = (migrated.to_f / total * 100).round(2)</p>
<pre><code>remaining = total - migrated
rate = calculate_rate  # Records per hour
hours_remaining = (remaining / rate).round(1)

{
  total: total,
  migrated: migrated,
  remaining: remaining,
  percentage: percentage,
  estimated_completion: hours_remaining
}
</code></pre>
<p>  end
end</p>
<h1>Check daily</h1>
<p>MigrationProgress.report</p>
<p>PHASE 4: VERIFICATION (Week 6)</p>
<ol>
<li>Data Integrity Checks:</li>
</ol>
<p>class VerifyMigration
  def self.run
    errors = []</p>
<pre><code># Sample verification
ActivityLog.where.not(migrated_activity_id: nil)
           .sample(10_000)
           .each do |log|
  activity = Activity.find(log.migrated_activity_id)
  
  unless verify_match(log, activity)
    errors &lt;&lt; {log_id: log.id, activity_id: activity.id}
  end
end

errors
</code></pre>
<p>  end</p>
<p>  def self.verify_match(log, activity)
    log.user_id == activity.user_id &amp;&amp;
    log.data[&#39;type&#39;] == activity.activity_type &amp;&amp;
    (log.created_at - activity.occurred_at).abs &lt; 1.second
  end
end</p>
<p>errors = VerifyMigration.run
if errors.any?
  puts &quot;Found #{errors.count} mismatches!&quot;</p>
<h1>Fix mismatches</h1>
<p>else
  puts &quot;All data verified ✓&quot;
end</p>
<ol start="2">
<li>Count Verification:</li>
</ol>
<p>old_count = ActivityLog.count
new_count = Activity.count</p>
<p>puts &quot;Old schema: #{old_count}&quot;
puts &quot;New schema: #{new_count}&quot;
puts &quot;Difference: #{(old_count - new_count).abs}&quot;</p>
<h1>Should be within small margin (accounting for in-progress writes)</h1>
<ol start="3">
<li>Performance Verification:</li>
</ol>
<h1>Compare query performance</h1>
<p>Benchmark.measure do</p>
<h1>Old schema</h1>
<p>  ActivityLog.where(user_id: user_id)
             .where(&quot;data-&gt;&gt;&#39;type&#39; = &#39;purchase&#39;&quot;)
             .where(&quot;created_at &gt; ?&quot;, 30.days.ago)
             .count
end</p>
<p>Benchmark.measure do</p>
<h1>New schema</h1>
<p>  Activity.where(user_id: user_id)
          .where(activity_type: &#39;purchase&#39;)
          .where(&quot;occurred_at &gt; ?&quot;, 30.days.ago)
          .count
end</p>
<p>PHASE 5: SWITCH READS (Week 7)</p>
<p>Gradually move reads to new schema:</p>
<p>class ActivityQuery
  def self.for_user(user_id, options = {})
    if use_new_schema?(user_id)
      query_new_schema(user_id, options)
    else
      query_old_schema(user_id, options)
    end
  end</p>
<p>  def self.use_new_schema?(user_id)
    # Gradual rollout
    rollout_percentage = ENV.fetch(&#39;NEW_SCHEMA_ROLLOUT&#39;, 0).to_i
    (user_id % 100) &lt; rollout_percentage
  end</p>
<p>  def self.query_new_schema(user_id, options)
    Activity.where(user_id: user_id)
            .where(activity_type: options[:type])
            .where(&quot;occurred_at &gt; ?&quot;, options[:since])
  end</p>
<p>  def self.query_old_schema(user_id, options)
    ActivityLog.where(user_id: user_id)
               .where(&quot;data-&gt;&gt;&#39;type&#39; = ?&quot;, options[:type])
               .where(&quot;created_at &gt; ?&quot;, options[:since])
  end
end</p>
<p>Rollout schedule:</p>
<ul>
<li>Day 1: 1% of users</li>
<li>Day 2: 5% of users</li>
<li>Day 3: 10% of users</li>
<li>Day 4: 25% of users</li>
<li>Day 5: 50% of users</li>
<li>Day 6: 75% of users</li>
<li>Day 7: 100% of users</li>
</ul>
<p>Monitor for issues at each step.</p>
<p>PHASE 6: DEPRECATE OLD SCHEMA (Week 8)</p>
<ol>
<li>Stop Dual Writes:</li>
</ol>
<h1>Remove dual write code</h1>
<p>class ActivityLogger
  def self.log(user_id, type, data)
    activity = Activity.create!(
      user_id: user_id,
      activity_type: type,
      occurred_at: Time.current,
      ip_address: Current.ip_address
    )</p>
<pre><code>data.each do |key, value|
  ActivityProperty.create!(
    activity: activity,
    key: key.to_s,
    value: value.to_s
  )
end
</code></pre>
<p>  end
end</p>
<ol start="2">
<li>Archive Old Data (Week 9-10):</li>
</ol>
<h1>Export to S3 for compliance</h1>
<p>class ArchiveOldActivityLogs &lt; ApplicationJob
  def perform
    csv_file = Tempfile.new([&#39;activity_logs&#39;, &#39;.csv&#39;])</p>
<pre><code>CSV.open(csv_file, &#39;wb&#39;) do |csv|
  csv &lt;&lt; [&#39;id&#39;, &#39;user_id&#39;, &#39;data&#39;, &#39;created_at&#39;]
  
  ActivityLog.find_each(batch_size: 10_000) do |log|
    csv &lt;&lt; [log.id, log.user_id, log.data.to_json, log.created_at]
  end
end

# Upload to S3
s3 = Aws::S3::Client.new
s3.put_object(
  bucket: &#39;archived-data&#39;,
  key: &quot;activity_logs/#{Date.current}.csv.gz&quot;,
  body: gzip(csv_file.read)
)

csv_file.close
csv_file.unlink
</code></pre>
<p>  end
end</p>
<ol start="3">
<li>Drop Old Table (Week 11):</li>
</ol>
<p>class DropActivityLogs &lt; ActiveRecord::Migration[7.0]
  def up
    # Final backup
    execute &quot;CREATE TABLE activity_logs_backup AS SELECT * FROM activity_logs LIMIT 0&quot;</p>
<pre><code># Drop table
drop_table :activity_logs
</code></pre>
<p>  end</p>
<p>  def down
    # Can restore from S3 if needed
    raise ActiveRecord::IrreversibleMigration
  end
end</p>
<p>RESULTS:</p>
<p>Timeline:</p>
<ul>
<li>Week 1: Preparation</li>
<li>Week 2: Dual write implementation</li>
<li>Week 3-5: Backfill (3 weeks running in background)</li>
<li>Week 6: Verification</li>
<li>Week 7: Gradual read migration</li>
<li>Week 8: Stop dual writes</li>
<li>Week 9-10: Archive old data</li>
<li>Week 11: Drop old table</li>
</ul>
<p>Total: 11 weeks, ZERO downtime</p>
<p>Data integrity: 100%
Performance improvement: 10x faster queries
Storage savings: 40% (normalized schema vs JSONB)</p>
<p>LESSONS LEARNED:</p>
<ol>
<li>Dual-write before backfilling</li>
<li>Backfill in background at low priority</li>
<li>Verify data integrity continuously</li>
<li>Gradual rollout for reads</li>
<li>Keep old schema until confident</li>
<li>Archive before deleting</li>
<li>Monitor every phase</li>
<li>Have rollback plan ready</li>
<li>Test on staging with production-size data</li>
<li>Communicate timeline to stakeholders</li>
</ol>
<p>TOOLS USED:</p>
<ul>
<li>Sidekiq for background jobs</li>
<li>AWS S3 for archival</li>
<li>Datadog for monitoring</li>
<li>Custom dashboard for progress</li>
<li>Automated verification scripts</li>
<li>Feature flags for gradual rollout</li>
</ul>
<p>This approach works for any large data migration:</p>
<ul>
<li>Add new schema alongside old</li>
<li>Dual write to both</li>
<li>Backfill historical data</li>
<li>Verify integrity</li>
<li>Migrate reads gradually</li>
<li>Deprecate old schema</li>
<li>Archive and cleanup&quot;</li>
</ul>
<pre><code>
---

## Question 376: What strategies do you use for database backup and recovery?

### Answer
</code></pre>
<p>COMPREHENSIVE BACKUP &amp; RECOVERY STRATEGY:</p>
<p>BACKUP TYPES:</p>
<ol>
<li>PHYSICAL BACKUPS (Full Database)</li>
<li>LOGICAL BACKUPS (SQL Dumps)</li>
<li>CONTINUOUS ARCHIVING (WAL)</li>
<li>POINT-IN-TIME RECOVERY (PITR)</li>
<li>REPLICA SNAPSHOTS</li>
</ol>
<p>STRATEGY 1: AUTOMATED DAILY BACKUPS</p>
<p>PostgreSQL pg_dump:</p>
<p>#!/bin/bash</p>
<h1>backup.sh</h1>
<p>DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR=&quot;/backups/postgres&quot;
DATABASE=&quot;production&quot;
S3_BUCKET=&quot;s3://myapp-backups&quot;</p>
<h1>Create backup</h1>
<p>pg_dump $DATABASE | gzip &gt; $BACKUP_DIR/backup_$DATE.sql.gz</p>
<h1>Upload to S3</h1>
<p>aws s3 cp $BACKUP_DIR/backup_$DATE.sql.gz $S3_BUCKET/daily/</p>
<h1>Keep local backups for 7 days</h1>
<p>find $BACKUP_DIR -name &quot;backup_*.sql.gz&quot; -mtime +7 -delete</p>
<h1>Verify backup</h1>
<p>gunzip -c $BACKUP_DIR/backup_$DATE.sql.gz | head -n 100</p>
<p>Schedule with cron:
0 2 * * * /scripts/backup.sh</p>
<p>STRATEGY 2: CONTINUOUS ARCHIVING (WAL)</p>
<p>PostgreSQL WAL archiving:</p>
<h1>postgresql.conf</h1>
<p>wal_level = replica
archive_mode = on
archive_command = &#39;test ! -f /mnt/wal_archive/%f &amp;&amp; cp %p /mnt/wal_archive/%f&#39;
archive_timeout = 300  # Archive every 5 minutes</p>
<h1>Or archive to S3</h1>
<p>archive_command = &#39;aws s3 cp %p s3://myapp-wal-archive/%f&#39;</p>
<p>Benefits:</p>
<ul>
<li>Point-in-time recovery</li>
<li>Minimal data loss (up to last WAL)</li>
<li>Can restore to any point in time</li>
</ul>
<p>STRATEGY 3: STREAMING REPLICATION</p>
<p>Setup read replica that can be promoted:</p>
<h1>Primary server postgresql.conf</h1>
<p>wal_level = replica
max_wal_senders = 3
wal_keep_size = &#39;1GB&#39;</p>
<h1>Replica server</h1>
<p>hot_standby = on
primary_conninfo = &#39;host=primary port=5432 user=replicator password=xxx&#39;</p>
<h1>Rails configuration</h1>
<p>class ApplicationRecord &lt; ActiveRecord::Base
  connects_to database: {writing: :primary, reading: :replica}
end</p>
<p>Recovery process:</p>
<ol>
<li><p>If primary fails, promote replica:
pg_ctl promote -D /var/lib/postgresql/data</p>
</li>
<li><p>Update Rails to use new primary</p>
</li>
<li><p>Set up new replica from new primary</p>
</li>
</ol>
<p>STRATEGY 4: SCHEDULED RAKE TASKS</p>
<h1>lib/tasks/backup.rake</h1>
<p>namespace :db do
  desc &quot;Backup database to S3&quot;
  task backup: :environment do
    timestamp = Time.current.strftime(&#39;%Y%m%d_%H%M%S&#39;)
    filename = &quot;#{Rails.env}_#{timestamp}.sql.gz&quot;</p>
<pre><code># Create backup
`pg_dump #{db_config[&#39;database&#39;]} | gzip &gt; /tmp/#{filename}`

# Upload to S3
s3 = Aws::S3::Client.new
File.open(&quot;/tmp/#{filename}&quot;, &#39;rb&#39;) do |file|
  s3.put_object(
    bucket: &#39;myapp-backups&#39;,
    key: &quot;databases/#{filename}&quot;,
    body: file
  )
end

# Cleanup
File.delete(&quot;/tmp/#{filename}&quot;)

puts &quot;Backup completed: #{filename}&quot;
</code></pre>
<p>  end</p>
<p>  desc &quot;Restore database from S3&quot;
  task restore: :environment do
    # List available backups
    s3 = Aws::S3::Client.new
    objects = s3.list_objects_v2(
      bucket: &#39;myapp-backups&#39;,
      prefix: &#39;databases/&#39;
    )</p>
<pre><code>puts &quot;Available backups:&quot;
objects.contents.each_with_index do |obj, i|
  puts &quot;#{i + 1}. #{obj.key} (#{obj.size} bytes, #{obj.last_modified})&quot;
end

print &quot;Select backup number: &quot;
selection = STDIN.gets.chomp.to_i - 1
backup_key = objects.contents[selection].key

# Download and restore
s3.get_object(
  bucket: &#39;myapp-backups&#39;,
  key: backup_key,
  response_target: &#39;/tmp/restore.sql.gz&#39;
)

`dropdb #{db_config[&#39;database&#39;]}`
`createdb #{db_config[&#39;database&#39;]}`
`gunzip -c /tmp/restore.sql.gz | psql #{db_config[&#39;database&#39;]}`

File.delete(&#39;/tmp/restore.sql.gz&#39;)

puts &quot;Restore completed!&quot;
</code></pre>
<p>  end
end</p>
<p>STRATEGY 5: BACKUP VERIFICATION</p>
<p>Automated testing of backups:</p>
<p>class BackupVerifier
  def self.verify_latest
    # Download latest backup
    backup = download_latest_backup</p>
<pre><code># Restore to test database
restore_to_test_db(backup)

# Run basic checks
checks = [
  check_table_counts,
  check_data_integrity,
  check_indexes,
  check_constraints
]

if checks.all?
  notify_success
else
  notify_failure(checks)
end
</code></pre>
<p>  end</p>
<p>  def self.check_table_counts
    # Compare record counts
    production_counts = get_production_table_counts
    test_counts = get_test_table_counts</p>
<pre><code>production_counts == test_counts
</code></pre>
<p>  end</p>
<p>  def self.check_data_integrity
    # Verify foreign keys
    <code>psql test_db -c &quot;SELECT * FROM pg_catalog.pg_constraint WHERE contype = &#39;f&#39;&quot;</code>
    $?.success?
  end
end</p>
<h1>Schedule daily</h1>
<p>class VerifyBackupJob &lt; ApplicationJob
  def perform
    BackupVerifier.verify_latest
  end
end</p>
<p>RETENTION POLICY:</p>
<p>┌──────────────────────────────────────────┐
│ RETENTION SCHEDULE                       │
├──────────────────────────────────────────┤
│ Hourly:  Keep last 24 hours              │
│ Daily:   Keep last 30 days               │
│ Weekly:  Keep last 12 weeks              │
│ Monthly: Keep last 12 months             │
│ Yearly:  Keep last 7 years               │
└──────────────────────────────────────────┘</p>
<p>Implementation:</p>
<p>class BackupRetentionManager
  RETENTION_RULES = {
    hourly: {count: 24, unit: :hours},
    daily: {count: 30, unit: :days},
    weekly: {count: 12, unit: :weeks},
    monthly: {count: 12, unit: :months},
    yearly: {count: 7, unit: :years}
  }</p>
<p>  def self.cleanup_old_backups
    s3 = Aws::S3::Client.new
    backups = list_all_backups(s3)</p>
<pre><code># Group by frequency
grouped = group_backups_by_frequency(backups)

# Apply retention rules
RETENTION_RULES.each do |frequency, rule|
  cutoff = rule[:count].send(rule[:unit]).ago
  
  grouped[frequency].each do |backup|
    if backup.last_modified &lt; cutoff
      s3.delete_object(
        bucket: &#39;myapp-backups&#39;,
        key: backup.key
      )
    end
  end
end
</code></pre>
<p>  end
end</p>
<p>DISASTER RECOVERY PLAN:</p>
<p>Step-by-step recovery procedure:</p>
<ol>
<li><p>ASSESS SITUATION</p>
<ul>
<li>Database corrupted?</li>
<li>Hardware failure?</li>
<li>Data loss extent?</li>
<li>Downtime acceptable?</li>
</ul>
</li>
<li><p>IDENTIFY RECOVERY POINT</p>
<ul>
<li>Latest backup timestamp</li>
<li>WAL archives available</li>
<li>Acceptable data loss</li>
</ul>
</li>
<li><p>RESTORE FROM BACKUP</p>
<h1>For complete loss</h1>
<p>aws s3 cp s3://myapp-backups/latest.sql.gz /tmp/
dropdb production
createdb production
gunzip -c /tmp/latest.sql.gz | psql production</p>
</li>
<li><p>APPLY WAL ARCHIVES (Point-in-Time Recovery)</p>
<h1>recovery.conf</h1>
<p>restore_command = &#39;aws s3 cp s3://myapp-wal-archive/%f %p&#39;
recovery_target_time = &#39;2025-01-15 14:30:00&#39;</p>
<h1>Start PostgreSQL in recovery mode</h1>
<p>touch /var/lib/postgresql/data/recovery.signal
pg_ctl start</p>
</li>
<li><p>VERIFY DATA INTEGRITY</p>
<ul>
<li>Check table counts</li>
<li>Verify recent transactions</li>
<li>Test application functionality</li>
</ul>
</li>
<li><p>PROMOTE TO PRODUCTION</p>
<ul>
<li>Update DNS/load balancer</li>
<li>Monitor error rates</li>
<li>Notify team</li>
</ul>
</li>
<li><p>POST-MORTEM</p>
<ul>
<li>What caused failure?</li>
<li>How to prevent?</li>
<li>Update runbooks</li>
</ul>
</li>
</ol>
<p>RTO / RPO TARGETS:</p>
<p>Recovery Time Objective (RTO): 4 hours
Recovery Point Objective (RPO): 15 minutes</p>
<p>To achieve:</p>
<ul>
<li>Automated failover to replica (5 min)</li>
<li>WAL archiving every 5 minutes</li>
<li>Practiced recovery procedures</li>
<li>24/7 on-call rotation</li>
</ul>
<p>MONITORING &amp; ALERTS:</p>
<p>class BackupMonitor
  def self.check_health
    checks = {
      last_backup_age: check_last_backup_age,
      backup_size: check_backup_size,
      wal_archiving: check_wal_archiving,
      replica_lag: check_replica_lag
    }</p>
<pre><code>failures = checks.select { |k, v| !v[:healthy] }

if failures.any?
  alert_team(failures)
end

checks
</code></pre>
<p>  end</p>
<p>  def self.check_last_backup_age
    s3 = Aws::S3::Client.new
    latest = s3.list_objects_v2(
      bucket: &#39;myapp-backups&#39;,
      prefix: &#39;databases/&#39;,
      max_keys: 1
    ).contents.first</p>
<pre><code>age_hours = (Time.current - latest.last_modified) / 3600

{
  healthy: age_hours &lt; 25,
  age_hours: age_hours,
  last_backup: latest.last_modified
}
</code></pre>
<p>  end
end</p>
<h1>Alert if backup failed</h1>
<p>if BackupMonitor.check_health[:last_backup_age][:age_hours] &gt; 25
  PagerDuty.trigger(&quot;Database backup overdue!&quot;)
end</p>
<p>BEST PRACTICES:</p>
<ol>
<li>✅ Automate all backups</li>
<li>✅ Store backups off-site (S3/GCS)</li>
<li>✅ Encrypt backups at rest</li>
<li>✅ Test restores regularly (monthly)</li>
<li>✅ Document recovery procedures</li>
<li>✅ Monitor backup health</li>
<li>✅ Use multiple backup strategies</li>
<li>✅ Keep WAL archives for PITR</li>
<li>✅ Practice disaster recovery drills</li>
<li>✅ Review and update retention policy</li>
</ol>
<p>TOOLS:</p>
<ul>
<li>pg_dump / pg_restore (PostgreSQL)</li>
<li>pgBackRest (PostgreSQL backup tool)</li>
<li>Barman (PostgreSQL backup manager)</li>
<li>AWS RDS Automated Backups</li>
<li>Percona XtraBackup (MySQL)</li>
</ul>
<p>This multi-layered approach ensures we can recover from any disaster 
scenario within our RTO/RPO targets.&quot;</p>
<pre><code>
# Behavioral and Scenario-Based Questions (363-376)

## Behavioral Questions - Experience

## Question 363: Can you describe a challenging project you worked on?

### Answer

Use the **STAR Method** for behavioral questions:
- **Situation**: Set the context
- **Task**: Your specific responsibility
- **Action**: What you did (most important part)
- **Result**: Quantifiable outcomes

---

### Sample Answer: E-commerce Platform Performance Crisis

**SITUATION:**
&quot;At my previous company, we had a Rails-based e-commerce platform serving 50,000+ daily active users. During Black Friday 2024, we experienced a critical performance crisis. Page load times increased from 800ms to 45+ seconds, checkout was failing 30% of the time, and our database was hitting 98% CPU utilization. We were losing approximately $10,000 per hour in failed transactions, and customer complaints were flooding our support channels.&quot;

**TASK:**
&quot;As the senior Rails developer, I was assigned to lead a team of 3 developers to diagnose and resolve the performance issues within 48 hours while maintaining site availability. The stakes were high - Black Friday weekend represented 40% of our annual revenue.&quot;

**ACTION:**

**Phase 1: Immediate Triage (Hours 0-4)**

1. Set up monitoring and profiling:
```ruby
# Added New Relic detailed profiling
# config/newrelic.yml
common: &amp;default_settings
  transaction_tracer:
    enabled: true
    transaction_threshold: 0.5
    record_sql: obfuscated
    stack_trace_threshold: 0.5
  
# Enabled Bullet for N+1 detection
# config/environments/production.rb
config.after_initialize do
  Bullet.enable = true
  Bullet.rails_logger = true
  Bullet.add_footer = false
end
</code></pre>
<ol start="2">
<li>Analyzed slow query logs:</li>
</ol>
<pre><code class="language-bash"># PostgreSQL slow query analysis
SELECT 
  query,
  calls,
  total_time,
  mean_time,
  max_time
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 20;
</code></pre>
<p>Found the culprits:</p>
<ul>
<li>Product listing page: 150+ N+1 queries</li>
<li>Cart calculation: No caching, recalculating on every request</li>
<li>Checkout: Missing indexes on orders table</li>
<li>Image processing: Happening synchronously in requests</li>
</ul>
<p><strong>Phase 2: Quick Wins (Hours 4-12)</strong></p>
<ol>
<li>Fixed N+1 queries:</li>
</ol>
<pre><code class="language-ruby"># BEFORE (Bad)
class ProductsController &lt; ApplicationController
  def index
    @products = Product.where(active: true).limit(50)
    # In view: @products.each { |p| p.category.name }
    # Result: 1 + 50 queries
  end
end

# AFTER (Fixed)
class ProductsController &lt; ApplicationController
  def index
    @products = Product
      .where(active: true)
      .includes(:category, :images, :reviews)
      .limit(50)
    # Result: 4 queries total
  end
end
</code></pre>
<ol start="2">
<li>Added critical indexes:</li>
</ol>
<pre><code class="language-ruby">class AddPerformanceIndexes &lt; ActiveRecord::Migration[7.0]
  def change
    add_index :orders, [:user_id, :created_at]
    add_index :orders, [:status, :created_at]
    add_index :order_items, [:order_id, :product_id]
    add_index :products, [:category_id, :active]
  end
end
</code></pre>
<ol start="3">
<li>Implemented aggressive caching:</li>
</ol>
<pre><code class="language-ruby">class Product &lt; ApplicationRecord
  def self.featured_products
    Rails.cache.fetch(&#39;homepage/featured_products&#39;, expires_in: 10.minutes) do
      where(featured: true)
        .includes(:category, :images)
        .limit(20)
        .to_a
    end
  end
end

class CartCalculator
  def calculate_total(cart)
    cache_key = &quot;cart/#{cart.id}/total/#{cart.updated_at.to_i}&quot;
    
    Rails.cache.fetch(cache_key, expires_in: 5.minutes) do
      cart.items.sum { |item| item.price * item.quantity }
    end
  end
end
</code></pre>
<ol start="4">
<li>Moved image processing to background:</li>
</ol>
<pre><code class="language-ruby"># BEFORE (Synchronous)
class ProductsController &lt; ApplicationController
  def create
    @product = Product.new(product_params)
    if @product.save
      @product.images.each do |image|
        ImageProcessor.process(image)  # BLOCKING!
      end
      redirect_to @product
    end
  end
end

# AFTER (Asynchronous)
class Product &lt; ApplicationRecord
  after_commit :process_images_async, on: :create
  
  private
  
  def process_images_async
    images.each do |image|
      ImageProcessingJob.perform_later(image.id)
    end
  end
end
</code></pre>
<p><strong>Results after 12 hours:</strong></p>
<ul>
<li>Page load: 45s → 3.2s (93% improvement)</li>
<li>Checkout success: 70% → 92%</li>
<li>Database CPU: 98% → 65%</li>
</ul>
<p><strong>Phase 3: Deeper Optimizations (Hours 12-24)</strong></p>
<ol>
<li>Implemented database connection pooling:</li>
</ol>
<pre><code class="language-ruby"># config/database.yml
production:
  adapter: postgresql
  pool: &lt;%= ENV.fetch(&quot;RAILS_MAX_THREADS&quot;) { 25 } %&gt;
  timeout: 5000
  checkout_timeout: 5
</code></pre>
<ol start="2">
<li>Added fragment caching for expensive views:</li>
</ol>
<pre><code class="language-erb">&lt;!-- app/views/products/show.html.erb --&gt;
&lt;% cache [&#39;product&#39;, @product, @product.reviews.maximum(:updated_at)] do %&gt;
  &lt;div class=&quot;product-details&quot;&gt;
    &lt;%= render @product %&gt;
    
    &lt;% cache [&#39;product-reviews&#39;, @product, @product.reviews.maximum(:updated_at)] do %&gt;
      &lt;%= render @product.reviews %&gt;
    &lt;% end %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>
<ol start="3">
<li>Optimized cart queries:</li>
</ol>
<pre><code class="language-ruby">class Cart &lt; ApplicationRecord
  has_many :cart_items
  
  def items_with_products
    # BEFORE: N+1 queries
    # cart_items.map { |item| [item, item.product] }
    
    # AFTER: Single query with join
    cart_items
      .joins(:product)
      .select(&#39;cart_items.*, products.name, products.price, products.image_url&#39;)
  end
  
  def total_with_counter_cache
    # Used counter_cache instead of counting each time
    cart_items.sum(:quantity)
  end
end

class AddCounterCacheToCart &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :carts, :items_count, :integer, default: 0
    
    reversible do |dir|
      dir.up do
        Cart.find_each do |cart|
          Cart.reset_counters(cart.id, :cart_items)
        end
      end
    end
  end
end
</code></pre>
<ol start="4">
<li>Implemented read replicas for heavy queries:</li>
</ol>
<pre><code class="language-ruby">class ApplicationRecord &lt; ActiveRecord::Base
  connects_to database: { writing: :primary, reading: :replica }
end

class ProductsController &lt; ApplicationController
  def index
    # Use replica for read-heavy operations
    ActiveRecord::Base.connected_to(role: :reading) do
      @products = Product.search(params[:q])
    end
  end
end
</code></pre>
<p><strong>Phase 4: Infrastructure Scaling (Hours 24-48)</strong></p>
<ol>
<li>Scaled web servers from 3 to 8 instances</li>
<li>Implemented CloudFront CDN for static assets</li>
<li>Set up auto-scaling based on CPU metrics</li>
<li>Configured Redis for session storage (was using database)</li>
</ol>
<pre><code class="language-ruby"># config/initializers/session_store.rb
Rails.application.config.session_store :redis_store,
  servers: ENV[&#39;REDIS_URL&#39;],
  expire_after: 24.hours,
  key: &#39;_app_session&#39;
</code></pre>
<p><strong>RESULT:</strong></p>
<p><strong>Performance Improvements:</strong></p>
<ul>
<li>Page load time: 45s → 850ms (98% improvement)</li>
<li>Checkout success rate: 70% → 98.5%</li>
<li>Database CPU utilization: 98% → 30%</li>
<li>Server response time: P95 from 12s to 600ms</li>
<li>Concurrent users supported: 1,000 → 5,000+</li>
</ul>
<p><strong>Business Impact:</strong></p>
<ul>
<li>Recovered $240,000 in potential lost revenue</li>
<li>Processed 45,000 orders over the weekend (vs 31,000 previous year)</li>
<li>Customer satisfaction scores increased from 2.1/5 to 4.3/5</li>
<li>Zero downtime during optimization</li>
<li>Support tickets decreased by 75%</li>
</ul>
<p><strong>Team Impact:</strong></p>
<ul>
<li>Implemented monitoring dashboard (Datadog)</li>
<li>Created performance testing suite</li>
<li>Documented optimization patterns for team</li>
<li>Established code review checklist for performance</li>
<li>Trained junior developers on profiling techniques</li>
</ul>
<p><strong>Long-term Improvements:</strong></p>
<ul>
<li>Set up automated performance testing in CI/CD</li>
<li>Implemented query performance budgets</li>
<li>Created runbook for scaling during traffic spikes</li>
<li>Quarterly performance audit process</li>
</ul>
<p><strong>Key Learnings:</strong></p>
<ol>
<li><strong>Monitoring First</strong>: Can&#39;t fix what you can&#39;t measure. New Relic was invaluable.</li>
<li><strong>Quick Wins Matter</strong>: Fixed N+1 queries gave immediate 50% improvement</li>
<li><strong>Caching Strategy</strong>: Fragment caching + Redis eliminated 80% of database queries</li>
<li><strong>Team Communication</strong>: Hourly standups kept everyone aligned</li>
<li><strong>Documentation</strong>: Wrote detailed post-mortem that helped entire engineering org</li>
<li><strong>Incremental Changes</strong>: Small, tested changes were safer than big rewrites</li>
<li><strong>Infrastructure Matters</strong>: Sometimes code optimization isn&#39;t enough - need to scale</li>
</ol>
<p><strong>Personal Growth:</strong></p>
<ul>
<li>Learned to work under extreme pressure</li>
<li>Improved incident management skills</li>
<li>Gained deep understanding of Rails performance</li>
<li>Enhanced leadership and decision-making</li>
<li>Learned importance of post-mortem analysis</li>
</ul>
<p>This experience taught me that the best solutions often combine quick tactical fixes with thoughtful strategic improvements. It also reinforced the importance of having good monitoring in place before crises occur.&quot;</p>
<hr>
<h3>Alternative Example: Legacy System Migration</h3>
<p><strong>SITUATION:</strong>
&quot;Our company had a 10-year-old Rails 4.2 application with no tests, 150,000 lines of code, and mounting technical debt. The system was becoming increasingly difficult to maintain, deployment took 2 hours with frequent rollbacks, and we couldn&#39;t attract developers who wanted to work on outdated technology.&quot;</p>
<p><strong>TASK:</strong>
&quot;I was tasked with leading the Rails 4.2 → Rails 7.0 migration while maintaining feature development and zero downtime for 100,000+ daily users.&quot;</p>
<p><strong>ACTION:</strong></p>
<ol>
<li><strong>Assessment (Week 1-2)</strong></li>
</ol>
<pre><code class="language-ruby"># Created migration roadmap
# - Rails 4.2 → 5.0 → 5.1 → 5.2 → 6.0 → 6.1 → 7.0
# - Each step tested thoroughly in staging
# - Feature flags for gradual rollout

# Analyzed deprecation warnings
rake rails:update
bundle exec rails app:update

# Created compatibility layer
module Rails4Compatibility
  def self.included(base)
    # Shim for removed methods
  end
end
</code></pre>
<ol start="2">
<li><strong>Added Test Coverage (Week 3-6)</strong></li>
</ol>
<pre><code class="language-ruby"># Started at 15% coverage
# Priority: Critical paths first

# Added request specs for main flows
RSpec.describe &quot;Checkout flow&quot;, type: :request do
  it &quot;completes purchase successfully&quot; do
    # Test end-to-end flow
  end
end

# Reached 75% coverage before major migration steps
</code></pre>
<ol start="3">
<li><strong>Incremental Migration (Week 7-20)</strong></li>
</ol>
<pre><code class="language-ruby"># Used dual-boot strategy
# Gemfile
if ENV[&#39;RAILS_NEXT&#39;]
  gem &#39;rails&#39;, &#39;~&gt; 5.0.0&#39;
else
  gem &#39;rails&#39;, &#39;~&gt; 4.2.0&#39;
end

# Ran CI against both versions
# Fixed compatibility issues incrementally
</code></pre>
<p><strong>RESULT:</strong></p>
<ul>
<li>Successfully migrated from Rails 4.2 → 7.0 in 5 months</li>
<li>Zero downtime during migration</li>
<li>Test coverage: 15% → 85%</li>
<li>Deployment time: 2 hours → 15 minutes</li>
<li>Developer satisfaction increased dramatically</li>
<li>Onboarded 3 new developers in first month after migration</li>
<li>Technical debt reduced by 60%</li>
</ul>
<hr>
<h3>Key Principles for STAR Answers:</h3>
<p><strong>BE SPECIFIC:</strong></p>
<ul>
<li>Use actual numbers and metrics</li>
<li>Name specific technologies and tools</li>
<li>Describe exact problems, not generalities</li>
</ul>
<p><strong>SHOW YOUR ROLE:</strong></p>
<ul>
<li>Use &quot;I&quot; for your actions, &quot;we&quot; for team</li>
<li>Highlight leadership even if not formal leader</li>
<li>Show decision-making process</li>
</ul>
<p><strong>QUANTIFY RESULTS:</strong></p>
<ul>
<li>Performance improvements (ms, %)</li>
<li>Business impact ($, users, conversions)</li>
<li>Team impact (satisfaction, velocity)</li>
<li>Time saved (hours, days)</li>
</ul>
<p><strong>INCLUDE LEARNINGS:</strong></p>
<ul>
<li>What would you do differently?</li>
<li>What surprised you?</li>
<li>How did this change your approach?</li>
</ul>
<p><strong>KEEP IT CONCISE:</strong></p>
<ul>
<li>3-5 minutes maximum</li>
<li>Focus on YOUR actions</li>
<li>Skip unnecessary details</li>
<li>Have multiple examples ready</li>
</ul>
<hr>
<h2>Question 364: Have you faced performance issues in Rails applications? How did you resolve them?</h2>
<h3>Answer</h3>
<p><strong>Framework for Answering Performance Questions:</strong></p>
<ol>
<li>Describe the symptom</li>
<li>Explain investigation process</li>
<li>Detail the root cause</li>
<li>Show the solution</li>
<li>Quantify the improvement</li>
<li>Discuss prevention</li>
</ol>
<hr>
<h3>Example 1: N+1 Query Hell</h3>
<p><strong>PROBLEM:</strong>
&quot;Dashboard was loading in 15+ seconds. Users were complaining, and we were seeing timeout errors in production.&quot;</p>
<p><strong>INVESTIGATION:</strong></p>
<pre><code class="language-ruby"># Step 1: Enable Bullet gem in development
# Gemfile
group :development do
  gem &#39;bullet&#39;
end

# config/environments/development.rb
config.after_initialize do
  Bullet.enable = true
  Bullet.alert = true
  Bullet.bullet_logger = true
  Bullet.console = true
  Bullet.rails_logger = true
end

# Step 2: Check Rails logs
# Found: 1,000+ queries on single page load!
Started GET &quot;/dashboard&quot;
  User Load (0.5ms)  SELECT * FROM users WHERE id = 1
  Post Load (0.4ms)  SELECT * FROM posts WHERE user_id = 1
  Comment Load (0.3ms)  SELECT * FROM comments WHERE post_id = 1
  # ... repeated 500 times!
Completed 200 OK in 15234ms
</code></pre>
<p><strong>ROOT CAUSE:</strong></p>
<pre><code class="language-ruby"># Controller
class DashboardController &lt; ApplicationController
  def index
    @users = User.limit(100)
    # In view:
    # @users.each do |user|
    #   user.posts.each do |post|
    #     post.comments.count
    #   end
    # end
  end
end
</code></pre>
<p>Generated queries:</p>
<pre><code class="language-sql">SELECT * FROM users LIMIT 100;                    -- 1 query
SELECT * FROM posts WHERE user_id = 1;            -- 100 queries (one per user)
SELECT COUNT(*) FROM comments WHERE post_id = 1;  -- 500 queries (one per post)
-- Total: 601 queries!
</code></pre>
<p><strong>SOLUTION:</strong></p>
<pre><code class="language-ruby"># Use eager loading with includes
class DashboardController &lt; ApplicationController
  def index
    @users = User
      .includes(posts: :comments)
      .limit(100)
  end
end

# Generated queries (after fix):
SELECT * FROM users LIMIT 100;
SELECT * FROM posts WHERE user_id IN (1,2,3...100);
SELECT * FROM comments WHERE post_id IN (1,2,3...500);
-- Total: 3 queries!
</code></pre>
<p><strong>IMPROVEMENT:</strong></p>
<ul>
<li>Queries: 601 → 3 (99.5% reduction)</li>
<li>Load time: 15s → 450ms (97% faster)</li>
<li>Database CPU: 85% → 15%</li>
</ul>
<hr>
<h3>Example 2: Missing Database Indexes</h3>
<p><strong>PROBLEM:</strong>
&quot;Search feature timing out after database grew to 5M products.&quot;</p>
<p><strong>INVESTIGATION:</strong></p>
<pre><code class="language-ruby"># Step 1: Use EXPLAIN to analyze query
Product.where(category: &#39;Electronics&#39;, active: true).explain

# Output showed Sequential Scan (bad!)
Seq Scan on products  (cost=0.00..98765.00 rows=123456 width=100)
  Filter: (category = &#39;Electronics&#39; AND active = true)
  Rows Removed by Filter: 4876544
Planning time: 1.234 ms
Execution time: 8234.567 ms
</code></pre>
<p><strong>ROOT CAUSE:</strong>
No indexes on frequently queried columns</p>
<p><strong>SOLUTION:</strong></p>
<pre><code class="language-ruby">class AddSearchIndexes &lt; ActiveRecord::Migration[7.0]
  def change
    # Add composite index for category + active
    add_index :products, [:category, :active]
    
    # Add index for text search
    add_index :products, :name, using: :gin, opclass: :gin_trgm_ops
    
    # Add index for sorting
    add_index :products, [:category, :created_at]
  end
end

# After migration, query uses index:
Index Scan using index_products_on_category_and_active
  (cost=0.43..1234.56 rows=5678 width=100)
  Index Cond: ((category = &#39;Electronics&#39;) AND (active = true))
Planning time: 0.234 ms
Execution time: 45.678 ms
</code></pre>
<p><strong>IMPROVEMENT:</strong></p>
<ul>
<li>Query time: 8,234ms → 45ms (99.4% faster)</li>
<li>Queries moved from Seq Scan to Index Scan</li>
<li>Can now handle searches across 10M+ products</li>
</ul>
<hr>
<h3>Example 3: Memory Leaks in Background Jobs</h3>
<p><strong>PROBLEM:</strong>
&quot;Sidekiq workers consuming 4GB+ RAM and crashing daily.&quot;</p>
<p><strong>INVESTIGATION:</strong></p>
<pre><code class="language-ruby"># Step 1: Use memory_profiler gem
require &#39;memory_profiler&#39;

report = MemoryProfiler.report do
  ProcessOrdersJob.new.perform(order_ids)
end

report.pretty_print

# Output showed:
# - Loading all 100,000 orders into memory at once
# - Not releasing AR objects properly
</code></pre>
<p><strong>ROOT CAUSE:</strong></p>
<pre><code class="language-ruby">class ProcessOrdersJob &lt; ApplicationJob
  def perform(order_ids)
    # BAD: Loads everything into memory
    orders = Order.where(id: order_ids)
    
    orders.each do |order|
      process_order(order)
    end
  end
end
</code></pre>
<p><strong>SOLUTION:</strong></p>
<pre><code class="language-ruby">class ProcessOrdersJob &lt; ApplicationJob
  def perform(order_ids)
    # GOOD: Use find_each to batch process
    Order.where(id: order_ids).find_each(batch_size: 1000) do |order|
      process_order(order)
      
      # Explicitly clear AR query cache
      ActiveRecord::Base.connection.clear_query_cache
    end
    
    # Force garbage collection
    GC.start
  end
  
  private
  
  def process_order(order)
    # Use select to load only needed columns
    line_items = order.line_items.select(:id, :product_id, :quantity)
    
    line_items.each do |item|
      # Process item
    end
  end
end
</code></pre>
<p><strong>IMPROVEMENT:</strong></p>
<ul>
<li>Memory usage: 4GB → 400MB (90% reduction)</li>
<li>Workers stopped crashing</li>
<li>Can process 10x more jobs concurrently</li>
</ul>
<hr>
<h3>Example 4: Slow View Rendering</h3>
<p><strong>PROBLEM:</strong>
&quot;Product catalog page taking 5 seconds to render even with fast database queries.&quot;</p>
<p><strong>INVESTIGATION:</strong></p>
<pre><code class="language-ruby"># Rails logs showed:
Completed 200 OK in 5234ms
  Views: 4987ms
  ActiveRecord: 247ms

# Most time spent in view rendering!
</code></pre>
<p><strong>ROOT CAUSE:</strong></p>
<pre><code class="language-erb">&lt;!-- app/views/products/index.html.erb --&gt;
&lt;% @products.each do |product| %&gt;
  &lt;%= render partial: &#39;product&#39;, locals: {product: product} %&gt;
  
  &lt;!-- Expensive computation in view --&gt;
  &lt;div class=&quot;discount&quot;&gt;
    &lt;%= calculate_discount(product) %&gt;
  &lt;/div&gt;
&lt;% end %&gt;

&lt;!-- Rendering 1000 partials + running calculations 1000 times --&gt;
</code></pre>
<p><strong>SOLUTION:</strong></p>
<pre><code class="language-ruby"># 1. Use collection rendering
&lt;%= render partial: &#39;product&#39;, collection: @products %&gt;

# 2. Move calculations to model with caching
class Product &lt; ApplicationRecord
  def discount_price
    Rails.cache.fetch(&quot;product/#{id}/discount&quot;, expires_in: 1.hour) do
      calculate_discount
    end
  end
  
  private
  
  def calculate_discount
    # Expensive calculation
    base_price * (1 - discount_rate) * seasonal_multiplier
  end
end

# 3. Use fragment caching
&lt;% cache [&#39;products-index&#39;, @products.maximum(:updated_at)] do %&gt;
  &lt;%= render partial: &#39;product&#39;, collection: @products %&gt;
&lt;% end %&gt;

# 4. Precompute and store in database
class AddDiscountPriceToProducts &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :products, :cached_discount_price, :decimal
    add_index :products, :cached_discount_price
  end
end

class Product &lt; ApplicationRecord
  before_save :update_cached_discount_price
  
  def update_cached_discount_price
    self.cached_discount_price = calculate_discount
  end
end
</code></pre>
<p><strong>IMPROVEMENT:</strong></p>
<ul>
<li>Rendering time: 4,987ms → 120ms (98% faster)</li>
<li>First load: 120ms, cached loads: 15ms</li>
<li>Can display 1000 products smoothly</li>
</ul>
<hr>
<h3>Example 5: API Rate Limiting Issues</h3>
<p><strong>PROBLEM:</strong>
&quot;Third-party API calls blocking request threads and causing timeouts.&quot;</p>
<p><strong>INVESTIGATION:</strong></p>
<pre><code class="language-ruby"># Logs showed long-running requests:
Started POST &quot;/checkout&quot;
  ExternalPaymentAPI.charge (3456ms)  # BLOCKING!
  ExternalShippingAPI.calculate (2345ms)  # BLOCKING!
Completed 200 OK in 6234ms

# Timeouts when API slow or down
</code></pre>
<p><strong>ROOT CAUSE:</strong></p>
<pre><code class="language-ruby">class CheckoutController &lt; ApplicationController
  def create
    # Synchronous API calls in request cycle
    payment_result = PaymentService.charge(params[:amount])
    shipping_cost = ShippingService.calculate(params[:address])
    
    # Request thread blocked for 6+ seconds!
  end
end
</code></pre>
<p><strong>SOLUTION:</strong></p>
<pre><code class="language-ruby"># 1. Move to background jobs
class CheckoutController &lt; ApplicationController
  def create
    order = Order.create!(order_params.merge(status: &#39;pending&#39;))
    
    # Process asynchronously
    ProcessCheckoutJob.perform_later(order.id)
    
    render json: {
      order_id: order.id,
      status: &#39;processing&#39;
    }, status: :accepted
  end
end

class ProcessCheckoutJob &lt; ApplicationJob
  queue_as :critical
  
  # Retry with exponential backoff
  retry_on ExternalAPIError, wait: :exponentially_longer, attempts: 5
  
  def perform(order_id)
    order = Order.find(order_id)
    
    # Parallel API calls with timeout
    results = Parallel.map([
      -&gt; { PaymentService.charge(order.total) },
      -&gt; { ShippingService.calculate(order.address) }
    ], in_threads: 2) do |api_call|
      Timeout.timeout(5) { api_call.call }
    rescue Timeout::Error =&gt; e
      # Handle timeout
      Rails.logger.error(&quot;API timeout: #{e.message}&quot;)
      nil
    end
    
    payment_result, shipping_cost = results
    
    order.update!(
      payment_status: payment_result&amp;.status,
      shipping_cost: shipping_cost,
      status: &#39;completed&#39;
    )
  end
end

# 2. Add circuit breaker for failing APIs
class ExternalAPIClient
  include CircuitBreaker
  
  circuit_breaker threshold: 5,
                  timeout: 60,
                  exceptions: [ExternalAPIError, Timeout::Error]
  
  def self.call(endpoint, params)
    response = Faraday.get(endpoint, params) do |req|
      req.options.timeout = 5
      req.options.open_timeout = 2
    end
    
    JSON.parse(response.body)
  rescue Faraday::TimeoutError
    # Return cached result or default
    Rails.cache.fetch(&quot;api/fallback/#{endpoint}&quot;) do
      default_response
    end
  end
end
</code></pre>
<p><strong>IMPROVEMENT:</strong></p>
<ul>
<li>Request time: 6,234ms → 45ms (99.3% faster)</li>
<li>Non-blocking user experience</li>
<li>Automatic retry with exponential backoff</li>
<li>Circuit breaker prevents cascade failures</li>
<li>Graceful degradation when APIs fail</li>
</ul>
<hr>
<h3>Performance Debugging Toolkit</h3>
<p><strong>Tools I Use:</strong></p>
<pre><code class="language-ruby"># 1. Bullet - N+1 detection
gem &#39;bullet&#39;, group: :development

# 2. rack-mini-profiler - Request profiling
gem &#39;rack-mini-profiler&#39;

# 3. memory_profiler - Memory analysis
gem &#39;memory_profiler&#39;

# 4. Skylight/New Relic - Production monitoring
gem &#39;skylight&#39;

# 5. pg_query - PostgreSQL analysis
SELECT * FROM pg_stat_statements 
ORDER BY mean_time DESC;

# 6. Rails query logs
config.active_record.verbose_query_logs = true

# 7. Benchmark for comparing approaches
require &#39;benchmark&#39;

Benchmark.bm do |x|
  x.report(&quot;approach 1:&quot;) { approach_1 }
  x.report(&quot;approach 2:&quot;) { approach_2 }
end
</code></pre>
<p><strong>My Performance Checklist:</strong></p>
<pre><code class="language-markdown">Before deploying any feature:
- [ ] Checked for N+1 queries with Bullet
- [ ] Verified indexes exist for WHERE/ORDER clauses
- [ ] Ensured no queries in loops
- [ ] Added caching for expensive operations
- [ ] Used select() to load only needed columns
- [ ] Background jobs for slow operations
- [ ] Fragment caching for expensive views
- [ ] Tested with production-size data
- [ ] Profiled with rack-mini-profiler
- [ ] Set up monitoring alerts
</code></pre>
<p><strong>Prevention Strategies:</strong></p>
<ol>
<li><p><strong>Code Review Focus</strong></p>
<ul>
<li>Every PR checked for performance issues</li>
<li>Automated Bullet gem reports in CI</li>
<li>Query count limits (max 10 queries per action)</li>
</ul>
</li>
<li><p><strong>Performance Testing</strong></p>
<ul>
<li>Load tests before major releases</li>
<li>Performance budgets (page load &lt; 1s)</li>
<li>Automated performance regression tests</li>
</ul>
</li>
<li><p><strong>Monitoring</strong></p>
<ul>
<li>APM dashboards (Datadog, New Relic)</li>
<li>Alerts for slow queries (&gt;1s)</li>
<li>Daily performance reports</li>
</ul>
</li>
<li><p><strong>Education</strong></p>
<ul>
<li>Team training on Rails performance</li>
<li>Internal wiki with patterns</li>
<li>Pair programming on complex queries</li>
</ul>
</li>
</ol>
<hr>
<h3>Key Takeaways</h3>
<p><strong>Most Common Performance Issues:</strong></p>
<ol>
<li>N+1 queries (80% of issues)</li>
<li>Missing indexes (15% of issues)</li>
<li>Inefficient views (3% of issues)</li>
<li>Memory leaks (2% of issues)</li>
</ol>
<p><strong>Golden Rules:</strong></p>
<ul>
<li>Measure before optimizing</li>
<li>Fix N+1 queries first (biggest impact)</li>
<li>Add indexes for all WHERE/ORDER columns</li>
<li>Cache expensive calculations</li>
<li>Move slow work to background</li>
<li>Use appropriate data structures</li>
<li>Test with production-size data</li>
</ul>
<p><strong>Remember:</strong></p>
<ul>
<li>Premature optimization is root of evil</li>
<li>But ignoring performance is worse</li>
<li>Profile, don&#39;t guess</li>
<li>Small changes, big impact</li>
<li>Prevention better than cure</li>
</ul>
<p>ENDOFFILE</p>
<h2>Question 365: Have you worked in Agile/Scrum? What was your role?</h2>
<h3>Answer</h3>
<p><strong>Structure: Overview → Roles → Practices → Challenges → Outcomes</strong></p>
<hr>
<h3>My Agile Experience</h3>
<p><strong>OVERVIEW:</strong>
&quot;I&#39;ve worked in Agile/Scrum environments for the past 4 years across multiple teams and projects. I&#39;ve held roles as both a developer and Scrum Master, and have experience with both co-located and distributed teams ranging from 5 to 12 people.&quot;</p>
<hr>
<h3>AS A DEVELOPER (First 2 years)</h3>
<p><strong>Daily Responsibilities:</strong></p>
<ol>
<li><strong>Daily Standup (9:00 AM, 15 minutes)</strong></li>
</ol>
<pre><code>My typical standup:
- Yesterday: &quot;Completed user authentication feature (PROJ-123), 
  merged PR with 2 approvals&quot;
- Today: &quot;Working on password reset flow (PROJ-124), 
  pairing with Sarah this afternoon&quot;
- Blockers: &quot;Waiting on API documentation from backend team&quot;

Key principles I followed:
- Keep it under 2 minutes
- Focus on work, not status updates
- Raise blockers immediately
- Take detailed discussions offline
</code></pre>
<ol start="2">
<li><strong>Sprint Planning (Every 2 weeks, 2-4 hours)</strong></li>
</ol>
<pre><code>My responsibilities:
- Break down user stories into technical tasks
- Provide estimation using planning poker
- Identify technical dependencies
- Raise technical risks early

Example story breakdown:
User Story: &quot;As a user, I want to reset my password&quot;
Points: 5

Technical Tasks:
- Create password reset controller (2 points)
- Design email template (1 point)
- Implement token generation/validation (2 points)
- Add integration tests (2 points)
- Update documentation (1 point)

Estimation philosophy:
1 point = 2-4 hours (simple CRUD)
2 points = 4-8 hours (standard feature)
3 points = 1 day (complex logic)
5 points = 2-3 days (new pattern/integration)
8 points = 1 week (break down further)
13 points = TOO BIG (must split)
</code></pre>
<ol start="3">
<li><strong>Sprint Review/Demo (End of sprint, 1 hour)</strong></li>
</ol>
<pre><code>Demonstrated completed features:
- Live demo on staging environment
- Showed both happy path and edge cases
- Gathered feedback from stakeholders
- Discussed what worked well

Example demo script:
&quot;I&#39;d like to demo the new password reset feature.
[Shows email sent] 
[Clicks reset link]
[Sets new password]
[Logs in successfully]

Edge cases handled:
- Expired tokens (show error)
- Invalid email (no information disclosure)
- Already used tokens (prevented)

Questions?&quot;
</code></pre>
<ol start="4">
<li><strong>Sprint Retrospective (End of sprint, 1 hour)</strong></li>
</ol>
<pre><code>Format: Start/Stop/Continue

What went well:
+ Pair programming reduced bugs by 40%
+ New testing framework saved time
+ Documentation improved onboarding

What didn&#39;t go well:
- Too many interruptions during sprint
- Scope creep on three stories
- Deployment took longer than expected

Action items:
→ Implement &quot;focus time&quot; blocks (2 hours/day)
→ Stricter definition of done
→ Improve CI/CD pipeline (automation)

Assigned owners and due dates for each action
</code></pre>
<p><strong>Code Review Process:</strong></p>
<pre><code class="language-ruby"># My code review standards

1. Review within 4 hours (same day)
2. Run code locally to test
3. Check test coverage (require 80%+)
4. Verify no N+1 queries (Bullet gem)
5. Ensure follows team conventions
6. Leave constructive comments

Example review comment:
&quot;This works well! One suggestion - consider extracting 
this logic to a service object for better testability:

class PasswordResetService
  def initialize(user)
    @user = user
  end
  
  def send_reset_email
    token = generate_token
    UserMailer.password_reset(@user, token).deliver_later
  end
end

This would make it easier to test without sending emails.
What do you think?&quot;

Types of comments I leave:
🔴 BLOCKING: Must fix (security, bugs)
🟡 IMPORTANT: Should fix (performance, maintainability)
🟢 NITPICK: Nice to have (style, naming)
💭 QUESTION: Seeking clarification
✅ PRAISE: Recognizing good work
</code></pre>
<p><strong>Sprint Metrics I Tracked:</strong></p>
<pre><code>Personal Velocity:
Sprint 1: 18 points completed
Sprint 2: 21 points completed
Sprint 3: 23 points completed
Sprint 4: 22 points completed
Average: ~21 points per sprint

Code Quality:
- Bug rate: 2-3 bugs per sprint
- Test coverage: 85-90%
- PR approval time: avg 6 hours
- Code review comments: avg 12 per PR

Team Velocity:
- 8-person team
- Avg 80-90 points per sprint
- Sprint success rate: 92%
</code></pre>
<hr>
<h3>AS SCRUM MASTER (Last year)</h3>
<p><strong>Additional Responsibilities:</strong></p>
<ol>
<li><strong>Facilitation</strong></li>
</ol>
<pre><code>Sprint Planning:
- Ensured product owner prepared stories
- Kept discussion focused and time-boxed
- Helped team reach consensus on estimates
- Documented decisions and commitments

Daily Standup:
- Started on time (respect people&#39;s calendars)
- Kept it to 15 minutes strict
- Helped resolve blockers immediately
- Followed up on action items

Retrospectives:
- Rotated formats (kept it fresh)
- Created psychological safety
- Focused on actionable outcomes
- Tracked action items to completion
</code></pre>
<ol start="2">
<li><strong>Removing Impediments</strong></li>
</ol>
<pre><code>Common blockers I handled:

Technical Blockers:
- &quot;Database migrations need DBA approval&quot;
  → Worked with DBA to streamline process
  → Set up pre-approved migration patterns

Resource Blockers:
- &quot;Waiting 2 days for design mockups&quot;
  → Scheduled recurring design sync
  → Created design request template

Process Blockers:
- &quot;Deployment process takes 4 hours&quot;
  → Automated CI/CD pipeline
  → Reduced to 20 minutes

Communication Blockers:
- &quot;Backend API not documented&quot;
  → Set up API documentation standard
  → Integrated Swagger/OpenAPI
</code></pre>
<ol start="3">
<li><strong>Metrics and Reporting</strong></li>
</ol>
<pre><code class="language-ruby"># Sprint Burndown Chart
class SprintMetrics
  def burndown_data
    days_in_sprint = 10
    total_points = sprint.total_story_points
    
    (0..days_in_sprint).map do |day|
      {
        day: day,
        ideal: total_points - (total_points / days_in_sprint * day),
        actual: remaining_points_on_day(day)
      }
    end
  end
end

# Velocity Chart (last 6 sprints)
Sprint 1: 82 points (committed: 85)
Sprint 2: 78 points (committed: 80)
Sprint 3: 91 points (committed: 85)
Sprint 4: 87 points (committed: 90)
Sprint 5: 84 points (committed: 85)
Sprint 6: 89 points (committed: 90)

Average Velocity: 85 points
Predictability: 94% (very consistent)

# Cumulative Flow Diagram
Tracked work states:
- Backlog
- Ready for Dev
- In Progress
- Code Review
- QA
- Done

Identified bottlenecks:
- Code Review taking 2-3 days (too long)
- QA queue building up

Solutions implemented:
- Added 2nd reviewer requirement
- Distributed QA responsibilities
</code></pre>
<ol start="4">
<li><strong>Team Health Initiatives</strong></li>
</ol>
<pre><code>Happiness Metric (1-5 scale):
Sprint 1: 3.2 avg
Sprint 6: 4.1 avg

Actions that improved morale:
- Reduced meetings by 30%
- Implemented &quot;no meeting Fridays&quot;
- Started peer recognition program
- Quarterly team building activities
- Protected focus time

Professional Development:
- Monthly tech talks (team members present)
- Paid for conference attendance
- Allocated 10% time for learning
- Supported certification programs
</code></pre>
<hr>
<h3>HANDLING CHALLENGES</h3>
<p><strong>Challenge 1: Scope Creep</strong></p>
<pre><code>Problem:
Product owner kept adding to sprint mid-sprint
Team velocity dropped 30%

Solution:
1. Established sprint commitment as contract
2. Created &quot;sprint interrupt&quot; budget (20% capacity)
3. New requests go to backlog for next sprint
4. Emergency requests require explicit trade-off

Result:
- Velocity recovered to normal
- Predictability improved from 70% to 94%
- Product owner learned to prioritize better
</code></pre>
<p><strong>Challenge 2: Technical Debt</strong></p>
<pre><code>Problem:
Always prioritizing features over technical debt
Build getting slower, bugs increasing

Solution:
1. Made technical debt visible on board
2. Allocated 20% of sprint capacity to debt
3. Created &quot;tech debt&quot; label in Jira
4. Demonstrated value in sprint reviews

Example sprint allocation:
- 64 points: New features
- 16 points: Technical debt
- Total: 80 points

Technical debt items tackled:
- Upgrade Rails 5 → 7 (over 4 sprints)
- Add test coverage (15% → 85%)
- Refactor payment service
- Database query optimization

Result:
- Build time: 45min → 12min
- Bug rate reduced 60%
- Developer satisfaction increased
</code></pre>
<p><strong>Challenge 3: Remote Team Coordination</strong></p>
<pre><code>Problem:
Team spread across 3 time zones
Communication gaps, async delays

Solution:
1. Core hours overlap (10am-2pm ET)
2. Async standup in Slack (timezone-friendly)
3. Recorded demos for time-shifted viewing
4. Better documentation culture

Tools implemented:
- Slack for async communication
- Notion for documentation
- Loom for demo recordings
- Miro for collaborative design

Format for async standup:
📅 Date: 2025-01-15
👤 Name: Harsh
✅ Yesterday: Completed authentication (PR #123)
🎯 Today: Working on authorization (PROJ-234)
🚧 Blockers: Need API keys from DevOps

Result:
- Reduced sync meetings by 40%
- Improved documentation quality
- Better work-life balance
- Maintained productivity
</code></pre>
<hr>
<h3>TOOLS &amp; PRACTICES</h3>
<p><strong>Project Management:</strong></p>
<ul>
<li>Jira for sprint boards and backlog</li>
<li>Confluence for documentation</li>
<li>GitHub for code and PRs</li>
<li>Slack for communication</li>
</ul>
<p><strong>Sprint Board Columns:</strong></p>
<pre><code>Backlog → Ready → In Progress → Code Review → QA → Done

Definition of Ready:
- Acceptance criteria defined
- Dependencies identified
- Design mockups available (if UI)
- Estimated by team

Definition of Done:
- Code complete and merged
- Tests written (80%+ coverage)
- Code reviewed (2 approvals)
- QA verified
- Documentation updated
- Deployed to staging
- Product owner accepted
</code></pre>
<p><strong>Meeting Schedule:</strong></p>
<pre><code>Monday:
- 9:00 AM: Daily standup (15 min)
- 10:00 AM: Sprint planning (if starting sprint, 2 hours)

Tuesday-Thursday:
- 9:00 AM: Daily standup (15 min)
- 2:00 PM: Backlog refinement (1 hour, Tuesday only)

Friday:
- 9:00 AM: Daily standup (15 min)
- 3:00 PM: Sprint review (if ending sprint, 1 hour)
- 4:00 PM: Sprint retrospective (if ending sprint, 1 hour)
- No other meetings (focus day)

Total meeting time: ~6 hours/week (15% of work time)
</code></pre>
<hr>
<h3>MEASURABLE OUTCOMES</h3>
<p><strong>Team Performance:</strong></p>
<ul>
<li>Velocity stabilized: 75-90 points per sprint</li>
<li>Sprint success rate: 92% (stories completed as planned)</li>
<li>Predictability: Can forecast 3 sprints ahead accurately</li>
<li>Bug escape rate: &lt;2% (found in production)</li>
</ul>
<p><strong>Delivery Speed:</strong></p>
<ul>
<li>Feature lead time: 4 weeks → 1.5 weeks</li>
<li>Deployment frequency: Weekly → Daily</li>
<li>Time to production: 2 weeks → 3 days</li>
<li>Rollback rate: &lt;1%</li>
</ul>
<p><strong>Team Satisfaction:</strong></p>
<ul>
<li>Developer happiness: 3.2 → 4.3 (out of 5)</li>
<li>Retention: 0 departures in 2 years</li>
<li>Grew team from 5 to 12 people</li>
<li>All new hires onboarded successfully</li>
</ul>
<p><strong>Business Impact:</strong></p>
<ul>
<li>Delivered 47 features in 24 sprints</li>
<li>94% of commitments met</li>
<li>Customer satisfaction: 4.1 → 4.6 (out of 5)</li>
<li>Support tickets reduced 40%</li>
</ul>
<hr>
<h3>KEY LEARNINGS</h3>
<p><strong>What Works:</strong></p>
<ol>
<li>Short sprints (2 weeks) maintain momentum</li>
<li>Clear definition of done prevents confusion</li>
<li>Retrospectives drive continuous improvement</li>
<li>Protected focus time increases productivity</li>
<li>Regular pairing reduces bugs and knowledge silos</li>
</ol>
<p><strong>What Doesn&#39;t Work:</strong></p>
<ol>
<li>Skipping retrospectives (miss improvement opportunities)</li>
<li>Overcommitting sprint (leads to burnout)</li>
<li>Too many meetings (reduces productive time)</li>
<li>Unclear acceptance criteria (causes rework)</li>
<li>Ignoring technical debt (creates future problems)</li>
</ol>
<p><strong>My Agile Philosophy:</strong></p>
<ul>
<li>People over process</li>
<li>Working software over documentation</li>
<li>Responding to change over following plan</li>
<li>But... process enables people, good documentation helps, and planning prevents chaos</li>
<li>Balance is key</li>
</ul>
<p><strong>Advice for Teams:</strong></p>
<ol>
<li>Start with basics, improve incrementally</li>
<li>Retrospectives are most important ceremony</li>
<li>Protect team from interruptions</li>
<li>Celebrate wins, learn from failures</li>
<li>Measure what matters, act on insights</li>
</ol>
<p>This experience taught me that Agile is not about following rules perfectly - it&#39;s about continuous improvement, team empowerment, and delivering value consistently.&quot;</p>
<hr>
<h2>Question 366: How do you handle code reviews and pull requests in a team?</h2>
<h3>Answer</h3>
<p><strong>My Code Review Philosophy:</strong>
&quot;Code reviews are a conversation, not a judgment. The goal is to improve code quality, share knowledge, and build better software together.&quot;</p>
<hr>
<h3>AS A REVIEWER</h3>
<p><strong>1. RESPONSE TIME</strong></p>
<pre><code>My commitment:
- Initial response: Within 4 hours
- Full review: Within 24 hours
- Large PRs (&gt;500 lines): Schedule pairing session

How I manage this:
- GitHub notifications to Slack
- Dedicated review time blocks (10am, 3pm)
- Browser extension for PR queue
- Team rotation system (2 reviewers per PR)

If I can&#39;t review promptly:
&quot;Hey @author, I see this PR but I&#39;m deep in a critical bug. 
Can @teammate review first? I&#39;ll follow up tomorrow.&quot;
</code></pre>
<p><strong>2. REVIEW FOCUS AREAS (Priority Order)</strong></p>
<pre><code>Level 1: BLOCKERS (Must fix before merge)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 Security vulnerabilities
🔴 Data loss risks
🔴 Breaking changes without migration
🔴 Critical bugs
🔴 No tests for critical paths

Example:
&quot;🔴 BLOCKER: This SQL query is vulnerable to injection:

# Current (UNSAFE)
User.where(&quot;email = &#39;#{params[:email]}&#39;&quot;)

# Fix
User.where(email: params[:email])

This is a critical security issue. Please fix before merging.&quot;

Level 2: IMPORTANT (Should fix)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🟡 Performance issues (N+1, missing indexes)
🟡 Missing error handling
🟡 Untested edge cases
🟡 Code duplication
🟡 Poor naming

Example:
&quot;🟡 IMPORTANT: This will cause N+1 queries:

# Current
@posts.each { |post| post.comments.count }

# Suggested
@posts = Post.includes(:comments)

Can you add eager loading? Also add a test to prevent regression:

it &#39;avoids N+1 queries&#39; do
  expect { get :index }.to perform_queries(count: 2).or_less
end&quot;

Level 3: NITPICKS (Nice to have)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🟢 Style preferences
🟢 Minor refactoring suggestions
🟢 Better naming
🟢 Additional comments

Example:
&quot;🟢 NITPICK: Consider a more descriptive method name:

# Current
def calc
  
# Suggested
def calculate_total_with_tax

Feel free to ignore if you prefer the current name!&quot;

Level 4: QUESTIONS (Seeking clarity)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💭 Understanding decisions
💭 Clarifying requirements
💭 Learning new patterns

Example:
&quot;💭 QUESTION: I see you&#39;re using a service object here. 
What was your thinking? I&#39;m curious about the trade-offs 
vs. the existing pattern.&quot;

Level 5: PRAISE (Positive feedback)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Good solutions
✅ Clean code
✅ Thoughtful tests

Example:
&quot;✅ PRAISE: Excellent test coverage! I especially like 
how you tested the edge case with expired tokens.&quot;
</code></pre>
<p><strong>3. PROVIDING FEEDBACK (Examples)</strong></p>
<pre><code class="language-ruby"># ❌ BAD COMMENT
&quot;This is wrong.&quot;

# ✅ GOOD COMMENT
&quot;This approach might cause issues when we have multiple 
payment methods. Have you considered using the Strategy pattern?

class PaymentProcessor
  def self.process(payment_method, amount)
    processor = PROCESSORS[payment_method]
    processor.new(amount).process
  end
end

This would make it easier to add new payment methods.&quot;

# ❌ BAD COMMENT
&quot;Too many queries.&quot;

# ✅ GOOD COMMENT
&quot;This will generate N+1 queries when loading posts with comments.
I tested locally and it created 101 queries for 100 posts.

Suggested fix:
@posts = Post.includes(:comments, :author)

This reduces it to 3 queries. Here&#39;s the before/after:

Before: 101 queries, 2.3s
After: 3 queries, 245ms

Can you make this change?&quot;

# ❌ BAD COMMENT
&quot;Use better naming.&quot;

# ✅ GOOD COMMENT
&quot;The method name &#39;do_stuff&#39; doesn&#39;t convey intent. 
Based on what it does, how about &#39;send_welcome_email&#39;?

def send_welcome_email(user)
  # Clear what this does
end

More descriptive names help future maintainers (including us 
in 6 months!)&quot;
</code></pre>
<p><strong>4. CODE REVIEW CHECKLIST</strong></p>
<pre><code class="language-markdown">Before approving, I verify:

FUNCTIONALITY
- [ ] Code solves the stated problem
- [ ] Edge cases handled
- [ ] Error handling appropriate
- [ ] User experience considered

SECURITY
- [ ] No SQL injection vulnerabilities
- [ ] No XSS vulnerabilities
- [ ] Strong parameters used
- [ ] Authentication/authorization checked
- [ ] Sensitive data not logged
- [ ] CSRF protection in place

PERFORMANCE
- [ ] No N+1 queries (check with Bullet)
- [ ] Appropriate indexes exist
- [ ] No slow operations in requests
- [ ] Background jobs for heavy work
- [ ] Caching considered where appropriate

TESTS
- [ ] Tests added for new code
- [ ] Tests cover edge cases
- [ ] Tests are meaningful (not just passing)
- [ ] Integration tests for critical paths
- [ ] Test coverage &gt;80% for new code

CODE QUALITY
- [ ] DRY (Don&#39;t Repeat Yourself)
- [ ] SOLID principles followed
- [ ] Clear, descriptive naming
- [ ] Appropriate abstraction level
- [ ] Follows team conventions
- [ ] No commented-out code
- [ ] No debug statements (puts, console.log)

DOCUMENTATION
- [ ] README updated if needed
- [ ] API documentation updated
- [ ] Complex logic has comments
- [ ] Migration has rollback
</code></pre>
<p><strong>5. HANDLING DISAGREEMENTS</strong></p>
<pre><code>Scenario 1: Author disagrees with feedback

# My approach:
1. Ask questions to understand their reasoning
2. Acknowledge valid points
3. Explain my concerns clearly
4. Suggest compromise if possible
5. Escalate to team lead if needed

Example conversation:
Me: &quot;I&#39;m concerned about the performance impact of this query.&quot;
Author: &quot;I tested it and it&#39;s fast enough.&quot;
Me: &quot;Great that you tested! What dataset did you use? 
     In production we have 10M records.&quot;
Author: &quot;Oh, I tested with 10k records.&quot;
Me: &quot;That might explain the difference. Can we add an index 
     to handle the production scale?&quot;
Author: &quot;Good point, I&#39;ll add that.&quot;

Scenario 2: Style preference differences

# My approach:
- Defer to team style guide
- If not in style guide, choose consistency
- Use RuboCop/Prettier to automate
- Pick my battles (style &lt; correctness)

Example:
&quot;I prefer this style, but both work. Let&#39;s stick with 
the existing pattern for consistency. We can discuss 
changing it team-wide in next retro if you feel strongly.&quot;

Scenario 3: Fundamental approach disagreement

# My approach:
- Suggest synchronous discussion (call/pairing)
- Present alternatives with trade-offs
- Involve tech lead if no consensus
- Document decision for future reference

Example:
&quot;We have different approaches here. Can we pair for 
30 minutes to discuss? I want to understand your 
reasoning better, and I can explain my concerns.&quot;
</code></pre>
<p><strong>6. APPROVAL CRITERIA</strong></p>
<pre><code>I APPROVE when:
✅ All blockers resolved
✅ Tests passing (CI green)
✅ No security concerns
✅ Performance acceptable
✅ Code is maintainable
✅ Author addressed major feedback

I REQUEST CHANGES when:
🔴 Security vulnerabilities present
🔴 Critical bugs found
🔴 No tests for critical functionality
🔴 Major performance issues
🔴 Breaking changes without migration path

I COMMENT (don&#39;t block) when:
🟢 Suggestions for improvement
🟢 Questions for clarification
🟢 Nitpicks on style
🟢 Ideas for future work
</code></pre>
<hr>
<h3>AS AN AUTHOR</h3>
<p><strong>1. BEFORE CREATING PR</strong></p>
<pre><code class="language-bash"># My pre-PR checklist (automated script)

#!/bin/bash
echo &quot;Running pre-PR checks...&quot;

# 1. Run tests
echo &quot;Running tests...&quot;
bundle exec rspec
if [ $? -ne 0 ]; then
  echo &quot;❌ Tests failing&quot;
  exit 1
fi

# 2. Check code style
echo &quot;Checking code style...&quot;
bundle exec rubocop
if [ $? -ne 0 ]; then
  echo &quot;❌ Rubocop violations&quot;
  exit 1
fi

# 3. Check for N+1 queries
echo &quot;Checking for N+1 queries...&quot;
bundle exec bullet
if grep -q &quot;N+1&quot; log/bullet.log; then
  echo &quot;⚠️  N+1 queries detected&quot;
  cat log/bullet.log
fi

# 4. Check test coverage
echo &quot;Checking test coverage...&quot;
COVERAGE=$(bundle exec rspec | grep -o &#39;[0-9]*\.[0-9]*%&#39;)
if [[ ${COVERAGE%\%} &lt; 80 ]]; then
  echo &quot;⚠️  Coverage is $COVERAGE (target: 80%)&quot;
fi

# 5. Self-review
echo &quot;Self-review checklist:&quot;
echo &quot;[ ] No commented-out code?&quot;
echo &quot;[ ] No debug statements?&quot;
echo &quot;[ ] Meaningful commit messages?&quot;
echo &quot;[ ] Branch up to date with main?&quot;

echo &quot;✅ Pre-PR checks complete!&quot;
</code></pre>
<p><strong>2. PR DESCRIPTION (Template)</strong></p>
<pre><code class="language-markdown">## What
Brief description of changes (1-2 sentences)

## Why
Link to Jira ticket / GitHub issue
Problem being solved or feature being added

## How
Technical approach and key decisions
- Used service object pattern for payment processing
- Added Redis caching for expensive query
- Extracted reusable component

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Refactoring
- [ ] Documentation

## Testing
- [ ] Unit tests added/updated
- [ ] Integration tests added
- [ ] Manual testing completed
- [ ] Edge cases covered

Test coverage: 87% (increased from 82%)

## Screenshots (if UI changes)
### Before
[screenshot]

### After
[screenshot]

## Database Changes
- [ ] Migration added
- [ ] Migration reversible
- [ ] Migration tested (up and down)
- [ ] Indexes added for new queries
- [ ] Data backfilled if needed

## Deployment Notes
- [ ] Requires environment variable: `NEW_FEATURE_FLAG=true`
- [ ] Database migration (estimated time: 30 seconds)
- [ ] No downtime required
- [ ] Feature flag: `payment_v2` (off by default)

## Checklist
- [ ] Self-reviewed my code
- [ ] All tests passing
- [ ] No console.log or puts statements
- [ ] RuboCop violations fixed
- [ ] Documentation updated
- [ ] Teammates tagged for review

## Reviewers
@senior-dev @domain-expert

## Additional Context
- Pairs well with PR #234
- Blocks PR #236
- Related discussion: [link to Slack thread]
</code></pre>
<p><strong>3. RESPONDING TO FEEDBACK</strong></p>
<pre><code>My response protocol:

1. READ ALL COMMENTS FIRST
   - Don&#39;t respond reactively
   - Understand full context
   - Take a break if needed

2. CATEGORIZE FEEDBACK
   - Blockers: Fix immediately
   - Important: Fix before merge
   - Nitpicks: Fix if quick, or create follow-up ticket
   - Questions: Answer thoughtfully

3. RESPOND TO EVERY COMMENT
   Even if just: &quot;Fixed in abc123&quot; or &quot;Good point, done!&quot;

4. BE APPRECIATIVE
   &quot;Great catch!&quot; 
   &quot;Thanks for the suggestion!&quot;
   &quot;I didn&#39;t think of that edge case.&quot;

5. PUSH BACK CONSTRUCTIVELY (if needed)
   &quot;I considered that approach but went with X because...
    Happy to discuss further if you have concerns.&quot;

Example responses:

# For security issue
&quot;😱 Great catch! I can&#39;t believe I missed that.
Fixed in commit abc123. Also added test to prevent regression.
Thanks for protecting us from a potential breach!&quot;

# For performance suggestion
&quot;Excellent suggestion! I implemented the eager loading:

Before: 157 queries, 2.3s
After: 4 queries, 0.2s

Added test to ensure we don&#39;t regress:

it &#39;avoids N+1 queries&#39; do
  expect { get :index }.not_to exceed_query_limit(5)
end&quot;

# For nitpick
&quot;Good point! Changed the naming:
process_data → process_order_with_payment

More descriptive now. Thanks!&quot;

# For disagreement
&quot;I understand your concern. I went with this approach because:
1. It&#39;s consistent with our payment processing pattern
2. It handles the edge case where...
3. It&#39;s more testable

But I&#39;m open to other approaches. Want to pair for 15 minutes 
to discuss?&quot;
</code></pre>
<p><strong>4. KEEPING PRS SMALL</strong></p>
<pre><code>My PR size guidelines:

IDEAL: &lt;200 lines
- Single feature/fix
- Easy to review (15-30 minutes)
- Fast feedback loop

ACCEPTABLE: 200-500 lines
- Medium feature
- Multiple related changes
- Still reviewable in one sitting

TOO LARGE: &gt;500 lines
- Hard to review thoroughly
- Easy to miss issues
- Long feedback cycle

Breaking down large changes:

# Instead of one 1500-line PR:
&quot;Implement new payment system&quot;

# Split into smaller PRs:
PR 1: &quot;Add payment service interface&quot; (100 lines)
PR 2: &quot;Implement Stripe payment provider&quot; (250 lines)
PR 3: &quot;Implement PayPal payment provider&quot; (250 lines)
PR 4: &quot;Add payment UI components&quot; (200 lines)
PR 5: &quot;Integrate payment system with checkout&quot; (150 lines)

Benefits:
- Each PR reviewed within 1 day
- Issues caught early
- Easier to revert if needed
- Can deploy incrementally with feature flags
</code></pre>
<p><strong>5. HANDLING REVIEW CYCLES</strong></p>
<pre><code>Typical PR lifecycle:

Day 1, 10:00 AM - Create PR
Day 1, 2:00 PM - First review (3 comments)
Day 1, 4:00 PM - Address comments, push changes
Day 1, 5:00 PM - Re-review, 1 more comment
Day 2, 9:00 AM - Address final comment
Day 2, 10:00 AM - Approval ✅
Day 2, 10:30 AM - Merge and deploy

Total time: ~24 hours

Red flags:
🚩 PR open for &gt;3 days (losing context)
🚩 &gt;5 review cycles (might need pairing)
🚩 Many unresolved threads (disagreements?)
🚩 No feedback after 24 hours (ping reviewers)

What I do if stuck:
1. Day 1: @ mention reviewers again
2. Day 2: Message in Slack
3. Day 3: Ask in standup
4. Last resort: Schedule pairing session
</code></pre>
<hr>
<h3>TEAM PRACTICES</h3>
<p><strong>1. PR Requirements</strong></p>
<pre><code>Our team rules:
- Minimum 2 approvals required
- At least 1 from senior developer
- All CI checks must pass
- All conversations must be resolved
- Branch must be up to date with main
- No force pushes after review starts
</code></pre>
<p><strong>2. Review Rotation</strong></p>
<pre><code>Automatic assignment algorithm:
1. Assign domain expert (if exists)
2. Assign someone who hasn&#39;t reviewed recently
3. Balance review load across team

We use GitHub CODEOWNERS:
# .github/CODEOWNERS
/app/services/payment/* @payment-team
/config/database.yml @database-team
/app/controllers/api/* @api-team
*.rb @rails-team

Benefits:
- Right expertise for each PR
- Knowledge sharing
- Load balancing
</code></pre>
<p><strong>3. Pair Reviews</strong></p>
<pre><code>When we pair review:
- PR &gt; 500 lines
- Complex architectural change
- New technology/pattern
- Security-sensitive code
- Multiple review cycles with no resolution

Format:
- 30-60 minute video call
- Author shares screen
- Walk through changes together
- Discuss trade-offs in real-time
- Resolve issues immediately

Much faster than async back-and-forth!
</code></pre>
<hr>
<h3>METRICS WE TRACK</h3>
<pre><code class="language-ruby">class CodeReviewMetrics
  def calculate
    {
      time_to_first_review: average_time_to_first_comment,
      time_to_merge: average_time_to_merge,
      review_cycles: average_number_of_review_cycles,
      pr_size: average_lines_changed,
      approval_rate: percentage_approved_first_review
    }
  end
end

Our team stats:
- Time to first review: 4.2 hours (target: &lt;4 hours)
- Time to merge: 18 hours (target: &lt;24 hours)
- Review cycles: 1.8 (target: &lt;3)
- PR size: 187 lines (target: &lt;200)
- First-review approval: 42% (healthy)

We review these monthly and adjust practices
</code></pre>
<hr>
<h3>IMPACT OF GOOD CODE REVIEWS</h3>
<p><strong>Quality Improvements:</strong></p>
<ul>
<li>Bugs found in review: 60% of total bugs</li>
<li>Security issues caught: 15 in last year</li>
<li>Performance issues prevented: 23 in last year</li>
<li>Code duplication reduced: 40%</li>
</ul>
<p><strong>Team Benefits:</strong></p>
<ul>
<li>Knowledge sharing increased</li>
<li>Onboarding time reduced 50%</li>
<li>Code consistency improved</li>
<li>Team cohesion strengthened</li>
</ul>
<p><strong>Personal Growth:</strong></p>
<ul>
<li>Learned new patterns from reviews</li>
<li>Improved code quality proactively</li>
<li>Better at explaining technical decisions</li>
<li>Developed empathy and communication skills</li>
</ul>
<p>&quot;Code reviews transformed our team from individuals writing code to a cohesive unit building a system together. It&#39;s not just about finding bugs - it&#39;s about learning, teaching, and building trust.&quot;</p>
<h2>Question 367: What is the biggest mistake you made in a project, and how did you resolve it?</h2>
<h3>Answer</h3>
<p>&quot;The biggest mistakes often teach the most valuable lessons. Here&#39;s mine:&quot;</p>
<hr>
<h3>THE MISTAKE: Production Data Deletion</h3>
<p><strong>SITUATION (The Setup):</strong>
&quot;I was working on an e-commerce platform, tasked with implementing a feature to archive old orders. We had 2 million orders, and orders older than 7 years needed to be moved to cold storage per legal requirements.&quot;</p>
<p><strong>THE IMPLEMENTATION (What Went Wrong):</strong></p>
<pre><code class="language-ruby"># What I wrote (WRONG!)
class ArchiveOldOrdersJob &lt; ApplicationJob
  def perform
    # My intention: Archive orders older than 7 years
    old_orders = Order.where(&#39;created_at &lt; ?&#39;, 7.years.ago)
    
    old_orders.find_each do |order|
      # Move to archive
      ArchivedOrder.create!(order.attributes)
      
      # Delete from main table
      order.destroy  # 😱 PERMANENT DELETE!
    end
  end
end

# What I SHOULD have written:
class ArchiveOldOrdersJob &lt; ApplicationJob
  def perform
    old_orders = Order.where(&#39;created_at &lt; ?&#39;, 7.years.ago)
    
    old_orders.find_each do |order|
      # First, verify archive succeeded
      archived = ArchivedOrder.create!(order.attributes)
      
      if archived.persisted?
        # Soft delete with verification
        order.update!(archived_at: Time.current, archived_id: archived.id)
      else
        raise &quot;Archive failed for order #{order.id}&quot;
      end
    end
  end
end
</code></pre>
<p><strong>THE DISASTER:</strong></p>
<pre><code>Friday, 4:30 PM - Deployed to production
Friday, 4:35 PM - Job started running
Friday, 4:45 PM - Customer support: &quot;Customers can&#39;t see their order history!&quot;
Friday, 4:50 PM - Realized the job was deleting orders, not archiving
Friday, 4:52 PM - PANIC: 340,000 orders already deleted
Friday, 4:53 PM - Killed the background job

Impact:
- 340,000 orders permanently deleted
- 50,000+ customers affected
- Order history: GONE
- Customer support flooded with calls
- Company reputation at risk
- My heart rate: 180 BPM
</code></pre>
<p><strong>ROOT CAUSES:</strong></p>
<ol>
<li><strong>No Soft Delete Pattern</strong></li>
</ol>
<pre><code class="language-ruby"># I used destroy instead of soft delete
order.destroy  # Hard delete - GONE FOREVER!

# Should have used:
order.update!(archived_at: Time.current)
</code></pre>
<ol start="2">
<li><strong>No Verification Step</strong></li>
</ol>
<pre><code class="language-ruby"># I didn&#39;t verify the archive before deleting
ArchivedOrder.create!(order.attributes)
order.destroy  # What if create failed?

# Should have:
archived = ArchivedOrder.create!(order.attributes)
raise &quot;Archive failed&quot; unless archived.valid?
</code></pre>
<ol start="3">
<li><strong>No Dry Run</strong></li>
</ol>
<pre><code class="language-ruby"># I deployed straight to production
ArchiveOldOrdersJob.perform_later

# Should have:
# 1. Tested in staging with production copy
# 2. Run with DRY_RUN=true first
# 3. Manual verification before auto-delete
</code></pre>
<ol start="4">
<li><strong>No Backup</strong></li>
</ol>
<pre><code class="language-ruby"># I didn&#39;t take a backup before the operation
# Should have:
pg_dump production_db &gt; backup_before_archive.sql
</code></pre>
<ol start="5">
<li><strong>Wrong Time to Deploy</strong></li>
</ol>
<pre><code class="language-ruby"># Friday 4:30 PM deployment
# Should have:
# - Tuesday-Thursday morning
# - Full team available
# - Time to monitor
</code></pre>
<hr>
<h3>THE RECOVERY (Under Pressure)</h3>
<p><strong>IMMEDIATE ACTIONS (Friday 5:00 PM - 11:00 PM):</strong></p>
<ol>
<li><strong>Stop the Bleeding (5 minutes)</strong></li>
</ol>
<pre><code class="language-ruby"># Killed all background jobs
Sidekiq::Queue.new.clear
Sidekiq::RetrySet.new.clear

# Disabled the job
# config/sidekiq.yml
:queues:
  - [critical, 10]
  # - [default, 5]  # DISABLED

# Prevented new deletions
</code></pre>
<ol start="2">
<li><strong>Assess the Damage (15 minutes)</strong></li>
</ol>
<pre><code class="language-sql">-- Check what was deleted
SELECT COUNT(*) FROM orders; -- 1,660,000 (was 2,000,000)
-- 340,000 orders GONE

-- Check what was archived
SELECT COUNT(*) FROM archived_orders; -- 340,000

-- At least the data exists in archive table!
</code></pre>
<ol start="3">
<li><strong>Emergency Data Recovery (3 hours)</strong></li>
</ol>
<pre><code class="language-ruby">class RestoreDeletedOrdersJob &lt; ApplicationJob
  def perform
    # Move data back from archive to main table
    ArchivedOrder.find_each(batch_size: 1000) do |archived|
      begin
        # Restore to orders table
        Order.create!(
          archived.attributes.except(&#39;id&#39;, &#39;created_at&#39;, &#39;updated_at&#39;)
        )
        
        # Mark as restored
        archived.update!(restored_at: Time.current)
      rescue =&gt; e
        Rails.logger.error(&quot;Restore failed: #{archived.id}: #{e.message}&quot;)
      end
    end
  end
end

# Started restoration
RestoreDeletedOrdersJob.perform_later

# Monitored progress
restored_count = ArchivedOrder.where.not(restored_at: nil).count
puts &quot;Restored: #{restored_count}/340,000&quot;
</code></pre>
<ol start="4">
<li><strong>Verified Data Integrity (2 hours)</strong></li>
</ol>
<pre><code class="language-ruby"># Check for missing foreign key data
Order.includes(:line_items).find_each do |order|
  if order.line_items.empty? &amp;&amp; order.should_have_items?
    puts &quot;Order #{order.id} missing line items!&quot;
  end
end

# Check order totals match
discrepancies = Order.where(&#39;total != calculated_total&#39;)
</code></pre>
<ol start="5">
<li><strong>Communication (Throughout)</strong></li>
</ol>
<pre><code>5:15 PM - Notified CTO and team lead
5:30 PM - Sent customer support update
6:00 PM - Status update to management
8:00 PM - Progress update (50% restored)
11:00 PM - Completion update (100% restored)

Email to customers:
&quot;We experienced a technical issue that temporarily affected 
order history access. The issue has been resolved and your 
order history is now fully restored. We sincerely apologize 
for any inconvenience.&quot;
</code></pre>
<p><strong>LONG-TERM FIXES (Week Following):</strong></p>
<ol>
<li><strong>Implemented Soft Delete Pattern</strong></li>
</ol>
<pre><code class="language-ruby"># Added deleted_at column
class AddDeletedAtToOrders &lt; ActiveRecord::Migration[7.0]
  def change
    add_column :orders, :deleted_at, :datetime
    add_index :orders, :deleted_at
  end
end

# Used paranoia gem
class Order &lt; ApplicationRecord
  acts_as_paranoid
end

# Now Order.destroy soft-deletes
order.destroy  # Sets deleted_at, doesn&#39;t actually delete
Order.with_deleted  # See all including deleted
</code></pre>
<ol start="2">
<li><strong>Added Archive Verification</strong></li>
</ol>
<pre><code class="language-ruby">class SafeArchiveJob &lt; ApplicationJob
  def perform
    Order.where(&#39;created_at &lt; ?&#39;, 7.years.ago).find_each do |order|
      ActiveRecord::Base.transaction do
        # 1. Create archive
        archived = ArchivedOrder.create!(order.attributes)
        
        # 2. Verify archive
        raise &quot;Archive failed&quot; unless archived.persisted?
        raise &quot;Data mismatch&quot; unless verify_data(order, archived)
        
        # 3. Soft delete (not hard delete!)
        order.update!(archived_at: Time.current, archived_id: archived.id)
        
        # 4. Verify soft delete worked
        raise &quot;Soft delete failed&quot; unless order.reload.archived_at
      end
    rescue =&gt; e
      # Log and continue
      Rails.logger.error(&quot;Archive failed for order #{order.id}: #{e.message}&quot;)
      Sentry.capture_exception(e)
    end
  end
  
  def verify_data(original, archived)
    original.total == archived.total &amp;&amp;
    original.user_id == archived.user_id
    # ... more checks
  end
end
</code></pre>
<ol start="3">
<li><strong>Added Dry Run Mode</strong></li>
</ol>
<pre><code class="language-ruby">class SafeArchiveJob &lt; ApplicationJob
  def perform(dry_run: false)
    orders_to_archive = Order.where(&#39;created_at &lt; ?&#39;, 7.years.ago)
    
    if dry_run
      # Just report what would happen
      puts &quot;Would archive #{orders_to_archive.count} orders&quot;
      orders_to_archive.limit(10).each do |order|
        puts &quot;- Order #{order.id} (#{order.created_at})&quot;
      end
      return
    end
    
    # Actual archiving...
  end
end

# Always run dry run first!
SafeArchiveJob.perform_now(dry_run: true)
</code></pre>
<ol start="4">
<li><strong>Automated Backups</strong></li>
</ol>
<pre><code class="language-bash"># Backup before dangerous operations
#!/bin/bash
echo &quot;Creating backup before archive job...&quot;
pg_dump production_db | gzip &gt; &quot;backup_$(date +%Y%m%d_%H%M%S).sql.gz&quot;
aws s3 cp backup_*.sql.gz s3://backups/pre-archive/

# Run in cron before archive job
0 2 * * * /scripts/backup_before_archive.sh
5 2 * * * bundle exec rake archive:old_orders
</code></pre>
<ol start="5">
<li><strong>Added Safety Checks</strong></li>
</ol>
<pre><code class="language-ruby">class SafeArchiveJob &lt; ApplicationJob
  MAX_DELETE_PERCENTAGE = 0.05  # Max 5% of data
  
  def perform
    total_orders = Order.count
    orders_to_archive = Order.where(&#39;created_at &lt; ?&#39;, 7.years.ago).count
    
    percentage = orders_to_archive.to_f / total_orders
    
    if percentage &gt; MAX_DELETE_PERCENTAGE
      raise &quot;Safety check: Would delete #{(percentage * 100).round(2)}% of data! Max allowed: 5%&quot;
    end
    
    # Proceed with archiving...
  end
end
</code></pre>
<ol start="6">
<li><strong>Comprehensive Testing</strong></li>
</ol>
<pre><code class="language-ruby">RSpec.describe SafeArchiveJob do
  describe &#39;#perform&#39; do
    it &#39;soft deletes old orders&#39; do
      old_order = create(:order, created_at: 8.years.ago)
      
      SafeArchiveJob.perform_now
      
      expect(old_order.reload.deleted_at).to be_present
      expect(old_order.archived_at).to be_present
    end
    
    it &#39;creates archive record&#39; do
      old_order = create(:order, created_at: 8.years.ago)
      
      expect {
        SafeArchiveJob.perform_now
      }.to change { ArchivedOrder.count }.by(1)
    end
    
    it &#39;does not hard delete&#39; do
      old_order = create(:order, created_at: 8.years.ago)
      
      expect {
        SafeArchiveJob.perform_now
      }.not_to change { Order.unscoped.count }
    end
    
    it &#39;links archive to original&#39; do
      old_order = create(:order, created_at: 8.years.ago)
      
      SafeArchiveJob.perform_now
      old_order.reload
      
      expect(old_order.archived_id).to be_present
      expect(ArchivedOrder.find(old_order.archived_id).order_id).to eq(old_order.id)
    end
    
    it &#39;refuses to archive if percentage too high&#39; do
      create_list(:order, 100, created_at: 8.years.ago)
      create_list(:order, 100, created_at: 1.year.ago)
      
      # 50% would be archived - exceeds 5% limit
      expect {
        SafeArchiveJob.perform_now
      }.to raise_error(/Safety check/)
    end
  end
end
</code></pre>
<hr>
<h3>THE AFTERMATH</h3>
<p><strong>IMMEDIATE RESULTS:</strong></p>
<ul>
<li>All 340,000 orders restored by 11 PM</li>
<li>Data integrity: 99.98% (found 67 orders with minor issues, fixed manually)</li>
<li>No permanent data loss</li>
<li>Worked until 2 AM ensuring everything perfect</li>
</ul>
<p><strong>BUSINESS IMPACT:</strong></p>
<ul>
<li>Customer complaints: Resolved within 24 hours</li>
<li>Reputation damage: Minimal (quick recovery)</li>
<li>Financial cost: ~$5,000 (overtime, emergency response)</li>
<li>Could have been: Catastrophic lawsuit, millions in damages</li>
</ul>
<p><strong>PERSONAL CONSEQUENCES:</strong></p>
<ul>
<li>Formal write-up in my file</li>
<li>Loss of deploy privileges for 1 month</li>
<li>Required code review from senior dev for 3 months</li>
<li>But kept my job (company valued the learning)</li>
</ul>
<p><strong>POSITIVE OUTCOMES:</strong></p>
<ol>
<li><strong>Company-Wide Improvements:</strong></li>
</ol>
<pre><code>Created &quot;Dangerous Operations Playbook&quot;:
- Mandatory dry runs
- Backup requirements
- Soft delete by default
- Verification steps
- Deployment windows
- Approval process
</code></pre>
<ol start="2">
<li><strong>Process Changes:</strong></li>
</ol>
<pre><code>New deployment rules:
- No Friday deployments (except hotfixes)
- No data manipulation without backup
- Soft delete required for all models
- Dry run mode for batch jobs
- Staging deployment first (48 hour soak)
- Senior approval for data operations
</code></pre>
<ol start="3">
<li><strong>Technical Improvements:</strong></li>
</ol>
<pre><code>Implemented safety measures:
- Paranoia gem for all models (soft delete)
- Automated backups before dangerous ops
- Safety checks (max deletion percentage)
- Comprehensive testing
- Monitoring alerts
- Rollback procedures documented
</code></pre>
<hr>
<h3>KEY LEARNINGS</h3>
<p><strong>Technical Lessons:</strong></p>
<ol>
<li><strong>Always Use Soft Deletes</strong></li>
</ol>
<pre><code class="language-ruby"># Never use destroy for user data
order.destroy  # ❌ NEVER

# Always soft delete
order.update!(deleted_at: Time.current)  # ✅ SAFE
</code></pre>
<ol start="2">
<li><strong>Verify Before Deleting</strong></li>
</ol>
<pre><code class="language-ruby"># Create, verify, then delete
archived = create_archive(order)
verify_archive(archived)
soft_delete(order)
link_archive_to_original(order, archived)
</code></pre>
<ol start="3">
<li><strong>Always Have Backups</strong></li>
</ol>
<pre><code class="language-ruby"># Before any data operation
backup_database
run_operation
verify_operation
# Can restore if needed
</code></pre>
<ol start="4">
<li><strong>Test with Production-Scale Data</strong></li>
</ol>
<pre><code class="language-ruby"># Not enough
Order.limit(10).destroy_all

# Better
# Copy production DB to staging
# Test with full dataset
</code></pre>
<p><strong>Process Lessons:</strong></p>
<ol>
<li><strong>Deployment Timing Matters</strong></li>
</ol>
<pre><code>❌ Friday 4:30 PM
✅ Tuesday 10:00 AM (team available, time to monitor)
</code></pre>
<ol start="2">
<li><strong>Incremental Rollout</strong></li>
</ol>
<pre><code>1. Deploy code (no execution)
2. Run dry run
3. Manual verification
4. Process small batch (1%)
5. Verify results
6. Process larger batches
7. Full automation (after confidence)
</code></pre>
<ol start="3">
<li><strong>Communication is Critical</strong></li>
</ol>
<pre><code>- Notified stakeholders immediately
- Regular status updates
- Transparent about mistake
- Clear recovery plan
- Post-mortem analysis
</code></pre>
<p><strong>Personal Growth:</strong></p>
<ol>
<li><strong>Humility</strong>: Everyone makes mistakes, even &quot;simple&quot; ones</li>
<li><strong>Responsibility</strong>: Own mistakes, don&#39;t make excuses</li>
<li><strong>Learning</strong>: Turned mistake into valuable lessons</li>
<li><strong>Sharing</strong>: Presented at company all-hands to help others</li>
<li><strong>Prevention</strong>: Better to prevent than recover</li>
</ol>
<p><strong>What I Do Differently Now:</strong></p>
<pre><code class="language-ruby"># My paranoid production habits:

# 1. Always backup first
rake db:backup

# 2. Always dry run
RAILS_ENV=production DRY_RUN=true rake archive:orders

# 3. Start small
rake archive:orders LIMIT=10

# 4. Verify each step
rake verify:archive

# 5. Monitor closely
watch -n 1 &#39;SELECT COUNT(*) FROM orders&#39;

# 6. Have rollback plan ready
# Document: &quot;If things go wrong, do X&quot;

# 7. Never alone
# Pair with senior dev for data operations

# 8. Never Friday
# Tuesday-Thursday only
</code></pre>
<hr>
<h3>THE MOST IMPORTANT LESSON</h3>
<p>&quot;The best engineers aren&#39;t those who never make mistakes - they&#39;re those who:</p>
<ol>
<li>Learn from mistakes</li>
<li>Share learnings openly</li>
<li>Improve systems to prevent recurrence</li>
<li>Help others avoid same mistakes</li>
</ol>
<p>This mistake made me a better, more careful engineer. It taught me:</p>
<ul>
<li>Measure twice, cut once</li>
<li>Defense in depth</li>
<li>Murphy&#39;s Law is real</li>
<li>Quick recovery matters</li>
<li>Transparency builds trust</li>
</ul>
<p>I&#39;m actually grateful for this experience (though I&#39;d never want to repeat it!). 
It fundamentally changed how I approach production operations, and the safety 
measures we implemented have prevented dozens of similar incidents company-wide.&quot;</p>
<hr>
<h3>POST-SCRIPT</h3>
<p><strong>5 Years Later:</strong></p>
<ul>
<li>The &quot;Dangerous Operations Playbook&quot; I created is still used</li>
<li>0 data loss incidents since implementing these practices</li>
<li>I&#39;m now the go-to person for sensitive data operations (ironic!)</li>
<li>Junior developers learn from my documented mistake</li>
<li>Company culture shifted to &quot;blameless post-mortems&quot;</li>
</ul>
<p><strong>Advice for Others:</strong></p>
<ul>
<li>Own your mistakes immediately</li>
<li>Focus on recovery first, blame never</li>
<li>Document everything for others</li>
<li>Turn mistakes into improvements</li>
<li>Share learnings generously</li>
</ul>
<p>&quot;The mistake hurt, but the lessons were invaluable. Better to learn from a 
recoverable mistake than to never be challenged enough to make one.&quot;</p>
